var tipuesearch = {"pages":[{"title":" M_unicode ","text":"M_unicode Note: The UDDTIO (User-Defined Derived-Type Input/Output) procedures for use\nwith the DT edit descriptor are still undergoing development. M_unicode module The M_unicode module supports using UTF-8 encoded files and data as\neasily as ASCII-7 encoded files. It fully implements the basics discussed in the Fortran Wiki Unicode\nLessons . Furthermore, the M_unicode module supports many string methods that\noperate on byte streams representing UTF-8 encoded text such as case\nconversion and sorting. ASCII-7 being a subset of UTF-8 the procedures work with standard ASCII-7\ntext as well. A user-defined type called unicode_type provides an object-oriented\ninterface supporting ragged arrays of strings and Unicode codepoints. The procedural interface supports all basic character intrinsics and\noperators. Over 45 example programs are included, as well as man-pages\ndescribing the procedures in *roff and html format, and a basic set of\nunit tests. program testit use , intrinsic :: iso_fortran_env , only : stdout => output_unit ! explicit USE statements for each feature: ! ! user-defined type to hold Unicode text use M_unicode , only : unicode_type ! convert unicode_type to CHARACTER variables use M_unicode , only : character ! intrinsic overloads use M_unicode , only : & adjustl , adjustr , trim , len , len_trim , & index , scan , verify , repeat , ichar , & split , tokenize ! additional methods use M_unicode , only : & upper , lower , sort , expandtabs , replace , & pad , join , fmt , escape ! operators (and overloads) and SORT(3f) use ! Unicode codepoints (NOT dictionary order) use M_unicode , only : assignment ( = ) use M_unicode , only : operator ( <= ), lle use M_unicode , only : operator ( < ), llt use M_unicode , only : operator ( /= ), lne use M_unicode , only : operator ( == ), leq use M_unicode , only : operator ( > ), lgt use M_unicode , only : operator ( >= ), lge use M_unicode , only : operator ( // ) ! low-level text conversion to integer codepoint arrays: use M_unicode , only : utf8_to_codepoints , codepoints_to_utf8 ! sample usage: ! implicit none type ( unicode_type ) :: ustr character ( len =* ), parameter :: g = '(*(g0))' , & gi = '(*(g0,1x))' , & gh = '(*(z0,1x))' integer :: iostat ! Constructors ! UNICODE_VARIABLE= UNICODE_VARIABLE|CHARACTER(LEN=*)|INTEGER_ARRAY ! assign UTF-8 string to OOP object. ustr = 'Hello World and Ni Hao -- ‰Ω†Â•Ω  ' write ( stdout , g ) character ( ustr ) ! convert to intrinsic CHARACTER variable write ( stdout , g ) len ( ustr ) write ( stdout , g ) len_trim ( ustr ) write ( stdout , g ) index ( ustr , '‰Ω†' ) ! OOPS ! VARIABLE%CHARACTER(start,end,step) returns a CHARACTER string ! VARIABLE%BYTE() returns an array of CHARACTER(len=1) values write ( stdout , g ) ustr % character () ! convert to CHARACTER variable write ( stdout , g ) ustr % character ( 27 , 28 ) ! similar to LINE(27:28) for CHARACTER write ( stdout , g ) ustr % character ( len ( ustr ), 1 , - 1 ) ! reverse string write ( stdout , g ) ustr % byte () ! convert to CHARACTER(LEN=1) type ! print write ( stdout , gi ) ustr % codepoint () ! convert to Unicode codepoints write ( stdout , gh ) ustr % codepoint () ! Hexadecimal values of codepoints end program testit Expected output: Hello World and Ni Hao -- ‰Ω†Â•Ω  \n30\n28\n27\nHello World and Ni Hao -- ‰Ω†Â•Ω  \n‰Ω†Â•Ω\n  Â•Ω‰Ω† -- oaH iN dna dlroW olleH\nHello World and Ni Hao -- ‰Ω†Â•Ω  \n72 101 108 108 111 32 87 111 114 108 100 32 97 110 100 32 78 105 32 72 97 111 32 45 45 32 20320 22909 32 32\n48 65 6C 6C 6F 20 57 6F 72 6C 64 20 61 6E 64 20 4E 69 20 48 61 6F 20 2D 2D 20 4F60 597D 20 20 Unicode usage from Fortran when UTF-8 source files are supported Fortran 2003 and later standards describe internal representation of\nUnicode using 4-byte-per-character UCS-4 encoding for characters/glyphs,\nincluding an ability to automatically encode and decode data read and\nwritten to UTF-8 files. But Unicode ISO-10646 support is optional, ragged string arrays are\nnot supported as intrinsic types, no OOP interface is provided for the\nintrinsic methods and there are no functions provided to convert from\nUCS-4 to UTF-8 byte streams accept via reading and writing to files. Where Unicode is supported (ie. where CHARACTER(KIND=‚ÄùISO_10646‚Äù)\nis provided)\nThe M_utf8 repository\nsupplements Unicode usage ‚Äì emphasizing adherence to the standard to\npromote portability. When the compiler does not support CHARACTER(KIND=‚ÄùISO_10646‚Äù)\nit still may support UTF-8 source files and permit entering multi-byte\nUnicode characters in comments and (more importantly) in constant strings\nand data. This support is now very common, as nearly all current operating\nsystems and many applications support UTF-8 text files. But whether in input and output files, or as what-you-see-is-what-you-get\ncharacter constants the compiler will see this text as byte streams,\nand will be unaware of how many Unicode glyphs/characters are represented. So it may often be easy to place Unicode characters in fixed messages,\nbut if the text needs manipulated or processed in any way dealing with\nUnicode as a raw series of 8-bit-bytes becomes complex and non-intuitive. To keep processing of Unicode as simple as it is to process ASCII-7\ncharacters the M_unicode module provides a user-defined type named UNICODE_TYPE and a number of procedures for converting byte streams\nthat represent UTF8-encoded text into Unicode code points (ie, 32-bit\ninteger values that generally identify one specific Unicode character). Additionally the most common character-related intrinsics and operators\nare overloaded to work with the UNICODE_TYPE variables; and the type\nis extended to include the procedures and operators as type-bound\nprocedures for programmers that prefer OOP (Object-Oriented Programming)\ncapabilities. UTF-8 source files ‚Äì just in comments and constants The Fortran character set is the set of characters used in constructing\nFortran code. It is now the same as the ASCII 7-bit character set sans\nthe unprintable control characters. The letters a-z,A-Z and digits 0-9\nand underscore are the only characters allowed in operator symbols. These\nsame characters and the ‚Äúspecial‚Äù characters (the remaining printable\nASCII 7-bit characters) are used for operators and bracketing, and\nvarious forms of separating and delimiting other lexical tokens. But what about other non-ASCII-7 characters representable by the\nprocessor?  Possibilities include the extended ASCII characters or\nmulti-byte characters as defined for UTF-8 text files. The standard\nstates that, whatever those ‚Äúadditional characters‚Äù are, they may appear\nin character constants: 6.1.6 Other characters Additional characters may be representable in the processor , but shall appear on ly in comments ( 6.3.2.3 , 6.3.3.2 ), character constants ( 7.4.4 ), input / output records ( 12.2.2 ), and character string edit descriptors ( 13.3.2 ) . Since ASCII-7-bit is a subset of UTF-8 it is very likely that if your\nsystem supports UTF-8 files that it therefore will allow multi-byte\ncharacters to be represented in comments and character constants. But it is up to the processor whether it supports or even allows\nUTF-8 files.  In the past when UTF-8 file support was rare this meant\nusing UTF-8 multi-byte characters in source files was likely to be\nnon-portable.  Now that UTF-8 files are supported on most systems this\nextension can be useful, particularly with compilers that do not support\nUCS-4 yet. NOTE: If concerned about directly placing multi-byte characters into constant\nstrings directly in the code, support of arrays of codepoint values is\nsupported as well . Environment Reading and writing properly to the screen requires that, independent\nof the M_unicode module, UTF-8 files display properly. This may require selecting a specific terminal emulator, setting the locale\nand selecting a font that supports the Unicode characters of interest. Without using any Fortran Unicode support features, if the output\nis redirected to a file does it appear correctly? program multibyte use , intrinsic :: iso_fortran_env , only : stdout => output_unit character ( len =* ), parameter :: all = '(*(g0))' integer :: iostat write ( stdout , '(a)' ) & 'Confucius never claimed to be a prophet, ' ,& 'but I think he foresaw AI! He said ' ,& '' ,& ' \"Â≠¶ËÄå‰∏çÊÄùÂàôÁΩîÔºåÊÄùËÄå‰∏çÂ≠¶ÂàôÊÆÜ\"' ,& 'or' ,& ' (xu√© √©r b√π sƒ´ z√© w«éng, sƒ´ √©r b√π xu√© z√© d√†i),' ,& 'which is also' ,& ' \"To learn without thinking is to be lost, ' ,& ' to think without learning is to be in danger\".' end program multibyte Does the text display properly when written to the screen?  If it does\nnot you need to determine how to set up a terminal on your system to\ndisplay UTF-8 data, which is system dependent. Remember that unless the compiler directly supports UTF-8 representation (\nso far I have identified no compilers that do so) these strings are seen\nby the compiler as a string of bytes, and it is otherwise unaware they\nrepresent Unicode characters. If they are just to be read and written\nas-is as in the previous example program that is not a major concern;\nbut if you are manipulating or processing the strings in significant\nways is when you use the M_unicode module. Download and Build with Make(1) Compile the M_unicode module and build all the example programs. git clone https://github.com/urbanjost/M_unicode.git cd M_unicode/src # change Makefile if not using one of the listed compilers # for gfortran make clean make gfortran # for ifort make clean make ifort # for nvfortran make clean make nvfortran # display other options (test, run, doxygen, ford, ...) make help To install you then generally copy the .mod file and .a file to\n   an appropriate directory.  Unfortunately, the specifics vary but in\n   general if you have a directory $HOME/.local/lib and copy those files\n   there then you can generally enter something like gfortran -L $HOME /.local/lib -lM_unicode myprogram.f90 -o myprogram There are different methods for adding the directory to your default\n   load path, but frequently you can append the directory you have\n   placed the files in into the colon-separated list of directories\n   in the $LD_LIBRARY_PATH or $LIBRARY_PATH environment variable, and\n   then the -L option will not be required (or it‚Äôs equivalent in your\n   programming environment). export LD_LIBRARY_PATH = $HOME /.local/lib: $LD_LIBRARY_PATH NOTE : If you use multiple Fortran compilers you may need to create\n   a different directory for each compiler. I would recommend it, such\n   as $HOME/.local/lib/gfortran/. Creating a shared library If you desire a shared library as well, for gfortran you may enter make clean gfortran gfortran_install and everything needed by gfortran will be placed in libgfortran/ that\n   you may add to an appropriate area, such as $HOME/.local/lib/gfortran/. make clean ifort ifort_install # same for ifort does the same for the ifort compiler and places the output in libifort/. Specifics may vary NOTE: The build instructions above are specific to a ULS (Unix-Like\n   System) and may differ, especially for those wishing to generate shared\n   libraries (which varies significantly depending on the programming\n   environment). For some builds it is simpler to make a Makefile for\n   each compiler, which might be required for a more comprehensive build\n   unless you are very familiar with gmake(1). If you always use one compiler it is relatively simple, otherwise\n   make sure you know what your system requires and change the Makefile\n   as appropriate. Build with FPM Alternatively, fpm(1) users may download the github repository and build it with\n   fpm ( as described at Fortran Package Manager ) git clone https://github.com/urbanjost/M_unicode.git cd M_unicode fpm test # build and test the module fpm install # install the module (in the default location) or just list it as a dependency in your fpm.toml project file. [dependencies] M_unicode = { git = \"https://github.com/urbanjost/M_unicode.git\" } Download and Build using cmake To download the github repository and build and install with cmake\n(you may wish to change the install path in src/CMakeLists.txt first) : git clone https://github.com/urbanjost/M_unicode.git cd M_unicode # Create a Build Directory: mkdir -p build cd build cmake -S ../src -B . # Configure the Build, specifying your preferred compiler (ifort, flang, etc.): cmake . -DCMAKE_Fortran_COMPILER = gfortran # Build the Project: cmake --build . #This creates: # #    build/lib/libM_unicode.a (the static library). #    build/include/*.mod (module files). #    build/test/* (test executables). #    build/example/* (example executables). # OPTIONAL SECTION: # Verify build ls build/lib/libM_unicode.a ls build/include/*.mod ls build/test/* ls build/example/* #Optionally Run Tests and Examples: for name in ./test/* ./example/* do $name done #Install (Optional): # This installs the library and module files to the system # (e.g., /usr/local/lib/ and /usr/local/include/). cmake --install . # if you have insufficient permissions sudo(1) may be required # to perform the install #sudo cmake --install . # Verify installation ls /usr/local/lib/libM_unicode.a ls /usr/local/include/*.mod # Cleaning Up: To clean artifacts, remove the build/ directory: rm -rf build Supports Meson Alternatively, meson(1) users may download the github repository and build it with\n   meson ( as described at Meson Build System ) git clone https://github.com/urbanjost/M_unicode.git cd M_unicode meson setup _build meson test -C _build # build and test the module # install the module (in the <DIR> location) # --destdir is only on newer versions of meson meson install -C _build --destdir <DIR> # older method if --destdir is not available env DESTDIR = <DIR> meson install -C _build or just list it as a subproject dependency in your meson.build project file. M_unicode_dep = subproject ( 'M_unicode' ). get_variable ( 'M_unicode_dep' ) Summary Yes, a Fortran source file can contain multibyte Unicode characters in\nmost environments, but the level of support and how they are handled\ndepends on the specific Fortran compiler and operating system and is\nnot otherwise defined by the Fortran standard. The appearance of multi-byte characters in comments and character\nconstants is typically all that is allowed and compiler errors occur\nwhen unsupported characters outside the Fortran character set are used\nin the body of the code ‚Äì unless the vendor extends Fortran beyond the\nrequirements of the Fortran standard. It is assumed here that is not the\ncase; so be careful that outside of quoted strings and comments that only\nASCII-7-bit characters are used to write the actual coding instructions. Some editors might try to be ‚Äúhelpful‚Äù and change ASCII quote and dash\ncharacters to other multi-byte characters when editing UTF-8 files, so\nbe aware you might need to normalize your source files into the allowed\nFortran character set outside of constant strings. When using Unicode as byte streams avoid list-directed output. It\ndoes not know which bytes are composing a glyph and may split lines at\ninappropriate points. Compiler Support: Even with standard features, compiler support for Unicode in source\n   files can vary. Some compilers might require specific flags (e.g.,\n   -qmbcs for XL Fortran) or might offer better integration with\n   system-level Unicode functionalities. Source File Encoding: The encoding of the Fortran source file itself is crucial. If the\n    file is saved in a Unicode encoding like UTF-8, the compiler needs\n   to be able to correctly interpret these characters during compilation. Limitations: While modern Fortran can handle Unicode characters, there might still be\nlimitations compared to languages like C++ regarding the ease of use with\ncomplex Unicode features (e.g., surrogate pairs, text directionality,\nnormalization). For many uses of Unicode support of codepoints and system\nsupport for UTF-8 encoding is sufficient, however. ## References\n * Initially based on a discussion begun in\nhttps://fortran-lang.discourse.group/t/how-to-use-utf-8-in-gfortran/9949, 2025-08;\nincluding features and enhancements from Francois Jacq. The improvements include procedures for handling ASCII encoding extensions\n   often used for internationalization that pre-date Unicode, such as the\n   Latin encodings now in module M_isolatin . See Also https://fortran-lang.discourse.group/t/how-to-use-utf-8-in-gfortran/9949 https://fortran-lang.discourse.group/t/how-do-i-file-read-french-special-characters-like-e-etc/6618 https://fortran-lang.discourse.group/t/using-unicode-characters-in-fortran/2764 Developer Info John S. Urban","tags":"home","url":"index.html"},{"title":"unicode_type ‚Äì M_unicode ","text":"type, public :: unicode_type Constructor public        interface unicode_type private module function new_codes(codes) result(new) Arguments Type Intent Optional Attributes Name integer, intent(in) :: codes (:) Return Value type( unicode_type ) private elemental module function new_str(string) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Return Value type( unicode_type ) private module function new_strs(strings) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: strings (:) Return Value type( unicode_type ), (size(strings)) Type-Bound Procedures procedure, public :: adjustl => oop_adjustl private  function oop_adjustl(self, glyphs) result(string_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self integer, intent(in), optional :: glyphs Return Value type( unicode_type ) procedure, public :: adjustr => oop_adjustr private  function oop_adjustr(self, glyphs) result(string_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self integer, intent(in), optional :: glyphs Return Value type( unicode_type ) procedure, public :: byte => oop_byte private  function oop_byte(self, first, last, step) result(bytes_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self integer, intent(in), optional :: first integer, intent(in), optional :: last integer, intent(in), optional :: step Return Value character(len=1), allocatable, (:) procedure, public :: ch => oop_character private  function oop_character(self, first, last, step) result(str_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self integer, intent(in), optional :: first integer, intent(in), optional :: last integer, intent(in), optional :: step Return Value character(len=:), allocatable procedure, public :: character => oop_character private  function oop_character(self, first, last, step) result(str_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self integer, intent(in), optional :: first integer, intent(in), optional :: last integer, intent(in), optional :: step Return Value character(len=:), allocatable procedure, public :: codepoint => oop_codepoint private  function oop_codepoint(self, first, last, step) result(codes_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self integer, intent(in), optional :: first integer, intent(in), optional :: last integer, intent(in), optional :: step Return Value integer, allocatable, (:) procedure, public :: escape => oop_escape private  function oop_escape(self, protect) result(string_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self character(len=1), intent(in), optional :: protect Return Value type( unicode_type ) procedure, public :: expandtabs => oop_expandtabs private  function oop_expandtabs(self, tab_size) result(string_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self integer, intent(in), optional :: tab_size Return Value type( unicode_type ) procedure, public :: fmt => oop_fmt private  function oop_fmt(self, format) result(string_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self character(len=*), optional :: format Return Value type( unicode_type ) procedure, public :: get_arg => oop_get_arg_iu private  function oop_get_arg_iu(self, position) result(value) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self integer, intent(in) :: position Return Value type( unicode_type ) procedure, public :: get_env => oop_get_env_uu private  function oop_get_env_uu(self, default) result(value) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self type( unicode_type ), intent(in) :: default Return Value type( unicode_type ) procedure, public :: ichar => oop_ichar private elemental function oop_ichar(self) result(code) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self Return Value integer procedure, public :: index => oop_index private impure function oop_index(self, substring) result(index_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self class(*), intent(in) :: substring Return Value integer procedure, public :: join => oop_join private  function oop_join(self, array, clip) result(out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self type( unicode_type ), intent(in) :: array (:) logical, intent(in), optional :: clip Return Value type( unicode_type ) procedure, public :: len => oop_len private pure function oop_len(self) result(len_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self Return Value integer procedure, public :: len_trim => oop_len_trim private pure function oop_len_trim(self) result(len_trim_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self Return Value integer procedure, public :: lower => oop_lower private  function oop_lower(self) result(string_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self Return Value type( unicode_type ) procedure, public :: oop_get_env_ua private  function oop_get_env_ua(self, default) result(value) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self character(len=*), intent(in) :: default Return Value type( unicode_type ) procedure, public :: pad => oop_pad private  function oop_pad(self, length, pattern, right, clip) result(out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self integer, intent(in) :: length type( unicode_type ), intent(in), optional :: pattern logical, intent(in), optional :: right logical, intent(in), optional :: clip Return Value type( unicode_type ) generic, public :: replace => oop_replace_uuu, oop_replace_uaa, oop_replace_uau, oop_replace_uua, oop_section_uu, oop_section_ua private  function oop_replace_uuu(self, old, new, occurrence, repeat, ignorecase, changes, back) result(newline) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self type( unicode_type ), intent(in) :: old type( unicode_type ), intent(in) :: new integer, intent(in), optional :: occurrence integer, intent(in), optional :: repeat logical, intent(in), optional :: ignorecase integer, intent(out), optional :: changes logical, intent(in), optional :: back Return Value type( unicode_type ) private  function oop_replace_uaa(self, old, new, occurrence, repeat, ignorecase, changes, back) result(newline) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self character(len=*), intent(in) :: old character(len=*), intent(in) :: new integer, intent(in), optional :: occurrence integer, intent(in), optional :: repeat logical, intent(in), optional :: ignorecase integer, intent(out), optional :: changes logical, intent(in), optional :: back Return Value type( unicode_type ) private  function oop_replace_uau(self, old, new, occurrence, repeat, ignorecase, changes, back) result(newline) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self character(len=*), intent(in) :: old type( unicode_type ), intent(in) :: new integer, intent(in), optional :: occurrence integer, intent(in), optional :: repeat logical, intent(in), optional :: ignorecase integer, intent(out), optional :: changes logical, intent(in), optional :: back Return Value type( unicode_type ) private  function oop_replace_uua(self, old, new, occurrence, repeat, ignorecase, changes, back) result(newline) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self type( unicode_type ), intent(in) :: old character(len=*), intent(in) :: new integer, intent(in), optional :: occurrence integer, intent(in), optional :: repeat logical, intent(in), optional :: ignorecase integer, intent(out), optional :: changes logical, intent(in), optional :: back Return Value type( unicode_type ) private  function oop_section_uu(self, start, end, new) result(newline) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self integer, intent(in) :: start integer, intent(in) :: end type( unicode_type ), intent(in) :: new Return Value type( unicode_type ) private  function oop_section_ua(self, start, end, new) result(newline) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self integer, intent(in) :: start integer, intent(in) :: end character(len=*), intent(in) :: new Return Value type( unicode_type ) procedure, public :: scan => oop_scan private pure function oop_scan(self, set, back) result(pos) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self class( unicode_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer procedure, public :: split => oop_split private  function oop_split(self, set) result(tokens) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self type( unicode_type ), intent(in) :: set Return Value type( unicode_type ), allocatable, (:) procedure, public :: sub => oop_sub private  function oop_sub(self, first, last, step) result(str_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self integer, intent(in), optional :: first integer, intent(in), optional :: last integer, intent(in), optional :: step Return Value type( unicode_type ) procedure, public :: tokenize => oop_tokenize private  function oop_tokenize(self, set) result(tokens) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self type( unicode_type ), intent(in) :: set Return Value type( unicode_type ), allocatable, (:) generic, public :: transliterate => oop_transliterate_uu, oop_transliterate_aa, oop_transliterate_au, oop_transliterate_ua private  function oop_transliterate_uu(self, old_set, new_set) result(outstr) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self type( unicode_type ), intent(in) :: old_set type( unicode_type ), intent(in) :: new_set Return Value type( unicode_type ) private  function oop_transliterate_aa(self, old_set, new_set) result(outstr) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self character(len=*), intent(in) :: old_set character(len=*), intent(in) :: new_set Return Value type( unicode_type ) private  function oop_transliterate_au(self, old_set, new_set) result(outstr) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self character(len=*), intent(in) :: old_set type( unicode_type ), intent(in) :: new_set Return Value type( unicode_type ) private  function oop_transliterate_ua(self, old_set, new_set) result(outstr) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self type( unicode_type ), intent(in) :: old_set character(len=*), intent(in) :: new_set Return Value type( unicode_type ) procedure, public :: trim => oop_trim private pure function oop_trim(self) result(string_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self Return Value type( unicode_type ) procedure, public :: upper => oop_upper private  function oop_upper(self) result(string_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self Return Value type( unicode_type ) procedure, public :: verify => oop_verify private impure function oop_verify(self, set, back) result(pos) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self class( unicode_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer Source Code type :: unicode_type ! Unicode string type holding an arbitrary sequence of integer codes. !sequence ! not used for storage association; a kludge to prevent extending this type. private integer , allocatable :: codes (:) contains ! METHODS (type-bound procedures) : ! conversion procedure :: character => oop_character ! a single variable in UTF-8 encoding procedure :: ch => oop_character ! a single variable in UTF-8 encoding procedure :: codepoint => oop_codepoint ! codes of each glyph procedure :: byte => oop_byte ! stream of bytes in UTF-8 encoding procedure :: ichar => oop_ichar ! code of a single character ! intrinsics procedure :: adjustl => oop_adjustl procedure :: adjustr => oop_adjustr procedure :: index => oop_index procedure :: len => oop_len procedure :: len_trim => oop_len_trim procedure :: trim => oop_trim procedure :: split => oop_split procedure :: tokenize => oop_tokenize procedure :: scan => oop_scan procedure :: verify => oop_verify ! transform procedure :: upper => oop_upper procedure :: lower => oop_lower procedure :: expandtabs => oop_expandtabs procedure :: escape => oop_escape procedure :: fmt => oop_fmt procedure :: sub => oop_sub procedure :: pad => oop_pad procedure :: join => oop_join procedure :: get_env => oop_get_env_uu , oop_get_env_ua procedure :: get_arg => oop_get_arg_iu procedure , private :: oop_transliterate_uu , oop_transliterate_aa , oop_transliterate_au , oop_transliterate_ua generic , public :: transliterate => oop_transliterate_uu , oop_transliterate_aa , oop_transliterate_au , oop_transliterate_ua procedure , private :: oop_replace_uuu procedure , private :: oop_replace_uaa procedure , private :: oop_replace_uau procedure , private :: oop_replace_uua procedure , private :: oop_section_uu procedure , private :: oop_section_ua generic , public :: replace => oop_replace_uuu , oop_replace_uaa , oop_replace_uau , oop_replace_uua , & & oop_section_uu , oop_section_ua !DECLARATION OF OVERLOADED OPERATORS FOR TYPE(UNICODE_TYPE) procedure , private :: eq => oop_eq !   generic           :: operator(==) => oop_eq !   procedure,private :: ge => oop_ge !   generic           :: operator(>=) => oop_ge !   procedure,private :: lt => oop_lt !   generic           :: operator(<)  => oop_lt !   procedure,private :: gt => oop_gt !   generic           :: operator(>)  => oop_gt !   procedure,private :: le => oop_le !   generic           :: operator(<=) => oop_le !   procedure,private :: ne => oop_ne !   generic           :: operator(/=) => oop_ne !   procedure,private :: oop_g_g !   generic           :: operator(//) => oop_g_g end type unicode_type","tags":"","url":"type/unicode_type.html"},{"title":"numberline ‚Äì M_unicode","text":"subroutine numberline(ireps) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ireps Source Code subroutine numberline ( ireps ) integer , intent ( in ) :: ireps write ( * , '(1x,a)' ) repeat ( '1234567890' , ireps ) end subroutine numberline","tags":"","url":"proc/numberline.html"},{"title":"inset ‚Äì M_unicode","text":"function inset(string) result(longer) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=:), allocatable Variables Type Visibility Attributes Name Initial integer, public :: i character(len=*), public, parameter :: nl = new_line('a') Source Code function inset ( string ) result ( longer ) character ( len =* ), intent ( in ) :: string character ( len = :), allocatable :: longer character ( len =* ), parameter :: nl = new_line ( 'a' ) integer :: i longer = '' do i = 1 , len ( string ) longer = longer // string ( i : i ) if ( string ( i : i ). eq . nl ) then longer = longer // '   ' endif enddo end function inset","tags":"","url":"proc/inset.html"},{"title":"platform ‚Äì M_unicode","text":"subroutine platform() Uses iso_fortran_env Arguments None Variables Type Visibility Attributes Name Initial integer, public :: break integer, public :: col integer, public :: i integer, public :: last character(len=*), public, parameter :: nl = new_line('a') character(len=:), public, allocatable :: options integer, public :: start character(len=:), public, allocatable :: version integer, public :: where Source Code subroutine platform () use , intrinsic :: iso_fortran_env , only : compiler_version use , intrinsic :: iso_fortran_env , only : compiler_options implicit none character ( len = :), allocatable :: version , options character ( len =* ), parameter :: nl = new_line ( 'a' ) integer :: where , start , break , i , last , col version = compiler_version () // ' ' options = ' ' // compiler_options () start = 1 do where = index ( options ( start :), ' -' ) if ( where . eq . 0 ) exit break = where + start - 1 options ( break : break ) = nl start = where enddo if ( start . eq . 1 ) then do where = index ( options ( start :), ' /' ) if ( where . eq . 0 ) exit break = where + start - 1 options ( break : break ) = nl start = where enddo endif last = len_trim ( version ) + 1 col = 0 do i = 1 , len_trim ( version ) col = col + 1 if ( version ( i : i ). eq . ' ' ) last = i if ( col . gt . 76 ) then version ( last : last ) = nl col = 0 endif enddo print '(a,/,3x,*(a))' , 'This file was compiled by :' , inset ( version ) if ( options . ne . '' ) then print '(*(a))' , 'using the options :' , inset ( options ) endif end subroutine platform","tags":"","url":"proc/platform.html"},{"title":"test ‚Äì M_unicode","text":"subroutine test(in, expected) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: in type( unicode_type ), intent(in) :: expected Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: nl = new_line('A') type( unicode_type ), public :: uppercase Source Code subroutine test ( in , expected ) type ( unicode_type ), intent ( in ) :: in type ( unicode_type ), intent ( in ) :: expected type ( unicode_type ) :: uppercase character ( len =* ), parameter :: nl = new_line ( 'A' ) write ( stdout , g ) in % character () uppercase = upper ( in ) write ( stdout , g ) uppercase % character () write ( stdout , g ) merge ( 'PASSED' , 'FAILED' , uppercase == expected ), nl end subroutine test","tags":"","url":"proc/test.html"},{"title":"showme ‚Äì M_unicode","text":"subroutine showme(uline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: uline Variables Type Visibility Attributes Name Initial integer, public :: i Source Code subroutine showme ( uline ) type ( unicode_type ), intent ( in ) :: uline integer :: i write ( stdout , cat ) ' ' , repeat ( '1234567890' , len ( uline ) / 10 + 1 ) write ( stdout , bracket ) character ( uline ) write ( stdout , cat ) 'length in bytes is: ' , len ( uline % character ()) write ( stdout , cat ) 'length in glyphs is: ' , len ( uline ) write ( stdout , cat ) 'trimmed length in glyphs is: ' , len_trim ( uline ) write ( stdout , cat ) 'adjustr:[' , character ( adjustr ( uline )), ']' write ( stdout , cat ) 'adjustl:[' , character ( adjustl ( uline )), ']' write ( stdout , cat ) 'cropped:[' , character ( trim ( adjustl ( uline ))), ']' write ( stdout , gap ) 'codepoints:' , uline % codepoint () write ( stdout , dash ) 'glyphs:' ,( character ( uline % sub ( i , i )), i = 1 , len ( uline )) write ( stdout , * ) end subroutine showme","tags":"","url":"proc/showme.html"},{"title":"getarg ‚Äì M_unicode","text":"function getarg(arg) result(argument) Arguments Type Intent Optional Attributes Name integer, intent(in) :: arg Return Value character(len=:), allocatable Variables Type Visibility Attributes Name Initial integer, public :: length Source Code function getarg ( arg ) result ( argument ) integer , intent ( in ) :: arg integer :: length character ( len = :), allocatable :: argument call get_command_argument ( arg , length = length ) ! get command line argument length allocate ( character ( len = length ) :: argument ) ! allocate string big enough to hold argument call get_command_argument ( arg , argument ) ! get command line argument as a string end function getarg","tags":"","url":"proc/getarg.html"},{"title":"passed ‚Äì M_unicode","text":"subroutine passed(str) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: str Source Code subroutine passed ( str ) type ( ut ), intent ( in ) :: str ! you can query the length of the passed variable ! when an interface is present write ( * , '(*(g0))' ) 'length of passed value is ' , len ( str ) end subroutine passed","tags":"","url":"proc/passed.html"},{"title":"getargs ‚Äì M_unicode","text":"function getargs() result(command_line) Arguments None Return Value character(len=:), allocatable Variables Type Visibility Attributes Name Initial integer, public :: length Source Code function getargs () result ( command_line ) integer :: length character ( len = :), allocatable :: command_line call get_command ( length = length ) ! get command line length allocate ( character ( len = length ) :: command_line ) ! allocate string big enough to hold command line call get_command ( command = command_line ) ! get command line as a string call get_command_argument ( 0 , length = length ) ! remove argument 0 command_line = adjustl ( command_line ( length + 2 :)) end function getargs","tags":"","url":"proc/getargs.html"},{"title":"downside_up ‚Äì M_unicode","text":"function downside_up(string) result(uline) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( unicode_type ) Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ichr integer, public :: ichrs (len(string)) character(len=1), public :: letter integer, public :: which Source Code function downside_up ( string ) result ( uline ) character ( len =* ), intent ( in ) :: string type ( ut ) :: uline character ( len = 1 ) :: letter integer :: i integer :: which integer :: ichr integer :: ichrs ( len ( string )) which = 1 do i = 1 , len ( string ) letter = string ( i : i ) select case ( letter ) case ( ' ' ); ichr = iachar ( ' ' ) case ( '!' ); ichr = int ( z '00A1' ) case ( '\"' ); ichr = int ( z '201E' ) case ( '#' ); ichr = iachar ( '#' ) case ( '$' ); ichr = iachar ( '$' ) case ( '%' ); ichr = iachar ( '%' ) case ( '&' ); ichr = int ( z '214B' ) case ( '''' ); ichr = int ( z '002C' ) case ( '(' ); ichr = int ( z '0029' ) case ( ')' ); ichr = iachar ( '(' ) case ( '*' ); ichr = iachar ( '*' ) case ( '+' ); ichr = iachar ( '+' ) case ( ',' ); ichr = iachar ( '''' ) case ( '-' ); ichr = iachar ( '-' ) case ( '.' ); ichr = int ( z '02D9' ) case ( '/' ); ichr = iachar ( '/' ) case ( '0' ); ichr = iachar ( '0' ) case ( '1' ); ichr = int ( z '0196' ) case ( '2' ); ichr = int ( z '1105' ) case ( '3' ); ichr = int ( z '0190' ) case ( '4' ); ichr = int ( z '152D' ) if ( which . eq . 2 ) ichr = int ( z '3123' ) if ( which . eq . 3 ) ichr = iachar ( 'h' ) case ( '5' ); ichr = int ( z '03DB' ) case ( '6' ); ichr = iachar ( '9' ) case ( '7' ); ichr = int ( z '2C62' ) if ( which . eq . 2 ) ichr = int ( z '3125' ) case ( '8' ); ichr = iachar ( '8' ) case ( '9' ); ichr = iachar ( '6' ) case ( ':' ); ichr = iachar ( ':' ) case ( ';' ); ichr = int ( z '061B' ) case ( '<' ); ichr = iachar ( '>' ) case ( '=' ); ichr = iachar ( '=' ) case ( '>' ); ichr = iachar ( '<' ) case ( '?' ); ichr = int ( z '00BF' ) case ( '@' ); ichr = iachar ( '@' ) ! Default ‚àÄêêí‚ÜÉ‚óñ∆é‚Ñ≤‚ÖÅHI≈ø‚ãä‚ÖÇW·¥éO‘ÄŒå·¥öS‚ä•‚à©·¥ßMX‚ÖÑZ case ( 'A' ); ichr = int ( z '2200' ) if ( which . eq . 4 ) ichr = int ( z 'A4EF' ) ! ÍìØ case ( 'B' ); ichr = int ( z '00010412' ) if ( which . eq . 4 ) ichr = int ( z 'A4ED' ) ! Íì≠ case ( 'C' ); ichr = int ( z '2183' ) if ( which . eq . 2 ) ichr = int ( z '0186' ) ichr = int ( z 'A4DB' ) ! Íìõ case ( 'D' ); ichr = int ( z '25D6' ) ichr = int ( z 'A4F7' ) ! Íì∑ case ( 'E' ); ichr = int ( z '018E' ) ichr = int ( z 'A4F1' ) ! Íì± case ( 'F' ); ichr = int ( z '2132' ) if ( which . eq . 4 ) ichr = int ( z 'A4DE' ) ! Íìû case ( 'G' ); ichr = int ( z '2141' ) ichr = int ( z 'A4E8' ) ! Íì® if ( which . eq . 2 ) ichr = int ( z '05E4' ) case ( 'H' ); ichr = iachar ( 'H' ) ichr = int ( z 'A4E7' ) ! Íìß case ( 'I' ); ichr = iachar ( 'I' ) ichr = int ( z 'A4F2' ) ! Íì≤ case ( 'J' ); ichr = int ( z '017F' ) ichr = int ( z 'A4E9' ) ! Íì© case ( 'K' ); ichr = int ( z '22CA' ) ichr = int ( z 'A4D8' ) ! Íìò case ( 'L' ); ichr = int ( z '2142' ) if ( which . eq . 4 ) ichr = int ( z 'A4F6' ) ! Íì∂ if ( which . eq . 2 ) ichr = int ( z '02E5' ) case ( 'M' ); ichr = ichar ( 'W' ) ichr = int ( z 'A4EA' ) ! Íì™ case ( 'N' ); ichr = int ( z '1D0E' ) ichr = int ( z 'A4E0' ) ! Íì† case ( 'O' ); ichr = iachar ( 'O' ) ichr = int ( z 'A4F3' ) ! Íì≥ case ( 'P' ); ichr = int ( z '0500' ) ichr = int ( z 'A4D2' ) ! Íìí case ( 'Q' ); ichr = int ( z '038C' ) case ( 'R' ); ichr = int ( z '1D1A' ) ichr = int ( z 'A4E4' ) ! Íì§ case ( 'S' ); ichr = iachar ( 'S' ) ichr = int ( z 'A4E2' ) ! Íì¢ case ( 'T' ); ichr = int ( z '22A5' ) ichr = int ( z 'A4D5' ) ! Íìï if ( which . eq . 2 ) ichr = int ( z '2534' ) case ( 'U' ); ichr = int ( z '2229' ) ichr = int ( z 'A4F5' ) ! Íìµ case ( 'V' ); ichr = int ( z '1D27' ) ichr = int ( z 'A4E5' ) ! Íì• if ( which . eq . 2 ) ichr = int ( z '039B' ) case ( 'W' ); ichr = iachar ( 'M' ) ichr = int ( z 'A4DF' ) ! Íìü case ( 'X' ); ichr = iachar ( 'X' ) ichr = int ( z 'A4EB' ) ! Íì´ case ( 'Y' ); ichr = int ( z '2144' ) case ( 'Z' ); ichr = iachar ( 'Z' ) ichr = int ( z 'A4DC' ) ! Íìú case ( '[' ); ichr = iachar ( ']' ) case ( '\\'); ichr=iachar(' \\ ') case(' ] '); ichr=iachar(' [ ') case(' &#94; '); ichr=iachar(' v ') case(' _ '); ichr=int(z' 20 3 E ') case(' ` '); ichr=iachar(' , ') case(' a '); ichr=int(z' 0250 ') case(' b '); ichr=iachar(' q ') case(' c '); ichr=int(z' 0254 ') case(' d '); ichr=iachar(' p ') case(' e '); ichr=int(z' 01 DD ') case(' f '); ichr=int(z' 025 F ') case(' g '); ichr=int(z' 0183 ') case(' h '); ichr=int(z' 0265 ') case(' i '); ichr=int(z' 0131 ') if(which.eq.2)ichr=int(z' 1 D09 ') case(' j '); ichr=int(z' 02 7 E ') case(' k '); ichr=int(z' 02 9 E ') case(' l '); ichr=int(z' 0283 ') case(' m '); ichr=int(z' 026 F ') case(' n '); ichr=iachar(' u ') case(' o '); ichr=iachar(' o ') case(' p '); ichr=iachar(' d ') case(' q '); ichr=iachar(' b ') case(' r '); ichr=int(z' 0279 ') case(' s '); ichr=iachar(' s ') case(' t '); ichr=int(z' 0287 ') case(' u '); ichr=iachar(' n ') case(' v '); ichr=int(z' 028 C ') case(' w '); ichr=int(z' 028 D ') case(' x '); ichr=iachar(' x ') case(' y '); ichr=int(z' 02 8 E ') case(' z '); ichr=iachar(' z ') case(' { '); ichr=iachar(' } ') case(' | '); ichr=iachar(' | ') case(' } '); ichr=iachar(' { ') case(' ~ '); ichr=iachar(' ~' ) case default ichr = iachar ( letter ) end select ichrs ( size ( ichrs ) - i + 1 ) = ichr enddo uline = ichrs end function downside_up","tags":"","url":"proc/downside_up.html"},{"title":"getargs ‚Äì M_unicode","text":"function getargs() result(command_line) Arguments None Return Value character(len=:), allocatable Variables Type Visibility Attributes Name Initial integer, public :: length Source Code function getargs () result ( command_line ) integer :: length character ( len = :), allocatable :: command_line call get_command ( length = length ) ! get command line length allocate ( character ( len = length ) :: command_line ) ! allocate string big enough to hold command line call get_command ( command = command_line ) ! get command line as a string call get_command_argument ( 0 , length = length ) ! remove argument 0 command_line = adjustl ( command_line ( length + 2 :)) end function getargs","tags":"","url":"proc/getargs~2.html"},{"title":"getargs ‚Äì M_unicode","text":"function getargs() result(command_line) Arguments None Return Value character(len=:), allocatable Variables Type Visibility Attributes Name Initial integer, public :: length Source Code function getargs () result ( command_line ) integer :: length character ( len = :), allocatable :: command_line call get_command ( length = length ) ! get command line length allocate ( character ( len = length ) :: command_line ) ! allocate string big enough to hold command line call get_command ( command = command_line ) ! get command line as a string call get_command_argument ( 0 , length = length ) ! remove argument 0 command_line = command_line ( length + 2 :) end function getargs","tags":"","url":"proc/getargs~3.html"},{"title":"afmt ‚Äì M_unicode","text":"public recursive function afmt(generic, format) result(line) NAME FMT(3f) - [M_unicode:CONVERSION] convert any intrinsic to a string using specified format\n (LICENSE:MIT) SYNOPSIS function fmt(value,format) result ( string ) class ( * ), intent ( in ), optional :: value character ( len = * ), intent ( in ), optional :: format or type ( unicode_type ), intent ( in ), optional :: format type ( unicode_type ) :: string DESCRIPTION FMT(3f) converts any standard intrinsic value to a string using the specified\n format. OPTIONS value value to print the value of . May be of type INTEGER , LOGICAL , REAL , DOUBLEPRECISION , COMPLEX , or CHARACTER as well as TYPE ( UNICODE_TYPE ). format format to use to print value . It is up to the user to use an appropriate format . The format does not require being surrounded by parenthesis . If not present a default is selected similar to what would be produced with free format , with trailing zeros removed . RETURNS string   A string value EXAMPLES Sample program : program demo_fmt use :: M_unicode , only : fmt , assignment ( = ) use :: M_unicode , only : ut => unicode_type , ch => character implicit none character ( len = : ), allocatable :: Astr , Aformat type ( ut ) :: Ustr ! format can be CHARACTER Aformat = \"('[',i0,']')\" Astr = fmt ( 10 , Aformat ) write ( * , * ) 'result is ' , Astr ! format can be string Astr = fmt ( 10.0 / 3.0 , ut ( \"'[',g0.5,']'\" )) write ( * , * ) 'result is ' , Astr ! Output is a string , so use ch () write ( * , * ) 'result is ' , ch ( fmt (. true ., \"'The answer is [',g0,']'\" )) ! OOP Ustr = 'A B C' Ustr = Ustr % fmt ( \"'[',g0,']'\" ) write ( * , * ) 'result is ' , ch ( Ustr ) end program demo_fmt Results : result is [ 10 ] result is [ 3.3333 ] result is The final answer is [ T ] result is [ A B C ] AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name class(*), intent(in) :: generic character(len=*), intent(in), optional :: format Return Value character(len=:), allocatable Source Code recursive function afmt ( generic , format ) result ( line ) ! ident_19=\"@(#) M_unicode afmt(3f) convert any intrinsic to a CHARACTER variable using specified format\" class ( * ), intent ( in ) :: generic character ( len =* ), intent ( in ), optional :: format character ( len = :), allocatable :: line character ( len = :), allocatable :: fmt_local character ( len = :), allocatable :: re , im integer :: iostat character ( len = 255 ) :: iomsg character ( len = 1 ), parameter :: null = char ( 0 ) integer :: iilen logical :: trimit if ( present ( format )) then fmt_local = format trimit = . false . else fmt_local = '' trimit = . true . endif ! add \",a\" and print null and use position of null to find length of output ! add cannot use SIZE= or POS= or ADVANCE='NO' on WRITE() on INTERNAL READ, ! and do not want to trim as trailing spaces can be significant if ( fmt_local == '' ) then select type ( generic ) type is ( integer ( kind = int8 )); fmt_local = '(i0,a)' type is ( integer ( kind = int16 )); fmt_local = '(i0,a)' type is ( integer ( kind = int32 )); fmt_local = '(i0,a)' type is ( integer ( kind = int64 )); fmt_local = '(i0,a)' type is ( real ( kind = real32 )); fmt_local = '(1pg0,a)' type is ( real ( kind = real64 )); fmt_local = '(1pg0,a)' #ifdef FLOAT128 type is ( real ( kind = real128 )); fmt_local = '(1pg0,a)' #endif type is ( logical ); fmt_local = '(l1,a)' type is ( character ( len =* )); fmt_local = '(a,a)' trimit = . false . type is ( unicode_type ); fmt_local = '(a,a)' trimit = . false . type is ( complex ); fmt_local = '(\"(\",1pg0,\",\",1pg0,\")\",a)' type is ( complex ( kind = real64 )); fmt_local = '(\"(\",1pg0,\",\",1pg0,\")\",a)' class default fmt_local = '(*(g0,1x)' stop '<ERROR>*afmt* unknown type.' end select else if ( format ( 1 : 1 ) == '(' ) then fmt_local = format (: len_trim ( format ) - 1 ) // ',a)' else fmt_local = '(' // fmt_local // ',a)' endif endif if ( allocated ( line )) deallocate ( line ) allocate ( character ( len = 256 ) :: line ) ! cannot currently write into allocatable variable iostat = 0 select type ( generic ) type is ( integer ( kind = int8 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , null type is ( integer ( kind = int16 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , null type is ( integer ( kind = int32 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , null type is ( integer ( kind = int64 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , null type is ( real ( kind = real32 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , null type is ( real ( kind = real64 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , null #ifdef FLOAT128 type is ( real ( kind = real128 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , null #endif type is ( logical ); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , null type is ( character ( len =* )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , null type is ( unicode_type ); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) character ( generic ), null type is ( complex ); if ( trimit ) then re = afmt ( real ( generic )) im = afmt ( aimag ( generic )) call trimzeros_ ( re ) call trimzeros_ ( im ) fmt_local = '(\"(\",g0,\",\",g0,\")\",a)' write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) trim ( re ), trim ( im ), null trimit = . false . else write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , null endif type is ( complex ( kind = real64 )); if ( trimit ) then re = afmt ( real ( generic )) im = afmt ( aimag ( generic )) call trimzeros_ ( re ) call trimzeros_ ( im ) fmt_local = '(\"(\",g0,\",\",g0,\")\",a)' write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) trim ( re ), trim ( im ), null trimit = . false . else write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , null endif class default stop '<ERROR>*afmt* unknown type' end select if ( iostat /= 0 ) then line = '<ERROR>' // trim ( iomsg ) else iilen = index ( line , null , back = . true .) if ( iilen == 0 ) iilen = len ( line ) line = line (: iilen - 1 ) endif if ( index ( line , '.' ) /= 0 . and . trimit ) call trimzeros_ ( line ) end function afmt","tags":"","url":"proc/afmt.html"},{"title":"expandtabs ‚Äì M_unicode","text":"public elemental function expandtabs(instr, tab_size) result(out) NAME EXPANDTABS(3f) - [M_unicode:WHITESPACE] function to expand tab characters\n (LICENSE:MIT) SYNOPSIS elemental function expandtabs ( INSTR , TABSIZE ) result ( OUT ) type ( unicode_type ), intent =( in ) :: INSTR integer , intent ( in ), optional :: TAB_SIZE type ( unicode_type ) :: OUT DESCRIPTION EXPANDTABS(3) expands tabs in INSTR to spaces in OUT. It assumes a\ntab is set every 8 characters by default. Trailing spaces are removed. OPTIONS instr     Input line to remove tabs from\ntab_size  spacing between tab stops. RETURNS out       Output string with tabs expanded. EXAMPLES Sample program: program demo_expandtabs use M_unicode , only : expandtabs , ch => character , replace use M_unicode , only : assignment ( = ), ut => unicode_type implicit none type ( ut ) :: in type ( ut ) :: inexpanded character ( len = : ), allocatable :: dat integer :: i dat = '  this is my string  ' ! change spaces to tabs to make a sample input do i = 1 , len ( dat ) if ( dat ( i : i ) == ' ' ) dat ( i : i ) = char ( 9 ) enddo in = dat ! inexpanded = expandtabs ( in ) write ( * , '(\"[\",a,\"]\")' ) ch ( inexpanded ) inexpanded = replace ( inexpanded , ut ( ' ' ), ut ( '_' )) write ( * , '(\"[\",a,\"]\")' ) ch ( inexpanded ) ! write ( * , '(\"[\",a,\"]\")' ) ch ( in % expandtabs ()) write ( * , '(\"[\",a,\"]\")' ) ch ( in % expandtabs ( tab_size = 8 )) write ( * , '(\"[\",a,\"]\")' ) ch ( in % expandtabs ( tab_size = 1 )) write ( * , '(\"[\",a,\"]\")' ) ch ( in % expandtabs ( tab_size = 0 )) ! end program demo_expandtabs Results : > [ this    is      my      string ] > [ ________________this____is______my______string ] > [ this    is      my      string ] > [ this    is      my      string ] > [ this is my string ] > [ thisismystring ] AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: instr integer, intent(in), optional :: tab_size Return Value type( unicode_type ) Source Code elemental function expandtabs ( instr , tab_size ) result ( out ) ! ident_13=\"@(#) M_unicode expandtabs(3f) convert tabs to spaces and trim line removing CRLF chars\" type ( unicode_type ), intent ( in ) :: instr ! input line to scan for tab characters type ( unicode_type ) :: out ! tab-expanded version of INSTR produced integer , intent ( in ), optional :: tab_size integer :: ipos ! position in OUT to put next character of INSTR integer :: istep ! counter advances thru string INSTR integer :: icount ! number of tab characters in input integer :: i integer :: tab_size_local tab_size_local = 8 ! assume a tab stop is set every 8th column if ( present ( tab_size )) tab_size_local = tab_size ! count number of tab characters in input icount = 0 do i = 1 , size ( instr % codes ) if ( instr % codes ( i ) == 9 ) icount = icount + 1 enddo ! initially set length of output to the maxiumum length that might result if ( allocated ( out % codes )) deallocate ( out % codes ) allocate ( out % codes ( size ( instr % codes ) + 8 * icount ) ) out % codes = 32 ! blank-fill string ipos = 1 ! where to put next character in output string OUT SCAN_LINE : do istep = 1 , len_trim ( instr ) ! look through input string one character at a time EXPAND_TABS : select case ( instr % codes ( istep )) ! take actions based on character found case ( 9 ) ! character is a horizontal tab so move pointer out to appropriate column if ( tab_size_local . gt . 0 ) then ipos = ipos + ( tab_size_local - ( mod ( ipos - 1 , tab_size_local ))) endif case default ! character is anything else other than a tab out % codes ( ipos ) = instr % codes ( istep ) ipos = ipos + 1 end select EXPAND_TABS enddo SCAN_LINE out = trim ( out ) end function expandtabs","tags":"","url":"proc/expandtabs.html"},{"title":"join ‚Äì M_unicode","text":"public impure function join(str, sep, clip) result(string) NAME JOIN ( 3 f ) - [ M_unicode : EDITING ] append CHARACTER variable array into a single CHARACTER variable with specified separator ( LICENSE : MIT ) SYNOPSIS impure function join ( str , sep , clip ) result ( string ) type ( unicode_type ), intent ( in ) :: str (:) type ( unicode_type ), intent ( in ), optional :: sep logical , intent ( in ), optional :: clip type ( unicode_type ), allocatable :: string DESCRIPTION JOIN ( 3 f ) appends the elements of a CHARACTER array into a single CHARACTER variable , with elements 1 to N joined from left to right . By default each element is trimmed of trailing spaces and the default separator is a null string . OPTIONS STR array of variables to be joined SEP separator string to place between each variable . defaults to a null string . CLIP option to trim each element of STR of trailing and leading spaces . Defaults to . TRUE . RETURNS STRING CHARACTER variable composed of all of the elements of STR () appended together with the optional separator SEP placed between the elements . EXAMPLES Sample program: program demo_join use M_unicode , only : join , ut => unicode_type , ch => character , assignment (=) ! use M_unicode , only : write ( formatted ) implicit none character ( len = * ), parameter :: w = ' (( g0 , / , g0 )) ' ! character ( len = * ), parameter :: v = ' (( g0 , / , DT )) ' character ( len = 20 ), allocatable :: proverb (:) type ( ut ), allocatable :: s (:) type ( ut ), allocatable :: sep ! proverb =[ character ( len = 13 ) :: & & ' United ' , & & ' we ' , & & ' stand , ' , & & ' divided ' , & & ' we fall . ' ] ! if ( allocated ( s )) deallocate ( s ) allocate ( s ( size ( proverb ))) ! avoid GNU Fortran ( GCC ) 16.0.0 bug s = proverb write ( * , w ) ' SIMPLE JOIN : ' , ch ( join ( s ) ) write ( * , w ) ' JOIN WITH SEPARATOR : ' , ch ( join ( s , sep = ut ( ' ' )) ) write ( * , w ) ' CUSTOM SEPARATOR : ' , ch ( join ( s , sep = ut ( ' < -- > ' )) ) write ( * , w ) ' NO TRIMMING : ' , ch ( join ( s , clip =. false .) ) ! sep = ut () write ( * , w ) ' SIMPLE JOIN : ' , ch ( sep % join ( s ) ) sep = ' ' write ( * , w ) ' JOIN WITH SEPARATOR : ' , ch ( sep % join ( s ) ) sep = ' < -- > ' write ( * , w ) ' CUSTOM SEPARATOR : ' , ch ( sep % join ( s ) ) sep = '' write ( * , w ) ' NO TRIMMING : ' , ch ( sep % join ( s , clip =. false .) ) end program demo_join Results: SIMPLE JOIN:\nUnitedwestand,dividedwe fall.\nJOIN WITH SEPARATOR:\nUnited we stand, divided we fall.\nCUSTOM SEPARATOR:\nUnited==>we==>stand,==>divided==>we fall.\nNO TRIMMING:\n United         we             stand,         divided        we fall.\nSIMPLE JOIN:\nUnitedwestand,dividedwe fall.\nJOIN WITH SEPARATOR:\nUnited we stand, divided we fall.\nCUSTOM SEPARATOR:\nUnited==>we==>stand,==>divided==>we fall.\nNO TRIMMING:\n United         we             stand,         divided        we fall. AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: str (:) type( unicode_type ), intent(in), optional :: sep logical, intent(in), optional :: clip Return Value type( unicode_type ) Source Code impure function join ( str , sep , clip ) result ( string ) ! ident_7=\"@(#) M_unicode join(3f) merge string array into a single string value adding specified separator\" type ( unicode_type ), intent ( in ) :: str (:) type ( unicode_type ), intent ( in ), optional :: sep logical , intent ( in ), optional :: clip type ( unicode_type ) :: temp type ( unicode_type ) :: sep_local type ( unicode_type ) :: string logical :: clip_local integer :: i if ( present ( sep )) then ; sep_local = sep ; else ; sep_local = '' ; endif if ( present ( clip )) then ; clip_local = clip ; else ; clip_local = . true . ; endif string = '' if ( size ( str ) /= 0 ) then do i = 1 , size ( str ) - 1 if ( clip_local ) then temp = adjustl ( str ( i )) ! avoid gfortran GNU Fortran (GCC) 16.0.0 20250727 (experimental) bug !gfortran!string=string//adjustl(trim(str))//sep_local ! produces no left adjust in gfortran as the moment !ifx!string=string//trim(temp)//sep_local temp = trim ( temp ) string = [ string % codes , temp % codes , sep_local % codes ] else !string=string//str(i)//sep_local string = [ string % codes , str ( i )% codes , sep_local % codes ] endif enddo if ( clip_local ) then temp = adjustl ( str ( i )) !string=[string//trim(temp) temp = trim ( temp ) string = [ string % codes , temp % codes ] else !string=string//str(i) string = [ string % codes , str ( i )% codes ] endif endif end function join","tags":"","url":"proc/join.html"},{"title":"lower ‚Äì M_unicode","text":"public pure elemental function lower(str) result(string) NAME LOWER(3f) - [M_unicode:CASE] changes a string to lowercase over\n specified range\n (LICENSE:MIT) SYNOPSIS elemental pure function lower(str) result (string)\n\n  character(*), intent(in) :: str\n  character(len(str))      :: string  ! output string DESCRIPTION lower(str) returns a copy of the input string with all\n   characters converted to miniscule (ie. \"lowercase\"). OPTIONS str    string to convert to miniscule RETURNS lower  copy of the entire input string with all characters converted\n        to miniscule. TRIVIA The terms \"uppercase\" and \"lowercase\" date back to the early days\nof the mechanical printing press. Individual metal alloy casts of\neach needed letter or punctuation symbol were meticulously added to a\npress block, by hand, before rolling out copies of a page. These metal\ncasts were stored and organized in wooden cases. The more-often-needed\nminiscule letters were placed closer to hand, in the lower cases of\nthe work bench. The less often needed, capitalized, majuscule letters,\nended up in the harder to reach upper cases. EXAMPLES Sample program: program demo_lower use iso_fortran_env , only : stdout => output_unit use M_unicode , only : lower , unicode_type , assignment (=), trim use M_unicode , only : ut => unicode_type , operator ( == ) implicit none character ( len = * ), parameter :: g = ' ( * ( g0 )) ' type ( unicode_type ) :: pangram type ( unicode_type ) :: diacritics type ( unicode_type ) :: expected ! ! a sentence containing every letter of the English alphabet pangram = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\" expected = \"the quick brown fox jumps over the lazy dog\" call test ( pangram , expected ) ! ! Slovak pangram PANGRAM = ' VYP√ÑT√Å DC√âRA GR√ìFA MAXWELLA S IQ NI≈Ω≈†√çM AKO & & K√î≈á N√öTI ƒåEƒΩAƒé HR√ùZ≈§ H≈îBU JABƒπK . ' expected = ' vyp√§t√° dc√©ra gr√≥fa maxwella s iq ni≈æ≈°√≠m ako & & k√¥≈à n√∫ti ƒçeƒæaƒè hr√Ωz≈• h≈ïbu jabƒ∫k . ' call test ( pangram , expected ) ! ! contains each special Czech letter with diacritics exactly once DIACRITICS = ' P≈ò√çLI≈† ≈ΩLU≈§OUƒåK√ù K≈Æ≈á √öPƒöL ƒé√ÅBELSK√â √ìDY . ' expected = ' p≈ô√≠li≈° ≈ælu≈•ouƒçk√Ω k≈Ø≈à √∫pƒõl ƒè√°belsk√© √≥dy . ' print g , ' ( \"A horse that was too yellow-ish moaned devilish odes\" ) ' call test ( diacritics , expected ) contains subroutine test ( in , expected ) type ( unicode_type ), intent ( in ) :: in type ( unicode_type ), intent ( in ) :: expected type ( unicode_type ) :: lowercase character ( len = * ), parameter :: nl = new_line ( 'A' ) write ( stdout , g ) in % character () lowercase = lower ( in ) write ( stdout , g ) lowercase % character () write ( stdout , g ) merge ( ' PASSED ',' FAILED ' , lowercase == expected ), nl end subroutine test end program demo_lower Expected output > THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\n> the quick brown fox jumps over the lazy dog\n> PASSED\n>\n> VYP√ÑT√Å DC√âRA GR√ìFA MAXWELLA S IQ NI≈Ω≈†√çM AKO K√î≈á N√öTI ...\n> ƒåEƒΩAƒé HR√ùZ≈§ H≈îBU JABƒπK.\n> vyp√§t√° dc√©ra gr√≥fa maxwella s iq ni≈æ≈°√≠m ako k√¥≈à n√∫ti ...\n> ƒçeƒæaƒè hr√Ωz≈• h≈ïbu jabƒ∫k.\n> PASSED\n>\n> (\"A horse that was too yellow-ish moaned devilish odes\")\n> P≈ò√çLI≈† ≈ΩLU≈§OUƒåK√ù K≈Æ≈á √öPƒöL ƒé√ÅBELSK√â √ìDY.\n> p≈ô√≠li≈° ≈ælu≈•ouƒçk√Ω k≈Ø≈à √∫pƒõl ƒè√°belsk√© √≥dy.\n> PASSED AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: str Return Value type( unicode_type ) Source Code elemental pure function lower ( str ) result ( string ) ! ident_9=\"@(#) M_unicode lower(3f) returns a lowercase string\" type ( unicode_type ), intent ( in ) :: str ! input string to convert to all lowercase type ( unicode_type ) :: string ! output string that contains no miniscule letters integer :: i ! loop counter integer :: pos integer , parameter :: ade_a = iachar ( 'A' ), ade_z = iachar ( 'Z' ) integer , parameter :: diff = iachar ( 'A' ) - iachar ( 'a' ) string = str do i = 1 , len ( str ) ! step thru each letter in the string in specified range select case ( str % codes ( i )) case ( ade_a : ade_z ) string % codes ( i ) = str % codes ( i ) - diff case default pos = binary_search ( up_to_low (:, 1 ), str % codes ( i )) if ( pos > 0 ) then string % codes ( i ) = up_to_low ( pos , 2 ) endif end select enddo if ( len ( str ). eq . 0 ) string = str end function lower","tags":"","url":"proc/lower.html"},{"title":"pad ‚Äì M_unicode","text":"public impure elemental function pad(line, length, pattern, right, clip) result(out) NAME PAD(3f) - [M_unicode:WHITESPACE] return string padded to at least\nspecified length\n(LICENSE:MIT) SYNOPSIS function pad(str,length,pattern,right,clip) result ( out ) type ( unicode_type ) :: str integer , intent ( in ) :: length type ( unicode_type ) :: out type ( unicode_type ), intent ( in ), optional :: pattern logical , intent ( in ), optional :: right logical , intent ( in ), optional :: clip DESCRIPTION pad ( 3 f ) pads a string with a pattern to at least the specified length . If the trimmed input string is longer than the requested length the trimmed string is returned . OPTIONS str the input string to return trimmed , but then padded to the specified length if shorter than length length The minimum string length to return pattern optional string to use as padding . Defaults to a space . right if true pads string on the right , else on the left . Defaults to true . clip trim spaces from input string ends . Defaults to . true . RETURNS out The input string padded to the requested length or the trimmed input string if the input string is longer than the requested length . EXAMPLES Sample Program: program demo_pad\n   use M_unicode, only  : pad, assignment(=)\n   !use M_unicode, only : write(formatted)\n   use M_unicode, only  : len\n   use M_unicode, only  : ch=> character\n   use M_unicode, only  : ut=> unicode_type\n   implicit none\n   type(ut)                   :: string\n   type(ut)                   :: answer\n   integer                    :: i\n   !character(len= ),parameter :: u=‚Äô( (DT))‚Äô\n   character(len= ),parameter :: u=‚Äô( (g0))‚Äô\n     !\n     string=‚Äôabcdefghij‚Äô\n     !\n     write( , )‚Äôpad on right till 20 characters long‚Äô\n     answer=pad(string,20)\n     write( ,‚Äô(‚Äú[‚Äú,g0,‚Äù]‚Äù,/)‚Äô) answer%character()\n     !\n     write( , )‚Äôoriginal is not trimmed for short length requests‚Äô\n     answer=pad(string,5)\n     write( ,‚Äô(‚Äú[‚Äú,g0,‚Äù]‚Äù,/)‚Äô) answer%character()\n     !\n     i=30\n     write( , )‚Äôpad with specified string and left-justified integers‚Äô\n     write( ,‚Äô(1x,g0,1x,i0)‚Äô) &\n      & ch(pad(ut(‚ÄòCHAPTER 1 : The beginning ‚Äò),i,ut(‚Äò.‚Äô) )), 1   , &\n      & ch(pad(ut(‚ÄòCHAPTER 2 : The end ‚Äò),i,ut(‚Äò.‚Äô) )),       1234, &\n      & ch(pad(ut(‚ÄòAPPENDIX ‚Äò),i,ut(‚Äò.‚Äô) )),                  1235\n     !\n     write( , )‚Äôpad with specified string and right-justified integers‚Äô\n     write( ,‚Äô(1x,g0,i7)‚Äô) &\n      & ch(pad(ut(‚ÄòCHAPTER 1 : The beginning ‚Äò),i,ut(‚Äò.‚Äô) )), 1   , &\n      & ch(pad(ut(‚ÄòCHAPTER 2 : The end ‚Äò),i,ut(‚Äò.‚Äô) )),       1234, &\n      & ch(pad(ut(‚ÄòAPPENDIX ‚Äò),i,ut(‚Äò.‚Äô) )),                  1235\n     !\n     write( , )‚Äôpad on left with zeros‚Äô\n     write( ,u)ch(pad(ut(‚Äò12‚Äô),5,ut(‚Äò0‚Äô),right=.false.))\n     !\n     write( , )‚Äôvarious lengths with clip .true. and .false.‚Äô\n     write( ,u)ch(pad(ut(‚Äò12345 ‚Äò),30,ut(‚Äò ‚Äô),right=.false.))\n     write( ,u)ch(pad(ut(‚Äò12345 ‚Äò),30,ut(‚Äò_‚Äô),right=.false.,clip=.true.))\n     write( ,u)ch(pad(ut(‚Äò12345 ‚Äò), 7,ut(‚Äò ‚Äô),right=.false.))\n     write( ,u)ch(pad(ut(‚Äò12345 ‚Äò), 7,ut(‚Äò_‚Äô),right=.false.,clip=.true.))\n     write( ,u)ch(pad(ut(‚Äò12345 ‚Äò), 6,ut(‚Äò ‚Äô),right=.false.))\n     write( ,u)ch(pad(ut(‚Äò12345 ‚Äò), 6,ut(‚Äò_‚Äô),right=.false.,clip=.true.))\n     write( ,u)ch(pad(ut(‚Äò12345 ‚Äò), 5,ut(‚Äò ‚Äô),right=.false.))\n     write( ,u)ch(pad(ut(‚Äò12345 ‚Äò), 5,ut(‚Äò_‚Äô),right=.false.,clip=.true.))\n     write( ,u)ch(pad(ut(‚Äò12345 ‚Äò), 4,ut(‚Äò ‚Äô),right=.false.))\n     write(*,u)ch(pad(ut(‚Äò12345 ‚Äò), 4,ut(‚Äò ‚Äô),right=.false.,clip=.true.))\n  end program demo_pad Results: > pad on right till 20 characters long > [ abcdefghij ] > > original is not trimmed for short length requests > [ abcdefghij ] > > pad with specified string and left - justified integers > CHAPTER 1 : The beginning .... 1 > CHAPTER 2 : The end .......... 1234 > APPENDIX ..................... 1235 > pad with specified string and right - justified integers > CHAPTER 1 : The beginning .... 1 > CHAPTER 2 : The end .......... 1234 > APPENDIX ..................... 1235 > pad on left with zeros > 00012 > various lengths with clip . true . and . false . > ________________________12345 > _________________________12345 > _12345 > __12345 > 12345 > _12345 > 12345 > 12345 > 12345 > 2345 SEE ALSO adjustl(3f), adjustr(3f), repeat(3f), trim(3f), len_trim(3f), len(3f) AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: line integer, intent(in) :: length type( unicode_type ), intent(in), optional :: pattern logical, intent(in), optional :: right logical, intent(in), optional :: clip Return Value type( unicode_type ) Source Code impure elemental function pad ( line , length , pattern , right , clip ) result ( out ) ! ident_10=\"@(#) M_unicode pad(3f) return string padded to at least specified length\" type ( unicode_type ), intent ( in ) :: line integer , intent ( in ) :: length type ( unicode_type ), intent ( in ), optional :: pattern logical , optional , intent ( in ) :: right logical , optional , intent ( in ) :: clip type ( unicode_type ) :: out type ( unicode_type ) :: temp logical :: local_right logical :: local_clip type ( unicode_type ) :: local_pattern type ( unicode_type ) :: local_line integer :: newlen if ( present ( right ) ) then ; local_right = right ; else ; local_right = . true .; endif if ( present ( clip ) ) then ; local_clip = clip ; else ; local_clip = . true . ; endif if ( present ( pattern ) ) then ; local_pattern = pattern ; else ; local_pattern = ' ' ; endif if ( len ( local_pattern ) == 0 ) then out = line else if ( local_clip ) then local_line = trim ( adjustl ( line )) newlen = max ( length , len ( local_line )) else local_line = line newlen = max ( length , len ( line ) ) endif if ( local_right ) then !out=[local_line//repeat(local_pattern,newlen/len(local_pattern)+1) temp = repeat ( local_pattern , newlen / len ( local_pattern ) + 1 ) out = [ local_line % codes , temp % codes ] else ! make a line of pattern out = repeat ( local_pattern , ceiling ( real ( newlen ) / len ( local_pattern ))) !out=out%sub(1,newlen-len(local_line))//local_line out = out % sub ( 1 , newlen - len ( local_line )) out = [ out % codes , local_line % codes ] endif out = out % sub ( 1 , newlen ) endif end function pad","tags":"","url":"proc/pad.html"},{"title":"readline ‚Äì M_unicode","text":"public  function readline(lun, iostat) result(line) NAME READLINE(3f) - [M_unicode:READ] read a line from specified LUN into\n                string up to line length limit\n                (LICENSE:MIT) SYNTAX function readline(lun,iostat) result ( line ) integer , intent ( in ), optional :: lun integer , intent ( out ), optional :: iostat type ( unicode_type ) :: line DESCRIPTION Read a line of any length up to programming environment maximum line length . Requires Fortran 2003 +. It is primarily expected to be used when reading input which will then be parsed . The input file must have a PAD attribute of YES for the function to work properly , which is typically true . The simple use of a loop that repeatedly re - allocates a character variable in addition to reading the input file one buffer at a time could ( depending on the programming environment used ) be inefficient , as it could reallocate and allocate memory used for the output string with each buffer read . OPTIONS LUN optional LUN ( Fortran logical I / O unit ) number . Defaults to stdin . IOSTAT status returned by READ ( IOSTAT = IOS ) . If not zero , an error occurred or an end - of - file or end - of - record was encountered . RETURNS LINE line read . if IOSTAT is not zero , LINE returns the I / O error message . EXAMPLE Sample program : program demo_readline use , intrinsic :: iso_fortran_env , only : stdin => input_unit use , intrinsic :: iso_fortran_env , only : iostat_end use M_unicode , only : readline , len , trim use M_unicode , only : assignment (=), ch => character , ut => unicode_type implicit none type ( ut ) :: line character ( len =:), allocatable :: aline integer , allocatable :: ints (:) integer :: iostat open ( unit = stdin , pad = ' yes ' ) ! INFINITE : do line = readline ( iostat = iostat ) if ( iostat . ne .0 ) exit ! write the length , line in brackets and its Unicode codepoints write ( * , ' ( * ( g0 , 1 x )) ' ) len ( line ), '[' //ch(line)//']',line%codepoint() ! or assign the string to an allocatable array of integers ints = line ! and the string to a character variable aline = line write ( * , ' ( * ( g0 , 1 x )) ' ) len ( line ), '[' //ch(line)//']',ints enddo INFINITE ! if ( iostat /= iostat_end ) then write ( * , * ) ' error reading input : ' , ch ( trim ( line )) endif ! end program demo_readline AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: lun integer, intent(out), optional :: iostat Return Value type( unicode_type ) Source Code function readline ( lun , iostat ) result ( line ) implicit none ! ident_18=\"@(#) M_unicode readline(3f) read a line from specified LUN into string up to line length limit\" type ( unicode_type ) :: line integer , intent ( in ), optional :: lun integer , intent ( out ), optional :: iostat integer :: iostat_local character ( len = 4096 ) :: message integer , parameter :: buflen = 1024 character ( len = :), allocatable :: line_local character ( len = buflen ) :: buffer integer :: isize integer :: lun_local line_local = '' iostat_local = 0 if ( present ( lun )) then lun_local = lun else lun_local = stdin endif INFINITE : do ! read characters from line and append to result read ( lun_local , pad = 'yes' , iostat = iostat_local , fmt = '(a)' , advance = 'no' , & & size = isize , iomsg = message ) buffer ! read next buffer (might use stream I/O for files ! other than stdin so system line limit is not limiting if ( isize > 0 ) line_local = line_local // buffer (: isize ) ! append what was read to result if ( is_iostat_eor ( iostat_local )) then ! if hit EOR reading is complete unless backslash ends the line iostat_local = 0 ! hitting end of record is not an error for this routine exit INFINITE ! end of reading line elseif ( iostat_local /= 0 ) then ! end of file or error line = trim ( message ) exit INFINITE endif enddo INFINITE line = line_local ! trim line if ( present ( iostat )) iostat = iostat_local end function readline","tags":"","url":"proc/readline.html"},{"title":"sub ‚Äì M_unicode","text":"public  function sub(str, start, end, step) result(section) NAME SUB(3f) - [M_unicode:EDITING] Return substring\n(LICENSE:MIT) SYNOPSIS function sub(str,left,right,step) result ( section ) type ( unicode_type ) :: str integer , intent ( in ), optional :: left integer , intent ( in ), optional :: right integer , intent ( in ), optional :: step DESCRIPTION sub(3f) returns a substring from one column to another. OPTIONS str the input string to return a section of left column number of str starting section of str to return . Defaults to 1 when STEP is positive , or right end of STR when STEP is negative . right column number of str ending section of str to return . Defaults to right end of STR when STEP is positive , or 1 when STEP is negative . step step to take from left column to right column . Defaults to 1 . RETURNS out  The specified subsection of the input string EXAMPLES Sample Program: program demo_sub use M_unicode , only : sub , assignment (=) use M_unicode , only : len use M_unicode , only : ut => unicode_type implicit none type ( ut ) :: string type ( ut ) :: piece ! string = ' abcdefghij ' ! piece = sub ( string , 3 , 5 ) call printme ( ' selected range : ' ) piece = sub ( string , 6 ) call printme ( ' from character to end : ' ) piece = sub ( string , 5 , 5 ) call printme ( ' single character : ' ) piece = sub ( string , step = - 1 ) call printme ( ' reverse string : ' ) contains subroutine printme ( label ) character ( len = * ), intent ( in ) :: label write ( * , ' ( a , \"[\" , g0 , \"]\" , / ) ' ) label , piece % character () end subroutine printme end program demo_sub Results: SEE ALSO adjustl(3f), adjustr(3f), repeat(3f), trim(3f), len_trim(3f), len(3f) AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: str integer, intent(in), optional :: start integer, intent(in), optional :: end integer, intent(in), optional :: step Return Value type( unicode_type ) Source Code function sub ( str , start , end , step ) result ( section ) type ( unicode_type ), intent ( in ) :: str type ( unicode_type ) :: section integer , intent ( in ), optional :: start , end , step integer :: start_ , end_ , step_ integer :: which integer :: sgn sgn = 1 if ( present ( step )) sgn = sign ( 1 , step ) which = 4 * merge ( 1 , 0 , present ( start )) + 2 * merge ( 1 , 0 , present ( end )) + 1 * merge ( 1 , 0 , present ( step )) select case ( which * sgn ) case ( int ( b '000' )) ; start_ = 1 ; end_ = len ( str ) ; step_ = 1 case ( int ( b '001' )) ; start_ = 1 ; end_ = len ( str ) ; step_ = step case ( int ( b '010' )) ; start_ = 1 ; end_ = end ; step_ = 1 case ( int ( b '011' )) ; start_ = 1 ; end_ = end ; step_ = step case ( int ( b '100' )) ; start_ = start ; end_ = len ( str ) ; step_ = 1 case ( int ( b '101' )) ; start_ = start ; end_ = len ( str ) ; step_ = step case ( int ( b '110' )) ; start_ = start ; end_ = end ; step_ = 1 case ( int ( b '111' )) ; start_ = start ; end_ = end ; step_ = step case ( int ( b '001' ) * ( - 1 )) ; start_ = len ( str ) ; end_ = 1 ; step_ = step case ( int ( b '011' ) * ( - 1 )) ; start_ = 1 ; end_ = end ; step_ = step case ( int ( b '101' ) * ( - 1 )) ; start_ = start ; end_ = 1 ; step_ = step case ( int ( b '111' ) * ( - 1 )) ; start_ = start ; end_ = end ; step_ = step case default write ( 0 , * ) '*sub* unknown case ' , which , 'sign' , sgn stop 1 end select if ( step_ . gt . 0 ) then end_ = min ( size ( str % codes ), end_ ) start_ = max ( 1 , start_ ) else start_ = min ( size ( str % codes ), start_ ) end_ = max ( 1 , end_ ) endif section = str % codes ( start_ : end_ : step_ ) end function sub","tags":"","url":"proc/sub.html"},{"title":"upper ‚Äì M_unicode","text":"public pure elemental function upper(str) result(string) NAME UPPER(3f) - [M_unicode:CASE] changes a string to uppercase\n  (LICENSE:MIT) SYNOPSIS elemental pure function upper(str) result (string)\n\n  character(*), intent(in)    :: str\n  character(len(str))         :: string  ! output string DESCRIPTION upper(string) returns a copy of the input string with all characters\nconverted to uppercase, assuming Unicode character sets are being used. OPTIONS str    string to convert to uppercase RETURNS upper  copy of the input string with all characters converted to\n        uppercase. TRIVIA The terms \"uppercase\" and \"lowercase\" date back to the early days of\n the mechanical printing press. Individual metal alloy casts of each\n needed letter, or punctuation symbol, were meticulously added to a\n press block, by hand, before rolling out copies of a page. These\n metal casts were stored and organized in wooden cases. The more\n often needed miniscule letters were placed closer to hand, in the\n lower cases of the work bench. The less often needed, capitalized,\n majuscule letters, ended up in the harder to reach upper cases. EXAMPLES Sample program: program demo_upper use iso_fortran_env , only : stdout => output_unit use M_unicode , only : upper , unicode_type , assignment (=) use M_unicode , only : ut => unicode_type , operator ( == ) implicit none character ( len = * ), parameter :: g = ' ( * ( g0 )) ' type ( unicode_type ) :: pangram type ( unicode_type ) :: diacritics type ( unicode_type ) :: expected ! ! a sentence containing every letter of the English alphabet ! often used to test telegraphs since the advent of the 19 th century ! and as an exercise repetitively generated in typing classes pangram = \"The quick brown fox jumps over the lazy dog.\" expected = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.\" call test ( pangram , expected ) ! ! Slovak pangram pangram = ' Vyp√§t√° dc√©ra gr√≥fa Maxwella s IQ ni≈æ≈°√≠m ako & & k√¥≈à n√∫ti ƒçeƒæaƒè hr√Ωz≈• h≈ïbu jabƒ∫k . ' expected = ' VYP√ÑT√Å DC√âRA GR√ìFA MAXWELLA S IQ NI≈Ω≈†√çM AKO & & K√î≈á N√öTI ƒåEƒΩAƒé HR√ùZ≈§ H≈îBU JABƒπK . ' call test ( pangram , expected ) ! ! contains each special Czech letter with diacritics exactly once print g , ' ( \"A horse that was too yellow-ish moaned devilish odes\" ) ' diacritics = ' P≈ô√≠li≈° ≈ælu≈•ouƒçk√Ω k≈Ø≈à √∫pƒõl ƒè√°belsk√© √≥dy . ' expected = ' P≈ò√çLI≈† ≈ΩLU≈§OUƒåK√ù K≈Æ≈á √öPƒöL ƒé√ÅBELSK√â √ìDY . ' call test ( diacritics , expected ) contains subroutine test ( in , expected ) type ( unicode_type ), intent ( in ) :: in type ( unicode_type ), intent ( in ) :: expected type ( unicode_type ) :: uppercase character ( len = * ), parameter :: nl = new_line ( 'A' ) write ( stdout , g ) in % character () uppercase = upper ( in ) write ( stdout , g ) uppercase % character () write ( stdout , g ) merge ( ' PASSED ',' FAILED ' , uppercase == expected ), nl end subroutine test end program demo_upper Expected output The quick brown fox jumps over the lazy dog.\nTHE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.\nPASSED Vyp√§t√° dc√©ra gr√≥fa Maxwella s IQ ni≈æ≈°√≠m ako k√¥≈à n√∫ti ‚Ä¶\nƒçeƒæaƒè hr√Ωz≈• h≈ïbu jabƒ∫k.\nVYP√ÑT√Å DC√âRA GR√ìFA MAXWELLA S IQ NI≈Ω≈†√çM AKO K√î≈á N√öTI ‚Ä¶\nƒåEƒΩAƒé HR√ùZ≈§ H≈îBU JABƒπK.\nPASSED (‚ÄúA horse that was too yellow-ish moaned devilish odes‚Äù)\nP≈ô√≠li≈° ≈ælu≈•ouƒçk√Ω k≈Ø≈à √∫pƒõl ƒè√°belsk√© √≥dy.\nP≈ò√çLI≈† ≈ΩLU≈§OUƒåK√ù K≈Æ≈á √öPƒöL ƒé√ÅBELSK√â √ìDY.\nPASSED AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: str Return Value type( unicode_type ) Source Code elemental pure function upper ( str ) result ( string ) ! ident_8=\"@(#) M_unicode upper(3f) returns an uppercase string\" type ( unicode_type ), intent ( in ) :: str ! input string to convert to all uppercase type ( unicode_type ) :: string ! output string that contains no miniscule letters integer :: i ! loop counter integer :: pos integer , parameter :: ade_a = iachar ( 'a' ), ade_z = iachar ( 'z' ) integer , parameter :: diff = iachar ( 'A' ) - iachar ( 'a' ) string = str do i = 1 , len ( str ) ! step thru each letter in the string in specified range select case ( str % codes ( i )) case ( ade_a : ade_z ) string % codes ( i ) = str % codes ( i ) + diff case default pos = binary_search ( low_to_up (:, 1 ), str % codes ( i )) if ( pos > 0 ) then string % codes ( i ) = low_to_up ( pos , 2 ) endif end select enddo if ( len ( str ). eq . 0 ) string = str end function upper","tags":"","url":"proc/upper.html"},{"title":"adjustl ‚Äì M_unicode","text":"public interface adjustl Module Procedures private elemental function adjustl_str(string, glyphs) result(adjusted) NAME ADJUSTL(3f) - [M_unicode:WHITESPACE] Left-justified a string\n                 (LICENSE:MIT) SYNOPSIS result = adjustl(string,glyphs) function adjustl(string,glyphs) result ( out ) type ( unicode_type ), intent ( in ) :: string integer , intent ( in ), optional :: glyphs type ( unicode_type ) :: out CHARACTERISTICS STRING is a string variable of type(unicode_type) GLYPHS is a default integer The return value is a string variable of type(unicode_type) DESCRIPTION adjustl(3) will left-justify a string by removing leading spaces. Spaces\n   are inserted at the end of the string as needed to keep the number of\n   glyphs on output the same as the number on input unless overridden by\n   the GLYPHS parameter. OPTIONS STRING : the string to left-justify GLYPHS : the length of the output in glyphs RESULT A copy of STRING where leading spaces are removed and the same\n   number of spaces are inserted on the end of STRING unless GLYPHS is\n   specified. Note using GLYPHS can cause in string truncation. EXAMPLES Sample program: program demo_adjustl use M_unicode , only : ut => unicode_type use M_unicode , only : ch => character use M_unicode , only : adjustl , trim , len_trim , verify use M_unicode , only : write ( formatted ) use M_unicode , only : assignment (=) implicit none type ( ut ) :: usample , uout integer :: istart , iend character ( len = * ), parameter :: adt = ' ( a , \"[\" , DT , \"]\" ) ' ! ! basic use usample = ' sample string ' write ( * , adt ) ' original : ' , usample ! ! note a string stays the same length ! and is not trimmed by just an adjustl ( 3 ) call . write ( * , adt ) ' adjusted : ' , adjustl ( usample ) ! ! a fixed ‚Äê length string can be trimmed using trim ( 3 ) uout = trim ( adjustl ( usample )) write ( * , adt ) ' trimmed : ' , uout ! ! or alternatively you can select a substring without adjusting istart = max ( 1 , verify ( usample , ' ' )) ! first non ‚Äê blank character iend = len_trim ( usample ) write ( * , adt ) ' substring : ' , usample % sub ( istart , iend ) ! write ( * , adt ) ' substring : ' , adjustl ( usample , 30 ) write ( * , adt ) ' substring : ' , adjustl ( usample , 20 ) write ( * , adt ) ' substring : ' , adjustl ( usample , 10 ) write ( * , adt ) ' substring : ' , adjustl ( usample , 0 ) end program demo_adjustl Results: > original : [ sample string ] > adjusted : [ sample string ] > trimmed : [ sample string ] > substring : [ sample string ] SEE ALSO ADJUSTR(3), TRIM(3) AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in), optional :: glyphs Return Value type( unicode_type )","tags":"","url":"interface/adjustl.html"},{"title":"adjustr ‚Äì M_unicode","text":"public interface adjustr Module Procedures private impure elemental function adjustr_str(string, glyphs) result(adjusted) NAME ADJUSTR(3f) - [M_unicode:WHITESPACE] right-justify a string\n                 (LICENSE:MIT) SYNOPSIS result = adjustr(string,glyphs) elemental function adjustr ( string ) type ( unicode_type ) :: adjustr type ( unicode_type ), intent ( in ) :: string integer , intent ( in ), optional :: glyphs CHARACTERISTICS STRING is a string variable GLYPHS is a default integer the return value is a string variable DESCRIPTION ADJUSTR(3) right-justifies a string by removing trailing spaces. Spaces\n   are inserted at the start of the string as needed to retain the\n   original length unless an explicit return length is specified by the\n   GLYPHS parameter. OPTIONS STRING : the string to right-justify GLYPHS : length in glyphs to extend to or truncate to RESULT trailing spaces are removed and the same number of spaces are then\n   inserted at the start of string. EXAMPLES sample program: program demo_adjustr\n   use M_unicode, only : ut=>unicode_type\n   use M_unicode, only : adjustr, len\n   use M_unicode, only : write(formatted)\n   use M_unicode, only : assignment(=)\n   implicit none\n   type(ut)                   :: str\n   type(ut),allocatable       :: array(:)\n   integer                    :: i\n   character(len= ),parameter :: bracket=‚Äô(‚Äú[‚Äú,DT,‚Äù]‚Äù)‚Äô\n       !\n       call numberline(2)\n       !\n       ! basic usage\n       str = ‚Äô  sample string     ‚Äô\n       write( ,bracket) str\n       str = adjustr(str)\n       write( ,bracket) str\n       !\n       call numberline(5)\n       !\n       ! elemental\n       array=ut([character(len=50) :: &\n       ‚Äô    ‡§è‡§ï (ek) ‚Äò, &\n       ‚Äô       ‡§¶‡•ã (do) ‚Äò, &\n       ‚Äô          ‡§§‡•Ä‡§®(teen) ‚Äô ])\n       !\n       ! print array unadjusted\n       write( ,bracket)array\n       !do i=1,size(array)\n       !   write( ,‚Äô( (g0,1x))‚Äô)array(i)%codepoint()\n       !enddo\n       ! note 50 bytes is not necessarily 50 glyphs\n       write( ,‚Äô( (g0,1x))‚Äô)‚Äôlength in glyphs=‚Äô,len(array)\n       write( ,‚Äô( (g0,1x))‚Äô)‚Äôlength in bytes=‚Äô,(len(array(i)%character()),i=1,size(array))\n       !\n       call numberline(5)\n       !\n       ! print array right-justified\n       write( ,bracket)adjustr(array)\n       !\n       call numberline(5)\n       !\n       ! print array right-justified specifying number of glyphs\n       write( , )‚Äôset to 50‚Äô\n       write( ,bracket)adjustr(array,50)\n       !\n       write( , )‚Äôset to 60‚Äô\n       call numberline(6)\n       write( ,bracket)adjustr(array,60)\n       write( , )‚Äôset to 40‚Äô\n       call numberline(4)\n       write( ,bracket)adjustr(array,40)\n       write( , )‚Äôset to 10‚Äô\n       call numberline(1)\n       write( ,bracket)adjustr(array,10)\n       write( , )‚Äôset to 5‚Äô\n       write( ,bracket)adjustr(array,5)\n       write( , )‚Äôset to 4‚Äô\n       write( ,bracket)adjustr(array,4)\n       write( , )‚Äôset to 1‚Äô\n       write( ,bracket)adjustr(array,1)\n    contains\n       !\n       subroutine numberline(ireps)\n       integer,intent(in) :: ireps\n          write(*,‚Äô(1x,a)‚Äô)repeat(‚Äò1234567890‚Äô,ireps)\n       end subroutine numberline\n    end program demo_adjustr Results: > 12345678901234567890 > [ sample string ] > [ sample string ] > 12345678901234567890123456789012345678901234567890 > [ ‡§è‡§ï ( ek ) ] > [ ‡§¶ ‡•ã ( do ) ] > [ ‡§§ ‡•Ä ‡§® ( teen ) ] > length in glyphs = 46 46 44 > length in bytes = 50 50 50 > 12345678901234567890123456789012345678901234567890 > [ ‡§è‡§ï ( ek )] > [ ‡§¶ ‡•ã ( do )] > [ ‡§§ ‡•Ä ‡§® ( teen )] > 12345678901234567890123456789012345678901234567890 > set to 50 > [ ‡§è‡§ï ( ek )] > [ ‡§¶ ‡•ã ( do )] > [ ‡§§ ‡•Ä ‡§® ( teen )] > set to 60 > 123456789012345678901234567890123456789012345678901234567890 > [ ‡§è‡§ï ( ek )] > [ ‡§¶ ‡•ã ( do )] > [ ‡§§ ‡•Ä ‡§® ( teen )] > set to 40 > 1234567890123456789012345678901234567890 > [ ‡§è‡§ï ( ek )] > [ ‡§¶ ‡•ã ( do )] > [ ‡§§ ‡•Ä ‡§® ( teen )] > set to 10 > 1234567890 > [ ‡§è‡§ï ( ek )] > [ ‡§¶ ‡•ã ( do )] > [ ‡§§ ‡•Ä ‡§® ( teen )] > set to 5 > [ ( ek )] > [ ( do )] > [ teen )] > set to 4 > [( ek )] > [( do )] > [ een )] > set to 1 > [)] > [)] > [)] SEE ALSO ADJUSTL(3), TRIM(3) AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in), optional :: glyphs Return Value type( unicode_type )","tags":"","url":"interface/adjustr.html"},{"title":"assignment(=) ‚Äì M_unicode","text":"public interface assignment(=) Module Procedures private elemental subroutine assign_str_char(lhs, rhs) Assign a character sequence to a string. Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(inout) :: lhs character(len=*), intent(in) :: rhs private  subroutine assign_strs_char(lhs, rhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(inout) :: lhs character(len=*), intent(in) :: rhs (:) private elemental subroutine assign_str_code(lhs, rhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(inout) :: lhs integer, intent(in) :: rhs private  subroutine assign_str_codes(lhs, rhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(inout) :: lhs integer, intent(in) :: rhs (:) private  subroutine assign_char_str(lhs, rhs) Assign a string to a character sequence Arguments Type Intent Optional Attributes Name character(len=:), intent(inout), allocatable :: lhs type( unicode_type ), intent(in) :: rhs private  subroutine assign_ints_str(lhs, rhs) Assign a string to a character sequence Arguments Type Intent Optional Attributes Name integer, intent(inout), allocatable :: lhs (:) type( unicode_type ), intent(in) :: rhs","tags":"","url":"interface/assignment(=).html"},{"title":"character ‚Äì M_unicode","text":"public interface character Module Procedures private pure function str_to_char(string) result(aline) NAME CHARACTER ( 3 f ) - [ M_unicode : WHITESPACE ] convert type ( unicode_type ) string to a CHARACTER variable ( LICENSE : MIT ) SYNOPSIS result = character ( STRING , start , end , inc ) or result = STRING % character ( start , end , inc ) elemental function character ( string , start , end , inc ) type ( unicode_type ), intent ( in ) :: string integer , intent ( in ) :: start integer , intent ( in ) :: end integer , intent ( in ) :: inc CHARACTERISTICS STRING is a scalar or array string variable the returned value is a CHARACTER scalar or array DESCRIPTION CHARACTER(3f) returns a CHARACTER variable given a string variable\n   of type type(unicode_type). OPTIONS STRING : A scalar or array string to convert to intrinsic CHARACTER\n              type. RESULT The result converts each string to bytes stored in CHARACTER variables.\n   All elements will be padded to the same length of the longest element;\n   as all elements of a CHARACTER array are required to be of the same length. Commonly used to pass data to procedures requiring CHARACTER variables\n   or for printing when the DT format is not used.. EXAMPLES Sample program program demo_character use M_unicode , only : ut => unicode_type , ch => character , trim , len , pad use M_unicode , only : write ( formatted ), assignment ( = ) type ( ut ) :: ustr type ( ut ), allocatable :: array (:) integer :: i character ( len =* ), parameter :: all = '(*(g0))' ustr = [ 949 , 8021 , 961 , 951 , 954 , 945 , 33 ] ! eureka in codepoints ! when doing I / O using DT might be the most intuitive ! but sometimes converting to intrinsic character variables ! is preferred write ( * , all ) ch ( ustr ) ! convert to CHARACTER variable write ( * , all ) ustr % character () ! convert to CHARACTER variable ! you can select a range of glyphs write ( * , all ) ustr % character ( 3 , 4 ) ! similar to LINE ( 3 : 4 ) for ! CHARACTER variables ! and even reverse a string write ( * , all ) ustr % character ( len ( ustr ), 1 , - 1 ) ! reverse string ! note that OOP syntax provides a few other options write ( * , all ) ustr % byte () ! convert to CHARACTER ( LEN = 1 ) type ! arrays ! ! using this syntax make sure to make the LEN value large enough ! that glyphs can take up to four bytes array = ut ([ character ( len = 60 ) :: & 'Confucius never claimed to be a prophet, ' , & 'but I think he foresaw AI! He said ' , & '' , & ' \"Â≠¶ËÄå‰∏çÊÄùÂàôÁΩîÔºåÊÄùËÄå‰∏çÂ≠¶ÂàôÊÆÜ\"' , & 'or' , & ' (xu√© √©r b√π sƒ´ z√© w«éng, sƒ´ √©r b√π xu√© z√© d√†i),' , & 'which is also' , & ' \"To learn without thinking is to be lost, ' , & ' to think without learning is to be in danger\".' ]) ! write ( * , '(*(:,\"[\",g0,\"]\",/))' ) ch ( array ) ! all elements will be the same length in bytes but not necessarily ! in glyphs write ( * , '(a,*(i0,1x))' ) 'all elements the same length in BYTES:' , & & len ( ch ( array )) write ( * , '(a,*(i0,1x))' ) 'lengths (in glyphs):' , len ( array ) array = trim ( array ) write ( * , '(a,*(i0,1x))' ) 'lengths after trimming (in glyphs):' , & & len ( array ) write ( * , '(:*(:,\"[\",g0,\"]\",/))' ) ch ( array ) write ( * , * ) ! ! using this syntax the elements will be of different lengths array = [ & ut ( 'Confucius never claimed to be a prophet,' ) , & ut ( 'but I think he foresaw AI! He said' ) , & ut ( '' ) , & ut ( ' \"Â≠¶ËÄå‰∏çÊÄùÂàôÁΩîÔºåÊÄùËÄå‰∏çÂ≠¶ÂàôÊÆÜ\"' ) , & ut ( 'or' ) , & ut ( ' (xu√© √©r b√π sƒ´ z√© w«éng, sƒ´ √©r b√π xu√© z√© d√†i),' ) , & ut ( 'which is also' ) , & ut ( ' \"To learn without thinking is to be lost,' ) , & ut ( ' to think without learning is to be in danger\".' )] ! but using the CHARACTER function will still make them the same ! length in bytes so you might want to print them individually ! for certain effects , subject to font properties such as varying ! glyph widths . write ( * , '(*(\"[\",g0,\"]\",/))' )( ch ( array ( i )), i = 1 , size ( array )) write ( * , '(*(\"[\",g0,\"]\",/))' )( ch ( pad ( array ( i ), 60 )), i = 1 , size ( array )) ! end program demo_character Results: > Œµ·ΩïœÅŒ∑Œ∫Œ± ! > Œµ·ΩïœÅŒ∑Œ∫Œ± ! > œÅŒ∑ > ! Œ±Œ∫Œ∑œÅ·ΩïŒµ > Œµ·ΩïœÅŒ∑Œ∫Œ± ! > [ Confucius never claimed to be a prophet, ] > [ but I think he foresaw AI! He said ] > [ ] > [ \"Â≠¶ËÄå‰∏çÊÄùÂàôÁΩîÔºåÊÄùËÄå‰∏çÂ≠¶ÂàôÊÆÜ\" ] > [ or ] > [ (xu√© √©r b√π sƒ´ z√© w«éng, sƒ´ √©r b√π xu√© z√© d√†i), ] > [ which is also ] > [ \"To learn without thinking is to be lost, ] > [ to think without learning is to be in danger\". ] > > all elements the same length in BYTES : 60 > lengths ( in glyphs ) : 60 60 60 34 60 48 60 60 60 > lengths after trimming ( in glyphs ) : 40 34 0 16 2 45 13 42 47 > [ Confucius never claimed to be a prophet, ] > [ but I think he foresaw AI! He said ] > [ ] > [ \"Â≠¶ËÄå‰∏çÊÄùÂàôÁΩîÔºåÊÄùËÄå‰∏çÂ≠¶ÂàôÊÆÜ\" ] > [ or ] > [ (xu√© √©r b√π sƒ´ z√© w«éng, sƒ´ √©r b√π xu√© z√© d√†i), ] > [ which is also ] > [ \"To learn without thinking is to be lost, ] > [ to think without learning is to be in danger\". ] > > > [ Confucius never claimed to be a prophet, ] > [ but I think he foresaw AI! He said ] > [] > [ \"Â≠¶ËÄå‰∏çÊÄùÂàôÁΩîÔºåÊÄùËÄå‰∏çÂ≠¶ÂàôÊÆÜ\" ] > [ or ] > [ (xu√© √©r b√π sƒ´ z√© w«éng, sƒ´ √©r b√π xu√© z√© d√†i), ] > [ which is also ] > [ \"To learn without thinking is to be lost, ] > [ to think without learning is to be in danger\". ] > [ > [Confucius never claimed to be a prophet, ] > [ but I think he foresaw AI! He said ] > [ ] > [ \"Â≠¶ËÄå‰∏çÊÄùÂàôÁΩîÔºåÊÄùËÄå‰∏çÂ≠¶ÂàôÊÆÜ\" ] > [ or ] > [ (xu√© √©r b√π sƒ´ z√© w«éng, sƒ´ √©r b√π xu√© z√© d√†i), ] > [ which is also ] > [ \"To learn without thinking is to be lost, ] > [ to think without learning is to be in danger\". ] > [ SEE ALSO functions that perform operations on character strings: elemental: adjustl(3), adjustr(3), index(3), scan(3), verify(3) non-elemental: len_trim(3), len(3), repeat(3), trim(3) AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value character(len=:), allocatable private pure function strs_to_chars(string) result(lines) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string (:) Return Value character(len=:), allocatable, (:) private pure function str_to_char_pos(string, pos) result(aline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in) :: pos Return Value character(len=:), allocatable private pure function strs_to_chars_pos(string, pos) result(aline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string (:) integer, intent(in) :: pos Return Value character(len=1), allocatable, (:) private pure function str_to_char_range(string, first, last) result(aline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in) :: first integer, intent(in) :: last Return Value character(len=:), allocatable private pure function strs_to_chars_range(string, first, last) result(lines) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string (:) integer, intent(in) :: first integer, intent(in) :: last Return Value character(len=:), allocatable, (:) private pure function str_to_char_range_step(string, first, last, step) result(aline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in) :: first integer, intent(in) :: last integer, intent(in) :: step Return Value character(len=:), allocatable private pure function strs_to_chars_range_step(string, first, last, step) result(lines) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string (:) integer, intent(in) :: first integer, intent(in) :: last integer, intent(in) :: step Return Value character(len=:), allocatable, (:)","tags":"","url":"interface/character.html"},{"title":"codepoints_to_utf8 ‚Äì M_unicode","text":"public interface codepoints_to_utf8 Module Procedures private pure subroutine codepoints_to_utf8_str(codepoints, utf8, nerr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: codepoints (:) character(len=:), intent(out), allocatable :: utf8 integer, intent(out) :: nerr private pure subroutine codepoints_to_utf8_chars(codepoints, utf8, nerr) NAME CODEPOINTS_TO_UTF8(3f) - [M_unicode:CONVERSION] convert codepoints\n   to CHARACTER\n   (LICENSE:MIT) SYNOPSIS pure subroutine codepoints_to_utf8(codepoints,utf8,nerr)\n\n integer,allocatable,intent(in) :: codepoints(:)\n !\n character(len=1),intent(out)   :: utf8(:)\n !  or\n character(len=*),intent(out)   :: utf8\n !\n integer,intent(out)            :: nerr CHARACTERISTICS UTF8 is a scalar or array CHARACTER variable CODEPOINTS is of default INTEGER kind NERR is of default INTEGER kind DESCRIPTION CODEPOINTS_TO_UTF8(3f) takes an integer array of Unicode codepoint\n   values and generates either a scalar CHARACTER variable or an array\n   of bytes (AKA. CHARACTER(LEN=1)) which are assumed to contain a stream\n   of bytes representing UTF-8-encoded data. OPTIONS + CODEPOINTS : An INTEGER array of Unicode codepoint values representing the glyphs to be encoded at UTF - 8 data + UTF8 : Scalar or single - character array CHARACTER variables to contain a stream of bytes containing data encoded at UTF - 8 text . + NERR : Zero if no error occurred . If not zero the stream of bytes could not be completely converted to UTF - 8 characters . EXAMPLES Sample program program demo_codepoints_to_utf8 use m_unicode , only : codepoints_to_utf8 implicit none ! ' Noho me ka hau ‚Äô oli ' !( Be happy ) integer , parameter :: codepoints ( * )=[ & & 78 , 111 , 104 , 111 , & & 32 , 109 , 101 , & & 32 , 107 , 97 , & & 32 , 104 , 97 , 117 , 8217 , 111 , 108 , 105 ] character ( len =:), allocatable :: string character ( len = 1 ), allocatable :: bytes (:) character ( len = * ), parameter :: solid = ' ( * ( g0 )) ' character ( len = * ), parameter :: space = ' ( * ( g0 , 1 x )) ' character ( len = * ), parameter :: z = ' ( a , * ( z0 , 1 x )) ' integer :: nerr ! BASIC USAGE : SCALAR CHARACTER VARIABLE write ( * , space ) ' CODEPOINTS : ' , codepoints write ( * , z ) ' HEXADECIMAL CODEPOINTS : ' , codepoints call codepoints_to_utf8 ( codepoints , string , nerr ) write ( * , solid ) ' STRING : ' , string ! write ( * , space ) ' How long is this string in glyphs ? ' write ( * , space ) size ( codepoints ) write ( * , space ) ' How long is this string in bytes ? ' write ( * , space ) len ( string ) ! ! BASIC USAGE : ARRAY OF BYTES call codepoints_to_utf8 ( codepoints , bytes , nerr ) write ( * , solid ) ' STRING : ' , bytes ! write ( * , space ) ' How long is this string in glyphs ? ' write ( * , space ) size ( codepoints ) write ( * , space ) ' How long is this string in bytes ? ' write ( * , space ) size ( bytes ) ! end program demo_codepoints_to_utf8 Results: > CODEPOINTS: 78 111 104 111 32 109 101 32 107 97 32 104 97 117 ...\n > 8217 111 108 105\n > 48 4E 6F 68 6F 20 6D 65 20 6B 61 20 68 61 75 2019 6F 6C 69\n > STRING:Noho me ka hau‚Äôoli\n > How long is this string in glyphs?\n > 18\n > How long is this string in bytes?\n > 20\n > STRING:Noho me ka hau‚Äôoli\n > How long is this string in glyphs?\n > 18\n > How long is this string in bytes?\n > 20 SEE ALSO functions that perform operations on character strings: elemental: adjustl(3), adjustr(3), index(3), scan(3), verify(3) non-elemental: len_trim(3), repeat(3), trim(3),\n                    codepoints_to_utf8(3), utf8_to_codepoints(3) AUTHOR John S. Urban Francois Jacq - enhancements and Latin support from Francois Jacq, 2025-08 LICENSE MIT Arguments Type Intent Optional Attributes Name integer, intent(in) :: codepoints (:) character(len=1), intent(out), allocatable :: utf8 (:) integer, intent(out) :: nerr","tags":"","url":"interface/codepoints_to_utf8.html"},{"title":"escape ‚Äì M_unicode","text":"public interface escape Module Procedures private impure elemental function escape_uu(line, protect) result(out) NAME ESCAPE(3f) - [M_unicode:CONVERSION] expand C-like escape sequences\n (LICENSE:MIT) SYNOPSIS function escape(line,utf8) result ( out ) type ( unicode_type ) :: line character ( len = 1 ), intent ( in ), optional :: protect type ( unicode_type ) :: out DESCRIPTION ESCAPE ( 3 ) expands commonly used escape sequences that represent glyphs or control characters . By default ... Escape sequences \\ backslash a alert ( BEL ) -- g is an alias for a b backspace c suppress further output e escape f form feed n new line r carriage return t horizontal tab v vertical tab oNNN byte with octal value NNN ( 3 digits ) 0 - 9 digits will be assumed an octal value till a non - octal value character is encountered dNNN byte with decimal value NNN ( 3 digits ) xHH byte with hexadecimal value HH ( 2 digits ) ; h is an alias for x uZZZZ translate Unicode codepoint value to bytes UZZZZZZZZ translate Unicode codepoint value to bytes The default escape character is the backslash, but this may be\n   changed using the optional parameter ESCAPE. EXAMPLES Sample Program: program demo_escape ! demonstrate filter to expand C - like escape sequences in input lines use iso_fortran_env , only : stdout => output_unit use M_unicode , only : ut => unicode_type , ch => character , len , escape use M_unicode , only : assignment (=), trim implicit none type ( ut ), allocatable :: poem (:) type ( ut ) :: test ( 5 ) integer :: i ! ! ‚Äú The Crow and the Fox ‚Äù by Jean de la Fontaine write ( stdout , ' ( a , / ) ' ) & ' Le Corbeau et le Renard -- Jean de la Fontaine ' ! poem =[ & ut ( ' Le Corbeau et le Renard ' ), & ut ( '' ), & ut ( ' Ma \\ u00EEtre Corbeau , sur un arbre perch \\ u00E9 , ' ), & ut ( ' Tenait en son bec un fromage . ' ), & ut ( ' Ma \\ u00EEtre Renard , par l \\ u2019odeur all \\ u00E9ch \\ u00E9 , ' ), & ut ( ' Lui tint \\ U000000E0 peu pr \\ U000000E8s ce langage : ' ), & ut ( '\\ U000000ABH \\ U000000E9 ! bonjour , Monsieur du Corbeau . ' ), & ut ( ' Que vous \\ U000000EAtes joli ! que vous me semblez beau ! ' ), & ut ( ' Sans mentir , si votre ramage ' ), & ut ( ' Se rapporte \\ U000000E0 votre plumage , ' ), & ut ( ' Vous \\ xEAtes le Ph \\ xE9nix des h \\ xF4tes de ces bois . \\ xBB ' ), & ut ( ' A ces mots le Corbeau ne se sent pas de joie ; ' ), & ut ( ' Et pour montrer sa belle voix , ' ), & ut ( ' Il ouvre un large bec , laisse tomber sa proie . ' ), & ut ( ' Le Renard s \\ u2019en saisit , et dit : \\ xABMon bon Monsieur , ' ), & ut ( ' Apprenez que tout flatteur ' ), & ut ( ' Vit aux d \\ xE9pens de celui qui l \\ U00002019 \\ u00E9coute : ' ), & ut ( ' Cette le \\ xE7on vaut bien un fromage , sans doute . \\ xBB ' ), & ut ( ' Le Corbeau , honteux et confus , ' ), & ut ( & ' Jura , mais un peu tard , qu \\ u2019on ne l \\ u2019y prendrait plus . ' ), & ut ( ' -- Jean de la Fontaine ' )] ! poem = escape ( poem ) write ( stdout , ' ( g0 ) ' ) ch ( poem ) ! test =[ & '\\ e [ H \\ e [ 2 J ' , & ! home cursor and clear screen ! on ANSI terminals '\\ tABC \\ tabc ' , & ! write some tabs in the output '\\ tA \\ a ' , & ! ring bell at end if supported '\\ nONE \\ nTWO \\ nTHREE ' , & ! place one word per line '\\\\ ' ] test = trim ( escape ( test )) write ( * , ' ( a ) ' )( test ( i ) % character (), i = 1 , size ( test )) ! end program demo_escape Results (with nonprintable characters shown visible): > &#94;[[H&#94;[[2J\n  > &#94;IABC&#94;Iabc\n  > &#94;IA&#94;G\n  >\n  > ONE\n  > TWO\n  > THREE\n  > !! AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: line type( unicode_type ), intent(in), optional :: protect Return Value type( unicode_type ) private impure elemental function escape_ua(line, protect) result(out) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: line character(len=1), intent(in) :: protect Return Value type( unicode_type ) private impure elemental function escape_au(line, protect) result(out) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line type( unicode_type ), intent(in), optional :: protect Return Value type( unicode_type ) private impure elemental function escape_aa(line, protect) result(out) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line character(len=1), intent(in) :: protect Return Value type( unicode_type )","tags":"","url":"interface/escape.html"},{"title":"fmt ‚Äì M_unicode","text":"public interface fmt Module Procedures private recursive function fmt_ga(generic, format) result(line) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: generic character(len=*), intent(in), optional :: format Return Value type( unicode_type ) private recursive function fmt_gs(generic, format) result(line) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: generic type( unicode_type ), intent(in) :: format Return Value type( unicode_type )","tags":"","url":"interface/fmt.html"},{"title":"get_arg ‚Äì M_unicode","text":"public interface get_arg Module Procedures private impure elemental function get_arg_ia(position, default) result(value) NAME get_arg(3f) - [M_unicode:SYSTEM] get command line argument\n(LICENSE:MIT) SYNOPSIS impure elemental function get_arg ( position , default ) result ( out ) integer , intent =( in ) :: position type ( unicode_type ), optional :: default type ( unicode_type ) :: out CHARACTERISTICS DEFAULT may be default CHARACTER type as well . DESCRIPTION get_arg(3) gets the value of the requested command line argument\nas TYPE(UNICODE_TYPE) . OPTIONS position Position on command line of requested argument . Zero returns the name of the command executed . Non - existent positions default to returning a null string . default value to return if argument is not set or set to a blank value RETURNS out value assigned based on value of environment variable NAME EXAMPLES Sample program: program demo_get_arg use M_unicode , only : get_arg , ut => unicode_type , ch => character use M_unicode , only : assignment (=), operator ( //), write(formatted) implicit none integer :: position type ( ut ) :: default type ( ut ) :: value type ( ut ) :: smiley integer :: i character ( len = * ), parameter :: bracket = ' ( 1 x , * ( \"[\" , a , \"]\" ,:)) ' ! smiley = 128515 ! set with Unicode code point default = ' Wish I was first ' //smiley//'!' ! set with unicode_type ! ! arguments can be type ( unicode_type ) or character ! but type ( unicode_type ) is always returned do position = 0 , command_argument_count () value = get_arg ( position , default ) value = get_arg ( position , default % character () ) ! write ( * , * ) value % character () write ( * , ' ( DT ) ' ) default % get_arg ( position ) ! ! print each glyph surrounded by brackets write ( * , bracket )( value % character ( i , i ), i = 1 , value % len ()) enddo ! end program demo_get_arg Results: > demo_get_arg > demo_get_arg > [ d ][ e ][ m ][ o ][ _ ][ g ][ e ][ t ][ _ ][ a ][ r ][ g ] AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name integer, intent(in) :: position character(len=*), intent(in), optional :: default Return Value type( unicode_type ) private impure elemental function get_arg_iu(position, default) result(value) Arguments Type Intent Optional Attributes Name integer, intent(in) :: position type( unicode_type ), intent(in) :: default Return Value type( unicode_type )","tags":"","url":"interface/get_arg.html"},{"title":"get_env ‚Äì M_unicode","text":"public interface get_env Module Procedures private impure elemental function get_env_uu(name, default) result(value) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: name type( unicode_type ), intent(in), optional :: default Return Value type( unicode_type ) private impure elemental function get_env_ua(name, default) result(value) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: name character(len=*), intent(in) :: default Return Value type( unicode_type ) private impure elemental function get_env_au(name, default) result(value) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name type( unicode_type ), intent(in) :: default Return Value type( unicode_type ) private impure elemental function get_env_aa(name, default) result(uvalue) NAME get_env ( 3 f ) - [ M_unicode : SYSTEM ] return value of environment variable ( LICENSE : MIT ) SYNOPSIS impure elemental function get_env ( name , default ) result ( out ) type ( unicode_type ), intent =( in ) :: name type ( unicode_type ), optional :: default type ( unicode_type ) :: out CHARACTERISTICS NAME and DEFAULT may be default CHARACTER type as well . DESCRIPTION get_env ( 3 ) gets the value of the requested environment variable as TYPE ( UNICODE_TYPE ) . OPTIONS name name of environment variable to return the value of . Typically the name may only contain the characters A - Z , a - z , 0 - 9 and underscore ; but allowed values are system - dependent . default value to return if environment variable NAME is not set or set to a blank value RETURNS out value assigned based on value of environment variable NAME EXAMPLES Sample program: program demo_get_env use M_unicode , only : get_env , ut => unicode_type use M_unicode , only : assignment (=), operator ( //) implicit none type ( ut ) :: name type ( ut ) :: default type ( ut ) :: value type ( ut ) :: smiley integer :: i character ( len = * ), parameter :: bracket = ' ( 1 x , * ( \"[\" , a , \"]\" ,:)) ' ! smiley = 128515 ! set with Unicode code point name = ' UTF8 ' ! set with ASCII default = ' Have a nice day ' //smiley//'!' ! set with unicode_type ! ! arguments can be type ( unicode_type ) or character ! but type ( unicode_type ) is always returned value = get_env ( name , default ) value = get_env ( name % character (), default % character () ) value = get_env ( name , default % character () ) value = get_env ( name % character (), default ) ! write ( * , * ) value % character () ! ! print each glyph surrounded by brackets write ( * , bracket )( value % character ( i , i ), i = 1 , value % len ()) ! end program demo_get_env Results: > Have a nice day üòÉ! > [ H ][ a ][ v ][ e ][ ][ a ][ ][ n ][ i ][ c ][ e ][ ][ d ][ a ][ y ][ ][ üòÉ ][ ! ] AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: default Return Value type( unicode_type )","tags":"","url":"interface/get_env.html"},{"title":"ichar ‚Äì M_unicode","text":"public interface ichar Module Procedures private elemental function ichar_str(string) result(code) NAME ICHAR(3f) - [M_unicode:CONVERSION] character-to-integer code conversion\n   function\n   (LICENSE:MIT) SYNOPSIS result = ichar(c) elemental integer function ichar ( c , kind ) type ( unicode_type ), intent ( in ) :: c CHARACTERISTICS ‚Ä¢  c is a scalar character ‚Ä¢  the return value is of default integer kind. DESCRIPTION ichar(3) returns the code for the character in the system‚Äôs native\n   character set. the correspondence between characters and their codes is\n   not necessarily the same across different Fortran implementations. For\n   example, a platform using EBCDIC would return different values than\n   an ASCII platform. See IACHAR(3) for specifically working with the ASCII character set. OPTIONS C : The input character to determine the decimal code of. RESULT The codepoint in the Unicode character set for the character being queried is returned . The result is the position of C in the Unicode collating sequence , which is generally not the dictionary order in a particular language . It is nonnegative and less than n , where n is the number of characters in the collating sequence . For any characters C and D capable of representation in the processor , C <= D is true if and only if ICHAR ( C ) <= ICHAR ( D ) is true and C == D is true if and only if ICHAR ( C ) == ICHAR ( D ) is true . EXAMPLES sample program: program demo_ichar use M_unicode , only : assignment (=), ch => character use M_unicode , only : ut => unicode_type , write ( formatted ) use M_unicode , only : ichar , escape , len implicit none type ( ut ) :: string type ( ut ), allocatable :: lets (:) integer , allocatable :: ilets (:) integer :: i ! ! create a string containing multibyte characters string =[ 949 , 8021 , 961 , 951 , 954 , 945 , 33 ] ! eureka write ( * , ' ( * ( DT , 1 x , \"(AKA. eureka!)\" )) ' ) string ! ! call ichar ( 3 ) on each glyph of the string to convert ! the string to an array of integer codepoints ilets =[( ichar ( string % sub ( i , i )), i = 1 , len ( string ))] write ( * , ' ( * ( z0 , 1 x )) ' ) ilets ! ! note that the % codepoint method is commonly used to ! convert a string to an integer array of codepoints write ( * , ' ( * ( z0 , 1 x )) ' ) string % codepoint () ! elemental write ( * , ' ( \"WRITING ISSUES:\" ) ' ) ! ! define an array LETS with escape codes with one glyph per element lets =[ ut ( '\\ U03B5 ' ), ut ( '\\ U1F55 ' ), ut ( '\\ U03C1 ' ), ut ( '\\ U03B7 ' ), & & ut ( '\\ U03BA ' ), ut ( '\\ U03B1 ' ), ut ( '\\ U0021 ' )] lets = escape ( lets ) ! convert escape codes to glyphs ! ! look at issues with converting to CHARACTER for simple printing ! write ( * , ' ( \"each element is a single glyph \" , * ( g0 , 1 x )) ' ) len ( lets ) ! ! notice if you convert to an array of intrinsic CHARACTER type the ! strings are all the same length in bytes ; but unicode characters ! can take various numbers of bytes write ( * , ' ( * ( g0 , \":\" )) ')' CHARACTER array elements have same length ' , & & len ( ch ( lets )) ! this will not appear correctly because all elements are padded to ! the same length in bytes write ( * , ' ( * ( a , \":\" )) ' ) ch ( lets ) ! one element at a time will retain the size of each element write ( * , ' ( * ( a , \":\" )) ' )( ch ( lets ( i : i )), i = 1 , size ( lets )) ! ! the FIRST LETTER of each element is converted to a codepoint so ! for the special case where each string element is a single glyph ! an elemental approach works write ( * , ' ( \"ELEMENTAL:\" , * ( z0 , 1 x )) ' ) ichar ( lets ) ! OOPS write ( * , ' ( \"OOPS:\" , * ( z0 , 1 x )) ' ) lets % ichar () end program demo_ichar results: > Project is up to date\n> Œµ·ΩïœÅŒ∑Œ∫Œ±! (AKA. eureka!)\n> 3B5 1F55 3C1 3B7 3BA 3B1 21\n> 3B5 1F55 3C1 3B7 3BA 3B1 21\n> WRITING ISSUES:\n> each element is a single glyph 1 1 1 1 1 1 1\n> CHARACTER array elements have same length:3:\n> Œµ :·Ωï:œÅ :Œ∑ :Œ∫ :Œ± :!  :\n> Œµ:·Ωï:œÅ:Œ∑:Œ∫:Œ±:!:\n> ELEMENTAL:3B5 1F55 3C1 3B7 3BA 3B1 21\n> OOPS:3B5 1F55 3C1 3B7 3BA 3B1 21 SEE ALSO achar(3), char(3), iachar(3) functions that perform operations on character strings, return\n   lengths of arguments, and search for certain arguments: elemental: adjustl(3), adjustr(3), index(3),\n      scan(3), verify(3) nonelemental: len_trim(3), len(3), repeat(3), trim(3) AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value integer","tags":"","url":"interface/ichar.html"},{"title":"index ‚Äì M_unicode","text":"public interface index Module Procedures private elemental function index_str_str(string, substring, back) result(foundat) NAME INDEX(3f) - [M_unicode:SEARCH] Position of a substring within a string\n               (LICENSE:MIT) SYNOPSIS result = index( string, substring [,back] [,kind] ) elemental integer(kind=KIND) function index(string,substring,back,kind)\n\n character(len=*,kind=KIND),intent(in) :: string\n character(len=*,kind=KIND),intent(in) :: substring\n logical(kind=**),intent(in),optional :: back\n integer(kind=**),intent(in),optional :: kind CHARACTERISTICS STRING     is a character variable of any kind SUBSTRING  is a character variable of the same kind as STRING BACK       is a logical variable of any supported kind KIND       is a scalar integer constant expression. DESCRIPTION INDEX(3) returns the position of the start of the leftmost or\n   rightmost occurrence of string SUBSTRING in STRING, counting from\n   one. If SUBSTRING is not present in STRING, zero is returned. OPTIONS STRING : string to be searched for a match SUBSTRING : string to attempt to locate in STRING BACK : If the BACK argument is present and true, the return value\n     is the start of the rightmost occurrence rather than the\n     leftmost. KIND : if KIND is present, the kind type parameter is that specified\n     by the value of KIND; otherwise the kind type parameter is\n     that of default integer type. RESULT The result is the starting position of the first substring SUBSTRING\n   found in STRING. If the length of SUBSTRING is longer than STRING the result is zero. If the substring is not found the result is zero. If BACK is .true. the greatest starting position is returned (that is,\n   the position of the right‚Äêmost match). Otherwise, the smallest\n   position starting a match (ie. the left‚Äêmost match) is returned. The position returned is measured from the left with the first character\n   of STRING being position one. Otherwise, if no match is found zero is returned. EXAMPLES Example program program demo_index use M_unicode , only : ut => unicode_type use M_unicode , only : assignment ( = ) use M_unicode , only : index implicit none type ( ut ) :: str character ( len =* ), parameter :: all = '(*(g0))' integer :: ii ! str = 'Huli i kƒìia kaula no kƒìia  ª≈çlelo' ! bug ! print all , index ( str , 'kƒìia' ). eq .8 ii = index ( str , 'kƒìia' ); print all , ii . eq .8 ! ! return value is counted from the left end even if BACK = . TRUE . ! bug ! print all , index ( str , 'kƒìia' , back = . true .). eq .22 ii = index ( str , 'kƒìia' , back = . true .); print all , ii . eq .22 ! ! INDEX is case - sensitive ! bug ! print all , index ( str , 'Kƒìia' ). eq .0 ii = index ( str , 'Kƒìia' ); print all , ii . eq .0 !<<<<<<<<<< ! ifx bug : ifx ( IFX ) 2024.1.0 20240308 ! ! example / demo_index . f90 ( 17 ) : error #6766 : A binary defined OPERATOR ! definition is missing or incorrect . [ EQ ] ! print all , index ( str , 'k  ia' , back = . true .). eq .22 ! --------------------------------------------------&#94; ! Original works with gfortran and flang_new and this works with ifx ! ii = ndex ( str , 'k  ia' , back = . true .) ! print all , ii . eq .22 !>>>>>>>>>> end program demo_index Expected Results: > T\n> T\n> T\n> T\n> T\n> T SEE ALSO Functions that perform operations on character strings, return lengths\n   of arguments, and search for certain arguments: ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), SCAN(3), VERIFY(3) NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3) AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function index_str_char(string, substring, back) result(foundat) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string character(len=*), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function index_char_str(string, substring, back) result(foundat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( unicode_type ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer","tags":"","url":"interface/index.html"},{"title":"len ‚Äì M_unicode","text":"public interface len Module Procedures private elemental function len_str(string) result(length) NAME LEN(3f) - [M_unicode:WHITESPACE] Length of a string\n     (LICENSE:MIT) SYNOPSIS result = len(string) elemental integer function len ( string ) type ( unicode_type ), intent ( in ) :: string CHARACTERISTICS STRING is a scalar or array string variable the returned value is of default INTEGER kind DESCRIPTION LEN(3) returns the length of a type(unicode_type) string. Note that unlike the intrinsic of the same name STRING needs to be\n   defined; as the length of each element is not defined until allocated;\n   and the KIND parameter is not available for specifying the kind of the\n   integer returned. OPTIONS STRING : A scalar or array string to return the length(s) of in glyph\n     counts. If it is an unallocated allocatable variable or a pointer that\n     is not associated, its length type parameter shall not be deferred. RESULT The result has a value equal to the number of glyphs in STRING if\n   it is scalar or the elements of STRING if it is an array. EXAMPLES Sample program program demo_len use M_unicode , only : assignment (=), ut => unicode_type , len use M_unicode , only : write ( formatted ) implicit none type ( ut ) :: string type ( ut ), allocatable :: many_strings (:) integer :: ii ! BASIC USAGE string = ' Noho me ka hau ‚Äô oli ' ! ( Be happy .) ii = len ( string ) write ( * , ' ( DT , * ( g0 )) ' ) string , ' LEN = ' , ii ! string = ' How long is this allocatable string ? ' write ( * , ' ( DT , * ( g0 )) ' ) string , ' LEN = ' , len ( string ) ! ! STRINGS IN AN ARRAY MAY BE OF DIFFERENT LENGTHS many_strings = [ ut ( ' Tom ' ), ut ( ' Dick ' ), ut ( ' Harry ' ) ] write ( * , ' ( * ( g0 , 1 x )) ')' length of elements of array = ' , len ( many_strings ) ! write ( * , ' ( * ( g0 )) ')' length from type parameter inquiry = ' , string % len () ! ! LOOK AT HOW A PASSED STRING CAN BE USED ... call passed ( ut ( ' how long ? ' )) ! contains ! subroutine passed ( str ) type ( ut ), intent ( in ) :: str ! you can query the length of the passed variable ! when an interface is present write ( * , ' ( * ( g0 )) ')' length of passed value is ' , len ( str ) end subroutine passed ! end program demo_len Results: > Noho me ka hau ‚Äô oli LEN = 18 > How long is this allocatable string ? LEN = 38 > length of elements of array = 3 4 5 > length from type parameter inquiry = 38 > length of passed value is 11 SEE ALSO functions that perform operations on character strings: elemental: adjustl(3), adjustr(3), index(3), scan(3), verify(3) non-elemental: len_trim(3), len(3), repeat(3), trim(3) AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value integer","tags":"","url":"interface/len.html"},{"title":"len_trim ‚Äì M_unicode","text":"public interface len_trim Module Procedures private elemental function len_trim_str(string) result(length) NAME LEN_TRIM(3f) - [M_unicode:WHITESPACE] string length without trailing blank\n   characters\n   (LICENSE:MIT) SYNOPSIS result = len_trim(string) elemental integer(kind=kind) function len_trim(string)\n\n       character(len=*),intent(in) :: string CHARACTERISTICS string is of type type(unicode_type) the return value is of type default integer. DESCRIPTION len_trim(3) returns the length of a string, ignoring any trailing\n   blanks. OPTIONS string : the input string whose length is to be measured. RESULT the result equals the number of glyphs remaining after any trailing\n   blanks in string are removed. if the input argument is of zero length or all blanks the result is zero. EXAMPLES sample program program demo_len_trim use M_unicode , only : ut => unicode_type , assignment (=) use M_unicode , only : len , len_trim use M_unicode , only : write ( formatted ) implicit none type ( ut ) :: string integer :: i ! basic usage string = \" how long is this string?     \" print ' ( DT ) ' , string print * , ' untrimmed length = ' , len ( string ) print * , ' trimmed length = ' , len_trim ( string ) ! ! print string , then print substring of string string = ' xxxxx ' write ( * , ' ( * ( DT )) ' ) string , string , string i = len_trim ( string ) print ' ( * ( DT )) ' , string % sub ( 1 , i ), string % sub ( 1 , i ), string % sub ( 1 , i ) ! ! elemental example ele : block ! an array of strings may be used type ( ut ), allocatable :: tablet (:) tablet =[ & & ut ( ' how long is this string ? ' ), & & ut ( ' and this one ? ' )] write ( * , * ) ' untrimmed length = ' , len ( tablet ) write ( * , * ) ' trimmed length = ' , len_trim ( tablet ) write ( * , * ) ' sum trimmed length = ' , sum ( len_trim ( tablet )) endblock ele ! end program demo_len_trim results: >  how long is this string?\n>  untrimmed length=          30\n>  trimmed length=          25\n> xxxxx   xxxxx   xxxxx\n> xxxxxxxxxxxxxxx\n>  untrimmed length=            30          13\n>  trimmed length=              25          13\n>  sum trimmed length=          38 SEE ALSO functions that perform operations on character strings, return lengths of\n   arguments, and search for certain arguments: elemental: adjustl(3), adjustr(3), index(3), scan(3), verify(3) nonelemental: repeat(3), len(3), trim(3) AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value integer","tags":"","url":"interface/len_trim.html"},{"title":"leq ‚Äì M_unicode","text":"public interface leq Module Procedures private elemental function leq_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function leq_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function leq_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/leq.html"},{"title":"lge ‚Äì M_unicode","text":"public interface lge Module Procedures private elemental function lge_str_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lge_str_char(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lge_char_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/lge.html"},{"title":"lgt ‚Äì M_unicode","text":"public interface lgt Module Procedures private elemental function lgt_str_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lgt_str_char(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lgt_char_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/lgt.html"},{"title":"lle ‚Äì M_unicode","text":"public interface lle Module Procedures private elemental function lle_str_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lle_str_char(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lle_char_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/lle.html"},{"title":"llt ‚Äì M_unicode","text":"public interface llt Module Procedures private elemental function llt_str_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function llt_str_char(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function llt_char_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/llt.html"},{"title":"lne ‚Äì M_unicode","text":"public interface lne Module Procedures private elemental function lne_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lne_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lne_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/lne.html"},{"title":"operator(.cat.) ‚Äì M_unicode","text":"public interface operator(.cat.) Module Procedures private  function concat_g_g(lhs, rhs) result(string) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: lhs class(*), intent(in) :: rhs Return Value type( unicode_type )","tags":"","url":"interface/operator(.cat.).html"},{"title":"operator(//) ‚Äì M_unicode","text":"public interface operator(//) Module Procedures private  function concat_g_u(lhs, rhs) result(string) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value type( unicode_type ) private  function concat_u_g(lhs, rhs) result(string) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs class(*), intent(in) :: rhs Return Value type( unicode_type ) private  function concat_g_i(lhs, rhs) result(string) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: lhs integer, intent(in) :: rhs Return Value type( unicode_type ) private  function concat_i_g(lhs, rhs) result(string) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs class(*), intent(in) :: rhs Return Value type( unicode_type ) private  function concat_g_r(lhs, rhs) result(string) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: lhs real, intent(in) :: rhs Return Value type( unicode_type ) private  function concat_r_g(lhs, rhs) result(string) Arguments Type Intent Optional Attributes Name real, intent(in) :: lhs class(*), intent(in) :: rhs Return Value type( unicode_type ) private  function concat_g_d(lhs, rhs) result(string) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: lhs doubleprecision, intent(in) :: rhs Return Value type( unicode_type ) private  function concat_d_g(lhs, rhs) result(string) Arguments Type Intent Optional Attributes Name doubleprecision, intent(in) :: lhs class(*), intent(in) :: rhs Return Value type( unicode_type ) private  function concat_g_c(lhs, rhs) result(string) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: lhs complex, intent(in) :: rhs Return Value type( unicode_type ) private  function concat_c_g(lhs, rhs) result(string) Arguments Type Intent Optional Attributes Name complex, intent(in) :: lhs class(*), intent(in) :: rhs Return Value type( unicode_type ) private  function concat_g_l(lhs, rhs) result(string) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: lhs logical, intent(in) :: rhs Return Value type( unicode_type ) private  function concat_l_g(lhs, rhs) result(string) Arguments Type Intent Optional Attributes Name logical, intent(in) :: lhs class(*), intent(in) :: rhs Return Value type( unicode_type )","tags":"","url":"interface/operator(SLASHSLASH).html"},{"title":"operator(/=) ‚Äì M_unicode","text":"public interface operator(/=) Module Procedures private elemental function lne_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lne_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lne_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(SLASH=).html"},{"title":"operator(<) ‚Äì M_unicode","text":"public interface operator(<) Module Procedures private elemental function llt_str_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function llt_str_char(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function llt_char_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(lt).html"},{"title":"operator(<=) ‚Äì M_unicode","text":"public interface operator(<=) Module Procedures private elemental function lle_str_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lle_str_char(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lle_char_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(lt=).html"},{"title":"operator(==) ‚Äì M_unicode","text":"public interface operator(==) Module Procedures private elemental function leq_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function leq_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function leq_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(==).html"},{"title":"operator(>) ‚Äì M_unicode","text":"public interface operator(>) Module Procedures private elemental function lgt_str_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lgt_str_char(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lgt_char_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(gt).html"},{"title":"operator(>=) ‚Äì M_unicode","text":"public interface operator(>=) Module Procedures private elemental function lge_str_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lge_str_char(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lge_char_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(gt=).html"},{"title":"repeat ‚Äì M_unicode","text":"public interface repeat Module Procedures private elemental function repeat_str(string, ncopies) result(repeated_str) NAME REPEAT(3) - [M_unicode:CHARACTER] Repeated string concatenation SYNOPSIS result = repeat(string, ncopies) type ( unicode_type ) function repeat ( string , ncopies ) type ( unicode_type ), intent ( in ) :: string integer ( kind = ** ), intent ( in ) :: ncopies CHARACTERISTICS STRING is a scalar string of type(unicode_type). NCOPIES is a scalar integer. the result is a new scalar string of type type(unicode_type) DESCRIPTION REPEAT(3) concatenates copies of a string. OPTIONS STRING : The input string to repeat NCOPIES : Number of copies to make of STRING, greater than or equal to\n      zero (0). RESULT A new string built up from NCOPIES copies of STRING. EXAMPLES Sample program: program demo_repeat use M_unicode , only : ut => unicode_type , repeat , escape , write ( formatted ) implicit none write ( * , ' ( DT ) ' ) repeat ( escape ( \"\\u2025*\" ), 35 ) write ( * , ' ( DT ) ' ) repeat ( ut ( \"_\" ), 70 ) ! line break write ( * , ' ( DT ) ' ) repeat ( ut ( \"1234567890\" ), 7 ) ! number line write ( * , ' ( DT ) ' ) repeat ( ut ( \"         |\" ), 7 ) ! end program demo_repeat STANDARD Fortran 95 SEE ALSO Functions that perform operations on character strings: ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), SCAN(3), VERIFY(3) NON-ELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3) Fortran descriptions (license: MIT) @urbanjost Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in) :: ncopies Return Value type( unicode_type )","tags":"","url":"interface/repeat.html"},{"title":"replace ‚Äì M_unicode","text":"public interface replace Module Procedures private  function replace_uuu(target, old, new, force_, occurrence, repeat, ignorecase, changes, back) result(newline) NAME REPLACE(3f) - [M_unicode:EDITING] function replaces one\n substring for another in string\n (LICENSE:MIT) SYNOPSIS syntax: function replace ( target , old , new , & & occurrence , & & repeat , & & ignorecase , & & ierr , back ) result ( newline ) or function replace ( target,start,end,new ) result newline type ( unicode_type ) | character ( len = * ), intent ( in ) :: target type ( unicode_type ) | character ( len = * ), intent ( in ) :: old type ( unicode_type ) | character ( len = * ), intent ( in ) :: new or type ( unicode_type ) | character ( len = * ), intent ( in ) :: new integer , intent ( in ) :: start integer , intent ( in ) :: end integer , intent ( in ), optional :: occurrence integer , intent ( in ), optional :: repeat logical , intent ( in ), optional :: ignorecase integer , intent ( out ), optional :: changes logical , intent ( in ), optional :: back character ( len =:), allocatable :: newline CHARACTERISTICS TARGET,OLD and NEW may be a string or a character variable. DESCRIPTION Replace old substring with new value in string. Either a\n old and new string is specified, or a new string and a\n column range indicating the position of the text to replace\n is specified. OPTIONS target input line to be changed old old substring to replace new new substring start starting column of text to replace end ending column of text to replace KEYWORD REQUIRED occurrence if present , start changing at the Nth occurrence of the OLD string . repeat number of replacements to perform . Defaults to a global replacement . ignorecase whether to ignore ASCII case or not . Defaults to . false . . back if true start replacing moving from the right end of the string moving left instead of from the left to the right . RETURNS newline     allocatable string returned\n  changes     count of changes made. EXAMPLES Sample Program: program demo_replace use M_unicode , only : ut => unicode_type use M_unicode , only : unicode_type use M_unicode , only : character , replace use M_unicode , only : write ( formatted ) implicit none type ( unicode_type ) :: line ! write ( * , ' ( DT ) ' ) & & replace ( ut ( ' Xis is Xe string ' ), ut ( 'X' ), ut ( ' th ' ) ) write ( * , ' ( DT ) ' ) & & replace ( ut ( ' Xis is xe string ' ), ut ( 'x' ), ut ( ' th ' ), ignorecase =. true .) write ( * , ' ( DT ) ' ) & & replace ( ut ( ' Xis is xe string ' ), ut ( 'X' ), ut ( ' th ' ), ignorecase =. false .) ! ! a null old substring means \"at beginning of line\" write ( * , ' ( DT ) ' ) & & replace ( ut ( ' my line of text ' ), ut ( '' ), ut ( ' BEFORE : ' )) ! ! a null new string deletes occurrences of the old substring write ( * , ' ( DT ) ' ) replace ( ut ( ' I wonder i ii iii ' ), ut ( 'i' ), ut ( '' )) ! ! Examples of the use of RANGE ! line = replace ( ut ( ' aaaaaaaaa ' ), ut ( 'a' ), ut ( 'A' ), occurrence = 1 , repeat = 1 ) write ( * , * ) ' replace first a with A [ ' //line%character()//']' ! line = replace ( ut ( ' aaaaaaaaa ' ), ut ( 'a' ), ut ( 'A' ), occurrence = 3 , repeat = 3 ) write ( * , * ) ' replace a with A for 3 rd to 5 th occurrence [ ' & & //line%character()//']' ! line = replace ( ut ( ' ababababa ' ), ut ( 'a' ), ut ( '' ), occurrence = 3 , repeat = 3 ) write ( * , * ) ' replace a with null instances 3 to 5 [ ' // & & line % character () //']' ! line = replace ( & & ut ( ' a b ab baaa aaaa aa aa a a a aa aaaaaa ' ), & & ut ( ' aa ' ), ut ( ' CCCC ' ), occurrence = - 1 , repeat = 1 ) write ( * , * ) ' replace lastaa with CCCC [ ' //line%character()//']' ! write ( * , ' ( DT ) ' ) replace ( ut ( ' myf90stuff . f90 . f90 ' ), & & ut ( ' f90 ' ), ut ( ' for ' ), occurrence = - 1 , repeat = 1 ) write ( * , ' ( DT ) ' ) replace ( ut ( ' myf90stuff . f90 . f90 ' ), & & ut ( ' f90 ' ), ut ( ' for ' ), occurrence = - 2 , repeat = 2 ) ! end program demo_replace Results: > this is the string > this is the string > this is xe string > BEFORE : my line of text > I wonder > replace first a with A [ Aaaaaaaaa ] > replace a with A for 3 rd to 5 th occurrence [ aaAAAaaaa ] > replace a with null instances 3 to 5 [ ababbb ] > replace lastaa with CCCC [ a b ab baaa aaaa aa aa a a a aa aaaaCCCC ] > myf90stuff . f90 . for > myforstuff . for . f90 AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: target type( unicode_type ), intent(in) :: old type( unicode_type ), intent(in) :: new type(force_keywords), intent(in), optional :: force_ integer, intent(in), optional :: occurrence integer, intent(in), optional :: repeat logical, intent(in), optional :: ignorecase integer, intent(out), optional :: changes logical, intent(in), optional :: back Return Value type( unicode_type ) private  function replace_uua(target, old, new, force_, occurrence, repeat, ignorecase, changes, back) result(newline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: target type( unicode_type ), intent(in) :: old character(len=*), intent(in) :: new type(force_keywords), intent(in), optional :: force_ integer, intent(in), optional :: occurrence integer, intent(in), optional :: repeat logical, intent(in), optional :: ignorecase integer, intent(out), optional :: changes logical, intent(in), optional :: back Return Value type( unicode_type ) private  function replace_uaa(target, old, new, force_, occurrence, repeat, ignorecase, changes, back) result(newline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: target character(len=*), intent(in) :: old character(len=*), intent(in) :: new type(force_keywords), intent(in), optional :: force_ integer, intent(in), optional :: occurrence integer, intent(in), optional :: repeat logical, intent(in), optional :: ignorecase integer, intent(out), optional :: changes logical, intent(in), optional :: back Return Value type( unicode_type ) private  function replace_uau(target, old, new, force_, occurrence, repeat, ignorecase, changes, back) result(newline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: target character(len=*), intent(in) :: old type( unicode_type ), intent(in) :: new type(force_keywords), intent(in), optional :: force_ integer, intent(in), optional :: occurrence integer, intent(in), optional :: repeat logical, intent(in), optional :: ignorecase integer, intent(out), optional :: changes logical, intent(in), optional :: back Return Value type( unicode_type ) private  function replace_aaa(target, old, new, force_, occurrence, repeat, ignorecase, changes, back) result(newline) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: target character(len=*), intent(in) :: old character(len=*), intent(in) :: new type(force_keywords), intent(in), optional :: force_ integer, intent(in), optional :: occurrence integer, intent(in), optional :: repeat logical, intent(in), optional :: ignorecase integer, intent(out), optional :: changes logical, intent(in), optional :: back Return Value type( unicode_type ) private  function replace_aua(target, old, new, force_, occurrence, repeat, ignorecase, changes, back) result(newline) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: target type( unicode_type ), intent(in) :: old character(len=*), intent(in) :: new type(force_keywords), intent(in), optional :: force_ integer, intent(in), optional :: occurrence integer, intent(in), optional :: repeat logical, intent(in), optional :: ignorecase integer, intent(out), optional :: changes logical, intent(in), optional :: back Return Value type( unicode_type ) private  function replace_aau(target, old, new, force_, occurrence, repeat, ignorecase, changes, back) result(newline) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: target character(len=*), intent(in) :: old type( unicode_type ), intent(in) :: new type(force_keywords), intent(in), optional :: force_ integer, intent(in), optional :: occurrence integer, intent(in), optional :: repeat logical, intent(in), optional :: ignorecase integer, intent(out), optional :: changes logical, intent(in), optional :: back Return Value type( unicode_type ) private  function replace_auu(target, old, new, force_, occurrence, repeat, ignorecase, changes, back) result(newline) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: target type( unicode_type ), intent(in) :: old type( unicode_type ), intent(in) :: new type(force_keywords), intent(in), optional :: force_ integer, intent(in), optional :: occurrence integer, intent(in), optional :: repeat logical, intent(in), optional :: ignorecase integer, intent(out), optional :: changes logical, intent(in), optional :: back Return Value type( unicode_type ) private  function section_uu(str, first, last, new) result(out) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: str integer, intent(in), optional :: first integer, intent(in), optional :: last type( unicode_type ), intent(in) :: new Return Value type( unicode_type ) private  function section_ua(str, first, last, new) result(out) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: str integer, intent(in) :: first integer, intent(in) :: last character(len=*), intent(in) :: new Return Value type( unicode_type ) private  function section_au(str, first, last, new) result(out) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: first integer, intent(in) :: last type( unicode_type ), intent(in) :: new Return Value type( unicode_type ) private  function section_aa(str, first, last, new) result(out) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: first integer, intent(in) :: last character(len=*), intent(in) :: new Return Value type( unicode_type )","tags":"","url":"interface/replace.html"},{"title":"scan ‚Äì M_unicode","text":"public interface scan Module Procedures private pure elemental function scan_uu(string, set, back) result(pos) NAME SCAN(3f) - [M_unicode:SEARCH] Scan a string for the presence of a\n   set of characters\n   (LICENSE:MIT) SYNOPSIS result = scan( string, set, [,back] ) elemental integer ( kind = KIND ) function scan ( string , set , back ) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set or character ( len = * ), intent ( in ) :: set logical , intent ( in ), optional :: back CHARACTERISTICS STRING is a string of type unicode_type SET must be a string of type unicode_type or character BACK is a logical of default kind the result is an integer of default kind. DESCRIPTION SCAN(3) scans a STRING for any of the characters in a SET of characters. If BACK is either absent or equals .false., this function returns the\n   position of the leftmost character of STRING that is in SET. If BACK\n   equals .true., the rightmost position is returned. If no character of\n   SET is found in STRING, the result is zero. OPTIONS STRING : the string to be scanned SET : the set of characters which will be matched BACK : if .true. the position of the rightmost character matched\n      is returned, instead of the leftmost. RESULT If BACK is absent or is present with the value false and if STRING\n   contains at least one character that is in SET, the value of the result\n   is the position of the leftmost character of STRING that is in SET. If BACK is present with the value true and if STRING contains at least\n   one character that is in SET, the value of the result is the position\n   of the rightmost character of STRING that is in SET. The value of the result is zero if no character of STRING is in SET\n   or if the length of STRING or SET is zero. EXAMPLES Sample program: program demo_scan use iso_fortran_env , only : stdout => output_unit use M_unicode , only : scan , unicode_type , assignment (=) use M_unicode , only : ut => unicode_type implicit none character ( len = * ), parameter :: g = ' ( * ( g0 , 1 x )) ' type ( ut ) :: line type ( ut ) :: set ! write ( * , * ) scan ( \"fortran\" , \"ao\" ) ! 2 , found ‚Äô o ‚Äô write ( * , * ) scan ( \"fortran\" , \"ao\" , . true .) ! 6 , found ‚Äô a ‚Äô write ( * , * ) scan ( \"fortran\" , \"c++\" ) ! 0 , found none ! line = ' parsley üòÉ sage üòÉ rosemary üòÉüòÉ thyme ' set = 'üòÉ' write ( stdout , g ) ' 12345678901234567890123456789012345678901234567890 ' write ( stdout , g ) line % character () write ( stdout , g ) scan ( line , set ) write ( stdout , g ) scan ( line , set , back =. true .) write ( stdout , g ) scan ( line , set , back =. false .) write ( stdout , g ) scan ( line , unicode_type ( \"NOT\" )) write ( stdout , g ) ' OOP ' write ( stdout , g ) line % scan ( set ) write ( stdout , g ) line % scan ( ut ( \"o\" )) end program demo_scan Results: >            2\n >            6\n >            0\n > 12345678901234567890123456789012345678901234567890\n > parsleyüòÉsageüòÉrosemaryüòÉüòÉthyme\n > 8\n > 23\n > 8\n > 0\n > OOP\n > 8\n > 15 SEE ALSO Functions that perform operations on character strings, return lengths\n   of arguments, and search for certain arguments: ADJUSTL(3), ADJUSTR(3), INDEX(3), VERIFY(3) LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3) AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer private pure elemental function scan_ua(string, set, back) result(pos) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer","tags":"","url":"interface/scan.html"},{"title":"sort ‚Äì M_unicode","text":"public interface sort Module Procedures private  subroutine sort_quick_rx(data, indx) NAME SORT(3f) - [M_unicode:SORT] indexed hybrid quicksort of\n an array\n (LICENSE:MIT) SYNOPSIS subroutine sort ( data , index ) type ( unicode_type ), intent ( in ) :: data (:) integer , intent ( out ) :: indx ( size ( data )) DESCRIPTION A rank hybrid quicksort . The data is not moved . An integer array is generated instead with values that are indices to the sorted order of the data . This requires a second array the size of the input array , which for large arrays would require a significant amount of memory . One major advantage of this method is that the indices can be used to access an entire user - defined type in sorted order . This makes this seemingly simple sort procedure usable with the vast majority of user - defined types . or other correlated data . BACKGROUND From Leonard J . Moss of SLAC : Here ' s a hybrid QuickSort I wrote a number of years ago . It ' s based on suggestions in Knuth , Volume 3 , and performs much better than a pure QuickSort on short or partially ordered input arrays . This routine performs an in - memory sort of the first N elements of array DATA , returning into array INDEX the indices of elements of DATA arranged in ascending order . Thus , DATA ( INDX ( 1 )) will be the smallest number in array DATA ; DATA ( INDX ( N )) will be the largest number in DATA . The original data is not physically rearranged . The original order of equal input values is not necessarily preserved . sort ( 3f ) uses a hybrid QuickSort algorithm , based on several suggestions in Knuth , Volume 3 , Section 5.2.2 . In particular , the \"pivot key\" [ my term ] for dividing each subsequence is chosen to be the median of the first , last , and middle values of the subsequence ; and the QuickSort is cut off when a subsequence has 9 or fewer elements , and a straight insertion sort of the entire array is done at the end . The result is comparable to a pure insertion sort for very short arrays , and very fast for very large arrays ( of order 12 micro - sec / element on the 3081 K for arrays of 10 K elements ). It is also not subject to the poor performance of the pure QuickSort on partially ordered data . Complex values are sorted by the magnitude of sqrt ( r ** 2 + i ** 2 ). o Created : sortrx ( 3f ) : 15 Jul 1986 , Len Moss o saved from url = ( 0044 ) http : //www.fortran.com/fortran/quick_sort2.f o changed to update syntax from F77 style ; John S . Urban 20161021 o generalized from only real values to include other intrinsic types ; John S . Urban 20210110 o type ( unicode_type ) version JSU 2025-09 -20. See M_sort for other types . EXAMPLES Sample usage: program demo_sort use iso_fortran_env , only : stdout => output_unit use M_unicode , only : sort , unicode_type , assignment (=) use M_unicode , only : ut => unicode_type , write ( formatted ) use M_unicode , only : ch => character implicit none character ( len = * ), parameter :: g = ' ( * ( g0 , 1 x )) ' integer , parameter :: isz = 4 type ( unicode_type ) :: rr ( isz ) integer :: ii ( isz ) integer :: i ! write ( stdout , g ) ' sort array with sort ( 3 f ) ' rr =[ & ut ( \"the\" ), & ut ( \"quick\" ), & ut ( \"brown\" ), & ut ( \"fox\" ) ] ! write ( stdout , g ) ' original order ' write ( stdout , g ) ch ( rr ) ! call sort ( rr , ii ) ! write ( stdout , g ) ' sorted order ' ! convert to character do i = 1 , size ( rr ) write ( stdout , ' ( i3 .3 , 1 x , a ) ' ) i , rr ( ii ( i )) % character () enddo ! write ( stdout , g ) ' reorder original ' rr = rr ( ii ) write ( stdout , g ) ch ( rr ) end program demo_sort Results: > sort array with sort(3f)\n> original order\n> the quick brown fox\n> sorted order\n> 001 brown\n> 002 fox\n> 003 quick\n> 004 the\n> reorder original\n> brown fox quick the AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: data (:) integer(kind=int32), intent(out) :: indx (:)","tags":"","url":"interface/sort.html"},{"title":"split ‚Äì M_unicode","text":"public interface split Module Procedures private impure subroutine split_first_last(string, set, first, last) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set integer, intent(out), allocatable :: first (:) integer, intent(out), allocatable :: last (:) private impure subroutine split_first_last_uaii(string, set, first, last) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string character(len=*), intent(in) :: set integer, intent(out), allocatable :: first (:) integer, intent(out), optional, allocatable :: last (:) private impure subroutine split_pos(string, set, pos, back) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set integer, intent(inout) :: pos logical, intent(in), optional :: back private impure subroutine split_pos_uail(string, set, pos, back) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string character(len=*), intent(in) :: set integer, intent(inout) :: pos logical, intent(in), optional :: back private impure subroutine split_tokens(string, set, tokens, separator) NAME SPLIT(3f) - [M_unicode:PARSE] parse a string into tokens, one at a time.\n   (LICENSE:MIT) SYNOPSIS call split (string, set, pos [, back]) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set integer , intent ( inout ) :: pos logical , intent ( in ), optional :: back CHARACTERISTICS STRING is a scalar character variable SET is a scalar string variable DESCRIPTION Find the extent of consecutive tokens in a string. given a string and\n   a position to start looking for a token return the position of the\n   end of the token. a set of separator characters may be specified as\n   well as the direction of parsing. typically consecutive calls are used to parse a string into a set of\n   tokens by stepping through the start and end positions of each token. OPTIONS STRING : the string to search for tokens in. SET : Each character in set is a token delimiter. a sequence of\n     zero or more characters in string delimited by any token delimiter,\n     or the beginning or end of string, comprise a token. thus, two\n     consecutive token delimiters in STRING, or a token delimiter in the\n     first or last character of STRING, indicate a token with zero length. POS : on input, the position from which to start looking for the next\n     separator from. This is typically the first character or the last\n     returned value of POS if searching from left to right (ie. back is\n     absent or .true.) or the last character or the last returned value\n     of POS when searching from right to left (ie. when back is .FALSE.). If BACK is present with the value .TRUE., the value of pos shall be\n in the range 0 < POS <= len(STRING)+1; otherwise it shall be in the\n range 0 <= POS <= len(STRING). So POS on input is typically an end of the string or the position\n of a separator, probably from a previous call to split but POS on\n input can be any position in the range 1 <= POS <= len(STRING). if\n POS points to a non-separator character in the string the call is\n still valid but it will start searching from the specified position\n and that will result (somewhat obviously) in the string from POS on\n input to the returned POS being a partial token. BACK : If BACK is absent or is present with the value .FALSE., POS is\n     assigned the position of the leftmost token delimiter in string\n     whose position is greater than POS, or if there is no such character,\n     it is assigned a value one greater than the length of string. this\n     identifies a token with starting position one greater than the value\n     of POS on invocation, and ending position one less than the value\n     of POS on return. If BACK is present with the value .TRUE., POS is assigned the\n position of the rightmost token delimiter in string whose position\n is less than POS, or if there is no such character, it is assigned\n the value zero. This identifies a token with ending position one\n less than the value of POS on invocation, and starting position one\n greater than the value of POS  on return. EXAMPLE sample program: program demo_split use iso_fortran_env , only : stdout => output_unit use M_unicode , only : unicode_type , assignment (=) use M_unicode , only : split , len , character use M_unicode , only : ut => unicode_type implicit none character ( len = * ), parameter :: g = ' ( * ( g0 , 1 x )) ' type ( ut ) :: proverb type ( ut ) :: delims type ( ut ), allocatable :: array (:) integer :: first integer :: last integer :: pos integer :: i ! delims = ' = | ; ' ! proverb = \"M√°s vale p√°jaro en mano, que ciento volando.\" call printwords ( proverb ) ! there really are not spaces between these glyphs array =[ & ut ( \"‰∏ÉËª¢„Å≥ÂÖ´Ëµ∑„Åç„ÄÇ\" ), & ut ( \"Ëª¢„Çì„Åß„ÇÇ„Åæ„ÅüÁ´ã„Å°‰∏ä„Åå„Çã„ÄÇ\" ), & ut ( \"„Åè„Åò„Åë„Åö„Å´Ââç„ÇíÂêë„ÅÑ„Å¶Ê≠©„ÅÑ„Å¶„ÅÑ„Åì„ÅÜ„ÄÇ\" )] call printwords ( array ) ! write ( stdout , g ) ' OOP ' array = proverb % split ( ut ( ' ' )) write ( stdout , ' ( * (: \"[\" , a , \"]\" )) ' )( character ( array ( i )), i = 1 , size ( array )) contains impure elemental subroutine printwords ( line ) type ( ut ), intent ( in ) :: line pos = 0 write ( stdout , g ) line % character (), len ( line ) do while ( pos < len ( line )) first = pos + 1 call split ( line , delims , pos ) last = pos - 1 print g , line % character ( first , last ), first , last , pos end do end subroutine printwords end program demo_split Results: > Project is up to date > M√°s vale p√°jaro en mano , que ciento volando . 44 > M√°s 1 3 4 > vale 5 8 9 > p√°jaro 10 15 16 > en 17 18 19 > mano , 20 24 25 > que 26 28 29 > ciento 30 35 36 > volando . 37 44 45 > ‰∏ÉËª¢„Å≥ÂÖ´Ëµ∑„Åç „ÄÇ 7 > ‰∏ÉËª¢„Å≥ÂÖ´Ëµ∑„Åç „ÄÇ 1 7 8 > Ëª¢„Çì„Åß„ÇÇ„Åæ„ÅüÁ´ã„Å°‰∏ä„Åå„Çã „ÄÇ 12 > Ëª¢„Çì„Åß„ÇÇ„Åæ„ÅüÁ´ã„Å°‰∏ä„Åå„Çã „ÄÇ 1 12 13 > „Åè„Åò„Åë„Åö„Å´Ââç„ÇíÂêë„ÅÑ„Å¶Ê≠©„ÅÑ„Å¶„ÅÑ„Åì„ÅÜ „ÄÇ 17 > „Åè„Åò„Åë„Åö„Å´Ââç„ÇíÂêë„ÅÑ„Å¶Ê≠©„ÅÑ„Å¶„ÅÑ„Åì„ÅÜ „ÄÇ 1 17 18 > OOP > [ M√°s ][ vale ][ p√°jaro ][ en ][ mano, ][ que ][ ciento ][ volando. ] SEE ALSO tokenize(3) - parse a string into tokens index(3) - position of a substring within a string scan(3) - scan a string for the presence of a set of characters verify(3)  -  position  of a character in a string of characters that does\n     not appear in a given set of characters. AUTHOR Milan Curcic , \"milancurcic@hey.com\" John S . Urban -- UTF-8 version LICENSE MIT NAME TOKENIZE(3f) - [M_unicode:PARSE] Parse a string into tokens.\n   (LICENSE:MIT) SYNOPSIS TOKEN form (returns array of strings) subroutine tokenize ( string , set , tokens [, separator ]) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set type ( unicode_type ), allocatable , intent ( out ) :: tokens (:) type ( unicode_type ), allocatable , intent ( out ), optional :: separator (:) ARRAY BOUNDS form (returns arrays defining token positions) subroutine tokenize ( string , set , first , last ) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set integer , allocatable , intent ( out ) :: first (:) integer , allocatable , intent ( out ) :: last (:) CHARACTERISTICS STRING ‚Äê a scalar of type string. It is an INTENT(IN)\n      argument. SET ‚Äê a scalar of type string with the same kind type\n      parameter as STRING. It is an INTENT(IN) argument. SEPARATOR ‚Äê (optional) shall be of type string. It is an\n      INTENT(OUT)argument. It shall not be a coarray or a coindexed object. TOKENS ‚Äê of type string. It is an INTENT(OUT) argument. It shall\n      not be a coarray or a coindexed object. FIRST,LAST ‚Äê an allocatable array of type integer and rank\n      one. It is an INTENT(OUT) argument. It shall not be a coarray or a\n      coindexed object. DESCRIPTION TOKENIZE(3) parses a string into tokens. There are two forms of the\n   subroutine TOKENIZE(3). The token form returns an array with one token per element,\n      all of the same length as the longest token. The array bounds form returns two integer arrays. One\n      contains the beginning position of the tokens and the other the end\n      positions. Since the token form pads all the tokens to the same length the\n   original number of trailing spaces of each token accept for the\n   longest is lost. The array bounds form retains information regarding the exact token\n   length even when padded by spaces. OPTIONS ‚Ä¢  STRING : The string to parse into tokens. SET :  Each character in SET is a token delimiter. A\n      sequence of zero or more characters in STRING delimited by any token\n      delimiter, or the beginning or end of STRING, comprise a token. Thus,\n      two consecutive token delimiters in STRING, or a token delimiter\n      in the first or last character of STRING, indicate a token with\n      zero length. TOKENS : It shall be an allocatable array of rank one with\n      deferred length. It is allocated with the lower bound equal to one\n      and the upper bound equal to the number of tokens in STRING, and\n      with character length equal to the length of the longest token. The tokens in STRING are assigned in the order found, as if by\n  intrinsic assignment, to the elements of TOKENS, in array element\n  order. FIRST : shall be an allocatable array of type integer and rank one.\n      It is an INTENT(OUT) argument. It shall not be a coarray or\n      a coindexed object. It is allocated with the lower bound equal to one and the upper\n  bound equal to the number of tokens in STRING. Each element is\n  assigned, in array element order, the starting position of each\n  token in STRING, in the order found. If a token has zero length, the starting position is equal to\n  one if the token is at the beginning of STRING, and one greater\n  than the position of the preceding delimiter otherwise. LAST : It is allocated with the lower bound equal to one and the\n      upper bound equal to the number of tokens in STRING. Each\n      element is assigned, in array element order, the ending position\n      of each token in STRING, in the order found. If a token has zero length, the ending position is one less than\n  the starting position. EXAMPLES Sample of uses program demo_tokenize use M_unicode , only : tokenize , ut => unicode_type , ch => character use M_unicode , only : assignment (=), operator ( /= ) implicit none ! ! some useful formats character ( len = * ), parameter :: & & brackets = ' ( * ( \"[\" , g0 , \"]\" :, \",\" )) ' , & & a_commas = ' ( a , * ( g0 :, \",\" )) ' , & & gen = ' ( * ( g0 )) ' ! ! Execution of TOKEN form ( return array of tokens ) ! block type ( ut ) :: string type ( ut ), allocatable :: tokens (:) integer :: i string = ' first , second , third ' call tokenize ( string , set = ' ;, ' , tokens = tokens ) write ( * , brackets ) ch ( tokens ) string = ' first , second , third ' call tokenize ( string , set = ' , ' , tokens = tokens ) write ( * , brackets )( tokens ( i ) % character (), i = 1 , size ( tokens )) ! remove blank tokens tokens = pack ( tokens , tokens /= '' ) write ( * , brackets ) ch ( tokens ) ! endblock ! ! Execution of BOUNDS form ( return position of tokens ) ! block type ( ut ) :: string character ( len = * ), parameter :: set = \" ,\" integer , allocatable :: first (:), last (:) write ( * , gen ) repeat ( ' 1234567890 ' , 6 ) string = ' first , second ,, fourth ' write ( * , gen ) ch ( string ) call tokenize ( string , set , first , last ) write ( * , a_commas ) ' FIRST = ' , first write ( * , a_commas ) ' LAST = ' , last write ( * , a_commas ) ' HAS LENGTH = ' , last - first . gt .0 endblock ! end program demo_tokenize Results: > [ first ] , [ second ] , [ third ] > [] , [ first ] , [] , [] , [ second ] , [] , [ third ] , [] , [] , [] , [] , [] > [ first ] , [ second ] , [ third ] > 123456789012345678901234567890123456789012345678901234567890 > first , second ,, fourth > FIRST = 1 , 7 , 14 , 15 > LAST = 5 , 12 , 13 , 20 > HAS LENGTH = T , T , F , T SEE ALSO SPLIT(3) ‚Äê return tokens from a string, one at a time INDEX(3) ‚Äê Position of a substring within a string SCAN(3) ‚Äê Scan a string for the presence of a set of characters VERIFY(3) ‚Äê Position of a character in a string of characters\n                  that does not appear in a given set of characters. AUTHOR Milan Curcic , \"milancurcic@hey.com\" John S . Urban -- UTF-8 version LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set type( unicode_type ), intent(out), allocatable :: tokens (:) type( unicode_type ), intent(out), optional, allocatable :: separator (:) private impure subroutine split_tokens_uauu(string, set, tokens, separator) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string character(len=*), intent(in) :: set type( unicode_type ), intent(out), allocatable :: tokens (:) type( unicode_type ), intent(out), optional, allocatable :: separator (:)","tags":"","url":"interface/split.html"},{"title":"tokenize ‚Äì M_unicode","text":"public interface tokenize Module Procedures private impure subroutine split_first_last(string, set, first, last) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set integer, intent(out), allocatable :: first (:) integer, intent(out), allocatable :: last (:) private impure subroutine split_first_last_uaii(string, set, first, last) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string character(len=*), intent(in) :: set integer, intent(out), allocatable :: first (:) integer, intent(out), optional, allocatable :: last (:) private impure subroutine split_pos(string, set, pos, back) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set integer, intent(inout) :: pos logical, intent(in), optional :: back private impure subroutine split_pos_uail(string, set, pos, back) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string character(len=*), intent(in) :: set integer, intent(inout) :: pos logical, intent(in), optional :: back private impure subroutine split_tokens(string, set, tokens, separator) NAME SPLIT(3f) - [M_unicode:PARSE] parse a string into tokens, one at a time.\n   (LICENSE:MIT) SYNOPSIS call split (string, set, pos [, back]) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set integer , intent ( inout ) :: pos logical , intent ( in ), optional :: back CHARACTERISTICS STRING is a scalar character variable SET is a scalar string variable DESCRIPTION Find the extent of consecutive tokens in a string. given a string and\n   a position to start looking for a token return the position of the\n   end of the token. a set of separator characters may be specified as\n   well as the direction of parsing. typically consecutive calls are used to parse a string into a set of\n   tokens by stepping through the start and end positions of each token. OPTIONS STRING : the string to search for tokens in. SET : Each character in set is a token delimiter. a sequence of\n     zero or more characters in string delimited by any token delimiter,\n     or the beginning or end of string, comprise a token. thus, two\n     consecutive token delimiters in STRING, or a token delimiter in the\n     first or last character of STRING, indicate a token with zero length. POS : on input, the position from which to start looking for the next\n     separator from. This is typically the first character or the last\n     returned value of POS if searching from left to right (ie. back is\n     absent or .true.) or the last character or the last returned value\n     of POS when searching from right to left (ie. when back is .FALSE.). If BACK is present with the value .TRUE., the value of pos shall be\n in the range 0 < POS <= len(STRING)+1; otherwise it shall be in the\n range 0 <= POS <= len(STRING). So POS on input is typically an end of the string or the position\n of a separator, probably from a previous call to split but POS on\n input can be any position in the range 1 <= POS <= len(STRING). if\n POS points to a non-separator character in the string the call is\n still valid but it will start searching from the specified position\n and that will result (somewhat obviously) in the string from POS on\n input to the returned POS being a partial token. BACK : If BACK is absent or is present with the value .FALSE., POS is\n     assigned the position of the leftmost token delimiter in string\n     whose position is greater than POS, or if there is no such character,\n     it is assigned a value one greater than the length of string. this\n     identifies a token with starting position one greater than the value\n     of POS on invocation, and ending position one less than the value\n     of POS on return. If BACK is present with the value .TRUE., POS is assigned the\n position of the rightmost token delimiter in string whose position\n is less than POS, or if there is no such character, it is assigned\n the value zero. This identifies a token with ending position one\n less than the value of POS on invocation, and starting position one\n greater than the value of POS  on return. EXAMPLE sample program: program demo_split use iso_fortran_env , only : stdout => output_unit use M_unicode , only : unicode_type , assignment (=) use M_unicode , only : split , len , character use M_unicode , only : ut => unicode_type implicit none character ( len = * ), parameter :: g = ' ( * ( g0 , 1 x )) ' type ( ut ) :: proverb type ( ut ) :: delims type ( ut ), allocatable :: array (:) integer :: first integer :: last integer :: pos integer :: i ! delims = ' = | ; ' ! proverb = \"M√°s vale p√°jaro en mano, que ciento volando.\" call printwords ( proverb ) ! there really are not spaces between these glyphs array =[ & ut ( \"‰∏ÉËª¢„Å≥ÂÖ´Ëµ∑„Åç„ÄÇ\" ), & ut ( \"Ëª¢„Çì„Åß„ÇÇ„Åæ„ÅüÁ´ã„Å°‰∏ä„Åå„Çã„ÄÇ\" ), & ut ( \"„Åè„Åò„Åë„Åö„Å´Ââç„ÇíÂêë„ÅÑ„Å¶Ê≠©„ÅÑ„Å¶„ÅÑ„Åì„ÅÜ„ÄÇ\" )] call printwords ( array ) ! write ( stdout , g ) ' OOP ' array = proverb % split ( ut ( ' ' )) write ( stdout , ' ( * (: \"[\" , a , \"]\" )) ' )( character ( array ( i )), i = 1 , size ( array )) contains impure elemental subroutine printwords ( line ) type ( ut ), intent ( in ) :: line pos = 0 write ( stdout , g ) line % character (), len ( line ) do while ( pos < len ( line )) first = pos + 1 call split ( line , delims , pos ) last = pos - 1 print g , line % character ( first , last ), first , last , pos end do end subroutine printwords end program demo_split Results: > Project is up to date > M√°s vale p√°jaro en mano , que ciento volando . 44 > M√°s 1 3 4 > vale 5 8 9 > p√°jaro 10 15 16 > en 17 18 19 > mano , 20 24 25 > que 26 28 29 > ciento 30 35 36 > volando . 37 44 45 > ‰∏ÉËª¢„Å≥ÂÖ´Ëµ∑„Åç „ÄÇ 7 > ‰∏ÉËª¢„Å≥ÂÖ´Ëµ∑„Åç „ÄÇ 1 7 8 > Ëª¢„Çì„Åß„ÇÇ„Åæ„ÅüÁ´ã„Å°‰∏ä„Åå„Çã „ÄÇ 12 > Ëª¢„Çì„Åß„ÇÇ„Åæ„ÅüÁ´ã„Å°‰∏ä„Åå„Çã „ÄÇ 1 12 13 > „Åè„Åò„Åë„Åö„Å´Ââç„ÇíÂêë„ÅÑ„Å¶Ê≠©„ÅÑ„Å¶„ÅÑ„Åì„ÅÜ „ÄÇ 17 > „Åè„Åò„Åë„Åö„Å´Ââç„ÇíÂêë„ÅÑ„Å¶Ê≠©„ÅÑ„Å¶„ÅÑ„Åì„ÅÜ „ÄÇ 1 17 18 > OOP > [ M√°s ][ vale ][ p√°jaro ][ en ][ mano, ][ que ][ ciento ][ volando. ] SEE ALSO tokenize(3) - parse a string into tokens index(3) - position of a substring within a string scan(3) - scan a string for the presence of a set of characters verify(3)  -  position  of a character in a string of characters that does\n     not appear in a given set of characters. AUTHOR Milan Curcic , \"milancurcic@hey.com\" John S . Urban -- UTF-8 version LICENSE MIT NAME TOKENIZE(3f) - [M_unicode:PARSE] Parse a string into tokens.\n   (LICENSE:MIT) SYNOPSIS TOKEN form (returns array of strings) subroutine tokenize ( string , set , tokens [, separator ]) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set type ( unicode_type ), allocatable , intent ( out ) :: tokens (:) type ( unicode_type ), allocatable , intent ( out ), optional :: separator (:) ARRAY BOUNDS form (returns arrays defining token positions) subroutine tokenize ( string , set , first , last ) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set integer , allocatable , intent ( out ) :: first (:) integer , allocatable , intent ( out ) :: last (:) CHARACTERISTICS STRING ‚Äê a scalar of type string. It is an INTENT(IN)\n      argument. SET ‚Äê a scalar of type string with the same kind type\n      parameter as STRING. It is an INTENT(IN) argument. SEPARATOR ‚Äê (optional) shall be of type string. It is an\n      INTENT(OUT)argument. It shall not be a coarray or a coindexed object. TOKENS ‚Äê of type string. It is an INTENT(OUT) argument. It shall\n      not be a coarray or a coindexed object. FIRST,LAST ‚Äê an allocatable array of type integer and rank\n      one. It is an INTENT(OUT) argument. It shall not be a coarray or a\n      coindexed object. DESCRIPTION TOKENIZE(3) parses a string into tokens. There are two forms of the\n   subroutine TOKENIZE(3). The token form returns an array with one token per element,\n      all of the same length as the longest token. The array bounds form returns two integer arrays. One\n      contains the beginning position of the tokens and the other the end\n      positions. Since the token form pads all the tokens to the same length the\n   original number of trailing spaces of each token accept for the\n   longest is lost. The array bounds form retains information regarding the exact token\n   length even when padded by spaces. OPTIONS ‚Ä¢  STRING : The string to parse into tokens. SET :  Each character in SET is a token delimiter. A\n      sequence of zero or more characters in STRING delimited by any token\n      delimiter, or the beginning or end of STRING, comprise a token. Thus,\n      two consecutive token delimiters in STRING, or a token delimiter\n      in the first or last character of STRING, indicate a token with\n      zero length. TOKENS : It shall be an allocatable array of rank one with\n      deferred length. It is allocated with the lower bound equal to one\n      and the upper bound equal to the number of tokens in STRING, and\n      with character length equal to the length of the longest token. The tokens in STRING are assigned in the order found, as if by\n  intrinsic assignment, to the elements of TOKENS, in array element\n  order. FIRST : shall be an allocatable array of type integer and rank one.\n      It is an INTENT(OUT) argument. It shall not be a coarray or\n      a coindexed object. It is allocated with the lower bound equal to one and the upper\n  bound equal to the number of tokens in STRING. Each element is\n  assigned, in array element order, the starting position of each\n  token in STRING, in the order found. If a token has zero length, the starting position is equal to\n  one if the token is at the beginning of STRING, and one greater\n  than the position of the preceding delimiter otherwise. LAST : It is allocated with the lower bound equal to one and the\n      upper bound equal to the number of tokens in STRING. Each\n      element is assigned, in array element order, the ending position\n      of each token in STRING, in the order found. If a token has zero length, the ending position is one less than\n  the starting position. EXAMPLES Sample of uses program demo_tokenize use M_unicode , only : tokenize , ut => unicode_type , ch => character use M_unicode , only : assignment (=), operator ( /= ) implicit none ! ! some useful formats character ( len = * ), parameter :: & & brackets = ' ( * ( \"[\" , g0 , \"]\" :, \",\" )) ' , & & a_commas = ' ( a , * ( g0 :, \",\" )) ' , & & gen = ' ( * ( g0 )) ' ! ! Execution of TOKEN form ( return array of tokens ) ! block type ( ut ) :: string type ( ut ), allocatable :: tokens (:) integer :: i string = ' first , second , third ' call tokenize ( string , set = ' ;, ' , tokens = tokens ) write ( * , brackets ) ch ( tokens ) string = ' first , second , third ' call tokenize ( string , set = ' , ' , tokens = tokens ) write ( * , brackets )( tokens ( i ) % character (), i = 1 , size ( tokens )) ! remove blank tokens tokens = pack ( tokens , tokens /= '' ) write ( * , brackets ) ch ( tokens ) ! endblock ! ! Execution of BOUNDS form ( return position of tokens ) ! block type ( ut ) :: string character ( len = * ), parameter :: set = \" ,\" integer , allocatable :: first (:), last (:) write ( * , gen ) repeat ( ' 1234567890 ' , 6 ) string = ' first , second ,, fourth ' write ( * , gen ) ch ( string ) call tokenize ( string , set , first , last ) write ( * , a_commas ) ' FIRST = ' , first write ( * , a_commas ) ' LAST = ' , last write ( * , a_commas ) ' HAS LENGTH = ' , last - first . gt .0 endblock ! end program demo_tokenize Results: > [ first ] , [ second ] , [ third ] > [] , [ first ] , [] , [] , [ second ] , [] , [ third ] , [] , [] , [] , [] , [] > [ first ] , [ second ] , [ third ] > 123456789012345678901234567890123456789012345678901234567890 > first , second ,, fourth > FIRST = 1 , 7 , 14 , 15 > LAST = 5 , 12 , 13 , 20 > HAS LENGTH = T , T , F , T SEE ALSO SPLIT(3) ‚Äê return tokens from a string, one at a time INDEX(3) ‚Äê Position of a substring within a string SCAN(3) ‚Äê Scan a string for the presence of a set of characters VERIFY(3) ‚Äê Position of a character in a string of characters\n                  that does not appear in a given set of characters. AUTHOR Milan Curcic , \"milancurcic@hey.com\" John S . Urban -- UTF-8 version LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set type( unicode_type ), intent(out), allocatable :: tokens (:) type( unicode_type ), intent(out), optional, allocatable :: separator (:) private impure subroutine split_tokens_uauu(string, set, tokens, separator) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string character(len=*), intent(in) :: set type( unicode_type ), intent(out), allocatable :: tokens (:) type( unicode_type ), intent(out), optional, allocatable :: separator (:)","tags":"","url":"interface/tokenize.html"},{"title":"transliterate ‚Äì M_unicode","text":"public interface transliterate Module Procedures private impure function transliterate_uuu(instr, old_set, new_set) result(outstr) NAME transliterate(3f) - [M_unicode:EDITING] replace characters from old\n                     set with new set\n (LICENSE:PD) SYNOPSIS impure function transliterate ( instr , old_set , new_set ) result ( outstr ) type ( unicode_type ), intent ( in ) :: instr type ( unicode_type ), intent ( in ) :: old_set type ( unicode_type ), intent ( in ) :: new_set type ( unicode_type ) :: outstr CHARACTERISTICS Although a conversion might occur on each call, the input values\nmay be CHARACTER as well as TYPE(UNICODE_TYPE). DESCRIPTION Translate or delete characters from an input string. OPTIONS instr    input string to change\n   old_set  list of glyphs to change in INSTR if found Each glyph in the input string that matches a glyph\n        in the old set is replaced. new_set  list of glyphs to replace glyphs in OLD_SET with. If NEW_SET is the empty set glyphs in INSTR that\n        match any in OLD_SET are deleted.\n\n        If NEW_SET is shorter than OLD_SET the last glyph\n        in NEW_SET is used to replace the remaining glyphs\n        in NEW_SET. RETURNS outstr  INSTR with substitutions applied EXAMPLES Sample Program: program demo_transliterate use M_unicode , only : transliterate , ut => unicode_type use M_unicode , only : write ( formatted ), ch => character use M_unicode , only : assignment (=) implicit none character ( len = * ), parameter :: u = ' ( DT ) ' type ( ut ) :: STRING , UPPER , LOWER type ( ut ) :: MIDDLE_DOT STRING = ' aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ ' LOWER = ' abcdefghijklmnopqrstuvwxyz ' UPPER = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ ' call callit () print u print u , ut ( ' Greek ' ) ! ! | Œë Œ± | Œí Œ≤ | Œì Œ≥ | Œî Œ¥ | Œï Œµ | Œñ Œ∂ | ! | Œó Œ∑ | Œò Œ∏ | Œô Œπ | Œö Œ∫ | Œõ Œª | Œú Œº | ! | Œù ŒΩ | Œû Œæ | Œü Œø | Œ† œÄ | Œ° œÅ | Œ£ œÉ œÇ | ! | Œ§ œÑ | Œ• œÖ | Œ¶ œÜ | Œß œá | Œ® œà | Œ© œâ | ! STRING = ' ŒëŒ±ŒíŒ≤ŒìŒ≥ŒîŒ¥ŒïŒµŒñŒ∂ŒóŒ∑ŒòŒ∏ŒôŒπŒöŒ∫ŒõŒªŒúŒºŒùŒΩŒûŒæŒüŒøŒ†œÄŒ°œÅŒ£œÉœÇŒ§œÑŒ•œÖŒ¶œÜŒßœáŒ®œàŒ©œâ ' ! ignoring œÇ for simplicity UPPER = ' ŒëŒíŒìŒîŒïŒñŒóŒòŒôŒöŒõŒúŒùŒûŒüŒ†Œ°Œ£Œ§Œ•Œ¶ŒßŒ®Œ© ' LOWER = ' Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÉœÑœÖœÜœáœàœâ ' call callit () ! OOP print u print u , ut ( ' OOP ! ' ) print u , STRING % TRANSLITERATE ( UPPER , '_' ) ! U + 00 B7 Middle Dot Unicode Character print u , STRING % TRANSLITERATE ( LOWER , '¬∑' ) ! ASCII bytes print u , STRING % TRANSLITERATE ( LOWER , ut ( '¬∑' )) ! cast MIDDLE_DOT = int ( z ' 00 B7 ' ) print u , STRING % TRANSLITERATE ( LOWER , MIDDLE_DOT ) ! hexadecimal contains subroutine callit () print u , STRING ! convert - 7 string to uppercase : print u , TRANSLITERATE ( STRING , LOWER , UPPER ) ! change all miniscule letters to a colon ( \":\" ): print u , TRANSLITERATE ( STRING , LOWER , ':' ) ! delete all miniscule letters print u , TRANSLITERATE ( STRING , LOWER , '' ) end subroutine callit end program demo_transliterate Results: > aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ > AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYYZZ > :A:B:C:D:E:F:G:H:I:J:K:L:M:N:O:P:Q:R:S:T:U:V:W:X:Y:Z > ABCDEFGHIJKLMNOPQRSTUVWXYZ > > Greek > ŒëŒ±ŒíŒ≤ŒìŒ≥ŒîŒ¥ŒïŒµŒñŒ∂ŒóŒ∑ŒòŒ∏ŒôŒπŒöŒ∫ŒõŒªŒúŒºŒùŒΩŒûŒæŒüŒøŒ†œÄŒ°œÅŒ£œÉœÇŒ§œÑŒ•œÖŒ¶œÜŒßœáŒ®œàŒ©œâ > ŒëŒëŒíŒíŒìŒìŒîŒîŒïŒïŒñŒñŒóŒóŒòŒòŒôŒôŒöŒöŒõŒõŒúŒúŒùŒùŒûŒûŒüŒüŒ†Œ†Œ°Œ°Œ£Œ£œÇŒ§Œ§Œ•Œ•Œ¶Œ¶ŒßŒßŒ®Œ®Œ©Œ© > Œë:Œí:Œì:Œî:Œï:Œñ:Œó:Œò:Œô:Œö:Œõ:Œú:Œù:Œû:Œü:Œ†:Œ°:Œ£:œÇŒ§:Œ•:Œ¶:Œß:Œ®:Œ©: > ŒëŒíŒìŒîŒïŒñŒóŒòŒôŒöŒõŒúŒùŒûŒüŒ†Œ°Œ£œÇŒ§Œ•Œ¶ŒßŒ®Œ© > > OOP! > _Œ±_Œ≤_Œ≥_Œ¥_Œµ_Œ∂_Œ∑_Œ∏_Œπ_Œ∫_Œª_Œº_ŒΩ_Œæ_Œø_œÄ_œÅ_œÉœÇ_œÑ_œÖ_œÜ_œá_œà_œâ > Œë¬∑Œí¬∑Œì¬∑Œî¬∑Œï¬∑Œñ¬∑Œó¬∑Œò¬∑Œô¬∑Œö¬∑Œõ¬∑Œú¬∑Œù¬∑Œû¬∑Œü¬∑Œ†¬∑Œ°¬∑Œ£¬∑œÇŒ§¬∑Œ•¬∑Œ¶¬∑Œß¬∑Œ®¬∑Œ©¬∑ > Œë¬∑Œí¬∑Œì¬∑Œî¬∑Œï¬∑Œñ¬∑Œó¬∑Œò¬∑Œô¬∑Œö¬∑Œõ¬∑Œú¬∑Œù¬∑Œû¬∑Œü¬∑Œ†¬∑Œ°¬∑Œ£¬∑œÇŒ§¬∑Œ•¬∑Œ¶¬∑Œß¬∑Œ®¬∑Œ©¬∑ > Œë¬∑Œí¬∑Œì¬∑Œî¬∑Œï¬∑Œñ¬∑Œó¬∑Œò¬∑Œô¬∑Œö¬∑Œõ¬∑Œú¬∑Œù¬∑Œû¬∑Œü¬∑Œ†¬∑Œ°¬∑Œ£¬∑œÇŒ§¬∑Œ•¬∑Œ¶¬∑Œß¬∑Œ®¬∑Œ©¬∑ AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: instr type( unicode_type ), intent(in) :: old_set type( unicode_type ), intent(in) :: new_set Return Value type( unicode_type ) private  function transliterate_uua(instr, old_set, new_set) result(outstr) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: instr type( unicode_type ), intent(in) :: old_set character(len=*), intent(in) :: new_set Return Value type( unicode_type ) private  function transliterate_uaa(instr, old_set, new_set) result(outstr) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: instr character(len=*), intent(in) :: old_set character(len=*), intent(in) :: new_set Return Value type( unicode_type ) private  function transliterate_uau(instr, old_set, new_set) result(outstr) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: instr character(len=*), intent(in) :: old_set type( unicode_type ), intent(in) :: new_set Return Value type( unicode_type ) private  function transliterate_aaa(instr, old_set, new_set) result(outstr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: instr character(len=*), intent(in) :: old_set character(len=*), intent(in) :: new_set Return Value type( unicode_type ) private  function transliterate_aua(instr, old_set, new_set) result(outstr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: instr type( unicode_type ), intent(in) :: old_set character(len=*), intent(in) :: new_set Return Value type( unicode_type ) private  function transliterate_aau(instr, old_set, new_set) result(outstr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: instr character(len=*), intent(in) :: old_set type( unicode_type ), intent(in) :: new_set Return Value type( unicode_type ) private  function transliterate_auu(instr, old_set, new_set) result(outstr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: instr type( unicode_type ), intent(in) :: old_set type( unicode_type ), intent(in) :: new_set Return Value type( unicode_type )","tags":"","url":"interface/transliterate.html"},{"title":"trim ‚Äì M_unicode","text":"public interface trim Module Procedures private elemental function trim_str(string) result(trimmed_str) NAME TRIM(3f) - [M_unicode:WHITESPACE] remove trailing blank characters from\n              a string\n              (LICENSE:MIT) SYNOPSIS result = trim(string) type ( unicode_type ) function trim ( string ) type ( unicode_type ), intent ( in ) :: string CHARACTERISTICS the result is a string. DESCRIPTION trim(3) removes trailing blank characters from a string. OPTIONS string : a string to trim RESULT the result is the same as string except trailing blanks are removed. if string is composed entirely of blanks or has zero length, the\n   result has zero length. EXAMPLES sample program: program demo_trim use M_unicode , only : ut => unicode_type , assignment (=) use M_unicode , only : trim , len use M_unicode , only : write ( formatted ) implicit none type ( ut ) :: str type ( ut ), allocatable :: strs (:) character ( len = * ), parameter :: brackets = ' ( * ( \"[\" , DT , \"]\" :, 1 x ) ) ' integer :: i ! str = ' trailing ' print brackets , str , trim ( str ) ! trims it ! str = ' leading ' print brackets , str , trim ( str ) ! no effect ! str = ' ' print brackets , str , trim ( str ) ! becomes zero length print * , len ( str ), len ( trim ( ' ' )) ! strs =[ ut ( \"Z \" ), ut ( \" a b c\" ), ut ( \"ABC   \" ), ut ( \"\" )] ! write ( * , * ) ' untrimmed : ' print brackets , ( strs ( i ), i = 1 , size ( strs )) print brackets , strs ! write ( * , * ) ' trimmed : ' ! everything prints trimmed print brackets , ( trim ( strs ( i )), i = 1 , size ( strs )) print brackets , trim ( strs ) ! end program demo_trim results: > [ trailing ] [ trailing ] > [ leading ] [ leading ] > [ ] [] > 12 0 > untrimmed : > [ Z ] [ a b c ] [ ABC ] [] > [ Z ] [ a b c ] [ ABC ] [] > trimmed : > [ Z ] [ a b c ] [ ABC ] [] > [ Z ] [ a b c ] [ ABC ] [] SEE ALSO Functions that perform operations on character strings, return\n   lengths of arguments, and search for certain arguments: elemental: adjustl(3), adjustr(3), index(3), scan(3), verify(3) nonelemental: len_trim(3), len(3), repeat(3), trim(3) AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value type( unicode_type )","tags":"","url":"interface/trim.html"},{"title":"unicode_type ‚Äì M_unicode","text":"public interface unicode_type Functions private module function new_codes(codes) result(new) Arguments Type Intent Optional Attributes Name integer, intent(in) :: codes (:) Return Value type( unicode_type ) private elemental module function new_str(string) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Return Value type( unicode_type ) private module function new_strs(strings) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: strings (:) Return Value type( unicode_type ), (size(strings))","tags":"","url":"interface/unicode_type.html"},{"title":"utf8_to_codepoints ‚Äì M_unicode","text":"public interface utf8_to_codepoints Module Procedures private pure subroutine utf8_to_codepoints_str(utf8, codepoints, nerr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: utf8 integer, intent(out), allocatable :: codepoints (:) integer, intent(out) :: nerr private pure subroutine utf8_to_codepoints_chars(utf8, codepoints, nerr) NAME UTF8_TO_CODEPOINTS(3f) - [M_unicode:CONVERSION] Convert UTF-8-encoded\n   data to Unicode codepoints\n   (LICENSE:MIT) SYNOPSIS pure subroutine utf8_to_codepoints(utf8,codepoints,nerr)\n\n character(len=1),intent(in)     :: utf8(:)\n !  or\n character(len=*),intent(in)     :: utf8\n !\n integer,allocatable,intent(out) :: codepoints(:)\n integer,intent(out)             :: nerr CHARACTERISTICS UTF8 is a scalar CHARACTER variable or array of single-byte\n     CHARACTER values the returned values in CODEPOINTS are of default INTEGER kind the error flag NERR is default integer kind DESCRIPTION UTF8_TO_CODEPOINTS(3f) takes either a scalar CHARACTER variable or\n   an array of CHARACTER(LEN=1) bytes which are treated as a stream of\n   bytes representing UTF-8-encoded data and converted to an INTEGER\n   array containing Unicode codepoint values for each glyph. In fact, this routine is also able to decode an ISOLATIN string OPTIONS UTF8 :  Scalar CHARACTER string or single-character array of CHARACTER\n             variables assumed to represent a stream of bytes containing\n             data encoded at UTF-8 text. CODEPOINTS :  An INTEGER array of Unicode codepoint values\n                   representing the glyphs found in STRING NERR :  Zero if no error occurred. If not zero the stream of bytes\n             could not be completely converted to UTF-8 characters. EXAMPLES Sample program program demo_utf8_to_codepoints use m_unicode , only : utf8_to_codepoints implicit none character ( len = * ), parameter :: string = ' Noho me ka hau ‚Äô oli ' !( Be happy ) character ( len = 1 ), allocatable :: bytes (:) character ( len = * ), parameter :: solid = ' ( * ( g0 )) ' character ( len = * ), parameter :: space = ' ( * ( g0 , 1 x )) ' character ( len = * ), parameter :: z = ' ( a , * ( z0 , 1 x )) ' integer , allocatable :: codepoints (:) integer :: nerr integer :: i ! BASIC USAGE : SCALAR CHARACTER VARIABLE write ( * , solid ) ' STRING : ' , string call utf8_to_codepoints ( string , codepoints , nerr ) write ( * , space ) ' CODEPOINTS : ' , codepoints write ( * , z ) ' HEXADECIMAL CODEPOINTS : ' , codepoints ! write ( * , space ) ' How long is this string in glyphs ? ' write ( * , space ) size ( codepoints ) write ( * , space ) ' How long is this string in bytes ? ' write ( * , space ) len ( string ) ! ! BASIC USAGE : ARRAY OF BYTES bytes =[( string ( i : i ), i = 1 , len ( string ))] write ( * , solid ) ' STRING : ' , bytes call utf8_to_codepoints ( bytes , codepoints , nerr ) write ( * , space ) ' CODEPOINTS : ' , codepoints write ( * , z ) ' HEXADECIMAL CODEPOINTS : ' , codepoints ! write ( * , space ) ' How long is this string in glyphs ? ' write ( * , space ) size ( codepoints ) write ( * , space ) ' How long is this string in bytes ? ' write ( * , space ) size ( bytes ) ! end program demo_utf8_to_codepoints Results: > STRING:Noho me ka hau‚Äôoli\n > CODEPOINTS: 78 111 104 111 32 109 101 32 107 97 32 104 97 117 ...\n > 8217 111 108 105\n > 48 4E 6F 68 6F 20 6D 65 20 6B 61 20 68 61 75 2019 6F 6C 69\n > How long is this string in glyphs?\n > 18\n > How long is this string in bytes?\n > 20\n > STRING:Noho me ka hau‚Äôoli\n > CODEPOINTS: 78 111 104 111 32 109 101 32 107 97 32 104 97 117 ...\n > 8217 111 108 105\n > 48 4E 6F 68 6F 20 6D 65 20 6B 61 20 68 61 75 2019 6F 6C 69\n > How long is this string in glyphs?\n > 18\n > How long is this string in bytes?\n > 20 SEE ALSO functions that perform operations on character strings: elemental: adjustl(3), adjustr(3), index(3), scan(3), verify(3) non-elemental: len_trim(3), repeat(3), trim(3), codepoints_to_utf8(3) AUTHOR John S. Urban Francois Jacq - enhancements and Latin support from Francois Jacq, 2025-08 LICENSE MIT Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: utf8 (:) integer, intent(out), allocatable :: codepoints (:) integer, intent(out) :: nerr","tags":"","url":"interface/utf8_to_codepoints.html"},{"title":"verify ‚Äì M_unicode","text":"public interface verify Module Procedures private impure elemental function verify_uu(string, set, back) result(result) NAME VERIFY(3f) - [M_unicode:SEARCH] Position of a character in a string of\n   characters that does not appear in a given set of characters.\n   (LICENSE:MIT) SYNOPSIS result = verify(string, set [,back] [,kind] ) elemental integer function verify ( string , set , back , KIND ) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set or character ( len = * ), intent ( in ) :: set logical , intent ( in ), optional :: back CHARACTERISTICS STRING  must be of type string SET  must be of type string or character. BACK shall be of type logical. A default integer kind is returned. DESCRIPTION VERIFY(3) verifies that all the characters in STRING belong to the set of\n   characters in SET by identifying the position of the first character in the\n   string that is not in the set. This makes it easy to verify strings are all uppercase or lowercase, follow a\n   basic syntax, only contain printable characters, and many of the conditions\n   tested for with the C routines ISALNUM(3c), ISALPHA(3c), ISASCII(3c),\n   ISBLANK(3c), ISCNTRL(3c), ISDIGIT(3c), ISGRAPH(3c), ISLOWER(3c), ISPRINT(3c),\n   ISPUNCT(3c), ISSPACE(3c), ISUPPER(3c), and ISXDIGIT(3c); but for a string as\n   well as an array of strings. OPTIONS STRING : The string to search in for an unmatched character. SET : The set of characters that must be matched. BACK : The direction to look for an unmatched character. The left‚Äêmost\n      unmatched character position isreturned unless BACK is present and\n      .false., which causes the position of the right‚Äêmost unmatched character\n      to be returned instead of the left‚Äêmost unmatched character. RESULT If all characters of STRING are found in SET, the result is zero. If STRING is of zero length a zero (0) is always returned. Otherwise, if an unmatched character is found The position of the first or\n   last (if BACK is .false.) unmatched character in STRING is returned, starting\n   with position one on the left end of the string. EXAMPLES Sample program I: program demo_verify ! general examples use M_unicode , only : assignment (=) use M_unicode , only : ut => unicode_type , ch => character use M_unicode , only : write ( formatted ) use M_unicode , only : operator ( == ) use M_unicode , only : verify , replace use M_unicode , only : operator ( //) implicit none ! some useful character sets character , parameter :: & & int * ( * ) = \"1234567890\" , & & low * ( * ) = \"abcdefghijklmnopqrstuvwxyz\" , & & upp * ( * ) = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" , & & punc * ( * ) = \"!\"\"#$%&'()*+,‚Äê./:;<=>?@['_‚Äò{|}Àú\" , & & blank * ( * ) = \" \" , & & tab = char ( 11 ), & & prnt * ( * ) = int //low//upp//blank//punc ! type ( ut ) :: stru integer :: i print * , \"basics:\" print * , VERIFY ( \"ABBA\" , \"A\" ) ! has the value 2 . print * , VERIFY ( \"ABBA\" , \"A\" , BACK = . TRUE .) ! has the value 3 . print * , VERIFY ( \"ABBA\" , \"AB\" ) ! has the value 0 . ! print * , \"find first non‚Äêuppercase letter\" ! will produce the location of \"d\" , because there is no match in UPP write ( * , * ) \"something unmatched\" , verify ( ut ( \"ABCdEFG\" ), upp ) ! print * , \"if everything is matched return zero\" ! will produce 0 as all letters have a match write ( * , * ) & & \"everything matched\" , verify ( ut ( \"ffoorrttrraann\" ), \"nartrof\" ) ! print * , \"easily categorize strings as uppercase, lowercase, ...\" ! C - like functionality but does entire strings not just characters write ( * , * ) \"isdigit 123?\" , verify ( ut ( \"123\" ), int ) == 0 write ( * , * ) \"islower abc?\" , verify ( ut ( \"abc\" ), low ) == 0 write ( * , * ) \"isalpha aBc?\" , verify ( ut ( \"aBc\" ), low //upp) == 0 write ( * , * ) \"isblank aBc dEf?\" , verify ( ut ( \"aBc dEf\" ), blank //tab ) /= 0 ! check if all printable characters stru = \"aB;cde,fgHI!Jklmno PQRSTU vwxyz\" write ( * , * ) \"isprint?\" , verify ( stru , prnt ) == 0 ! ! this now has a nonprintable tab character in it stru = replace ( stru , 10 , 10 , ut ( char ( 11 ))) write ( * , * ) \"isprint?\" , verify ( stru , prnt ) == 0 ! print * , \"VERIFY(3) is very powerful using expressions as masks\" ! verify ( 3 ) is often used in a logical expression stru = \" This is NOT all UPPERCASE \" write ( * , * ) \"all uppercase/spaces?\" , verify ( stru , blank //upp) == 0 stru = \" This IS all uppercase \" write ( * , * ) \"stru=[\" //stru//\"]\" write ( * , * ) \"all uppercase/spaces?\" , verify ( stru , blank //upp) == 0 ! ! set and show complex stru to be tested stru = \"  Check this out. Let me know  \" ! show the stru being examined write ( * , * ) \"stru=[\" //stru//\"]\" write ( * , * ) \"        \" //repeat(int,4) ! number line ! ! function returns a position just not a logical like C print * , \"returning a position not just a logical is useful\" ! which can be very useful for parsing strings write ( * , * ) \"first non‚Äêblank character\" , verify ( stru , blank ) write ( * , * ) \"last non‚Äêblank character\" , verify ( stru , blank , back =. true .) write ( * , * ) \"first non‚Äêletter non‚Äêblank\" , verify ( stru , low //upp//blank) ! ! VERIFY ( 3 ) is elemental ( can check an array of strings in one call ) print * , \"elemental\" ! are strings all letters ( or blanks )? write ( * , * ) \"array of strings\" , verify ( & ! strings must all be same length , so force to length 10 & [ character ( len = 10 ) :: \"YES\" , \"ok\" , \"000\" , \"good one\" , \"Nope!\" ], & & low //upp//blank) == 0 ! ! rarer , but the set can be an array , not just the strings to test ! you could do ISPRINT () this ( harder ) way :> write ( * , * ) \"isprint?\" , & & . not . all ( verify ( ut ( \"aBc\" ), [( char ( i ), i = 32 , 126 )]) == 1 ) ! instead of this way write ( * , * ) \"isprint?\" , verify ( ut ( \"aBc\" ), prnt ) == 0 ! end program demo_verify Results: > basics : > 2 > 3 > 0 > find first non ‚Äê uppercase letter > something unmatched 4 > if everything is matched return zero > everything matched 0 > easily categorize strings as uppercase , lowercase , ... > isdigit 123 ? T > islower abc ? T > isalpha aBc ? T > isblank aBc dEf ? T > isprint ? T > isprint ? F > VERIFY ( 3 ) is very powerful using expressions as masks > all uppercase / spaces ? F > string = [ This IS all uppercase ] > all uppercase / spaces ? F > string = [ Check this out . Let me know ] > 1234567890123456789012345678901234567890 > returning a position not just a logical is useful > first non ‚Äê blank character 3 > last non ‚Äê blank character 29 > first non ‚Äê letter non ‚Äê blank 17 > elemental > array of strings T T F T F > isprint ? T > isprint ? T Sample program II: Determine if strings are valid integer representations program fortran_ints use M_unicode , only : ut => unicode_type , assignment (=) use M_unicode , only : adjustr , verify , trim , len use M_unicode , only : write ( formatted ) use M_unicode , only : operator (. cat .) use M_unicode , only : operator ( == ) implicit none integer :: i character ( len = * ), parameter :: asciiints ( * )=[ character ( len = 10 ) :: & \"+1 \" , & \"3044848 \" , & \"30.40 \" , & \"September \" , & \"1 2 3\" , & \"  -3000 \" , & \" \" ] type ( ut ), allocatable :: ints (:) if ( allocated ( ints )) deallocate ( ints ) allocate ( ints ( size ( asciiints ))) ! gfortran bug ints = asciiints ints = trim ( ints ) ! show if strings pass or fail the test done by isint ( 3 ) write ( * , \"('is integer?')\" ) do i = 1 , size ( ints ) write ( * , ' ( \"|\" , DT , T14 , \"|\" , l1 , \"|\" ) ' ) ints ( i ), isint ( ints ( i )) enddo ! elemental write ( * , \"(*(g0,1x))\" ) isint ( ints ) contains impure elemental function isint ( line ) result ( lout ) use M_unicode , only : adjustl , verify , trim ! ! determine if string is a valid integer representation ! ignoring trailing spaces and leading spaces ! character ( len = * ), parameter :: digits = \"0123456789\" type ( ut ), intent ( in ) :: line type ( ut ) :: name logical :: lout lout =. false . ! make sure at least two characters long to simplify tests name = adjustl ( line ). cat . ' ' ! blank string if ( name == '' ) return ! allow one leading sign if ( verify ( name % sub ( 1 , 1 ), ut ( ' + ‚Äê - ' )) == 0 ) name = name % sub ( 2 , len ( name )) ! was just a sign if ( name == '' ) return lout = verify ( trim ( name ), digits ) == 0 end function isint end program fortran_ints Results: > is integer?\n > |+1          |T|\n > |3044848     |T|\n > |30.40       |F|\n > |September   |F|\n > |1 2 3       |F|\n > |  ‚Äê3000     |T|\n > |            |F|\n > T T F F F T F Sample program III: Determine if strings represent valid Fortran symbol names program fortran_symbol_name use M_unicode , only : ut => unicode_type , trim , verify , len use M_unicode , only : ch => character use M_unicode , only : write ( formatted ) implicit none integer :: i type ( ut ), allocatable :: symbols (:) symbols =[ & ut ( ' A_ ' ), ut ( ' 10 ' ), ut ( ' a10 ' ), ut ( ' September ' ), ut ( ' A B ' ), & ut ( ' _A ' ), ut ( ' ' )] do i = 1 , size ( symbols ) write ( * , ' ( 1 x , DT , T11 , \"|\" , l2 ) ' ) symbols ( i ), fortran_name ( symbols ( i )) enddo contains impure elemental function fortran_name ( line ) result ( lout ) ! ! determine if a string is a valid Fortran name ! ignoring trailing spaces ( but not leading spaces ) ! character ( len = * ), parameter :: int = \"0123456789\" character ( len = * ), parameter :: lower = \"abcdefghijklmnopqrstuvwxyz\" character ( len = * ), parameter :: upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" character ( len = * ), parameter :: allowed = upper //lower//int//\"_\" type ( ut ), intent ( in ) :: line type ( ut ) :: name logical :: lout name = trim ( line ) if ( len ( name ). ne .0 ) then ! first character is alphameric lout = verify ( name % sub ( 1 , 1 ), lower //upper) == 0  & ! other characters are allowed in a symbol name & . and . verify ( name , allowed ) == 0 & ! allowable length & . and . len ( name ) <= 63 else lout = . false . endif end function fortran_name end program fortran_symbol_name Results: > A_       | T > 10       | F > a10      | T > September| T > A B      | F > _A       | F > | F Sample program IV: check if string is of form NN‚ÄêHHHHH program form ! ! check if string is of form NN ‚Äê HHHHH ! use iso_fortran_env , only : stdout => output_unit use M_unicode , only : verify , unicode_type , assignment (=) use M_unicode , only : ut => unicode_type implicit none character ( len = * ), parameter :: g = ' ( * ( g0 , 1 x )) ' ! character ( len = * ), parameter :: int = ' 1234567890 ' character ( len = * ), parameter :: hex = ' abcdefABCDEF0123456789 ' logical :: lout type ( unicode_type ) :: chars type ( unicode_type ) :: str ! chars = ' 32 ‚Äê af43d ' lout =. true . ! ! are the first two characters integer characters ? str = chars % character ( 1 , 2 ) lout = ( verify ( str , ut ( int ) ) == 0 ) . and . lout ! ! is the third character a dash ? str = chars % character ( 3 , 3 ) lout = ( verify ( str , ut ( '‚Äê - ' ) ) == 0 ) . and . lout ! ! is remaining string a valid representation of a hex value ? str = chars % character ( 4 , 8 ) lout = ( verify ( str , ut ( hex ) ) == 0 ) . and . lout ! if ( lout ) then write ( stdout , g ) trim ( chars % character ()), ' passed ' else write ( stdout , g ) trim ( chars % character ()), ' failed ' endif end program form Results: 32‚Äêaf43d passed Sample program V: exploring uses of elemental functionality and dusty corners program more_verify use M_unicode , only : ut => unicode_type , verify use M_unicode , only : assignment (=) use M_unicode , only : ch => character implicit none character ( len = * ), parameter :: & & low = \"abcdefghijklmnopqrstuvwxyz\" , & & upp = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" , & & blank = \" \" ! note character variables in an array have to be of the same length type ( ut ), allocatable :: strings (:) type ( ut ), allocatable :: sets (:) strings =[ ut ( \"Go\" ), ut ( \"right\" ), ut ( \"home!\" )] sets =[ ut ( \"do\" ), ut ( \"re\" ), ut ( \"me\" )] ! elemental ‚Äê‚Äê you can use arrays for both strings and for sets ! check each string from right to left for non ‚Äê letter / non ‚Äê blank write ( * , * ) \"last non‚Äêletter\" , verify ( strings , upp //low//blank,back=.true.) ! even BACK can be an array ! find last non ‚Äê uppercase character in \"Go\" ! and first non ‚Äê lowercase in \"right\" write ( * , * ) verify ( strings ( 1 : 2 ),[ upp , low ], back =[. true .,. false .]) ! using a null string for a set is not well defined . Avoid it write ( * , * ) \"null\" , verify ( \"for tran \" , \"\" , . true .) ! 8 , length of string ? ! probably what you expected write ( * , * ) \"blank\" , verify ( \"for tran \" , \" \" , . true .) ! 7 , found ‚Äô n ‚Äô ! first character in \"Go    \" not in \"do\" , ! and first letter in \"right \" not in \"ri\" ! and first letter in \"home! \" not in \"me\" write ( * , * ) verify ( strings , sets ) end program more_verify Results: >  last non‚Äêletter 0 0 5\n>  2 0\n>  null 9\n>  blank 8\n>  1 2 1 SEE ALSO Functions that perform operations on character strings, return\n   lengths of arguments, and search for certain arguments: ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), SCAN(3), NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3) AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer private impure elemental function verify_ua(string, set, back) result(result) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer private impure elemental function verify_au(string, set, back) result(result) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( unicode_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer","tags":"","url":"interface/verify.html"},{"title":"write(formatted) ‚Äì M_unicode","text":"public interface write(formatted) Module Procedures private  subroutine write_formatted(string, unit, iotype, v_list, iostat, iomsg) Write string to connected formatted unit. Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: string integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","url":"interface/write(formatted).html"},{"title":"printwords ‚Äì M_unicode","text":"impure elemental subroutine printwords(line) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: line Source Code impure elemental subroutine printwords ( line ) type ( ut ), intent ( in ) :: line pos = 0 write ( stdout , g ) line % character (), len ( line ) do while ( pos < len ( line )) first = pos + 1 call split ( line , delims , pos ) last = pos - 1 print g , line % character ( first , last ), first , last , pos end do end subroutine printwords","tags":"","url":"proc/printwords.html"},{"title":"test ‚Äì M_unicode","text":"subroutine test(in, expected) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: in type( unicode_type ), intent(in) :: expected Variables Type Visibility Attributes Name Initial type( unicode_type ), public :: lowercase character(len=*), public, parameter :: nl = new_line('A') Source Code subroutine test ( in , expected ) type ( unicode_type ), intent ( in ) :: in type ( unicode_type ), intent ( in ) :: expected type ( unicode_type ) :: lowercase character ( len =* ), parameter :: nl = new_line ( 'A' ) write ( stdout , g ) in % character () lowercase = lower ( in ) write ( stdout , g ) lowercase % character () write ( stdout , g ) merge ( 'PASSED' , 'FAILED' , lowercase == expected ), nl end subroutine test","tags":"","url":"proc/test~2.html"},{"title":"isint ‚Äì M_unicode","text":"impure elemental function isint(line) result(lout) Uses M_unicode Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: line Return Value logical Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: digits = \"0123456789\" type( unicode_type ), public :: name Source Code impure elemental function isint ( line ) result ( lout ) use M_unicode , only : adjustl , verify , trim ! ! determine if string is a valid integer representation ! ignoring trailing spaces and leading spaces ! character ( len =* ), parameter :: digits = \"0123456789\" type ( ut ), intent ( in ) :: line type ( ut ) :: name logical :: lout lout = . false . ! make sure at least two characters long to simplify tests name = adjustl ( line ). cat . '  ' ! blank string if ( name == '' ) return ! allow one leading sign if ( verify ( name % sub ( 1 , 1 ), ut ( '+‚Äê-' )) == 0 ) name = name % sub ( 2 , len ( name )) ! was just a sign if ( name == '' ) return lout = verify ( trim ( name ), digits ) == 0 end function isint","tags":"","url":"proc/isint.html"},{"title":"fortran_name ‚Äì M_unicode","text":"impure elemental function fortran_name(line) result(lout) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: line Return Value logical Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: allowed = upper//lower//int//\"_\" character(len=*), public, parameter :: int = \"0123456789\" character(len=*), public, parameter :: lower = \"abcdefghijklmnopqrstuvwxyz\" type( unicode_type ), public :: name character(len=*), public, parameter :: upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" Source Code impure elemental function fortran_name ( line ) result ( lout ) ! ! determine if a string is a valid Fortran name ! ignoring trailing spaces (but not leading spaces) ! character ( len =* ), parameter :: int = \"0123456789\" character ( len =* ), parameter :: lower = \"abcdefghijklmnopqrstuvwxyz\" character ( len =* ), parameter :: upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" character ( len =* ), parameter :: allowed = upper // lower // int // \"_\" type ( ut ), intent ( in ) :: line type ( ut ) :: name logical :: lout name = trim ( line ) if ( len ( name ). ne . 0 ) then ! first character is alphameric lout = verify ( name % sub ( 1 , 1 ), lower // upper ) == 0 & ! other characters are allowed in a symbol name & . and . verify ( name , allowed ) == 0 & ! allowable length & . and . len ( name ) <= 63 else lout = . false . endif end function fortran_name","tags":"","url":"proc/fortran_name.html"},{"title":"callit ‚Äì M_unicode","text":"subroutine callit() Arguments None Source Code subroutine callit () print u , STRING ! convert -7 string to uppercase: print u , TRANSLITERATE ( STRING , LOWER , UPPER ) ! change all miniscule letters to a colon (\":\"): print u , TRANSLITERATE ( STRING , LOWER , ':' ) ! delete all miniscule letters print u , TRANSLITERATE ( STRING , LOWER , '' ) end subroutine callit","tags":"","url":"proc/callit.html"},{"title":"random_ascii_string ‚Äì M_unicode","text":"public  function random_ascii_string(chars, length) result(out) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars integer, intent(in) :: length Return Value character(len=:), allocatable Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: ilen integer, public :: which real, public :: x Source Code function random_ascii_string ( chars , length ) result ( out ) !$@(#) M_random::random_string(3f): create random string composed of provided characters of specified length character ( len =* ), intent ( in ) :: chars integer , intent ( in ) :: length character ( len = :), allocatable :: out real :: x integer :: ilen ! length of list of characters integer :: which integer :: i ilen = len ( chars ) out = '' if ( ilen . gt . 0 ) then do i = 1 , length call random_number ( x ) which = nint ( real ( ilen - 1 ) * x ) + 1 out = out // chars ( which : which ) enddo endif end function random_ascii_string","tags":"","url":"proc/random_ascii_string.html"},{"title":"check ‚Äì M_unicode","text":"public  subroutine check(label, test, description) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label logical, intent(in) :: test character(len=*), intent(in), optional :: description Source Code subroutine check ( label , test , description ) character ( len =* ), intent ( in ) :: label logical , intent ( in ) :: test character ( len =* ), intent ( in ), optional :: description if ( present ( description ) ) then write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , test ), ' ' , label , ':' , description else write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , test ), ' ' , label endif if (. not . test ) total = total + 1 end subroutine check","tags":"","url":"proc/check.html"},{"title":"checkit ‚Äì M_unicode","text":"public  subroutine checkit(label, aline, answer, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label character(len=*), intent(in) :: aline character(len=*), intent(in) :: answer character(len=*), intent(in) :: expected Source Code subroutine checkit ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline character ( len =* ), intent ( in ) :: answer character ( len =* ), intent ( in ) :: expected write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , answer . eq . expected ), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( answer . ne . expected ) total = total + 1 end subroutine checkit","tags":"","url":"proc/checkit.html"},{"title":"checkits ‚Äì M_unicode","text":"public  subroutine checkits(label, aline, answer, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label character(len=*), intent(in) :: aline character(len=*), intent(in) :: answer (:) character(len=*), intent(in) :: expected (:) Source Code subroutine checkits ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline character ( len =* ), intent ( in ) :: answer (:) character ( len =* ), intent ( in ) :: expected (:) if ( size ( answer ). eq . size ( expected ) ) then write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , all ( answer . eq . expected )), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( all ( answer . ne . expected )) total = total + 1 else write ( * , g0 ) 'FAILED' , ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' total = total + 1 endif end subroutine checkits","tags":"","url":"proc/checkits.html"},{"title":"checkits_l ‚Äì M_unicode","text":"public  subroutine checkits_l(label, aline, answer, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label character(len=*), intent(in) :: aline logical, intent(in) :: answer (:) logical, intent(in) :: expected (:) Source Code subroutine checkits_l ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline logical , intent ( in ) :: answer (:) logical , intent ( in ) :: expected (:) write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , all ( answer . eqv . expected )), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( all ( answer . neqv . expected )) total = total + 1 end subroutine checkits_l","tags":"","url":"proc/checkits_l.html"},{"title":"programming_environment ‚Äì M_unicode","text":"public  subroutine programming_environment() Uses iso_fortran_env Arguments None Variables Type Visibility Attributes Name Initial integer, public :: break character(len=*), public, parameter :: nl = new_line('a') character(len=:), public, allocatable :: options integer, public :: start character(len=:), public, allocatable :: version integer, public :: where Source Code subroutine programming_environment () use , intrinsic :: iso_fortran_env , only : compiler_version use , intrinsic :: iso_fortran_env , only : compiler_options implicit none character ( len = :), allocatable :: version , options character ( len =* ), parameter :: nl = new_line ( 'a' ) integer :: where , start , break version = compiler_version () options = ' ' // compiler_options () start = 1 do where = index ( options ( start :), ' -' ) if ( where . eq . 0 ) exit break = where + start - 1 options ( break : break ) = nl start = where enddo if ( start . eq . 1 ) then do where = index ( options ( start :), ' /' ) if ( where . eq . 0 ) exit break = where + start - 1 options ( break : break ) = nl start = where enddo endif print '(*(1x,a))' , & 'This file was compiled by ' , & version , nl , & 'using the options ' , & options end subroutine programming_environment","tags":"","url":"proc/programming_environment.html"},{"title":"test_adjustl ‚Äì M_unicode","text":"public  subroutine test_adjustl() Arguments None Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: astr type( unicode_type ), public :: ut_str Source Code subroutine test_adjustl () character ( len = :), allocatable :: astr type ( unicode_type ) :: ut_str astr = \"  this is a string    \" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), 'this is a string      ' ) astr = \"  \" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), '  ' ) astr = \"\" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), '' ) astr = \"ALLFULL\" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), 'ALLFULL' ) ut_str = [ 32 , 32 , int ( z '1F603' ), 32 , 32 , 32 ] astr = character ( ut_str ) call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), 'üòÉ     ' ) astr = \"this is a string              \" ut_str = \"  this is a string    \" call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ( 30 )), astr ) end subroutine test_adjustl","tags":"","url":"proc/test_adjustl.html"},{"title":"test_adjustr ‚Äì M_unicode","text":"public  subroutine test_adjustr() Arguments None Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: astr type( unicode_type ), public :: ut_str Source Code subroutine test_adjustr () character ( len = :), allocatable :: astr type ( unicode_type ) :: ut_str astr = \"  this is a string    \" ut_str = astr call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '      this is a string' ) astr = \"  \" ut_str = astr call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '  ' ) astr = \"\" ut_str = astr call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '' ) astr = \"ALLFULL\" ut_str = astr call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), 'ALLFULL' ) ut_str = [ 32 , 32 , int ( z '1F603' ), 32 , 32 , 32 ] astr = character ( ut_str ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '     üòÉ' ) astr = \"              this is a string\" ut_str = \"  this is a string    \" call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ( 30 )), astr ) end subroutine test_adjustr","tags":"","url":"proc/test_adjustr.html"},{"title":"test_concatenate ‚Äì M_unicode","text":"public  subroutine test_concatenate() Arguments None Variables Type Visibility Attributes Name Initial type( unicode_type ), public :: str integer, public :: ten = 10 integer, public :: twenty = 20 Source Code subroutine test_concatenate () type ( ut ) :: str integer :: ten = 10 , twenty = 20 !need clarification! () required by ifx, not flang_new or gfortran !str='so '//ten//'+'//twenty//'='//(ten+twenty)//' üòÉ' str = 'so ' . cat . ten . cat . '+' . cat . twenty . cat . '=' . cat .( ten + twenty ). cat . ' üòÉ' ! ifx cannot print when // overloaded call check ( '//' , str == 'so 10+20=30 üòÉ' , 'concatenate got ' // str % character ()) end subroutine test_concatenate","tags":"","url":"proc/test_concatenate.html"},{"title":"test_escape ‚Äì M_unicode","text":"public  subroutine test_escape() Arguments None Variables Type Visibility Attributes Name Initial integer, public, allocatable :: ints (:) type( unicode_type ), public :: ut_str Source Code subroutine test_escape () type ( unicode_type ) :: ut_str integer , allocatable :: ints (:) !    \\      backslash !    a      alert (BEL) -- g is an alias for a !    b      backspace !    c      suppress further output !    e      escape !    f      form feed !    n      new line !    r      carriage return !    t      horizontal tab !    v      vertical tab ! !    oNNN   byte with octal value NNN (3 digits) !    0-9    up to three digits following will be treated !           as an octal value !    dNNN   byte with decimal value NNN (3 digits) !    xHH        byte with hexadecimal value HH (2 digits); !               h is an alias for x !    uZZZZ      translate Unicode codepoint value to bytes !    UZZZZZZZZ  translate Unicode codepoint value to bytes ut_str = '\\\\\\a\\b\\e\\f\\n\\r\\t\\v\\c' ints = [ 92 , 7 , 8 , 27 , 12 , 10 , 13 , 9 , 11 ] ut_str = escape ( ut_str ) call check ( 'escape' , len ( ut_str ). eq . 9 , 'size' ) if ( len ( ut_str ). eq . 9 ) then call check ( 'escape' , all ( ut_str % codepoint (). eq . ints ), 'codes' ) endif call check ( 'escape' , escape ( ut ( '\\')).eq.' \\ ',' backslash at end of line ') call check(' escape ',escape(ut(' text \\ 0 ')).eq.' text '//char(0),' null at end ') call check(' escape ',escape(ut(' \\ 122 \\ 123 A ')).eq.' RSA ',' two ') ! (kaufii hai?) [Literal Meaning: ‚ÄúIs there coffee?‚Äù] ‚ÄúDo you have coffee?‚Äù (Informal) ut_str=' \\ u0915 \\ u0949 \\ u092B \\ U0000093C \\ U00000940 \\ x20 \\ u0939 \\ u0948 \\ x3F ' call check(' escape ',escape(ut_str).eq.' ‡§ï‡•â‡§´‡§º‡•Ä ‡§π‡•à? ',' hexadecimal ' ) end subroutine test_escape","tags":"","url":"proc/test_escape.html"},{"title":"test_expandtabs ‚Äì M_unicode","text":"public  subroutine test_expandtabs() Arguments None Variables Type Visibility Attributes Name Initial type( unicode_type ), public :: expected integer, public :: i type( unicode_type ), public :: in character(len=:), public, allocatable :: str Source Code subroutine test_expandtabs () character ( len = :), allocatable :: str type ( unicode_type ) :: in type ( unicode_type ) :: expected integer :: i str = '  this is my string  ' ! change spaces to tabs to make a sample input do i = 1 , len ( str ) if ( str ( i : i ) == ' ' ) str ( i : i ) = char ( 9 ) enddo in = str expected = \"                this    is      my      string\" call check ( 'expandtabs' , expandtabs ( in ). eq . expected , character ( expandtabs ( in ))) call check ( 'expandtabs' , in % expandtabs (). eq . expected , character ( expandtabs ( in ))) expected = \"thisismystring\" call check ( 'expandtabs' , in % expandtabs ( tab_size = 0 ). eq . expected , character ( in % expandtabs ( tab_size = 0 ))) end subroutine test_expandtabs","tags":"","url":"proc/test_expandtabs.html"},{"title":"test_fmt ‚Äì M_unicode","text":"public  subroutine test_fmt() Arguments None Subroutines subroutine add (message, question, answer) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: message type( unicode_type ), intent(in) :: question character(len=*), intent(in) :: answer Source Code subroutine test_fmt () call add ( 'INTEGER' , fmt ( 10 ), '10' ) call add ( 'LOGICAL' , fmt (. false .), 'F' ) call add ( 'LOGICAL' , fmt (. true .), 'T' ) call add ( 'REAL' , fmt ( 10 0.0 ), '100' ) call add ( 'COMPLEX' , fmt (( 1 1.0 , 2 2.0 )), '(11,22)' ) call add ( 'REAL' , fmt ( 10 0.0 , 'f0.2' ), '100.00' ) contains subroutine add ( message , question , answer ) character ( len =* ), intent ( in ) :: message type ( ut ), intent ( in ) :: question character ( len =* ), intent ( in ) :: answer call check ( 'fmt' , question . eq . answer , 'testing ' // message // ' expected ' // answer // ' got ' // ch ( question )) end subroutine add end subroutine test_fmt","tags":"","url":"proc/test_fmt.html"},{"title":"test_ichar ‚Äì M_unicode","text":"public  subroutine test_ichar() Arguments None Variables Type Visibility Attributes Name Initial type( unicode_type ), public :: ut_str Source Code subroutine test_ichar () type ( unicode_type ) :: ut_str ut_str = 'ABC' call check ( 'ichar' , ut_str % ichar (). eq . ichar ( 'A' ), 'string%ichar()' ) call check ( 'ichar' , ichar ( ut ( 'A' )). eq . ichar ( 'A' ), 'ichar(ut(\"A\")' ) call check ( 'ichar' , ichar ( ut_str % sub ( 2 , 3 )). eq . ichar ( 'B' ), 'ichar(ut_str%sub(2,3))' ) end subroutine test_ichar","tags":"","url":"proc/test_ichar.html"},{"title":"test_index ‚Äì M_unicode","text":"public  subroutine test_index() Arguments None Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: astr type( unicode_type ), public :: string type( unicode_type ), public :: substring Source Code subroutine test_index () type ( unicode_type ) :: string , substring character ( len = :), allocatable :: astr string = \" can you find me here? \" substring = \"find me\" astr = character ( substring ) call check ( 'index ' // string % character () // ':' // substring % character (), index ( string , substring ). eq . 10 ) call check ( 'index ' // string % character () // ':' // astr , index ( string , astr ). eq . 10 ) string = \" can you find me here? \" substring = \"not there\" astr = character ( substring ) call check ( 'index ' // string % character () // ':' // substring % character (), index ( string , substring ). eq . 0 ) call check ( 'index ' // string % character () // ':' // astr , index ( string , astr ). eq . 0 ) string = \"short\" substring = \"shortnot\" astr = character ( substring ) call check ( 'index ' // string % character () // ':' // substring % character (), index ( string , substring ). eq . 0 ) call check ( 'index ' // string % character () // ':' // astr , index ( string , astr ). eq . 0 ) end subroutine test_index","tags":"","url":"proc/test_index.html"},{"title":"test_join ‚Äì M_unicode","text":"public  subroutine test_join() Arguments None Variables Type Visibility Attributes Name Initial type( unicode_type ), public :: expected character(len=20), public, allocatable :: proverb (:) type( unicode_type ), public, allocatable :: s (:) type( unicode_type ), public, allocatable :: sep Source Code subroutine test_join () character ( len = 20 ), allocatable :: proverb (:) type ( ut ), allocatable :: s (:) type ( ut ), allocatable :: sep type ( ut ) :: expected proverb = [ character ( len = 13 ) :: & & ' United' ,& & '  we' ,& & '   stand,' ,& & '    divided' ,& & '     we fall.' ] allocate ( s ( size ( proverb ))) ! avoid GNU Fortran (GCC) 16.0.0 bug s = proverb expected = 'Unitedwestand,dividedwe fall.' call check ( 'join' , join ( s ) == expected , 'SIMPLE JOIN' ) expected = 'United we stand, divided we fall.' call check ( 'join' , join ( s , sep = ut ( ' ' ) ) == expected , 'JOIN WITH SEPARATOR' ) expected = 'United<-->we<-->stand,<-->divided<-->we fall.' call check ( 'join' , join ( s , sep = ut ( '<-->' )) == expected , 'CUSTOM SEPARATOR' ) expected = ' United               we                   stand,               divided              we fall.' call check ( 'join' , join ( s , clip = . false .) == expected , 'NO TRIMMING' ) sep = ut () expected = 'Unitedwestand,dividedwe fall.' call check ( 'join' , sep % join ( s ) == expected , 'OOP SIMPLE JOIN' ) sep = ' ' expected = 'United we stand, divided we fall.' call check ( 'join' , sep % join ( s ) == expected , 'OOP JOIN WITH SEPARATOR' ) sep = '<-->' expected = 'United<-->we<-->stand,<-->divided<-->we fall.' call check ( 'join' , sep % join ( s ) == expected , 'OOP CUSTOM SEPARATOR' ) sep = '' expected = ' United               we                   stand,               divided              we fall.' call check ( 'join' , sep % join ( s , clip = . false .) == expected , 'OOP NO TRIMMING' ) end subroutine test_join","tags":"","url":"proc/test_join.html"},{"title":"test_len ‚Äì M_unicode","text":"public  subroutine test_len() Arguments None Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: astr type( unicode_type ), public :: ut_str Source Code subroutine test_len () character ( len = :), allocatable :: astr type ( unicode_type ) :: ut_str astr = \"  this is a string    \" ut_str = astr call check ( 'len' , ut_str % len (). eq . 22 ) call check ( 'len' , len ( ut_str ). eq . 22 ) astr = \"  \" ut_str = astr call check ( 'len' , ut_str % len (). eq . 2 ) astr = \"\" ut_str = astr call check ( 'len' , ut_str % len (). eq . 0 ) astr = \"ALLFULL\" ut_str = astr call check ( 'len' , ut_str % len (). eq . 7 ) ut_str = [ 32 , 32 , int ( z '1F603' ), 32 , 32 , 32 ] astr = character ( ut_str ) call check ( 'len' , ut_str % len (). eq . 6 ) end subroutine test_len","tags":"","url":"proc/test_len.html"},{"title":"test_len_trim ‚Äì M_unicode","text":"public  subroutine test_len_trim() Arguments None Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: astr type( unicode_type ), public :: ut_str Source Code subroutine test_len_trim () character ( len = :), allocatable :: astr type ( unicode_type ) :: ut_str astr = \"  this is a string    \" ut_str = astr call check ( 'len_trim' , ut_str % len_trim (). eq . 18 ) call check ( 'len_trim' , len_trim ( ut_str ). eq . 18 ) astr = \"  \" ut_str = astr call check ( 'len_trim' , ut_str % len_trim (). eq . 0 ) astr = \"\" ut_str = astr call check ( 'len_trim' , ut_str % len_trim (). eq . 0 ) astr = \"ALLFULL\" ut_str = astr call check ( 'len_trim' , ut_str % len_trim (). eq . 7 ) ut_str = [ 32 , 32 , int ( z '1F603' ), 32 , 32 , 32 ] astr = character ( ut_str ) call check ( 'len_trim' , ut_str % len_trim (). eq . 3 ) end subroutine test_len_trim","tags":"","url":"proc/test_len_trim.html"},{"title":"test_lower ‚Äì M_unicode","text":"public  subroutine test_lower() Arguments None Variables Type Visibility Attributes Name Initial character(len=128), public :: ascii7 integer, public, allocatable :: codes (:) integer, public :: i type( unicode_type ), public :: letter1 type( unicode_type ), public :: letter2 type( unicode_type ), public :: letter3 type( unicode_type ), public :: letter4 type( unicode_type ), public :: low type( unicode_type ), public :: lowkludge type( unicode_type ), public :: temp type( unicode_type ), public :: upp Subroutines subroutine reportit () Arguments None Source Code subroutine test_lower () type ( unicode_type ) :: upp , low , lowkludge , temp , letter1 , letter2 , letter3 , letter4 integer :: i integer , allocatable :: codes (:) character ( len = 128 ) :: ascii7 ! ! remember unicode characters are multi-byte so be careful ! with older compilers to not exceed 132 bytes per line ! low = '& &abcdefghijklmnopqrstuvwxyz√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨& &√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∏√π√∫√ª√º√Ω√æ√øƒÅƒÉƒÖƒáƒâƒãƒçƒèƒëƒìƒïƒóƒôƒõƒùƒüƒ°ƒ£ƒ•ƒßƒ©ƒ´ƒ≠& &ƒØƒ±ƒ≥ƒµƒ∑ƒ∫ƒºƒæ≈Ä≈Ç≈Ñ≈Ü≈à≈ã≈ç≈è≈ë≈ì≈ï≈ó≈ô≈õ≈ù≈ü≈°≈£≈•≈ß≈©≈´≈≠≈Ø≈±≈≥≈µ≈∑≈∫≈º≈æ& &∆É∆Ö∆à∆å∆í∆ô∆°∆£∆•∆®∆≠∆∞∆¥∆∂∆π∆Ω«Ü«â«å«é«ê«í«î«ñ«ò«ö«ú«ü«°«£«•«ß«©«´«≠«Ø«≥«µ«ª«Ω«ø& &»Å»É»Ö»á»â»ã»ç»è»ë»ì»ï»ó…ì…î…ó…ò…ô…õ…†…£…®…©…Ø…≤…µ É à ä ã íŒ¨Œ≠ŒÆŒØ& &Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÉœÑœÖœÜœáœàœâœäœãœåœçœéœ£œ•œßœ©œ´œ≠œØ–∞–±–≤–≥–¥–µ–∂–∑–∏–π& &–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è—ë—í—ì—î—ï—ñ—ó—ò—ô—ö—õ—ú—û—ü& &—°—£—•—ß—©—´—≠—Ø—±—≥—µ—∑—π—ª—Ω—ø“Å“ë“ì“ï“ó“ô“õ“ù“ü“°“£“•“ß“©“´“≠“Ø“±“≥“µ“∑“π“ª“Ω“ø”Ç”Ñ”à& &”å”ë”ì”ï”ó”ô”õ”ù”ü”°”£”•”ß”©”´”Ø”±”≥”µ”π’°’¢’£’§’•’¶’ß’®’©’™’´’¨’≠’Æ’Ø’∞’±’≤& &’≥’¥’µ’∂’∑’∏’π’∫’ª’º’Ω’æ’ø÷Ä÷Å÷Ç÷É÷Ñ÷Ö÷Ü·Éê·Éë·Éí·Éì·Éî·Éï·Éñ·Éó·Éò·Éô·Éö·Éõ·Éú·Éù·Éû·Éü·É†·É°·É¢·É£·É§·É•& &·É¶·Éß·É®·É©·É™·É´·É¨·É≠·ÉÆ·ÉØ·É∞·É±·É≤·É≥·É¥·Éµ·∏Å·∏É·∏Ö·∏á·∏â·∏ã·∏ç·∏è·∏ë·∏ì·∏ï·∏ó·∏ô·∏õ·∏ù·∏ü·∏°·∏£·∏•·∏ß& &·∏©·∏´·∏≠·∏Ø·∏±·∏≥·∏µ·∏∑·∏π·∏ª·∏Ω·∏ø·πÅ·πÉ·πÖ·πá·πâ·πã·πç·πè·πë·πì·πï·πó·πô& &·πõ·πù·πü·π°·π£·π•·πß·π©·π´·π≠·πØ·π±·π≥·πµ·π∑·ππ·πª·πΩ·πø& &·∫Å·∫É·∫Ö·∫á·∫â·∫ã·∫ç·∫è·∫ë·∫ì·∫ï·∫°·∫£·∫•·∫ß·∫©·∫´·∫≠·∫Ø·∫±·∫≥·∫µ·∫∑·∫π·∫ª·∫Ω·∫ø·ªÅ·ªÉ·ªÖ·ªá·ªâ·ªã·ªç·ªè·ªë·ªì·ªï·ªó& &·ªô·ªõ·ªù·ªü·ª°·ª£·ª•·ªß·ª©·ª´·ª≠·ªØ·ª±·ª≥·ªµ·ª∑·ªπ·ºÄ·ºÅ·ºÇ·ºÉ·ºÑ·ºÖ·ºÜ·ºá·ºê·ºë·ºí·ºì·ºî·ºï·º†·º°·º¢·º£·º§·º•·º¶·ºß·º∞·º±& &·º≤·º≥·º¥·ºµ·º∂·º∑·ΩÄ·ΩÅ·ΩÇ·ΩÉ·ΩÑ·ΩÖ·Ωë·Ωì·Ωï·Ωó·Ω†·Ω°·Ω¢·Ω£·Ω§·Ω•·Ω¶·Ωß·æÄ·æÅ·æÇ·æÉ·æÑ·æÖ·æÜ·æá·æê·æë·æí·æì·æî·æï·æñ·æó& &·æ†·æ°·æ¢·æ£·æ§·æ•·æ¶·æß·æ∞·æ±·øê·øë·ø†·ø°‚ìê‚ìë‚ìí‚ìì‚ìî‚ìï‚ìñ‚ìó‚ìò‚ìô‚ìö‚ìõ‚ìú‚ìù‚ìû‚ìü‚ì†‚ì°‚ì¢‚ì£‚ì§‚ì•‚ì¶‚ìß‚ì®‚ì©& &ÔΩÅÔΩÇÔΩÉÔΩÑÔΩÖÔΩÜÔΩáÔΩàÔΩâÔΩäÔΩãÔΩåÔΩçÔΩéÔΩèÔΩêÔΩëÔΩíÔΩìÔΩîÔΩïÔΩñÔΩóÔΩòÔΩôÔΩö' upp = '& &ABCDEFGHIJKLMNOPQRSTUVWXYZ√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã& &√å√ç√é√è√ê√ë√í√ì√î√ï√ñ√ò√ô√ö√õ√ú√ù√û≈∏ƒÄƒÇƒÑƒÜƒàƒäƒåƒéƒêƒíƒîƒñƒòƒöƒúƒûƒ†ƒ¢ƒ§ƒ¶ƒ®ƒ™ƒ¨& &ƒÆIƒ≤ƒ¥ƒ∂ƒπƒªƒΩƒø≈Å≈É≈Ö≈á≈ä≈å≈é≈ê≈í≈î≈ñ≈ò≈ö≈ú≈û≈†≈¢≈§≈¶≈®≈™≈¨≈Æ≈∞≈≤≈¥≈∂≈π≈ª& &≈Ω∆Ç∆Ñ∆á∆ã∆ë∆ò∆†∆¢∆§∆ß∆¨∆Ø∆≥∆µ∆∏∆º«Ñ«á«ä«ç«è«ë«ì«ï«ó«ô«õ«û«†«¢«§«¶«®«™«¨«Æ«±«¥«∫«º«æ& &»Ä»Ç»Ñ»Ü»à»ä»å»é»ê»í»î»ñ∆Å∆Ü∆ä∆é∆è∆ê∆ì∆î∆ó∆ñ∆ú∆ù∆ü∆©∆Æ∆±∆≤∆∑ŒÜŒàŒâŒäŒëŒíŒìŒîŒïŒñŒóŒò& &ŒôŒöŒõŒúŒùŒûŒüŒ†Œ°Œ£Œ§Œ•Œ¶ŒßŒ®Œ©Œ™Œ´ŒåŒéŒèœ¢œ§œ¶œ®œ™œ¨œÆ–ê–ë–í–ì–î–ï–ñ–ó–ò–ô& &–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–Å–Ç–É–Ñ–Ö–Ü–á–à–â–ä–ã–å–é–è—†—¢—§—¶—®—™—¨& &—Æ—∞—≤—¥—∂—∏—∫—º—æ“Ä“ê“í“î“ñ“ò“ö“ú“û“†“¢“§“¶“®“™“¨“Æ“∞“≤“¥“∂“∏“∫“º“æ”Å”É”á& &”ã”ê”í”î”ñ”ò”ö”ú”û”†”¢”§”¶”®”™”Æ”∞”≤”¥”∏‘±‘≤‘≥‘¥‘µ‘∂‘∑‘∏‘π‘∫‘ª‘º‘Ω‘æ‘ø’Ä’Å’Ç’É’Ñ& &’Ö’Ü’á’à’â’ä’ã’å’ç’é’è’ê’ë’í’ì’î’ï’ñ·Ç†·Ç°·Ç¢·Ç£·Ç§·Ç•·Ç¶·Çß·Ç®·Ç©·Ç™·Ç´·Ç¨·Ç≠·ÇÆ·ÇØ·Ç∞·Ç±·Ç≤·Ç≥·Ç¥·Çµ& &·Ç∂·Ç∑·Ç∏·Çπ·Ç∫·Çª·Çº·ÇΩ·Çæ·Çø·ÉÄ·ÉÅ·ÉÇ·ÉÉ·ÉÑ·ÉÖ·∏Ä·∏Ç·∏Ñ·∏Ü·∏à·∏ä·∏å·∏é·∏ê·∏í·∏î·∏ñ·∏ò·∏ö·∏ú·∏û·∏†·∏¢·∏§·∏¶·∏®·∏™·∏¨·∏Æ& &·∏∞·∏≤·∏¥·∏∂·∏∏·∏∫·∏º·∏æ·πÄ·πÇ·πÑ·πÜ·πà·πä·πå·πé·πê·πí·πî·πñ·πò·πö·πú·πû·π†·π¢·π§·π¶·π®·π™·π¨·πÆ·π∞·π≤·π¥·π∂·π∏·π∫·πº·πæ& &·∫Ä·∫Ç·∫Ñ·∫Ü·∫à·∫ä·∫å·∫é·∫ê·∫í·∫î·∫†·∫¢·∫§·∫¶·∫®·∫™·∫¨·∫Æ·∫∞·∫≤·∫¥·∫∂·∫∏·∫∫·∫º·∫æ·ªÄ·ªÇ·ªÑ·ªÜ·ªà·ªä& &·ªå·ªé·ªê·ªí·ªî·ªñ·ªò·ªö·ªú·ªû·ª†·ª¢·ª§·ª¶·ª®·ª™·ª¨·ªÆ·ª∞·ª≤·ª¥·ª∂·ª∏& &·ºà·ºâ·ºä·ºã·ºå·ºç·ºé·ºè·ºò·ºô·ºö·ºõ·ºú·ºù·º®·º©·º™·º´·º¨·º≠·ºÆ·ºØ·º∏·ºπ& &·º∫·ºª·ºº·ºΩ·ºæ·ºø·Ωà·Ωâ·Ωä·Ωã·Ωå·Ωç·Ωô·Ωõ·Ωù·Ωü·Ω®·Ω©·Ω™·Ω´·Ω¨·Ω≠·ΩÆ·ΩØ& &·æà·æâ·æä·æã·æå·æç·æé·æè·æò·æô·æö·æõ·æú·æù·æû·æü·æ®·æ©·æ™·æ´·æ¨·æ≠·æÆ·æØ·æ∏·æπ& &·øò·øô·ø®·ø©‚í∂‚í∑‚í∏‚íπ‚í∫‚íª‚íº‚íΩ‚íæ‚íø‚ìÄ‚ìÅ‚ìÇ‚ìÉ‚ìÑ‚ìÖ‚ìÜ‚ìá‚ìà‚ìâ‚ìä‚ìã‚ìå‚ìç‚ìé‚ìè& &Ôº°Ôº¢Ôº£Ôº§Ôº•Ôº¶ÔºßÔº®Ôº©Ôº™Ôº´Ôº¨Ôº≠ÔºÆÔºØÔº∞Ôº±Ôº≤Ôº≥Ôº¥ÔºµÔº∂Ôº∑Ôº∏ÔºπÔº∫' temp = lower ( upp ) call reportit () codes = low % codepoint () codes ( 82 ) = ichar ( 'i' ) lowkludge = codes !call check('lower', temp==low ) !call check('lower', character(temp)==character(low) ) call check ( 'lower' , temp == lowkludge ) call check ( 'lower' , character ( temp ) == character ( lowkludge ) ) write ( ascii7 , g0 )( achar ( i ), i = 0 , 127 ) ascii7 ( ichar ( 'a' ) + 1 : ichar ( 'z' ) + 1 ) = ' ' ascii7 ( ichar ( 'A' ) + 1 : ichar ( 'Z' ) + 1 ) = ' ' temp = ascii7 !call check('lower',temp%character()==ascii7,'check non-alphameric like'//ascii7(ichar(' ')+1:len(ascii7)-1) ) call check ( 'lower' , upper ( temp ) == lower ( temp ), 'expect no difference' ) call check ( 'lower' , temp == lower ( temp ), 'expect no change' ) temp = upp % lower () !write(*,*)character(temp,82,82) ! known conundrum at 82 i ƒ± letter1 = int ( z \"0049\" ) ! * U+0049 I LATIN CAPITAL LETTER I. letter2 = int ( z \"0130\" ) ! * U+0130 ƒ∞ LATIN CAPITAL LETTER I WITH DOT ABOVE. letter3 = int ( z \"0069\" ) ! * U+0069 i LATIN SMALL LETTER I. (dotted) letter4 = int ( z \"0131\" ) ! * U+0131 ƒ± LATIN SMALL LETTER I DOTLESS temp = replace ( temp , 82 , 82 , letter4 ) call check ( '%lower' , temp == low ) call check ( '%lower' , character ( temp ) == character ( low ) ) contains subroutine reportit () ! known conundrum at 82 i ƒ± do i = 1 , len ( temp ) letter1 = temp % character ( i ) letter2 = low % character ( i , i ) if ( letter1 /= letter2 ) then if ( i . eq . 82 ) then call check ( 'lower' , i == 82 , 'expected difference' // letter1 % character () // letter2 % character ()) else call check ( 'lower' , letter1 == letter2 , 'failed' // letter1 % character () // letter2 % character ()) endif endif enddo end subroutine reportit end subroutine test_lower","tags":"","url":"proc/test_lower.html"},{"title":"test_operators ‚Äì M_unicode","text":"public  subroutine test_operators() Arguments None Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: astr type( unicode_type ), public :: lhs type( unicode_type ), public :: rhs type( unicode_type ), public :: smiley type( unicode_type ), public :: ut_str Source Code subroutine test_operators () type ( unicode_type ) :: lhs , rhs character ( len = :), allocatable :: astr type ( unicode_type ) :: smiley type ( unicode_type ) :: ut_str smiley = 'üòÉ' write ( * , g0 ) astr = 'Hello World and Ni Hao -- ‰Ω†Â•Ω' ut_str = astr call checkits ( 'convert to ASCII bytes' , astr , ut_str % byte (), transfer ( 'Hello World and Ni Hao -- ‰Ω†Â•Ω' ,[ 'A' ])) ut_str = smiley . cat . ' and ' . cat . smiley . cat . 'and' . cat . smiley . cat . smiley . cat . 'is it' astr = 'üòÉ and üòÉandüòÉüòÉis it' call checkit ( 'concatenation' , astr , character ( ut_str ), 'üòÉ and üòÉandüòÉüòÉis it' ) lhs = 'this is the left' rhs = 'this is the right' call checkits_l ( 'LLE' , ' ' , [ lle ( lhs , rhs ), lhs <= rhs , lle ( rhs , lhs ), rhs <= lhs ] , [ T , T , F , F ] ) call checkits_l ( 'LLT' , ' ' , [ llt ( lhs , rhs ), lhs < rhs , llt ( rhs , lhs ), rhs < lhs ] , [ T , T , F , F ] ) call checkits_l ( 'LNE' , ' ' , [ lne ( lhs , rhs ), lhs /= rhs , lne ( rhs , lhs ), rhs /= lhs ] , [ T , T , T , T ] ) call checkits_l ( 'LEQ' , ' ' , [ leq ( lhs , rhs ), lhs == rhs , leq ( rhs , lhs ), rhs == lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LGT' , ' ' , [ lgt ( lhs , rhs ), lhs > rhs , lgt ( rhs , lhs ), rhs > lhs ] , [ F , F , T , T ] ) call checkits_l ( 'LGE' , ' ' , [ lge ( lhs , rhs ), lhs >= rhs , lge ( rhs , lhs ), rhs >= lhs ] , [ F , F , T , T ] ) lhs = 'abc' rhs = 'abc ' call checkits_l ( 'LLE' , ' ' , [ lle ( lhs , rhs ), lhs <= rhs , lle ( rhs , lhs ), rhs <= lhs ] , [ T , T , T , T ] ) call checkits_l ( 'LLT' , ' ' , [ llt ( lhs , rhs ), lhs < rhs , llt ( rhs , lhs ), rhs < lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LNE' , ' ' , [ lne ( lhs , rhs ), lhs /= rhs , lne ( rhs , lhs ), rhs /= lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LEQ' , ' ' , [ leq ( lhs , rhs ), lhs == rhs , leq ( rhs , lhs ), rhs == lhs ] , [ T , T , T , T ] ) call checkits_l ( 'LGT' , ' ' , [ lgt ( lhs , rhs ), lhs > rhs , lgt ( rhs , lhs ), rhs > lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LGE' , ' ' , [ lge ( lhs , rhs ), lhs >= rhs , lge ( rhs , lhs ), rhs >= lhs ] , [ T , T , T , T ] ) end subroutine test_operators","tags":"","url":"proc/test_operators.html"},{"title":"test_other ‚Äì M_unicode","text":"public  subroutine test_other() Arguments None Variables Type Visibility Attributes Name Initial type( unicode_type ), public :: string character(len=*), public, parameter :: upagain = \"‰∏ÉËª¢„Å≥ÂÖ´Ëµ∑„Åç„ÄÇËª¢„Çì„Åß„ÇÇ„Åæ„ÅüÁ´ã„Å°‰∏ä„Åå„Çã„ÄÇ„Åè„Åò„Åë„Åö„Å´Ââç„ÇíÂêë„ÅÑ„Å¶Ê≠©„ÅÑ„Å¶„ÅÑ„Åì„ÅÜ„ÄÇ\" Source Code subroutine test_other () type ( unicode_type ) :: string character ( len =* ), parameter :: upagain = & \"‰∏ÉËª¢„Å≥ÂÖ´Ëµ∑„Åç„ÄÇËª¢„Çì„Åß„ÇÇ„Åæ„ÅüÁ´ã„Å°‰∏ä„Åå„Çã„ÄÇ„Åè„Åò„Åë„Åö„Å´Ââç„ÇíÂêë„ÅÑ„Å¶Ê≠©„ÅÑ„Å¶„ÅÑ„Åì„ÅÜ„ÄÇ\" ! Romanization: ! Nanakorobi yaoki. Koronde mo mata tachiagaru. Kujikezu ni mae o muite aruite ikou. ! or English translation ! \"Fall seven times, stand up eight. Even if you fall down, you will get up again. Don't be discouraged, just keep walking forward.\" ! string = upagain write ( * , g0 ) 'original bytes  :' , upagain !------------------- ! doing this generates non-unicode byte sequences in UTF-8, which means ! the OS may not longer recognize the output as UTF-8 !write(*,g0)'bytes reversed  :', (upagain(i:i),i=len(upagain),1,-1) !------------------- write ( * , g0 ) 'original string :' , string % character () write ( * , g0 ) 'string reversed :' , string % character ( string % len (), 1 , - 1 ) end subroutine test_other","tags":"","url":"proc/test_other.html"},{"title":"test_pad ‚Äì M_unicode","text":"public  subroutine test_pad() Arguments None Variables Type Visibility Attributes Name Initial type( unicode_type ), public :: answer type( unicode_type ), public :: string Functions function bracket (line) result(bracketed) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: line Return Value type( unicode_type ) Source Code subroutine test_pad () type ( ut ) :: string type ( ut ) :: answer ! string = 'abcdefghij' answer = '[abcdefghij          ]' call check ( 'pad' , bracket ( pad ( string , 20 )) == answer , 'pad on right till 20 characters long' ) answer = '[abcdefghij]' call check ( 'pad' , bracket ( pad ( string , 5 )) == answer , 'original is not truncated for short specified length' ) ! non-blank pattern ! pad on left call check ( 'pad' , pad ( ut ( '12' ), 5 , ut ( '0' ), right = . false .) == '00012' , 'pad on left with zeros' ) string = '12345 ' call check ( 'pad' , bracket ( pad ( string , 15 , ut ( '_' ), right = . false ., clip = . true .)) == '[__________12345]' ,& & character ( bracket ( pad ( string , 15 , ut ( '_' ), right = . false ., clip = . true .))) ) call check ( 'pad' , bracket ( pad ( string , 15 , ut ( '_' ), right = . false ., clip = . false .)) == '[_________12345 ]' ,& & character ( bracket ( pad ( string , 15 , ut ( '_' ), right = . false ., clip = . false .))) ) call check ( 'pad' , bracket ( pad ( string , 7 , ut ( '_' ), right = . false ., clip = . true .)) == '[__12345]' ,& & character ( bracket ( pad ( string , 7 , ut ( '_' ), right = . false ., clip = . true .))) ) call check ( 'pad' , bracket ( pad ( string , 7 , ut ( '_' ), right = . false ., clip = . false .)) == '[_12345 ]' ,& & character ( bracket ( pad ( string , 7 , ut ( '_' ), right = . false ., clip = . false .))) ) call check ( 'pad' , bracket ( pad ( ut ( '12345 ' ), 6 , ut ( '_' ), right = . false ., clip = . true .)) == '[_12345]' ,& & character ( bracket ( pad ( string , 6 , ut ( '_' ), right = . false ., clip = . true .))) ) call check ( 'pad' , bracket ( pad ( ut ( '12345 ' ), 6 , ut ( '_' ), right = . false ., clip = . false .)) == '[12345 ]' ,& & character ( bracket ( pad ( string , 6 , ut ( '_' ), right = . false ., clip = . false .))) ) call check ( 'pad' , bracket ( pad ( ut ( '12345 ' ), 5 , ut ( '_' ), right = . false ., clip = . true .)) == '[12345]' ,& & character ( bracket ( pad ( string , 5 , ut ( '_' ), right = . false ., clip = . true .))) ) call check ( 'pad' , bracket ( pad ( ut ( '12345 ' ), 5 , ut ( '_' ), right = . false ., clip = . false .)) == '[12345 ]' ,& & character ( bracket ( pad ( string , 5 , ut ( '_' ), right = . false ., clip = . false .))) ) call check ( 'pad' , bracket ( pad ( ut ( '12345 ' ), 4 , ut ( '_' ), right = . false ., clip = . true .)) == '[12345]' ,& & character ( bracket ( pad ( string , 4 , ut ( '_' ), right = . false ., clip = . true .))) ) call check ( 'pad' , bracket ( pad ( ut ( '12345 ' ), 4 , ut ( '_' ), right = . false ., clip = . false .)) == '[12345 ]' ,& & character ( bracket ( pad ( string , 4 , ut ( '_' ), right = . false ., clip = . false .))) ) contains function bracket ( line ) result ( bracketed ) type ( unicode_type ), intent ( in ) :: line type ( unicode_type ) :: bracketed bracketed = '[' . cat . line . cat . ']' end function bracket end subroutine test_pad","tags":"","url":"proc/test_pad.html"},{"title":"test_repeat ‚Äì M_unicode","text":"public  subroutine test_repeat() Arguments None Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: astr integer, public :: i type( unicode_type ), public :: ut_str Source Code subroutine test_repeat () character ( len = :), allocatable :: astr type ( unicode_type ) :: ut_str integer :: i ut_str = 'üí£üí•üí£üí•üí£üí•' astr = ut_str % character () ut_str = repeat ( ut_str , 5 ) call checkit ( 'repeat' , astr , ut_str % character (),& 'üí£üí•üí£üí•üí£üí•üí£üí•üí£üí•üí£üí•üí£üí•üí£üí•üí£üí•üí£üí•üí£üí•üí£üí•üí£üí•üí£üí•üí£üí•' ) ut_str = [( i , i = 48 , 57 )] ut_str = ut_str % character ( 2 , 10 ) // ut_str % character ( 1 , 1 ) call checkit ( 'repeat' , ut_str % character (), character ( repeat ( ut_str , 3 )), '123456789012345678901234567890' ) end subroutine test_repeat","tags":"","url":"proc/test_repeat.html"},{"title":"test_replace ‚Äì M_unicode","text":"public  subroutine test_replace() Arguments None Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: aline type( unicode_type ), public :: line Source Code subroutine test_replace () type ( unicode_type ) :: line character ( len = :), allocatable :: aline ! call check ( 'replace' ,& 'this is the string' == character ( replace ( ut ( 'Xis is Xe string' ), ut ( 'X' ), ut ( 'th' ) ) ) ) call check ( 'replace' ,& 'this is the string' == character ( replace ( ut ( 'Xis is xe string' ), ut ( 'x' ), ut ( 'th' ), ignorecase = . true .) ) ) call check ( 'replace' ,& 'this is xe string' == character ( replace ( ut ( 'Xis is xe string' ), ut ( 'X' ), ut ( 'th' ), ignorecase = . false .) ) ) call check ( 'replace' ,& 'BEFORE:my line of text' == character ( replace ( ut ( 'my line of text' ), ut ( '' ), ut ( 'BEFORE:' ))),& 'a null new substring means \"at beginning of line\"' ) ! call check ( 'replace' ,& 'I wonder' == character ( replace ( ut ( 'I wonder i ii iii' ), ut ( 'i' ), ut ( '' )) ),& 'a null new string deletes occurrences of the old substring' ) ! ! Examples of the use of RANGE ! line = replace ( ut ( 'aaaaaaaaa' ), ut ( 'a' ), ut ( 'A' ), occurrence = 1 , repeat = 1 ) call check ( 'replace' , line == ut ( 'Aaaaaaaaa' ), 'replace first a with A [' // line % character () // ']' ) ! line = replace ( ut ( 'aaaaaaaaa' ), ut ( 'a' ), ut ( 'A' ), occurrence = 3 , repeat = 3 ) call check ( 'replace' , line == ut ( 'aaAAAaaaa' ), 'replace a with A for 3rd to 5th occurrence [' // line % character () // ']' ) ! line = replace ( ut ( 'ababababa' ), ut ( 'a' ), ut ( '' ), occurrence = 3 , repeat = 3 ) call check ( 'replace' , line == ut ( 'ababbb' ), 'replace a with null instances 3 to 5 [' // line % character () // ']' ) ! line = replace ( & & ut ( 'a b ab baaa aaaa aa aa a a a aa aaaaaa' ),& & ut ( 'aa' ), ut ( 'CCCC' ), occurrence =- 1 , repeat = 1 ) call check ( 'replace' , line == ut ( 'a b ab baaa aaaa aa aa a a a aa aaaaCCCC' ), 'replace last aa with CCCC [' // line % character () // ']' ) ! line = replace ( ut ( 'myf90stuff.f90.f90' ), ut ( 'f90' ), ut ( 'for' ), occurrence =- 1 , repeat = 1 ) call check ( 'replace' , line == 'myf90stuff.f90.for' ) line = replace ( ut ( 'myf90stuff.f90.f90' ), ut ( 'f90' ), ut ( 'for' ), occurrence =- 2 , repeat = 2 ) call check ( 'replace' , line == 'myforstuff.for.f90' ) ! line = 'ABCDEFGHIJ' call check ( 'replace' , ut ( 'ABCdEFGHIJ' ) == replace ( line , 4 , 4 , 'd' ), 'replace a column ' ) call check ( 'replace' , ut ( 'ABCGHIJ' ) == replace ( line , 4 , 6 , '' ), 'remove columns in middle' ) call check ( 'replace' , ut ( 'ABCDE' ) == replace ( line , 6 , 10 , '' ), 'remove columns at end' ) call check ( 'replace' , ut ( 'ABCDEend' ) == replace ( line , 6 , 10 , 'end' ), 'replace end' ) call check ( 'replace' , ut ( 'startDEFGHIJ' ) == replace ( line , 1 , 3 , 'start' ), 'replace start' ) call check ( 'replace' , ut ( 'FGHIJ' ) == replace ( line , 1 , 5 , '' ), 'remove start ' // ch ( replace ( line , 1 , 5 , '' ))) ! ! combinations of character and string parameters call check ( 'replace' , ut ( 'ABC[def]GHIJ' ) == replace ( line , 'DEF' , '[def]' ), 'replace string' ) call check ( 'replace' , ut ( 'ABC[def]GHIJ' ) == replace ( line , ut ( 'DEF' ), ut ( '[def]' )), 'replace string' ) call check ( 'replace' , ut ( 'ABC[def]GHIJ' ) == replace ( line , 'DEF' , ut ( '[def]' )), 'replace string' ) call check ( 'replace' , ut ( 'ABC[def]GHIJ' ) == replace ( line , ut ( 'DEF' ), '[def]' ), 'replace string' ) aline = line call check ( 'replace' , ut ( 'ABC[def]GHIJ' ) == replace ( aline , 'DEF' , '[def]' ), 'replace string' ) call check ( 'replace' , ut ( 'ABC[def]GHIJ' ) == replace ( aline , ut ( 'DEF' ), ut ( '[def]' )), 'replace string' ) call check ( 'replace' , ut ( 'ABC[def]GHIJ' ) == replace ( aline , 'DEF' , ut ( '[def]' )), 'replace string' ) call check ( 'replace' , ut ( 'ABC[def]GHIJ' ) == replace ( aline , ut ( 'DEF' ), '[def]' ), 'replace string' ) !ifx bug!call check('replace',ut('ABC[def]GHIJ') == line%replace(   'DEF',    '[def]'), 'replace string') !ifx bug!call check('replace',ut('ABC[def]GHIJ') == line%replace(ut('DEF'),ut('[def]')),'replace string') !ifx bug!call check('replace',ut('ABC[def]GHIJ') == line%replace(   'DEF', ut('[def]')),'replace string') !ifx bug!call check('replace',ut('ABC[def]GHIJ') == line%replace(ut('DEF'),   '[def]'), 'replace string') !ifx bug!call check('replace',ut('ABCdEFGHIJ')  == line%replace(4,4,'d'),     'oop replace a column') !ifx bug!call check('replace',ut('ABCDE')       == line%replace(6,10,''),     'oop remove columns') !ifx bug!call check('replace',ut('ABCDEend')    == line%replace(6,10,'end'),  'oop replace end') !ifx bug!call check('replace',ut('startDEFGHIJ')== line%replace(1,3,'start'), 'oop replace start') end subroutine test_replace","tags":"","url":"proc/test_replace.html"},{"title":"test_scan ‚Äì M_unicode","text":"public  subroutine test_scan() Arguments None Variables Type Visibility Attributes Name Initial type( unicode_type ), public :: line type( unicode_type ), public :: set Source Code subroutine test_scan () type ( ut ) :: line type ( ut ) :: set !     1234567890123456789012345678901234567890 line = 'parsley?|sage?|rosemary?|?|thyme' line = 'parsleyüòÉ|sageüòÉ|rosemaryüòÉ|üòÉ|thyme' set = 'üòÉ|' call check ( 'scan' , scan ( line , set ) == 8 , 'default' ) call check ( 'scan' , scan ( line , set , back = . true .) == 27 , 'back=true' ) call check ( 'scan' , scan ( line , set , back = . false .) == 8 , 'back=false' ) call check ( 'scan' , scan ( line , unicode_type ( \"NOT\" )) == 0 , 'no match' ) ! OOP call check ( 'scan' , line % scan ( set ) == 8 , 'oop test' ) call check ( 'scan' , line % scan ( ut ( \"o\" )) == 17 , 'oop test' ) end subroutine test_scan","tags":"","url":"proc/test_scan.html"},{"title":"test_sort ‚Äì M_unicode","text":"public  subroutine test_sort() Arguments None Variables Type Visibility Attributes Name Initial type( unicode_type ), public, allocatable :: array (:) Subroutines subroutine chk () Arguments None Source Code subroutine test_sort () type ( unicode_type ), allocatable :: array (:) ! create using ASCII array ! -------------------------------- ! bug? ! array= [ 'red    ','green  ','blue   ','yellow ','orange ','black  ','white  ','brown  ','gray   ','cyan   ','magenta','purple '] ! Fortran runtime error: Array bound mismatch for dimension 1 of array 'array' (25769804402/12) ! -------------------------------- allocate ( array ( 12 )) ! gfortran requires this array (:) = [ 'red    ' , 'green  ' , 'blue   ' , 'yellow ' , 'orange ' , 'black  ' , 'white  ' , 'brown  ' , 'gray   ' , 'cyan   ' , 'magenta' , 'purple ' ] call chk () ! create using UNICODE_TYPE array array = [ ut ( 'RED' ), ut ( 'GREEN' ), ut ( 'BLUE' ), ut ( 'YELLOW' ), ut ( 'ORANGE' ), ut ( 'BLACK' ), & & ut ( 'WHITE' ), ut ( 'BROWN' ), ut ( 'GRAY' ), ut ( 'CYAN' ), ut ( 'MAGENTA' ), ut ( 'PURPLE' )] call chk () contains subroutine chk () integer :: temp integer :: csz integer :: i integer , allocatable :: ints (:) if ( allocated ( ints )) deallocate ( ints ) allocate ( ints ( size ( array ))) call sort ( array , ints ) csz = size ( array ) array = array ( ints ) temp = total call check ( 'sort' , all ( array ( 1 : csz - 1 ) . le . array ( 2 : csz )), 'sort array' ) ! verify in ascending order if ( total . ne . temp ) then do i = 1 , size ( array ) write ( * , g0 ) array ( i )% character () enddo endif end subroutine chk end subroutine test_sort","tags":"","url":"proc/test_sort.html"},{"title":"test_split ‚Äì M_unicode","text":"public  subroutine test_split() Arguments None Variables Type Visibility Attributes Name Initial type( unicode_type ), public, allocatable :: answer (:) type( unicode_type ), public :: delims type( unicode_type ), public, allocatable :: expected (:) integer, public :: first integer, public :: i integer, public :: last integer, public :: pos type( unicode_type ), public :: proverb Source Code subroutine test_split () type ( ut ) :: proverb type ( ut ) :: delims type ( ut ), allocatable :: expected (:) type ( ut ), allocatable :: answer (:) integer :: first integer :: last integer :: pos integer :: i delims = '=|; ' proverb = \"M√°s vale p√°jaro en mano, que ciento volando.\" expected = [ ut ( \"M√°s\" ), ut ( \"vale\" ), ut ( \"p√°jaro\" ), ut ( \"en\" ), ut ( \"mano,\" ), ut ( \"que\" ), ut ( \"ciento\" ), ut ( \"volando.\" ) ] pos = 0 i = 0 do while ( pos < len ( proverb )) first = pos + 1 call split ( proverb , delims , pos ) last = pos - 1 i = i + 1 call check ( 'split' , proverb % character ( first , last ) == expected ( i )% character () , expected ( i )% character () ) enddo ! OOP answer = proverb % split ( ut ( ' ' )) call check ( 'split' , size ( answer ) == size ( expected ) , 'size' ) if ( size ( answer ) == size ( expected ) ) then call check ( 'split' , all ( answer == expected ) , ' oop all at once' ) endif end subroutine test_split","tags":"","url":"proc/test_split.html"},{"title":"test_sub ‚Äì M_unicode","text":"public  subroutine test_sub() Arguments None Variables Type Visibility Attributes Name Initial type( unicode_type ), public :: line Source Code subroutine test_sub () type ( unicode_type ) :: line line = 'this is the string' call check ( 'sub' , 'this is the string' == character ( sub ( line ) ) ) call check ( 'sub' , 'the string' == character ( sub ( line , 9 ) ) ) call check ( 'sub' , 'this is ' == character ( sub ( line , 1 , 8 ) ) ) call check ( 'sub' , 'the string' == character ( sub ( line , 9 , len ( line )) ) ) call check ( 'sub' , 'is the' == character ( sub ( line , 6 , 11 ) ) ) call check ( 'sub' , 'this is the string' == character ( line % sub ( ) ) ) call check ( 'sub' , 'the string' == character ( line % sub ( 9 ) ) ) call check ( 'sub' , 'this is ' == character ( line % sub ( 1 , 8 ) ) ) call check ( 'sub' , 'the string' == character ( line % sub ( 9 , len ( line )) ) ) call check ( 'sub' , 'is the' == character ( line % sub ( 6 , 11 ) ) ) ! end subroutine test_sub","tags":"","url":"proc/test_sub.html"},{"title":"test_tokenize ‚Äì M_unicode","text":"public  subroutine test_tokenize() Arguments None Variables Type Visibility Attributes Name Initial integer, public, allocatable, dimension(:) :: begins type( unicode_type ), public :: delims integer, public, allocatable, dimension(:) :: ends type( unicode_type ), public, allocatable :: expected (:) type( unicode_type ), public :: herbs integer, public :: i character(len=:), public, allocatable :: line type( unicode_type ), public, allocatable :: separators (:) type( unicode_type ), public, allocatable :: tokens (:) Source Code subroutine test_tokenize () type ( unicode_type ), allocatable :: tokens (:), expected (:) type ( unicode_type ), allocatable :: separators (:) type ( unicode_type ) :: delims type ( unicode_type ) :: herbs character ( len = :), allocatable :: line integer , allocatable , dimension (:) :: begins integer , allocatable , dimension (:) :: ends integer :: i delims = ' ,&' herbs = 'parsley,sage,rosemary&thyme' expected = [ ut ( 'parsley' ), ut ( 'sage' ), ut ( 'rosemary' ), ut ( 'thyme' ) ] CALL TOKENIZE ( herbs , delims , tokens , separators ) line = 'tokens:' do i = 1 , size ( tokens ) line = line // '[' // tokens ( i )% character () // ']' enddo call check ( 'tokenize' , all ( tokens == expected ), line ) expected = [ ut ( ',' ), ut ( ',' ), ut ( '&' ) ] line = 'separators:' do i = 1 , size ( separators ) line = line // '[' // separators ( i )% character () // ']' enddo call check ( 'tokenize' , all ( separators == expected ), line ) CALL TOKENIZE ( herbs , delims , begins , ends ) call check ( 'tokenize' , size ( begins ) == 4 , 'size of begins' ) call check ( 'tokenize' , size ( ends ) == 4 , 'size of ends' ) if ( size ( begins ). eq . 4 . and . size ( ends ). eq . 4 ) then call check ( 'tokenize' , all ( begins == [ 1 , 9 , 14 , 23 ]) , 'begins' ) call check ( 'tokenize' , all ( ends == [ 7 , 12 , 21 , 27 ]) , 'ends' ) endif ! OOP herbs = 'parsleyüòÉsageüòÉrosemaryüòÉüòÉthyme' delims = 'üòÉ' expected = [ ut ( 'parsley' ), ut ( 'sage' ), ut ( 'rosemary' ), ut ( '' ), ut ( 'thyme' ) ] tokens = herbs % tokenize ( delims ) line = 'tokens:' do i = 1 , size ( tokens ) line = line // '[' // tokens ( i )% character () // ']' enddo call check ( 'tokenize' , all ( tokens == expected ), line ) end subroutine test_tokenize","tags":"","url":"proc/test_tokenize.html"},{"title":"test_transliterate ‚Äì M_unicode","text":"public  subroutine test_transliterate() Arguments None Variables Type Visibility Attributes Name Initial type( unicode_type ), public :: ANSWER type( unicode_type ), public :: EXPECTED type( unicode_type ), public :: LOWER type( unicode_type ), public :: MIDDLE_DOT type( unicode_type ), public :: STRING type( unicode_type ), public :: UPPER Source Code subroutine test_transliterate () type ( ut ) :: STRING , UPPER , LOWER , ANSWER , EXPECTED type ( ut ) :: MIDDLE_DOT ! ! | Œë Œ± | Œí Œ≤ | Œì Œ≥ | Œî Œ¥ | Œï Œµ | Œñ Œ∂   | ! | Œó Œ∑ | Œò Œ∏ | Œô Œπ | Œö Œ∫ | Œõ Œª | Œú Œº   | ! | Œù ŒΩ | Œû Œæ | Œü Œø | Œ† œÄ | Œ° œÅ | Œ£ œÉ œÇ | ! | Œ§ œÑ | Œ• œÖ | Œ¶ œÜ | Œß œá | Œ® œà | Œ© œâ   | ! STRING = 'ŒëŒ±ŒíŒ≤ŒìŒ≥ŒîŒ¥ŒïŒµŒñŒ∂ŒóŒ∑ŒòŒ∏ŒôŒπŒöŒ∫ŒõŒªŒúŒºŒùŒΩŒûŒæŒüŒøŒ†œÄŒ°œÅŒ£œÉœÇŒ§œÑŒ•œÖŒ¶œÜŒßœáŒ®œàŒ©œâ' ! ignoring œÇ for simplicity UPPER = 'ŒëŒíŒìŒîŒïŒñŒóŒòŒôŒöŒõŒúŒùŒûŒüŒ†Œ°Œ£Œ§Œ•Œ¶ŒßŒ®Œ©' LOWER = 'Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÉœÑœÖœÜœáœàœâ' ANSWER = TRANSLITERATE ( STRING , LOWER , UPPER ) ! convert ASCII-7 string to uppercase: EXPECTED = 'ŒëŒëŒíŒíŒìŒìŒîŒîŒïŒïŒñŒñŒóŒóŒòŒòŒôŒôŒöŒöŒõŒõŒúŒúŒùŒùŒûŒûŒüŒüŒ†Œ†Œ°Œ°Œ£Œ£œÇŒ§Œ§Œ•Œ•Œ¶Œ¶ŒßŒßŒ®Œ®Œ©Œ©' call check ( 'transliterate' , answer == expected , 'one-to-one correspondence' ) ANSWER = TRANSLITERATE ( STRING , LOWER , ':' ) ! change all miniscule letters to a colon (\":\"): EXPECTED = 'Œë:Œí:Œì:Œî:Œï:Œñ:Œó:Œò:Œô:Œö:Œõ:Œú:Œù:Œû:Œü:Œ†:Œ°:Œ£:œÇŒ§:Œ•:Œ¶:Œß:Œ®:Œ©:' call check ( 'transliterate' , answer == expected , 'set to a single character' ) ANSWER = TRANSLITERATE ( STRING , LOWER , '' ) ! delete all miniscule letters EXPECTED = 'ŒëŒíŒìŒîŒïŒñŒóŒòŒôŒöŒõŒúŒùŒûŒüŒ†Œ°Œ£œÇŒ§Œ•Œ¶ŒßŒ®Œ©' call check ( 'transliterate' , answer == expected , 'delete all miniscule letters' ) ! OOP EXPECTED = '_Œ±_Œ≤_Œ≥_Œ¥_Œµ_Œ∂_Œ∑_Œ∏_Œπ_Œ∫_Œª_Œº_ŒΩ_Œæ_Œø_œÄ_œÅ_œÉœÇ_œÑ_œÖ_œÜ_œá_œà_œâ' ANSWER = STRING % TRANSLITERATE ( UPPER , '_' ) call check ( 'transliterate' , answer == expected , 'OOP unicode:ASCII' ) ! U+00B7 Middle Dot Unicode Character EXPECTED = 'Œë¬∑Œí¬∑Œì¬∑Œî¬∑Œï¬∑Œñ¬∑Œó¬∑Œò¬∑Œô¬∑Œö¬∑Œõ¬∑Œú¬∑Œù¬∑Œû¬∑Œü¬∑Œ†¬∑Œ°¬∑Œ£¬∑œÇŒ§¬∑Œ•¬∑Œ¶¬∑Œß¬∑Œ®¬∑Œ©¬∑' ANSWER = STRING % TRANSLITERATE ( LOWER , '¬∑' ) ! ASCII bytes call check ( 'transliterate' , answer == expected , 'OOP unicode:ascii stream' ) EXPECTED = 'Œë¬∑Œí¬∑Œì¬∑Œî¬∑Œï¬∑Œñ¬∑Œó¬∑Œò¬∑Œô¬∑Œö¬∑Œõ¬∑Œú¬∑Œù¬∑Œû¬∑Œü¬∑Œ†¬∑Œ°¬∑Œ£¬∑œÇŒ§¬∑Œ•¬∑Œ¶¬∑Œß¬∑Œ®¬∑Œ©¬∑' ANSWER = STRING % TRANSLITERATE ( LOWER , ut ( '¬∑' )) ! cast call check ( 'transliterate' , answer == expected , 'OOP unicode:unicode' ) EXPECTED = 'Œë¬∑Œí¬∑Œì¬∑Œî¬∑Œï¬∑Œñ¬∑Œó¬∑Œò¬∑Œô¬∑Œö¬∑Œõ¬∑Œú¬∑Œù¬∑Œû¬∑Œü¬∑Œ†¬∑Œ°¬∑Œ£¬∑œÇŒ§¬∑Œ•¬∑Œ¶¬∑Œß¬∑Œ®¬∑Œ©¬∑' MIDDLE_DOT = int ( z '00B7' ) ANSWER = STRING % TRANSLITERATE ( LOWER , MIDDLE_DOT ) ! hexadecimal call check ( 'transliterate' , answer == expected , 'OOP unicode:unicode' ) end subroutine test_transliterate","tags":"","url":"proc/test_transliterate.html"},{"title":"test_trim ‚Äì M_unicode","text":"public  subroutine test_trim() Arguments None Variables Type Visibility Attributes Name Initial character(len=:), public, allocatable :: astr type( unicode_type ), public :: ut_str Source Code subroutine test_trim () character ( len = :), allocatable :: astr type ( unicode_type ) :: ut_str astr = \"  this is a string    \" ut_str = astr call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '  this is a string' ) astr = \"  \" ut_str = astr call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '' ) astr = \"\" ut_str = astr call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '' ) astr = \"ALLFULL\" ut_str = astr call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), 'ALLFULL' ) ut_str = [ 32 , 32 , int ( z '1F603' ), 32 , 32 , 32 ] astr = character ( ut_str ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '  üòÉ' ) end subroutine test_trim","tags":"","url":"proc/test_trim.html"},{"title":"test_upper ‚Äì M_unicode","text":"public  subroutine test_upper() Arguments None Variables Type Visibility Attributes Name Initial character(len=128), public :: ascii7 integer, public :: i type( unicode_type ), public :: low type( unicode_type ), public :: temp type( unicode_type ), public :: upp Source Code subroutine test_upper () type ( unicode_type ) :: upp , low , temp integer :: i character ( len = 128 ) :: ascii7 ! ! remember unicode characters are multi-byte so be careful ! with older compilers to not exceed 132 bytes per line ! low = '& &abcdefghijklmnopqrstuvwxyz√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨& &√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∏√π√∫√ª√º√Ω√æ√øƒÅƒÉƒÖƒáƒâƒãƒçƒèƒëƒìƒïƒóƒôƒõƒùƒüƒ°ƒ£ƒ•ƒßƒ©ƒ´ƒ≠& &ƒØƒ±ƒ≥ƒµƒ∑ƒ∫ƒºƒæ≈Ä≈Ç≈Ñ≈Ü≈à≈ã≈ç≈è≈ë≈ì≈ï≈ó≈ô≈õ≈ù≈ü≈°≈£≈•≈ß≈©≈´≈≠≈Ø≈±≈≥≈µ≈∑≈∫≈º≈æ& &∆É∆Ö∆à∆å∆í∆ô∆°∆£∆•∆®∆≠∆∞∆¥∆∂∆π∆Ω«Ü«â«å«é«ê«í«î«ñ«ò«ö«ú«ü«°«£«•«ß«©«´«≠«Ø«≥«µ«ª«Ω«ø& &»Å»É»Ö»á»â»ã»ç»è»ë»ì»ï»ó…ì…î…ó…ò…ô…õ…†…£…®…©…Ø…≤…µ É à ä ã íŒ¨Œ≠ŒÆŒØ& &Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÉœÑœÖœÜœáœàœâœäœãœåœçœéœ£œ•œßœ©œ´œ≠œØ–∞–±–≤–≥–¥–µ–∂–∑–∏–π& &–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è—ë—í—ì—î—ï—ñ—ó—ò—ô—ö—õ—ú—û—ü& &—°—£—•—ß—©—´—≠—Ø—±—≥—µ—∑—π—ª—Ω—ø“Å“ë“ì“ï“ó“ô“õ“ù“ü“°“£“•“ß“©“´“≠“Ø“±“≥“µ“∑“π“ª“Ω“ø”Ç”Ñ”à& &”å”ë”ì”ï”ó”ô”õ”ù”ü”°”£”•”ß”©”´”Ø”±”≥”µ”π’°’¢’£’§’•’¶’ß’®’©’™’´’¨’≠’Æ’Ø’∞’±’≤& &’≥’¥’µ’∂’∑’∏’π’∫’ª’º’Ω’æ’ø÷Ä÷Å÷Ç÷É÷Ñ÷Ö÷Ü·Éê·Éë·Éí·Éì·Éî·Éï·Éñ·Éó·Éò·Éô·Éö·Éõ·Éú·Éù·Éû·Éü·É†·É°·É¢·É£·É§·É•& &·É¶·Éß·É®·É©·É™·É´·É¨·É≠·ÉÆ·ÉØ·É∞·É±·É≤·É≥·É¥·Éµ·∏Å·∏É·∏Ö·∏á·∏â·∏ã·∏ç·∏è·∏ë·∏ì·∏ï·∏ó·∏ô·∏õ·∏ù·∏ü·∏°·∏£·∏•·∏ß& &·∏©·∏´·∏≠·∏Ø·∏±·∏≥·∏µ·∏∑·∏π·∏ª·∏Ω·∏ø·πÅ·πÉ·πÖ·πá·πâ·πã·πç·πè·πë·πì·πï·πó·πô& &·πõ·πù·πü·π°·π£·π•·πß·π©·π´·π≠·πØ·π±·π≥·πµ·π∑·ππ·πª·πΩ·πø& &·∫Å·∫É·∫Ö·∫á·∫â·∫ã·∫ç·∫è·∫ë·∫ì·∫ï·∫°·∫£·∫•·∫ß·∫©·∫´·∫≠·∫Ø·∫±·∫≥·∫µ·∫∑·∫π·∫ª·∫Ω·∫ø·ªÅ·ªÉ·ªÖ·ªá·ªâ·ªã·ªç·ªè·ªë·ªì·ªï·ªó& &·ªô·ªõ·ªù·ªü·ª°·ª£·ª•·ªß·ª©·ª´·ª≠·ªØ·ª±·ª≥·ªµ·ª∑·ªπ·ºÄ·ºÅ·ºÇ·ºÉ·ºÑ·ºÖ·ºÜ·ºá·ºê·ºë·ºí·ºì·ºî·ºï·º†·º°·º¢·º£·º§·º•·º¶·ºß·º∞·º±& &·º≤·º≥·º¥·ºµ·º∂·º∑·ΩÄ·ΩÅ·ΩÇ·ΩÉ·ΩÑ·ΩÖ·Ωë·Ωì·Ωï·Ωó·Ω†·Ω°·Ω¢·Ω£·Ω§·Ω•·Ω¶·Ωß·æÄ·æÅ·æÇ·æÉ·æÑ·æÖ·æÜ·æá·æê·æë·æí·æì·æî·æï·æñ·æó& &·æ†·æ°·æ¢·æ£·æ§·æ•·æ¶·æß·æ∞·æ±·øê·øë·ø†·ø°‚ìê‚ìë‚ìí‚ìì‚ìî‚ìï‚ìñ‚ìó‚ìò‚ìô‚ìö‚ìõ‚ìú‚ìù‚ìû‚ìü‚ì†‚ì°‚ì¢‚ì£‚ì§‚ì•‚ì¶‚ìß‚ì®‚ì©& &ÔΩÅÔΩÇÔΩÉÔΩÑÔΩÖÔΩÜÔΩáÔΩàÔΩâÔΩäÔΩãÔΩåÔΩçÔΩéÔΩèÔΩêÔΩëÔΩíÔΩìÔΩîÔΩïÔΩñÔΩóÔΩòÔΩôÔΩö' upp = '& &ABCDEFGHIJKLMNOPQRSTUVWXYZ√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã& &√å√ç√é√è√ê√ë√í√ì√î√ï√ñ√ò√ô√ö√õ√ú√ù√û≈∏ƒÄƒÇƒÑƒÜƒàƒäƒåƒéƒêƒíƒîƒñƒòƒöƒúƒûƒ†ƒ¢ƒ§ƒ¶ƒ®ƒ™ƒ¨& &ƒÆIƒ≤ƒ¥ƒ∂ƒπƒªƒΩƒø≈Å≈É≈Ö≈á≈ä≈å≈é≈ê≈í≈î≈ñ≈ò≈ö≈ú≈û≈†≈¢≈§≈¶≈®≈™≈¨≈Æ≈∞≈≤≈¥≈∂≈π≈ª& &≈Ω∆Ç∆Ñ∆á∆ã∆ë∆ò∆†∆¢∆§∆ß∆¨∆Ø∆≥∆µ∆∏∆º«Ñ«á«ä«ç«è«ë«ì«ï«ó«ô«õ«û«†«¢«§«¶«®«™«¨«Æ«±«¥«∫«º«æ& &»Ä»Ç»Ñ»Ü»à»ä»å»é»ê»í»î»ñ∆Å∆Ü∆ä∆é∆è∆ê∆ì∆î∆ó∆ñ∆ú∆ù∆ü∆©∆Æ∆±∆≤∆∑ŒÜŒàŒâŒäŒëŒíŒìŒîŒïŒñŒóŒò& &ŒôŒöŒõŒúŒùŒûŒüŒ†Œ°Œ£Œ§Œ•Œ¶ŒßŒ®Œ©Œ™Œ´ŒåŒéŒèœ¢œ§œ¶œ®œ™œ¨œÆ–ê–ë–í–ì–î–ï–ñ–ó–ò–ô& &–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–Å–Ç–É–Ñ–Ö–Ü–á–à–â–ä–ã–å–é–è—†—¢—§—¶—®—™—¨& &—Æ—∞—≤—¥—∂—∏—∫—º—æ“Ä“ê“í“î“ñ“ò“ö“ú“û“†“¢“§“¶“®“™“¨“Æ“∞“≤“¥“∂“∏“∫“º“æ”Å”É”á& &”ã”ê”í”î”ñ”ò”ö”ú”û”†”¢”§”¶”®”™”Æ”∞”≤”¥”∏‘±‘≤‘≥‘¥‘µ‘∂‘∑‘∏‘π‘∫‘ª‘º‘Ω‘æ‘ø’Ä’Å’Ç’É’Ñ& &’Ö’Ü’á’à’â’ä’ã’å’ç’é’è’ê’ë’í’ì’î’ï’ñ·Ç†·Ç°·Ç¢·Ç£·Ç§·Ç•·Ç¶·Çß·Ç®·Ç©·Ç™·Ç´·Ç¨·Ç≠·ÇÆ·ÇØ·Ç∞·Ç±·Ç≤·Ç≥·Ç¥·Çµ& &·Ç∂·Ç∑·Ç∏·Çπ·Ç∫·Çª·Çº·ÇΩ·Çæ·Çø·ÉÄ·ÉÅ·ÉÇ·ÉÉ·ÉÑ·ÉÖ·∏Ä·∏Ç·∏Ñ·∏Ü·∏à·∏ä·∏å·∏é·∏ê·∏í·∏î·∏ñ·∏ò·∏ö·∏ú·∏û·∏†·∏¢·∏§·∏¶·∏®·∏™·∏¨·∏Æ& &·∏∞·∏≤·∏¥·∏∂·∏∏·∏∫·∏º·∏æ·πÄ·πÇ·πÑ·πÜ·πà·πä·πå·πé·πê·πí·πî·πñ·πò·πö·πú·πû·π†·π¢·π§·π¶·π®·π™·π¨·πÆ·π∞·π≤·π¥·π∂·π∏·π∫·πº·πæ& &·∫Ä·∫Ç·∫Ñ·∫Ü·∫à·∫ä·∫å·∫é·∫ê·∫í·∫î·∫†·∫¢·∫§·∫¶·∫®·∫™·∫¨·∫Æ·∫∞·∫≤·∫¥·∫∂·∫∏·∫∫·∫º·∫æ·ªÄ·ªÇ·ªÑ·ªÜ·ªà·ªä& &·ªå·ªé·ªê·ªí·ªî·ªñ·ªò·ªö·ªú·ªû·ª†·ª¢·ª§·ª¶·ª®·ª™·ª¨·ªÆ·ª∞·ª≤·ª¥·ª∂·ª∏& &·ºà·ºâ·ºä·ºã·ºå·ºç·ºé·ºè·ºò·ºô·ºö·ºõ·ºú·ºù·º®·º©·º™·º´·º¨·º≠·ºÆ·ºØ·º∏·ºπ& &·º∫·ºª·ºº·ºΩ·ºæ·ºø·Ωà·Ωâ·Ωä·Ωã·Ωå·Ωç·Ωô·Ωõ·Ωù·Ωü·Ω®·Ω©·Ω™·Ω´·Ω¨·Ω≠·ΩÆ·ΩØ& &·æà·æâ·æä·æã·æå·æç·æé·æè·æò·æô·æö·æõ·æú·æù·æû·æü·æ®·æ©·æ™·æ´·æ¨·æ≠·æÆ·æØ·æ∏·æπ& &·øò·øô·ø®·ø©‚í∂‚í∑‚í∏‚íπ‚í∫‚íª‚íº‚íΩ‚íæ‚íø‚ìÄ‚ìÅ‚ìÇ‚ìÉ‚ìÑ‚ìÖ‚ìÜ‚ìá‚ìà‚ìâ‚ìä‚ìã‚ìå‚ìç‚ìé‚ìè& &Ôº°Ôº¢Ôº£Ôº§Ôº•Ôº¶ÔºßÔº®Ôº©Ôº™Ôº´Ôº¨Ôº≠ÔºÆÔºØÔº∞Ôº±Ôº≤Ôº≥Ôº¥ÔºµÔº∂Ôº∑Ôº∏ÔºπÔº∫' call check ( 'upper' , upper ( low ) == upp ) call check ( 'upper' , character ( upper ( low )) == character ( upp ) ) call check ( 'upper' , upper ( low ) == upp ) write ( ascii7 , g0 )( achar ( i ), i = 0 , 127 ) ascii7 ( ichar ( 'a' ) + 1 : ichar ( 'z' ) + 1 ) = ' ' ascii7 ( ichar ( 'A' ) + 1 : ichar ( 'Z' ) + 1 ) = ' ' temp = ascii7 call check ( 'upper' , temp % character () == ascii7 , 'check non-alphameric like' // ascii7 ( ichar ( ' ' ) + 1 : len ( ascii7 ) - 1 ) ) call check ( 'upper' , upper ( temp ) == lower ( temp ), 'expect no difference' ) call check ( 'upper' , temp == upper ( temp ), 'expect no change' ) call check ( '%upper' , low % upper () == upp ) call check ( '%upper' , character ( low % upper ()) == character ( upp ) ) end subroutine test_upper","tags":"","url":"proc/test_upper.html"},{"title":"test_verify ‚Äì M_unicode","text":"public  subroutine test_verify() Arguments None Variables Type Visibility Attributes Name Initial type( unicode_type ), public :: chars character(len=*), public, parameter :: hex = 'abcdefABCDEF0123456789' character(len=*), public, parameter :: int = '1234567890' logical, public :: lout type( unicode_type ), public :: str Source Code subroutine test_verify () character ( len =* ), parameter :: int = '1234567890' character ( len =* ), parameter :: hex = 'abcdefABCDEF0123456789' logical :: lout type ( unicode_type ) :: chars type ( unicode_type ) :: str chars = '32‚Äêaf43d' lout = . true . ! are the first two characters integer characters? str = chars % character ( 1 , 2 ) lout = ( verify ( str , ut ( int ) ) == 0 ) . and . lout ! is the third character a dash? str = chars % character ( 3 , 3 ) lout = ( verify ( str , ut ( '‚Äê-' ) ) == 0 ) . and . lout ! is remaining string a valid representation of a hex value? str = chars % character ( 4 , 8 ) lout = ( verify ( str , ut ( hex ) ) == 0 ) . and . lout call check ( 'verify' , lout , chars % character () ) end subroutine test_verify","tags":"","url":"proc/test_verify.html"},{"title":"printme ‚Äì M_unicode","text":"subroutine printme(label) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label Source Code subroutine printme ( label ) character ( len =* ), intent ( in ) :: label write ( * , '(a,\"[\",g0,\"]\",/)' ) label , piece % character () end subroutine printme","tags":"","url":"proc/printme.html"},{"title":"M_unicode ‚Äì M_unicode","text":"NAME M_unicode(3f) - [M_unicode::INTRO] Unicode string module\n (LICENSE:MIT) DESCRIPTION The M_unicode ( 3 f ) module is a collection of Fortran string methods that work with UTF - 8 - encoded as well as ASCII - 7 data via the user - defined type \"unicode_type\" . The type supports allocatable ragged arrays where each element may be of differing length . M_unicode ( 3 f ) includes routines for parsing , tokenizing , changing case , substituting new strings for substrings , locating strings with simple wildcard expressions , removing tabs and line terminators and other string manipulations . The M_unicode ( 3 fm ) module also supplements the Fortran built - in intrinsics with overloads of operators and intrinsics that allow type ( unicode_type ) to be used with intrinsic names in much the same manner the intrinsics operate on CHARACTER variables . Overloads of assignment , logical comparisons , and concatenation using the // operator with strings ( and other types ) are included as well as the intrinsics to make use of type ( unicode_type ) largely consistent with standard CHARACTER string manipulations . Nearly all the methods are available using OOP syntax as well as procedurally . The type components are not public to allow for use of the same user code when using other modules such as M_utf8 which ultimately will provide the same user interface but internally using ISO_10646 internal encoding instead of an array of integers containing codepoints ( which is what M_unicode uses ) . This has the drawback of not permitting easy use of array syntax directly on the codepoint array . Perhaps this decision will change but in the meantime several methods such as REPLACE and CHARACTER and SUB SYNOPSIS public methods: TOKENS split subroutine parses string using specified delimiter characters into tokens tokenize Parse a string into tokens . EDITING replace function non - recursively globally replaces old substring with new substring transliterate replace characters from old set with new set CASE upper function converts string to uppercase lower function converts string to miniscule STRING LENGTH len return the length of a string in glyphs len_trim find location of last non - whitespace glyph PADDING pad pad string to at least specified length with pattern string WHITE SPACE trim Remove trailing blank characters of a string expandtabs expand tab characters adjustl Left adjust a string adjustr Right adjust a string ENCODING character ( STRING , start , end , inc ) converts a string to type CHARACTER . escape expand C - like escape strings codepoints_to_utf8 ( codepoints , utf8 , nerr ) subroutine to convert codepoints to UTF - 8 bytes utf8_to_codepoints ( utf8 , codepoints , nerr ) subroutine to convert UTF - 8 bytes to codepoints STRING % character ( start , end , inc ) OOP syntax for converting a string to type CHARACTER . STRING % bytes ( start , end , inc ) Convert to an array of CHARACTER ( len = 1 ) bytes . STRING % codepoint ( start , end , inc ) converts a string to an INTEGER array of Unicode codepoints char converts an integer codepoint into a character ichar converts a type ( unicode_type ) glyph into an integer codepoint NUMERIC STRINGS fmt convert intrinsic to string using optional format CHARACTER TESTS ! based on Unicode codepoint , not dictionary order lgt Lexical greater than lge Lexical greater than or equal leq Lexical equal lne Lexical not equal lle Lexical less than or equal llt Lexical less than IO readline read a text line from a file LOCATION index Position of a substring within a string scan Scan a string for the presence of a set of characters verify Scan a string for the absence of a set of characters CONCATENATION join join elements of an array into a single string operator ( . cat . ), operator ( // ) concatenate strings and / or convert intrinsics to strings and concatenate SYSTEM get_env Get environment variable get_arg Get command line argument MISCELLANEOUS repeat Repeated string concatenation sort Sort by Unicode codepoint value ( not dictionary order ) BASE CONVERSION QUOTES NONALPHA OOPS INTERFACE An OOP ( Object - Oriented Programming ) interface to the M_unicode ( 3 fm ) module provides an alternative interface to all the same procedures except for SORT ( 3 f ) and CHAR ( 3 f ) . SEE ALSO All the procedure descriptions are conglomerated into the single file \"manual.txt\" for simple access not requiring access to man - pages or browsers . There are additional routines in other GPF modules for working with expressions ( M_calculator ), time strings ( M_time ), random strings ( M_random , M_uuid ), lists ( M_list ), and interfacing with the C regular expression library ( M_regex ). EXAMPLES Each of the procedures includes an example program in the example / directory as well as a corresponding man ( 1 ) page for the procedure . Sample program: program demo_M_unicode use , intrinsic :: iso_fortran_env , only : stdout = > output_unit use M_unicode,only : tokenize, replace, character, upper, lower, len use M_unicode,only : unicode_type, assignment(=), operator(//) use M_unicode,only : ut = > unicode_type , ch = > character use M_unicode,only : write(formatted) type ( unicode_type ) :: string type ( unicode_type ) :: numeric , uppercase , lowercase type ( unicode_type ), allocatable :: array (:) character ( len = * ), parameter :: all = '(g0)' !character(len=*),parameter     :: uni='(DT)' uppercase = '–ê–ë–í–ì“ê–î–ï–Ñ–ñ–ó–ò–Ü–á–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–¨–Æ–Ø' lowercase = '–∞–±–≤–≥“ë–¥–µ—î–∂–∑–∏—ñ—ó–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—å—é—è' numeric = '0123456789' ! string = uppercase // numeric // lowercase ! print all , 'Original string:' print all , ch ( string ) print all , 'length in bytes :' , len ( string %character()) print all , 'length in glyphs:' , len ( string ) print all ! print all , 'convert to all uppercase:' print all , ch ( UPPER ( string ) ) print all ! print all , 'convert to all lowercase:' print all , ch ( string %LOWER() ) print all ! print all , 'tokenize on spaces ... ' call TOKENIZE ( string , ut ( ' ' ), array ) print all , '... writing with A or G format:' , character ( array ) ! print uni , ut ( '... writing with DT format' ), array print all ! print all , 'case-insensitive replace:' print all , ch ( & & REPLACE ( string , & & ut ( '–∫–ª–º–Ω–æ–ø—Ä—Å' ), & & ut ( '--------' ), & & ignorecase =. true .) ) ! print all ! end program demo_M_unicode Results: > Original string:\n> –ê–ë–í–ì“ê–î–ï–Ñ–ñ–ó–ò–Ü–á–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–¨–Æ–Ø0123456789 ...\n> –∞–±–≤–≥“ë–¥–µ—î–∂–∑–∏—ñ—ó–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—å—é—è\n> length in bytes :\n> 144\n> length in glyphs:\n> 78\n>\n> convert to all uppercase:\n> –ê–ë–í–ì“ê–î–ï–Ñ–ñ–ó–ò–Ü–á–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–¨–Æ–Ø0123456789 ...\n> –ê–ë–í–ì“ê–î–ï–Ñ–ñ–ó–ò–Ü–á–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–¨–Æ–Ø\n>\n>\n> tokenize on spaces ...\n> ... writing with A or G format:\n> –ê–ë–í–ì“ê–î–ï–Ñ–ñ–ó–ò–Ü–á–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–¨–Æ–Ø\n> 0123456789\n> –∞–±–≤–≥“ë–¥–µ—î–∂–∑–∏—ñ—ó–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—å—é—è\n> ... writing with DT format\n> –ê–ë–í–ì“ê–î–ï–Ñ–ñ–ó–ò–Ü–á–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–¨–Æ–Ø\n> 0123456789\n> –∞–±–≤–≥“ë–¥–µ—î–∂–∑–∏—ñ—ó–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—å—é—è\n>\n> case-insensitive replace:\n> –ê–ë–í–ì“ê–î–ï–Ñ–ñ–ó–ò–Ü–á–ô--------–¢–£–§–•–¶–ß–®–©–¨–Æ–Ø0123456789 ...\n> –∞–±–≤–≥“ë–¥–µ—î–∂–∑–∏—ñ—ó–π--------—Ç—É—Ñ—Ö—Ü—á—à—â—å—é—è AUTHOR John S. Urban LICENSE MIT Write string to connected formatted unit. In computing, Unicode characters are typically sorted using one of two methods: a simple binary code point sort or a more sophisticated,\n language-sensitive collation. The correct approach depends on whether a\n linguistically accurate ‚Äúalphabetical‚Äù order is needed or if a simple,\n fixed order is sufficient. Binary code point sort This is the simplest and fastest method, often used as a default by\n programming languages and databases. How it works: Strings are sorted based on the numeric value of their underlying Unicode code points . For example , a character with a code point of U + 0061 ( lowercase \"a\" ) will always be placed before U + 0062 ( lowercase \"b\" ) because 97 is less than 98. Limitations: While this works for the basic English alphabet , it produces non - intuitive results for other characters because the code point value does not correlate with linguistic sorting rules . For instance , it may place: Uppercase letters before all lowercase letters ( Z comes before a ). Accented letters in an order that is not linguistically correct for a given language ( e . g ., in German , an umlauted character like √∂ might be sorted differently than a plain o ). Characters from different scripts ( like Latin , Greek , and Cyrillic ) in an order determined solely by their assigned code point blocks . Unicode Collation Algorithm (UCA) This is the standard, more robust method for sorting that produces\n correct, language-sensitive results. It is described in Unicode Technical\n Standard #10. How it works: Instead of sorting by a single numeric value , the UCA uses a multi - level approach to determine a sort key for each string . The algorithm takes into account the specific rules ( or \"tailorings\" ) of a given language or locale , which are defined in the Common Locale Data Repository ( CLDR ). Multi - level sorting: The UCA uses a hierarchy of weights for each character: Primary: Compares the base letter , ignoring case and accents . This groups all versions of \"a\" ( a , √° , A , √Å ) together . Secondary: Compares accents and diacritics . This establishes the order for different versions of the same base letter ( e . g ., o , √≥ , √¥ ). Tertiary: Compares case differences ( uppercase vs . lowercase ). Quaternary: Deals with other special features , such as handling punctuation . Locale - specific rules: The UCA can apply different rules based on a user ' s location . For example: In German phonebooks , umlauted letters ( √§ ) are often sorted as if they were ae . In other contexts , they are sorted with their base letter ( a ). The correct sorting order for Chinese characters can be based on pronunciation ( Pinyin ) or stroke count , depending on the dictionary or region . How to choose a sorting method Use binary sorting for performance when linguistic order doesn ' t matter . This is fine for internal data processing where you just need a consistent , quick sort . Use the UCA for user - facing applications where culturally appropriate sorting is critical . If your application supports multiple languages , you must use a language - sensitive collator to provide the sorting users will expect . Most modern programming languages and databases have built - in libraries that implement the Unicode Collation Algorithm . Uses iso_fortran_env Variables Type Visibility Attributes Name Initial type(unicode_codepoints), public, parameter :: unicode = unicode_codepoints(upper=up_to_low(:, 2), lower=low_to_up(:, 2), hexadecimal=[hexchars], bom=[int(z'FEFF')], spaces=spacescodes) Interfaces public        interface adjustl private elemental function adjustl_str(string, glyphs) result(adjusted) NAME ADJUSTL(3f) - [M_unicode:WHITESPACE] Left-justified a string\n                 (LICENSE:MIT) SYNOPSIS result = adjustl(string,glyphs) function adjustl(string,glyphs) result ( out ) type ( unicode_type ), intent ( in ) :: string integer , intent ( in ), optional :: glyphs type ( unicode_type ) :: out CHARACTERISTICS STRING is a string variable of type(unicode_type) GLYPHS is a default integer The return value is a string variable of type(unicode_type) DESCRIPTION adjustl(3) will left-justify a string by removing leading spaces. Spaces\n   are inserted at the end of the string as needed to keep the number of\n   glyphs on output the same as the number on input unless overridden by\n   the GLYPHS parameter. OPTIONS STRING : the string to left-justify GLYPHS : the length of the output in glyphs RESULT A copy of STRING where leading spaces are removed and the same\n   number of spaces are inserted on the end of STRING unless GLYPHS is\n   specified. Note using GLYPHS can cause in string truncation. EXAMPLES Sample program: program demo_adjustl use M_unicode , only : ut => unicode_type use M_unicode , only : ch => character use M_unicode , only : adjustl , trim , len_trim , verify use M_unicode , only : write ( formatted ) use M_unicode , only : assignment (=) implicit none type ( ut ) :: usample , uout integer :: istart , iend character ( len = * ), parameter :: adt = ' ( a , \"[\" , DT , \"]\" ) ' ! ! basic use usample = ' sample string ' write ( * , adt ) ' original : ' , usample ! ! note a string stays the same length ! and is not trimmed by just an adjustl ( 3 ) call . write ( * , adt ) ' adjusted : ' , adjustl ( usample ) ! ! a fixed ‚Äê length string can be trimmed using trim ( 3 ) uout = trim ( adjustl ( usample )) write ( * , adt ) ' trimmed : ' , uout ! ! or alternatively you can select a substring without adjusting istart = max ( 1 , verify ( usample , ' ' )) ! first non ‚Äê blank character iend = len_trim ( usample ) write ( * , adt ) ' substring : ' , usample % sub ( istart , iend ) ! write ( * , adt ) ' substring : ' , adjustl ( usample , 30 ) write ( * , adt ) ' substring : ' , adjustl ( usample , 20 ) write ( * , adt ) ' substring : ' , adjustl ( usample , 10 ) write ( * , adt ) ' substring : ' , adjustl ( usample , 0 ) end program demo_adjustl Results: > original : [ sample string ] > adjusted : [ sample string ] > trimmed : [ sample string ] > substring : [ sample string ] SEE ALSO ADJUSTR(3), TRIM(3) AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in), optional :: glyphs Return Value type( unicode_type ) public        interface adjustr private impure elemental function adjustr_str(string, glyphs) result(adjusted) NAME ADJUSTR(3f) - [M_unicode:WHITESPACE] right-justify a string\n                 (LICENSE:MIT) SYNOPSIS result = adjustr(string,glyphs) elemental function adjustr ( string ) type ( unicode_type ) :: adjustr type ( unicode_type ), intent ( in ) :: string integer , intent ( in ), optional :: glyphs CHARACTERISTICS STRING is a string variable GLYPHS is a default integer the return value is a string variable DESCRIPTION ADJUSTR(3) right-justifies a string by removing trailing spaces. Spaces\n   are inserted at the start of the string as needed to retain the\n   original length unless an explicit return length is specified by the\n   GLYPHS parameter. OPTIONS STRING : the string to right-justify GLYPHS : length in glyphs to extend to or truncate to RESULT trailing spaces are removed and the same number of spaces are then\n   inserted at the start of string. EXAMPLES sample program: program demo_adjustr\n   use M_unicode, only : ut=>unicode_type\n   use M_unicode, only : adjustr, len\n   use M_unicode, only : write(formatted)\n   use M_unicode, only : assignment(=)\n   implicit none\n   type(ut)                   :: str\n   type(ut),allocatable       :: array(:)\n   integer                    :: i\n   character(len= ),parameter :: bracket=‚Äô(‚Äú[‚Äú,DT,‚Äù]‚Äù)‚Äô\n       !\n       call numberline(2)\n       !\n       ! basic usage\n       str = ‚Äô  sample string     ‚Äô\n       write( ,bracket) str\n       str = adjustr(str)\n       write( ,bracket) str\n       !\n       call numberline(5)\n       !\n       ! elemental\n       array=ut([character(len=50) :: &\n       ‚Äô    ‡§è‡§ï (ek) ‚Äò, &\n       ‚Äô       ‡§¶‡•ã (do) ‚Äò, &\n       ‚Äô          ‡§§‡•Ä‡§®(teen) ‚Äô ])\n       !\n       ! print array unadjusted\n       write( ,bracket)array\n       !do i=1,size(array)\n       !   write( ,‚Äô( (g0,1x))‚Äô)array(i)%codepoint()\n       !enddo\n       ! note 50 bytes is not necessarily 50 glyphs\n       write( ,‚Äô( (g0,1x))‚Äô)‚Äôlength in glyphs=‚Äô,len(array)\n       write( ,‚Äô( (g0,1x))‚Äô)‚Äôlength in bytes=‚Äô,(len(array(i)%character()),i=1,size(array))\n       !\n       call numberline(5)\n       !\n       ! print array right-justified\n       write( ,bracket)adjustr(array)\n       !\n       call numberline(5)\n       !\n       ! print array right-justified specifying number of glyphs\n       write( , )‚Äôset to 50‚Äô\n       write( ,bracket)adjustr(array,50)\n       !\n       write( , )‚Äôset to 60‚Äô\n       call numberline(6)\n       write( ,bracket)adjustr(array,60)\n       write( , )‚Äôset to 40‚Äô\n       call numberline(4)\n       write( ,bracket)adjustr(array,40)\n       write( , )‚Äôset to 10‚Äô\n       call numberline(1)\n       write( ,bracket)adjustr(array,10)\n       write( , )‚Äôset to 5‚Äô\n       write( ,bracket)adjustr(array,5)\n       write( , )‚Äôset to 4‚Äô\n       write( ,bracket)adjustr(array,4)\n       write( , )‚Äôset to 1‚Äô\n       write( ,bracket)adjustr(array,1)\n    contains\n       !\n       subroutine numberline(ireps)\n       integer,intent(in) :: ireps\n          write(*,‚Äô(1x,a)‚Äô)repeat(‚Äò1234567890‚Äô,ireps)\n       end subroutine numberline\n    end program demo_adjustr Results: > 12345678901234567890 > [ sample string ] > [ sample string ] > 12345678901234567890123456789012345678901234567890 > [ ‡§è‡§ï ( ek ) ] > [ ‡§¶ ‡•ã ( do ) ] > [ ‡§§ ‡•Ä ‡§® ( teen ) ] > length in glyphs = 46 46 44 > length in bytes = 50 50 50 > 12345678901234567890123456789012345678901234567890 > [ ‡§è‡§ï ( ek )] > [ ‡§¶ ‡•ã ( do )] > [ ‡§§ ‡•Ä ‡§® ( teen )] > 12345678901234567890123456789012345678901234567890 > set to 50 > [ ‡§è‡§ï ( ek )] > [ ‡§¶ ‡•ã ( do )] > [ ‡§§ ‡•Ä ‡§® ( teen )] > set to 60 > 123456789012345678901234567890123456789012345678901234567890 > [ ‡§è‡§ï ( ek )] > [ ‡§¶ ‡•ã ( do )] > [ ‡§§ ‡•Ä ‡§® ( teen )] > set to 40 > 1234567890123456789012345678901234567890 > [ ‡§è‡§ï ( ek )] > [ ‡§¶ ‡•ã ( do )] > [ ‡§§ ‡•Ä ‡§® ( teen )] > set to 10 > 1234567890 > [ ‡§è‡§ï ( ek )] > [ ‡§¶ ‡•ã ( do )] > [ ‡§§ ‡•Ä ‡§® ( teen )] > set to 5 > [ ( ek )] > [ ( do )] > [ teen )] > set to 4 > [( ek )] > [( do )] > [ een )] > set to 1 > [)] > [)] > [)] SEE ALSO ADJUSTL(3), TRIM(3) AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in), optional :: glyphs Return Value type( unicode_type ) public        interface assignment(=) private elemental subroutine assign_str_char(lhs, rhs) Assign a character sequence to a string. Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(inout) :: lhs character(len=*), intent(in) :: rhs private  subroutine assign_strs_char(lhs, rhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(inout) :: lhs character(len=*), intent(in) :: rhs (:) private elemental subroutine assign_str_code(lhs, rhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(inout) :: lhs integer, intent(in) :: rhs private  subroutine assign_str_codes(lhs, rhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(inout) :: lhs integer, intent(in) :: rhs (:) private  subroutine assign_char_str(lhs, rhs) Assign a string to a character sequence Arguments Type Intent Optional Attributes Name character(len=:), intent(inout), allocatable :: lhs type( unicode_type ), intent(in) :: rhs private  subroutine assign_ints_str(lhs, rhs) Assign a string to a character sequence Arguments Type Intent Optional Attributes Name integer, intent(inout), allocatable :: lhs (:) type( unicode_type ), intent(in) :: rhs public        interface character private pure function str_to_char(string) result(aline) NAME CHARACTER ( 3 f ) - [ M_unicode : WHITESPACE ] convert type ( unicode_type ) string to a CHARACTER variable ( LICENSE : MIT ) SYNOPSIS result = character ( STRING , start , end , inc ) or result = STRING % character ( start , end , inc ) elemental function character ( string , start , end , inc ) type ( unicode_type ), intent ( in ) :: string integer , intent ( in ) :: start integer , intent ( in ) :: end integer , intent ( in ) :: inc CHARACTERISTICS STRING is a scalar or array string variable the returned value is a CHARACTER scalar or array DESCRIPTION CHARACTER(3f) returns a CHARACTER variable given a string variable\n   of type type(unicode_type). OPTIONS STRING : A scalar or array string to convert to intrinsic CHARACTER\n              type. RESULT The result converts each string to bytes stored in CHARACTER variables.\n   All elements will be padded to the same length of the longest element;\n   as all elements of a CHARACTER array are required to be of the same length. Commonly used to pass data to procedures requiring CHARACTER variables\n   or for printing when the DT format is not used.. EXAMPLES Sample program program demo_character use M_unicode , only : ut => unicode_type , ch => character , trim , len , pad use M_unicode , only : write ( formatted ), assignment ( = ) type ( ut ) :: ustr type ( ut ), allocatable :: array (:) integer :: i character ( len =* ), parameter :: all = '(*(g0))' ustr = [ 949 , 8021 , 961 , 951 , 954 , 945 , 33 ] ! eureka in codepoints ! when doing I / O using DT might be the most intuitive ! but sometimes converting to intrinsic character variables ! is preferred write ( * , all ) ch ( ustr ) ! convert to CHARACTER variable write ( * , all ) ustr % character () ! convert to CHARACTER variable ! you can select a range of glyphs write ( * , all ) ustr % character ( 3 , 4 ) ! similar to LINE ( 3 : 4 ) for ! CHARACTER variables ! and even reverse a string write ( * , all ) ustr % character ( len ( ustr ), 1 , - 1 ) ! reverse string ! note that OOP syntax provides a few other options write ( * , all ) ustr % byte () ! convert to CHARACTER ( LEN = 1 ) type ! arrays ! ! using this syntax make sure to make the LEN value large enough ! that glyphs can take up to four bytes array = ut ([ character ( len = 60 ) :: & 'Confucius never claimed to be a prophet, ' , & 'but I think he foresaw AI! He said ' , & '' , & ' \"Â≠¶ËÄå‰∏çÊÄùÂàôÁΩîÔºåÊÄùËÄå‰∏çÂ≠¶ÂàôÊÆÜ\"' , & 'or' , & ' (xu√© √©r b√π sƒ´ z√© w«éng, sƒ´ √©r b√π xu√© z√© d√†i),' , & 'which is also' , & ' \"To learn without thinking is to be lost, ' , & ' to think without learning is to be in danger\".' ]) ! write ( * , '(*(:,\"[\",g0,\"]\",/))' ) ch ( array ) ! all elements will be the same length in bytes but not necessarily ! in glyphs write ( * , '(a,*(i0,1x))' ) 'all elements the same length in BYTES:' , & & len ( ch ( array )) write ( * , '(a,*(i0,1x))' ) 'lengths (in glyphs):' , len ( array ) array = trim ( array ) write ( * , '(a,*(i0,1x))' ) 'lengths after trimming (in glyphs):' , & & len ( array ) write ( * , '(:*(:,\"[\",g0,\"]\",/))' ) ch ( array ) write ( * , * ) ! ! using this syntax the elements will be of different lengths array = [ & ut ( 'Confucius never claimed to be a prophet,' ) , & ut ( 'but I think he foresaw AI! He said' ) , & ut ( '' ) , & ut ( ' \"Â≠¶ËÄå‰∏çÊÄùÂàôÁΩîÔºåÊÄùËÄå‰∏çÂ≠¶ÂàôÊÆÜ\"' ) , & ut ( 'or' ) , & ut ( ' (xu√© √©r b√π sƒ´ z√© w«éng, sƒ´ √©r b√π xu√© z√© d√†i),' ) , & ut ( 'which is also' ) , & ut ( ' \"To learn without thinking is to be lost,' ) , & ut ( ' to think without learning is to be in danger\".' )] ! but using the CHARACTER function will still make them the same ! length in bytes so you might want to print them individually ! for certain effects , subject to font properties such as varying ! glyph widths . write ( * , '(*(\"[\",g0,\"]\",/))' )( ch ( array ( i )), i = 1 , size ( array )) write ( * , '(*(\"[\",g0,\"]\",/))' )( ch ( pad ( array ( i ), 60 )), i = 1 , size ( array )) ! end program demo_character Results: > Œµ·ΩïœÅŒ∑Œ∫Œ± ! > Œµ·ΩïœÅŒ∑Œ∫Œ± ! > œÅŒ∑ > ! Œ±Œ∫Œ∑œÅ·ΩïŒµ > Œµ·ΩïœÅŒ∑Œ∫Œ± ! > [ Confucius never claimed to be a prophet, ] > [ but I think he foresaw AI! He said ] > [ ] > [ \"Â≠¶ËÄå‰∏çÊÄùÂàôÁΩîÔºåÊÄùËÄå‰∏çÂ≠¶ÂàôÊÆÜ\" ] > [ or ] > [ (xu√© √©r b√π sƒ´ z√© w«éng, sƒ´ √©r b√π xu√© z√© d√†i), ] > [ which is also ] > [ \"To learn without thinking is to be lost, ] > [ to think without learning is to be in danger\". ] > > all elements the same length in BYTES : 60 > lengths ( in glyphs ) : 60 60 60 34 60 48 60 60 60 > lengths after trimming ( in glyphs ) : 40 34 0 16 2 45 13 42 47 > [ Confucius never claimed to be a prophet, ] > [ but I think he foresaw AI! He said ] > [ ] > [ \"Â≠¶ËÄå‰∏çÊÄùÂàôÁΩîÔºåÊÄùËÄå‰∏çÂ≠¶ÂàôÊÆÜ\" ] > [ or ] > [ (xu√© √©r b√π sƒ´ z√© w«éng, sƒ´ √©r b√π xu√© z√© d√†i), ] > [ which is also ] > [ \"To learn without thinking is to be lost, ] > [ to think without learning is to be in danger\". ] > > > [ Confucius never claimed to be a prophet, ] > [ but I think he foresaw AI! He said ] > [] > [ \"Â≠¶ËÄå‰∏çÊÄùÂàôÁΩîÔºåÊÄùËÄå‰∏çÂ≠¶ÂàôÊÆÜ\" ] > [ or ] > [ (xu√© √©r b√π sƒ´ z√© w«éng, sƒ´ √©r b√π xu√© z√© d√†i), ] > [ which is also ] > [ \"To learn without thinking is to be lost, ] > [ to think without learning is to be in danger\". ] > [ > [Confucius never claimed to be a prophet, ] > [ but I think he foresaw AI! He said ] > [ ] > [ \"Â≠¶ËÄå‰∏çÊÄùÂàôÁΩîÔºåÊÄùËÄå‰∏çÂ≠¶ÂàôÊÆÜ\" ] > [ or ] > [ (xu√© √©r b√π sƒ´ z√© w«éng, sƒ´ √©r b√π xu√© z√© d√†i), ] > [ which is also ] > [ \"To learn without thinking is to be lost, ] > [ to think without learning is to be in danger\". ] > [ SEE ALSO functions that perform operations on character strings: elemental: adjustl(3), adjustr(3), index(3), scan(3), verify(3) non-elemental: len_trim(3), len(3), repeat(3), trim(3) AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value character(len=:), allocatable private pure function strs_to_chars(string) result(lines) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string (:) Return Value character(len=:), allocatable, (:) private pure function str_to_char_pos(string, pos) result(aline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in) :: pos Return Value character(len=:), allocatable private pure function strs_to_chars_pos(string, pos) result(aline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string (:) integer, intent(in) :: pos Return Value character(len=1), allocatable, (:) private pure function str_to_char_range(string, first, last) result(aline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in) :: first integer, intent(in) :: last Return Value character(len=:), allocatable private pure function strs_to_chars_range(string, first, last) result(lines) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string (:) integer, intent(in) :: first integer, intent(in) :: last Return Value character(len=:), allocatable, (:) private pure function str_to_char_range_step(string, first, last, step) result(aline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in) :: first integer, intent(in) :: last integer, intent(in) :: step Return Value character(len=:), allocatable private pure function strs_to_chars_range_step(string, first, last, step) result(lines) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string (:) integer, intent(in) :: first integer, intent(in) :: last integer, intent(in) :: step Return Value character(len=:), allocatable, (:) public        interface codepoints_to_utf8 private pure subroutine codepoints_to_utf8_str(codepoints, utf8, nerr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: codepoints (:) character(len=:), intent(out), allocatable :: utf8 integer, intent(out) :: nerr private pure subroutine codepoints_to_utf8_chars(codepoints, utf8, nerr) NAME CODEPOINTS_TO_UTF8(3f) - [M_unicode:CONVERSION] convert codepoints\n   to CHARACTER\n   (LICENSE:MIT) SYNOPSIS pure subroutine codepoints_to_utf8(codepoints,utf8,nerr)\n\n integer,allocatable,intent(in) :: codepoints(:)\n !\n character(len=1),intent(out)   :: utf8(:)\n !  or\n character(len=*),intent(out)   :: utf8\n !\n integer,intent(out)            :: nerr CHARACTERISTICS UTF8 is a scalar or array CHARACTER variable CODEPOINTS is of default INTEGER kind NERR is of default INTEGER kind DESCRIPTION CODEPOINTS_TO_UTF8(3f) takes an integer array of Unicode codepoint\n   values and generates either a scalar CHARACTER variable or an array\n   of bytes (AKA. CHARACTER(LEN=1)) which are assumed to contain a stream\n   of bytes representing UTF-8-encoded data. OPTIONS + CODEPOINTS : An INTEGER array of Unicode codepoint values representing the glyphs to be encoded at UTF - 8 data + UTF8 : Scalar or single - character array CHARACTER variables to contain a stream of bytes containing data encoded at UTF - 8 text . + NERR : Zero if no error occurred . If not zero the stream of bytes could not be completely converted to UTF - 8 characters . EXAMPLES Sample program program demo_codepoints_to_utf8 use m_unicode , only : codepoints_to_utf8 implicit none ! ' Noho me ka hau ‚Äô oli ' !( Be happy ) integer , parameter :: codepoints ( * )=[ & & 78 , 111 , 104 , 111 , & & 32 , 109 , 101 , & & 32 , 107 , 97 , & & 32 , 104 , 97 , 117 , 8217 , 111 , 108 , 105 ] character ( len =:), allocatable :: string character ( len = 1 ), allocatable :: bytes (:) character ( len = * ), parameter :: solid = ' ( * ( g0 )) ' character ( len = * ), parameter :: space = ' ( * ( g0 , 1 x )) ' character ( len = * ), parameter :: z = ' ( a , * ( z0 , 1 x )) ' integer :: nerr ! BASIC USAGE : SCALAR CHARACTER VARIABLE write ( * , space ) ' CODEPOINTS : ' , codepoints write ( * , z ) ' HEXADECIMAL CODEPOINTS : ' , codepoints call codepoints_to_utf8 ( codepoints , string , nerr ) write ( * , solid ) ' STRING : ' , string ! write ( * , space ) ' How long is this string in glyphs ? ' write ( * , space ) size ( codepoints ) write ( * , space ) ' How long is this string in bytes ? ' write ( * , space ) len ( string ) ! ! BASIC USAGE : ARRAY OF BYTES call codepoints_to_utf8 ( codepoints , bytes , nerr ) write ( * , solid ) ' STRING : ' , bytes ! write ( * , space ) ' How long is this string in glyphs ? ' write ( * , space ) size ( codepoints ) write ( * , space ) ' How long is this string in bytes ? ' write ( * , space ) size ( bytes ) ! end program demo_codepoints_to_utf8 Results: > CODEPOINTS: 78 111 104 111 32 109 101 32 107 97 32 104 97 117 ...\n > 8217 111 108 105\n > 48 4E 6F 68 6F 20 6D 65 20 6B 61 20 68 61 75 2019 6F 6C 69\n > STRING:Noho me ka hau‚Äôoli\n > How long is this string in glyphs?\n > 18\n > How long is this string in bytes?\n > 20\n > STRING:Noho me ka hau‚Äôoli\n > How long is this string in glyphs?\n > 18\n > How long is this string in bytes?\n > 20 SEE ALSO functions that perform operations on character strings: elemental: adjustl(3), adjustr(3), index(3), scan(3), verify(3) non-elemental: len_trim(3), repeat(3), trim(3),\n                    codepoints_to_utf8(3), utf8_to_codepoints(3) AUTHOR John S. Urban Francois Jacq - enhancements and Latin support from Francois Jacq, 2025-08 LICENSE MIT Arguments Type Intent Optional Attributes Name integer, intent(in) :: codepoints (:) character(len=1), intent(out), allocatable :: utf8 (:) integer, intent(out) :: nerr public        interface escape private impure elemental function escape_uu(line, protect) result(out) NAME ESCAPE(3f) - [M_unicode:CONVERSION] expand C-like escape sequences\n (LICENSE:MIT) SYNOPSIS function escape(line,utf8) result ( out ) type ( unicode_type ) :: line character ( len = 1 ), intent ( in ), optional :: protect type ( unicode_type ) :: out DESCRIPTION ESCAPE ( 3 ) expands commonly used escape sequences that represent glyphs or control characters . By default ... Escape sequences \\ backslash a alert ( BEL ) -- g is an alias for a b backspace c suppress further output e escape f form feed n new line r carriage return t horizontal tab v vertical tab oNNN byte with octal value NNN ( 3 digits ) 0 - 9 digits will be assumed an octal value till a non - octal value character is encountered dNNN byte with decimal value NNN ( 3 digits ) xHH byte with hexadecimal value HH ( 2 digits ) ; h is an alias for x uZZZZ translate Unicode codepoint value to bytes UZZZZZZZZ translate Unicode codepoint value to bytes The default escape character is the backslash, but this may be\n   changed using the optional parameter ESCAPE. EXAMPLES Sample Program: program demo_escape ! demonstrate filter to expand C - like escape sequences in input lines use iso_fortran_env , only : stdout => output_unit use M_unicode , only : ut => unicode_type , ch => character , len , escape use M_unicode , only : assignment (=), trim implicit none type ( ut ), allocatable :: poem (:) type ( ut ) :: test ( 5 ) integer :: i ! ! ‚Äú The Crow and the Fox ‚Äù by Jean de la Fontaine write ( stdout , ' ( a , / ) ' ) & ' Le Corbeau et le Renard -- Jean de la Fontaine ' ! poem =[ & ut ( ' Le Corbeau et le Renard ' ), & ut ( '' ), & ut ( ' Ma \\ u00EEtre Corbeau , sur un arbre perch \\ u00E9 , ' ), & ut ( ' Tenait en son bec un fromage . ' ), & ut ( ' Ma \\ u00EEtre Renard , par l \\ u2019odeur all \\ u00E9ch \\ u00E9 , ' ), & ut ( ' Lui tint \\ U000000E0 peu pr \\ U000000E8s ce langage : ' ), & ut ( '\\ U000000ABH \\ U000000E9 ! bonjour , Monsieur du Corbeau . ' ), & ut ( ' Que vous \\ U000000EAtes joli ! que vous me semblez beau ! ' ), & ut ( ' Sans mentir , si votre ramage ' ), & ut ( ' Se rapporte \\ U000000E0 votre plumage , ' ), & ut ( ' Vous \\ xEAtes le Ph \\ xE9nix des h \\ xF4tes de ces bois . \\ xBB ' ), & ut ( ' A ces mots le Corbeau ne se sent pas de joie ; ' ), & ut ( ' Et pour montrer sa belle voix , ' ), & ut ( ' Il ouvre un large bec , laisse tomber sa proie . ' ), & ut ( ' Le Renard s \\ u2019en saisit , et dit : \\ xABMon bon Monsieur , ' ), & ut ( ' Apprenez que tout flatteur ' ), & ut ( ' Vit aux d \\ xE9pens de celui qui l \\ U00002019 \\ u00E9coute : ' ), & ut ( ' Cette le \\ xE7on vaut bien un fromage , sans doute . \\ xBB ' ), & ut ( ' Le Corbeau , honteux et confus , ' ), & ut ( & ' Jura , mais un peu tard , qu \\ u2019on ne l \\ u2019y prendrait plus . ' ), & ut ( ' -- Jean de la Fontaine ' )] ! poem = escape ( poem ) write ( stdout , ' ( g0 ) ' ) ch ( poem ) ! test =[ & '\\ e [ H \\ e [ 2 J ' , & ! home cursor and clear screen ! on ANSI terminals '\\ tABC \\ tabc ' , & ! write some tabs in the output '\\ tA \\ a ' , & ! ring bell at end if supported '\\ nONE \\ nTWO \\ nTHREE ' , & ! place one word per line '\\\\ ' ] test = trim ( escape ( test )) write ( * , ' ( a ) ' )( test ( i ) % character (), i = 1 , size ( test )) ! end program demo_escape Results (with nonprintable characters shown visible): > &#94;[[H&#94;[[2J\n  > &#94;IABC&#94;Iabc\n  > &#94;IA&#94;G\n  >\n  > ONE\n  > TWO\n  > THREE\n  > !! AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: line type( unicode_type ), intent(in), optional :: protect Return Value type( unicode_type ) private impure elemental function escape_ua(line, protect) result(out) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: line character(len=1), intent(in) :: protect Return Value type( unicode_type ) private impure elemental function escape_au(line, protect) result(out) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line type( unicode_type ), intent(in), optional :: protect Return Value type( unicode_type ) private impure elemental function escape_aa(line, protect) result(out) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: line character(len=1), intent(in) :: protect Return Value type( unicode_type ) public        interface fmt private recursive function fmt_ga(generic, format) result(line) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: generic character(len=*), intent(in), optional :: format Return Value type( unicode_type ) private recursive function fmt_gs(generic, format) result(line) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: generic type( unicode_type ), intent(in) :: format Return Value type( unicode_type ) public        interface get_arg private impure elemental function get_arg_ia(position, default) result(value) NAME get_arg(3f) - [M_unicode:SYSTEM] get command line argument\n(LICENSE:MIT) SYNOPSIS impure elemental function get_arg ( position , default ) result ( out ) integer , intent =( in ) :: position type ( unicode_type ), optional :: default type ( unicode_type ) :: out CHARACTERISTICS DEFAULT may be default CHARACTER type as well . DESCRIPTION get_arg(3) gets the value of the requested command line argument\nas TYPE(UNICODE_TYPE) . OPTIONS position Position on command line of requested argument . Zero returns the name of the command executed . Non - existent positions default to returning a null string . default value to return if argument is not set or set to a blank value RETURNS out value assigned based on value of environment variable NAME EXAMPLES Sample program: program demo_get_arg use M_unicode , only : get_arg , ut => unicode_type , ch => character use M_unicode , only : assignment (=), operator ( //), write(formatted) implicit none integer :: position type ( ut ) :: default type ( ut ) :: value type ( ut ) :: smiley integer :: i character ( len = * ), parameter :: bracket = ' ( 1 x , * ( \"[\" , a , \"]\" ,:)) ' ! smiley = 128515 ! set with Unicode code point default = ' Wish I was first ' //smiley//'!' ! set with unicode_type ! ! arguments can be type ( unicode_type ) or character ! but type ( unicode_type ) is always returned do position = 0 , command_argument_count () value = get_arg ( position , default ) value = get_arg ( position , default % character () ) ! write ( * , * ) value % character () write ( * , ' ( DT ) ' ) default % get_arg ( position ) ! ! print each glyph surrounded by brackets write ( * , bracket )( value % character ( i , i ), i = 1 , value % len ()) enddo ! end program demo_get_arg Results: > demo_get_arg > demo_get_arg > [ d ][ e ][ m ][ o ][ _ ][ g ][ e ][ t ][ _ ][ a ][ r ][ g ] AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name integer, intent(in) :: position character(len=*), intent(in), optional :: default Return Value type( unicode_type ) private impure elemental function get_arg_iu(position, default) result(value) Arguments Type Intent Optional Attributes Name integer, intent(in) :: position type( unicode_type ), intent(in) :: default Return Value type( unicode_type ) public        interface get_env private impure elemental function get_env_uu(name, default) result(value) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: name type( unicode_type ), intent(in), optional :: default Return Value type( unicode_type ) private impure elemental function get_env_ua(name, default) result(value) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: name character(len=*), intent(in) :: default Return Value type( unicode_type ) private impure elemental function get_env_au(name, default) result(value) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name type( unicode_type ), intent(in) :: default Return Value type( unicode_type ) private impure elemental function get_env_aa(name, default) result(uvalue) NAME get_env ( 3 f ) - [ M_unicode : SYSTEM ] return value of environment variable ( LICENSE : MIT ) SYNOPSIS impure elemental function get_env ( name , default ) result ( out ) type ( unicode_type ), intent =( in ) :: name type ( unicode_type ), optional :: default type ( unicode_type ) :: out CHARACTERISTICS NAME and DEFAULT may be default CHARACTER type as well . DESCRIPTION get_env ( 3 ) gets the value of the requested environment variable as TYPE ( UNICODE_TYPE ) . OPTIONS name name of environment variable to return the value of . Typically the name may only contain the characters A - Z , a - z , 0 - 9 and underscore ; but allowed values are system - dependent . default value to return if environment variable NAME is not set or set to a blank value RETURNS out value assigned based on value of environment variable NAME EXAMPLES Sample program: program demo_get_env use M_unicode , only : get_env , ut => unicode_type use M_unicode , only : assignment (=), operator ( //) implicit none type ( ut ) :: name type ( ut ) :: default type ( ut ) :: value type ( ut ) :: smiley integer :: i character ( len = * ), parameter :: bracket = ' ( 1 x , * ( \"[\" , a , \"]\" ,:)) ' ! smiley = 128515 ! set with Unicode code point name = ' UTF8 ' ! set with ASCII default = ' Have a nice day ' //smiley//'!' ! set with unicode_type ! ! arguments can be type ( unicode_type ) or character ! but type ( unicode_type ) is always returned value = get_env ( name , default ) value = get_env ( name % character (), default % character () ) value = get_env ( name , default % character () ) value = get_env ( name % character (), default ) ! write ( * , * ) value % character () ! ! print each glyph surrounded by brackets write ( * , bracket )( value % character ( i , i ), i = 1 , value % len ()) ! end program demo_get_env Results: > Have a nice day üòÉ! > [ H ][ a ][ v ][ e ][ ][ a ][ ][ n ][ i ][ c ][ e ][ ][ d ][ a ][ y ][ ][ üòÉ ][ ! ] AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: name character(len=*), intent(in), optional :: default Return Value type( unicode_type ) public        interface ichar private elemental function ichar_str(string) result(code) NAME ICHAR(3f) - [M_unicode:CONVERSION] character-to-integer code conversion\n   function\n   (LICENSE:MIT) SYNOPSIS result = ichar(c) elemental integer function ichar ( c , kind ) type ( unicode_type ), intent ( in ) :: c CHARACTERISTICS ‚Ä¢  c is a scalar character ‚Ä¢  the return value is of default integer kind. DESCRIPTION ichar(3) returns the code for the character in the system‚Äôs native\n   character set. the correspondence between characters and their codes is\n   not necessarily the same across different Fortran implementations. For\n   example, a platform using EBCDIC would return different values than\n   an ASCII platform. See IACHAR(3) for specifically working with the ASCII character set. OPTIONS C : The input character to determine the decimal code of. RESULT The codepoint in the Unicode character set for the character being queried is returned . The result is the position of C in the Unicode collating sequence , which is generally not the dictionary order in a particular language . It is nonnegative and less than n , where n is the number of characters in the collating sequence . For any characters C and D capable of representation in the processor , C <= D is true if and only if ICHAR ( C ) <= ICHAR ( D ) is true and C == D is true if and only if ICHAR ( C ) == ICHAR ( D ) is true . EXAMPLES sample program: program demo_ichar use M_unicode , only : assignment (=), ch => character use M_unicode , only : ut => unicode_type , write ( formatted ) use M_unicode , only : ichar , escape , len implicit none type ( ut ) :: string type ( ut ), allocatable :: lets (:) integer , allocatable :: ilets (:) integer :: i ! ! create a string containing multibyte characters string =[ 949 , 8021 , 961 , 951 , 954 , 945 , 33 ] ! eureka write ( * , ' ( * ( DT , 1 x , \"(AKA. eureka!)\" )) ' ) string ! ! call ichar ( 3 ) on each glyph of the string to convert ! the string to an array of integer codepoints ilets =[( ichar ( string % sub ( i , i )), i = 1 , len ( string ))] write ( * , ' ( * ( z0 , 1 x )) ' ) ilets ! ! note that the % codepoint method is commonly used to ! convert a string to an integer array of codepoints write ( * , ' ( * ( z0 , 1 x )) ' ) string % codepoint () ! elemental write ( * , ' ( \"WRITING ISSUES:\" ) ' ) ! ! define an array LETS with escape codes with one glyph per element lets =[ ut ( '\\ U03B5 ' ), ut ( '\\ U1F55 ' ), ut ( '\\ U03C1 ' ), ut ( '\\ U03B7 ' ), & & ut ( '\\ U03BA ' ), ut ( '\\ U03B1 ' ), ut ( '\\ U0021 ' )] lets = escape ( lets ) ! convert escape codes to glyphs ! ! look at issues with converting to CHARACTER for simple printing ! write ( * , ' ( \"each element is a single glyph \" , * ( g0 , 1 x )) ' ) len ( lets ) ! ! notice if you convert to an array of intrinsic CHARACTER type the ! strings are all the same length in bytes ; but unicode characters ! can take various numbers of bytes write ( * , ' ( * ( g0 , \":\" )) ')' CHARACTER array elements have same length ' , & & len ( ch ( lets )) ! this will not appear correctly because all elements are padded to ! the same length in bytes write ( * , ' ( * ( a , \":\" )) ' ) ch ( lets ) ! one element at a time will retain the size of each element write ( * , ' ( * ( a , \":\" )) ' )( ch ( lets ( i : i )), i = 1 , size ( lets )) ! ! the FIRST LETTER of each element is converted to a codepoint so ! for the special case where each string element is a single glyph ! an elemental approach works write ( * , ' ( \"ELEMENTAL:\" , * ( z0 , 1 x )) ' ) ichar ( lets ) ! OOPS write ( * , ' ( \"OOPS:\" , * ( z0 , 1 x )) ' ) lets % ichar () end program demo_ichar results: > Project is up to date\n> Œµ·ΩïœÅŒ∑Œ∫Œ±! (AKA. eureka!)\n> 3B5 1F55 3C1 3B7 3BA 3B1 21\n> 3B5 1F55 3C1 3B7 3BA 3B1 21\n> WRITING ISSUES:\n> each element is a single glyph 1 1 1 1 1 1 1\n> CHARACTER array elements have same length:3:\n> Œµ :·Ωï:œÅ :Œ∑ :Œ∫ :Œ± :!  :\n> Œµ:·Ωï:œÅ:Œ∑:Œ∫:Œ±:!:\n> ELEMENTAL:3B5 1F55 3C1 3B7 3BA 3B1 21\n> OOPS:3B5 1F55 3C1 3B7 3BA 3B1 21 SEE ALSO achar(3), char(3), iachar(3) functions that perform operations on character strings, return\n   lengths of arguments, and search for certain arguments: elemental: adjustl(3), adjustr(3), index(3),\n      scan(3), verify(3) nonelemental: len_trim(3), len(3), repeat(3), trim(3) AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value integer public        interface index private elemental function index_str_str(string, substring, back) result(foundat) NAME INDEX(3f) - [M_unicode:SEARCH] Position of a substring within a string\n               (LICENSE:MIT) SYNOPSIS result = index( string, substring [,back] [,kind] ) elemental integer(kind=KIND) function index(string,substring,back,kind)\n\n character(len=*,kind=KIND),intent(in) :: string\n character(len=*,kind=KIND),intent(in) :: substring\n logical(kind=**),intent(in),optional :: back\n integer(kind=**),intent(in),optional :: kind CHARACTERISTICS STRING     is a character variable of any kind SUBSTRING  is a character variable of the same kind as STRING BACK       is a logical variable of any supported kind KIND       is a scalar integer constant expression. DESCRIPTION INDEX(3) returns the position of the start of the leftmost or\n   rightmost occurrence of string SUBSTRING in STRING, counting from\n   one. If SUBSTRING is not present in STRING, zero is returned. OPTIONS STRING : string to be searched for a match SUBSTRING : string to attempt to locate in STRING BACK : If the BACK argument is present and true, the return value\n     is the start of the rightmost occurrence rather than the\n     leftmost. KIND : if KIND is present, the kind type parameter is that specified\n     by the value of KIND; otherwise the kind type parameter is\n     that of default integer type. RESULT The result is the starting position of the first substring SUBSTRING\n   found in STRING. If the length of SUBSTRING is longer than STRING the result is zero. If the substring is not found the result is zero. If BACK is .true. the greatest starting position is returned (that is,\n   the position of the right‚Äêmost match). Otherwise, the smallest\n   position starting a match (ie. the left‚Äêmost match) is returned. The position returned is measured from the left with the first character\n   of STRING being position one. Otherwise, if no match is found zero is returned. EXAMPLES Example program program demo_index use M_unicode , only : ut => unicode_type use M_unicode , only : assignment ( = ) use M_unicode , only : index implicit none type ( ut ) :: str character ( len =* ), parameter :: all = '(*(g0))' integer :: ii ! str = 'Huli i kƒìia kaula no kƒìia  ª≈çlelo' ! bug ! print all , index ( str , 'kƒìia' ). eq .8 ii = index ( str , 'kƒìia' ); print all , ii . eq .8 ! ! return value is counted from the left end even if BACK = . TRUE . ! bug ! print all , index ( str , 'kƒìia' , back = . true .). eq .22 ii = index ( str , 'kƒìia' , back = . true .); print all , ii . eq .22 ! ! INDEX is case - sensitive ! bug ! print all , index ( str , 'Kƒìia' ). eq .0 ii = index ( str , 'Kƒìia' ); print all , ii . eq .0 !<<<<<<<<<< ! ifx bug : ifx ( IFX ) 2024.1.0 20240308 ! ! example / demo_index . f90 ( 17 ) : error #6766 : A binary defined OPERATOR ! definition is missing or incorrect . [ EQ ] ! print all , index ( str , 'k  ia' , back = . true .). eq .22 ! --------------------------------------------------&#94; ! Original works with gfortran and flang_new and this works with ifx ! ii = ndex ( str , 'k  ia' , back = . true .) ! print all , ii . eq .22 !>>>>>>>>>> end program demo_index Expected Results: > T\n> T\n> T\n> T\n> T\n> T SEE ALSO Functions that perform operations on character strings, return lengths\n   of arguments, and search for certain arguments: ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), SCAN(3), VERIFY(3) NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3) AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function index_str_char(string, substring, back) result(foundat) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string character(len=*), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function index_char_str(string, substring, back) result(foundat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( unicode_type ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer public        interface len private elemental function len_str(string) result(length) NAME LEN(3f) - [M_unicode:WHITESPACE] Length of a string\n     (LICENSE:MIT) SYNOPSIS result = len(string) elemental integer function len ( string ) type ( unicode_type ), intent ( in ) :: string CHARACTERISTICS STRING is a scalar or array string variable the returned value is of default INTEGER kind DESCRIPTION LEN(3) returns the length of a type(unicode_type) string. Note that unlike the intrinsic of the same name STRING needs to be\n   defined; as the length of each element is not defined until allocated;\n   and the KIND parameter is not available for specifying the kind of the\n   integer returned. OPTIONS STRING : A scalar or array string to return the length(s) of in glyph\n     counts. If it is an unallocated allocatable variable or a pointer that\n     is not associated, its length type parameter shall not be deferred. RESULT The result has a value equal to the number of glyphs in STRING if\n   it is scalar or the elements of STRING if it is an array. EXAMPLES Sample program program demo_len use M_unicode , only : assignment (=), ut => unicode_type , len use M_unicode , only : write ( formatted ) implicit none type ( ut ) :: string type ( ut ), allocatable :: many_strings (:) integer :: ii ! BASIC USAGE string = ' Noho me ka hau ‚Äô oli ' ! ( Be happy .) ii = len ( string ) write ( * , ' ( DT , * ( g0 )) ' ) string , ' LEN = ' , ii ! string = ' How long is this allocatable string ? ' write ( * , ' ( DT , * ( g0 )) ' ) string , ' LEN = ' , len ( string ) ! ! STRINGS IN AN ARRAY MAY BE OF DIFFERENT LENGTHS many_strings = [ ut ( ' Tom ' ), ut ( ' Dick ' ), ut ( ' Harry ' ) ] write ( * , ' ( * ( g0 , 1 x )) ')' length of elements of array = ' , len ( many_strings ) ! write ( * , ' ( * ( g0 )) ')' length from type parameter inquiry = ' , string % len () ! ! LOOK AT HOW A PASSED STRING CAN BE USED ... call passed ( ut ( ' how long ? ' )) ! contains ! subroutine passed ( str ) type ( ut ), intent ( in ) :: str ! you can query the length of the passed variable ! when an interface is present write ( * , ' ( * ( g0 )) ')' length of passed value is ' , len ( str ) end subroutine passed ! end program demo_len Results: > Noho me ka hau ‚Äô oli LEN = 18 > How long is this allocatable string ? LEN = 38 > length of elements of array = 3 4 5 > length from type parameter inquiry = 38 > length of passed value is 11 SEE ALSO functions that perform operations on character strings: elemental: adjustl(3), adjustr(3), index(3), scan(3), verify(3) non-elemental: len_trim(3), len(3), repeat(3), trim(3) AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value integer public        interface len_trim private elemental function len_trim_str(string) result(length) NAME LEN_TRIM(3f) - [M_unicode:WHITESPACE] string length without trailing blank\n   characters\n   (LICENSE:MIT) SYNOPSIS result = len_trim(string) elemental integer(kind=kind) function len_trim(string)\n\n       character(len=*),intent(in) :: string CHARACTERISTICS string is of type type(unicode_type) the return value is of type default integer. DESCRIPTION len_trim(3) returns the length of a string, ignoring any trailing\n   blanks. OPTIONS string : the input string whose length is to be measured. RESULT the result equals the number of glyphs remaining after any trailing\n   blanks in string are removed. if the input argument is of zero length or all blanks the result is zero. EXAMPLES sample program program demo_len_trim use M_unicode , only : ut => unicode_type , assignment (=) use M_unicode , only : len , len_trim use M_unicode , only : write ( formatted ) implicit none type ( ut ) :: string integer :: i ! basic usage string = \" how long is this string?     \" print ' ( DT ) ' , string print * , ' untrimmed length = ' , len ( string ) print * , ' trimmed length = ' , len_trim ( string ) ! ! print string , then print substring of string string = ' xxxxx ' write ( * , ' ( * ( DT )) ' ) string , string , string i = len_trim ( string ) print ' ( * ( DT )) ' , string % sub ( 1 , i ), string % sub ( 1 , i ), string % sub ( 1 , i ) ! ! elemental example ele : block ! an array of strings may be used type ( ut ), allocatable :: tablet (:) tablet =[ & & ut ( ' how long is this string ? ' ), & & ut ( ' and this one ? ' )] write ( * , * ) ' untrimmed length = ' , len ( tablet ) write ( * , * ) ' trimmed length = ' , len_trim ( tablet ) write ( * , * ) ' sum trimmed length = ' , sum ( len_trim ( tablet )) endblock ele ! end program demo_len_trim results: >  how long is this string?\n>  untrimmed length=          30\n>  trimmed length=          25\n> xxxxx   xxxxx   xxxxx\n> xxxxxxxxxxxxxxx\n>  untrimmed length=            30          13\n>  trimmed length=              25          13\n>  sum trimmed length=          38 SEE ALSO functions that perform operations on character strings, return lengths of\n   arguments, and search for certain arguments: elemental: adjustl(3), adjustr(3), index(3), scan(3), verify(3) nonelemental: repeat(3), len(3), trim(3) AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value integer public        interface leq private elemental function leq_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function leq_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function leq_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface lge private elemental function lge_str_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lge_str_char(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lge_char_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface lgt private elemental function lgt_str_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lgt_str_char(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lgt_char_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface lle private elemental function lle_str_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lle_str_char(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lle_char_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface llt private elemental function llt_str_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function llt_str_char(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function llt_char_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface lne private elemental function lne_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lne_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lne_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface operator(.cat.) private  function concat_g_g(lhs, rhs) result(string) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: lhs class(*), intent(in) :: rhs Return Value type( unicode_type ) public        interface operator(//) private  function concat_g_u(lhs, rhs) result(string) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value type( unicode_type ) private  function concat_u_g(lhs, rhs) result(string) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs class(*), intent(in) :: rhs Return Value type( unicode_type ) private  function concat_g_i(lhs, rhs) result(string) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: lhs integer, intent(in) :: rhs Return Value type( unicode_type ) private  function concat_i_g(lhs, rhs) result(string) Arguments Type Intent Optional Attributes Name integer, intent(in) :: lhs class(*), intent(in) :: rhs Return Value type( unicode_type ) private  function concat_g_r(lhs, rhs) result(string) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: lhs real, intent(in) :: rhs Return Value type( unicode_type ) private  function concat_r_g(lhs, rhs) result(string) Arguments Type Intent Optional Attributes Name real, intent(in) :: lhs class(*), intent(in) :: rhs Return Value type( unicode_type ) private  function concat_g_d(lhs, rhs) result(string) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: lhs doubleprecision, intent(in) :: rhs Return Value type( unicode_type ) private  function concat_d_g(lhs, rhs) result(string) Arguments Type Intent Optional Attributes Name doubleprecision, intent(in) :: lhs class(*), intent(in) :: rhs Return Value type( unicode_type ) private  function concat_g_c(lhs, rhs) result(string) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: lhs complex, intent(in) :: rhs Return Value type( unicode_type ) private  function concat_c_g(lhs, rhs) result(string) Arguments Type Intent Optional Attributes Name complex, intent(in) :: lhs class(*), intent(in) :: rhs Return Value type( unicode_type ) private  function concat_g_l(lhs, rhs) result(string) Arguments Type Intent Optional Attributes Name class(*), intent(in) :: lhs logical, intent(in) :: rhs Return Value type( unicode_type ) private  function concat_l_g(lhs, rhs) result(string) Arguments Type Intent Optional Attributes Name logical, intent(in) :: lhs class(*), intent(in) :: rhs Return Value type( unicode_type ) public        interface operator(/=) private elemental function lne_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lne_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lne_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface operator(<) private elemental function llt_str_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function llt_str_char(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function llt_char_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface operator(<=) private elemental function lle_str_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lle_str_char(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lle_char_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface operator(==) private elemental function leq_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function leq_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function leq_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface operator(>) private elemental function lgt_str_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lgt_str_char(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lgt_char_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface operator(>=) private elemental function lge_str_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lge_str_char(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lge_char_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface repeat private elemental function repeat_str(string, ncopies) result(repeated_str) NAME REPEAT(3) - [M_unicode:CHARACTER] Repeated string concatenation SYNOPSIS result = repeat(string, ncopies) type ( unicode_type ) function repeat ( string , ncopies ) type ( unicode_type ), intent ( in ) :: string integer ( kind = ** ), intent ( in ) :: ncopies CHARACTERISTICS STRING is a scalar string of type(unicode_type). NCOPIES is a scalar integer. the result is a new scalar string of type type(unicode_type) DESCRIPTION REPEAT(3) concatenates copies of a string. OPTIONS STRING : The input string to repeat NCOPIES : Number of copies to make of STRING, greater than or equal to\n      zero (0). RESULT A new string built up from NCOPIES copies of STRING. EXAMPLES Sample program: program demo_repeat use M_unicode , only : ut => unicode_type , repeat , escape , write ( formatted ) implicit none write ( * , ' ( DT ) ' ) repeat ( escape ( \"\\u2025*\" ), 35 ) write ( * , ' ( DT ) ' ) repeat ( ut ( \"_\" ), 70 ) ! line break write ( * , ' ( DT ) ' ) repeat ( ut ( \"1234567890\" ), 7 ) ! number line write ( * , ' ( DT ) ' ) repeat ( ut ( \"         |\" ), 7 ) ! end program demo_repeat STANDARD Fortran 95 SEE ALSO Functions that perform operations on character strings: ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), SCAN(3), VERIFY(3) NON-ELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3) Fortran descriptions (license: MIT) @urbanjost Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in) :: ncopies Return Value type( unicode_type ) public        interface replace private  function replace_uuu(target, old, new, force_, occurrence, repeat, ignorecase, changes, back) result(newline) NAME REPLACE(3f) - [M_unicode:EDITING] function replaces one\n substring for another in string\n (LICENSE:MIT) SYNOPSIS syntax: function replace ( target , old , new , & & occurrence , & & repeat , & & ignorecase , & & ierr , back ) result ( newline ) or function replace ( target,start,end,new ) result newline type ( unicode_type ) | character ( len = * ), intent ( in ) :: target type ( unicode_type ) | character ( len = * ), intent ( in ) :: old type ( unicode_type ) | character ( len = * ), intent ( in ) :: new or type ( unicode_type ) | character ( len = * ), intent ( in ) :: new integer , intent ( in ) :: start integer , intent ( in ) :: end integer , intent ( in ), optional :: occurrence integer , intent ( in ), optional :: repeat logical , intent ( in ), optional :: ignorecase integer , intent ( out ), optional :: changes logical , intent ( in ), optional :: back character ( len =:), allocatable :: newline CHARACTERISTICS TARGET,OLD and NEW may be a string or a character variable. DESCRIPTION Replace old substring with new value in string. Either a\n old and new string is specified, or a new string and a\n column range indicating the position of the text to replace\n is specified. OPTIONS target input line to be changed old old substring to replace new new substring start starting column of text to replace end ending column of text to replace KEYWORD REQUIRED occurrence if present , start changing at the Nth occurrence of the OLD string . repeat number of replacements to perform . Defaults to a global replacement . ignorecase whether to ignore ASCII case or not . Defaults to . false . . back if true start replacing moving from the right end of the string moving left instead of from the left to the right . RETURNS newline     allocatable string returned\n  changes     count of changes made. EXAMPLES Sample Program: program demo_replace use M_unicode , only : ut => unicode_type use M_unicode , only : unicode_type use M_unicode , only : character , replace use M_unicode , only : write ( formatted ) implicit none type ( unicode_type ) :: line ! write ( * , ' ( DT ) ' ) & & replace ( ut ( ' Xis is Xe string ' ), ut ( 'X' ), ut ( ' th ' ) ) write ( * , ' ( DT ) ' ) & & replace ( ut ( ' Xis is xe string ' ), ut ( 'x' ), ut ( ' th ' ), ignorecase =. true .) write ( * , ' ( DT ) ' ) & & replace ( ut ( ' Xis is xe string ' ), ut ( 'X' ), ut ( ' th ' ), ignorecase =. false .) ! ! a null old substring means \"at beginning of line\" write ( * , ' ( DT ) ' ) & & replace ( ut ( ' my line of text ' ), ut ( '' ), ut ( ' BEFORE : ' )) ! ! a null new string deletes occurrences of the old substring write ( * , ' ( DT ) ' ) replace ( ut ( ' I wonder i ii iii ' ), ut ( 'i' ), ut ( '' )) ! ! Examples of the use of RANGE ! line = replace ( ut ( ' aaaaaaaaa ' ), ut ( 'a' ), ut ( 'A' ), occurrence = 1 , repeat = 1 ) write ( * , * ) ' replace first a with A [ ' //line%character()//']' ! line = replace ( ut ( ' aaaaaaaaa ' ), ut ( 'a' ), ut ( 'A' ), occurrence = 3 , repeat = 3 ) write ( * , * ) ' replace a with A for 3 rd to 5 th occurrence [ ' & & //line%character()//']' ! line = replace ( ut ( ' ababababa ' ), ut ( 'a' ), ut ( '' ), occurrence = 3 , repeat = 3 ) write ( * , * ) ' replace a with null instances 3 to 5 [ ' // & & line % character () //']' ! line = replace ( & & ut ( ' a b ab baaa aaaa aa aa a a a aa aaaaaa ' ), & & ut ( ' aa ' ), ut ( ' CCCC ' ), occurrence = - 1 , repeat = 1 ) write ( * , * ) ' replace lastaa with CCCC [ ' //line%character()//']' ! write ( * , ' ( DT ) ' ) replace ( ut ( ' myf90stuff . f90 . f90 ' ), & & ut ( ' f90 ' ), ut ( ' for ' ), occurrence = - 1 , repeat = 1 ) write ( * , ' ( DT ) ' ) replace ( ut ( ' myf90stuff . f90 . f90 ' ), & & ut ( ' f90 ' ), ut ( ' for ' ), occurrence = - 2 , repeat = 2 ) ! end program demo_replace Results: > this is the string > this is the string > this is xe string > BEFORE : my line of text > I wonder > replace first a with A [ Aaaaaaaaa ] > replace a with A for 3 rd to 5 th occurrence [ aaAAAaaaa ] > replace a with null instances 3 to 5 [ ababbb ] > replace lastaa with CCCC [ a b ab baaa aaaa aa aa a a a aa aaaaCCCC ] > myf90stuff . f90 . for > myforstuff . for . f90 AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: target type( unicode_type ), intent(in) :: old type( unicode_type ), intent(in) :: new type(force_keywords), intent(in), optional :: force_ integer, intent(in), optional :: occurrence integer, intent(in), optional :: repeat logical, intent(in), optional :: ignorecase integer, intent(out), optional :: changes logical, intent(in), optional :: back Return Value type( unicode_type ) private  function replace_uua(target, old, new, force_, occurrence, repeat, ignorecase, changes, back) result(newline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: target type( unicode_type ), intent(in) :: old character(len=*), intent(in) :: new type(force_keywords), intent(in), optional :: force_ integer, intent(in), optional :: occurrence integer, intent(in), optional :: repeat logical, intent(in), optional :: ignorecase integer, intent(out), optional :: changes logical, intent(in), optional :: back Return Value type( unicode_type ) private  function replace_uaa(target, old, new, force_, occurrence, repeat, ignorecase, changes, back) result(newline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: target character(len=*), intent(in) :: old character(len=*), intent(in) :: new type(force_keywords), intent(in), optional :: force_ integer, intent(in), optional :: occurrence integer, intent(in), optional :: repeat logical, intent(in), optional :: ignorecase integer, intent(out), optional :: changes logical, intent(in), optional :: back Return Value type( unicode_type ) private  function replace_uau(target, old, new, force_, occurrence, repeat, ignorecase, changes, back) result(newline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: target character(len=*), intent(in) :: old type( unicode_type ), intent(in) :: new type(force_keywords), intent(in), optional :: force_ integer, intent(in), optional :: occurrence integer, intent(in), optional :: repeat logical, intent(in), optional :: ignorecase integer, intent(out), optional :: changes logical, intent(in), optional :: back Return Value type( unicode_type ) private  function replace_aaa(target, old, new, force_, occurrence, repeat, ignorecase, changes, back) result(newline) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: target character(len=*), intent(in) :: old character(len=*), intent(in) :: new type(force_keywords), intent(in), optional :: force_ integer, intent(in), optional :: occurrence integer, intent(in), optional :: repeat logical, intent(in), optional :: ignorecase integer, intent(out), optional :: changes logical, intent(in), optional :: back Return Value type( unicode_type ) private  function replace_aua(target, old, new, force_, occurrence, repeat, ignorecase, changes, back) result(newline) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: target type( unicode_type ), intent(in) :: old character(len=*), intent(in) :: new type(force_keywords), intent(in), optional :: force_ integer, intent(in), optional :: occurrence integer, intent(in), optional :: repeat logical, intent(in), optional :: ignorecase integer, intent(out), optional :: changes logical, intent(in), optional :: back Return Value type( unicode_type ) private  function replace_aau(target, old, new, force_, occurrence, repeat, ignorecase, changes, back) result(newline) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: target character(len=*), intent(in) :: old type( unicode_type ), intent(in) :: new type(force_keywords), intent(in), optional :: force_ integer, intent(in), optional :: occurrence integer, intent(in), optional :: repeat logical, intent(in), optional :: ignorecase integer, intent(out), optional :: changes logical, intent(in), optional :: back Return Value type( unicode_type ) private  function replace_auu(target, old, new, force_, occurrence, repeat, ignorecase, changes, back) result(newline) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: target type( unicode_type ), intent(in) :: old type( unicode_type ), intent(in) :: new type(force_keywords), intent(in), optional :: force_ integer, intent(in), optional :: occurrence integer, intent(in), optional :: repeat logical, intent(in), optional :: ignorecase integer, intent(out), optional :: changes logical, intent(in), optional :: back Return Value type( unicode_type ) private  function section_uu(str, first, last, new) result(out) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: str integer, intent(in), optional :: first integer, intent(in), optional :: last type( unicode_type ), intent(in) :: new Return Value type( unicode_type ) private  function section_ua(str, first, last, new) result(out) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: str integer, intent(in) :: first integer, intent(in) :: last character(len=*), intent(in) :: new Return Value type( unicode_type ) private  function section_au(str, first, last, new) result(out) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: first integer, intent(in) :: last type( unicode_type ), intent(in) :: new Return Value type( unicode_type ) private  function section_aa(str, first, last, new) result(out) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str integer, intent(in) :: first integer, intent(in) :: last character(len=*), intent(in) :: new Return Value type( unicode_type ) public        interface scan private pure elemental function scan_uu(string, set, back) result(pos) NAME SCAN(3f) - [M_unicode:SEARCH] Scan a string for the presence of a\n   set of characters\n   (LICENSE:MIT) SYNOPSIS result = scan( string, set, [,back] ) elemental integer ( kind = KIND ) function scan ( string , set , back ) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set or character ( len = * ), intent ( in ) :: set logical , intent ( in ), optional :: back CHARACTERISTICS STRING is a string of type unicode_type SET must be a string of type unicode_type or character BACK is a logical of default kind the result is an integer of default kind. DESCRIPTION SCAN(3) scans a STRING for any of the characters in a SET of characters. If BACK is either absent or equals .false., this function returns the\n   position of the leftmost character of STRING that is in SET. If BACK\n   equals .true., the rightmost position is returned. If no character of\n   SET is found in STRING, the result is zero. OPTIONS STRING : the string to be scanned SET : the set of characters which will be matched BACK : if .true. the position of the rightmost character matched\n      is returned, instead of the leftmost. RESULT If BACK is absent or is present with the value false and if STRING\n   contains at least one character that is in SET, the value of the result\n   is the position of the leftmost character of STRING that is in SET. If BACK is present with the value true and if STRING contains at least\n   one character that is in SET, the value of the result is the position\n   of the rightmost character of STRING that is in SET. The value of the result is zero if no character of STRING is in SET\n   or if the length of STRING or SET is zero. EXAMPLES Sample program: program demo_scan use iso_fortran_env , only : stdout => output_unit use M_unicode , only : scan , unicode_type , assignment (=) use M_unicode , only : ut => unicode_type implicit none character ( len = * ), parameter :: g = ' ( * ( g0 , 1 x )) ' type ( ut ) :: line type ( ut ) :: set ! write ( * , * ) scan ( \"fortran\" , \"ao\" ) ! 2 , found ‚Äô o ‚Äô write ( * , * ) scan ( \"fortran\" , \"ao\" , . true .) ! 6 , found ‚Äô a ‚Äô write ( * , * ) scan ( \"fortran\" , \"c++\" ) ! 0 , found none ! line = ' parsley üòÉ sage üòÉ rosemary üòÉüòÉ thyme ' set = 'üòÉ' write ( stdout , g ) ' 12345678901234567890123456789012345678901234567890 ' write ( stdout , g ) line % character () write ( stdout , g ) scan ( line , set ) write ( stdout , g ) scan ( line , set , back =. true .) write ( stdout , g ) scan ( line , set , back =. false .) write ( stdout , g ) scan ( line , unicode_type ( \"NOT\" )) write ( stdout , g ) ' OOP ' write ( stdout , g ) line % scan ( set ) write ( stdout , g ) line % scan ( ut ( \"o\" )) end program demo_scan Results: >            2\n >            6\n >            0\n > 12345678901234567890123456789012345678901234567890\n > parsleyüòÉsageüòÉrosemaryüòÉüòÉthyme\n > 8\n > 23\n > 8\n > 0\n > OOP\n > 8\n > 15 SEE ALSO Functions that perform operations on character strings, return lengths\n   of arguments, and search for certain arguments: ADJUSTL(3), ADJUSTR(3), INDEX(3), VERIFY(3) LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3) AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer private pure elemental function scan_ua(string, set, back) result(pos) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer public        interface sort private  subroutine sort_quick_rx(data, indx) NAME SORT(3f) - [M_unicode:SORT] indexed hybrid quicksort of\n an array\n (LICENSE:MIT) SYNOPSIS subroutine sort ( data , index ) type ( unicode_type ), intent ( in ) :: data (:) integer , intent ( out ) :: indx ( size ( data )) DESCRIPTION A rank hybrid quicksort . The data is not moved . An integer array is generated instead with values that are indices to the sorted order of the data . This requires a second array the size of the input array , which for large arrays would require a significant amount of memory . One major advantage of this method is that the indices can be used to access an entire user - defined type in sorted order . This makes this seemingly simple sort procedure usable with the vast majority of user - defined types . or other correlated data . BACKGROUND From Leonard J . Moss of SLAC : Here ' s a hybrid QuickSort I wrote a number of years ago . It ' s based on suggestions in Knuth , Volume 3 , and performs much better than a pure QuickSort on short or partially ordered input arrays . This routine performs an in - memory sort of the first N elements of array DATA , returning into array INDEX the indices of elements of DATA arranged in ascending order . Thus , DATA ( INDX ( 1 )) will be the smallest number in array DATA ; DATA ( INDX ( N )) will be the largest number in DATA . The original data is not physically rearranged . The original order of equal input values is not necessarily preserved . sort ( 3f ) uses a hybrid QuickSort algorithm , based on several suggestions in Knuth , Volume 3 , Section 5.2.2 . In particular , the \"pivot key\" [ my term ] for dividing each subsequence is chosen to be the median of the first , last , and middle values of the subsequence ; and the QuickSort is cut off when a subsequence has 9 or fewer elements , and a straight insertion sort of the entire array is done at the end . The result is comparable to a pure insertion sort for very short arrays , and very fast for very large arrays ( of order 12 micro - sec / element on the 3081 K for arrays of 10 K elements ). It is also not subject to the poor performance of the pure QuickSort on partially ordered data . Complex values are sorted by the magnitude of sqrt ( r ** 2 + i ** 2 ). o Created : sortrx ( 3f ) : 15 Jul 1986 , Len Moss o saved from url = ( 0044 ) http : //www.fortran.com/fortran/quick_sort2.f o changed to update syntax from F77 style ; John S . Urban 20161021 o generalized from only real values to include other intrinsic types ; John S . Urban 20210110 o type ( unicode_type ) version JSU 2025-09 -20. See M_sort for other types . EXAMPLES Sample usage: program demo_sort use iso_fortran_env , only : stdout => output_unit use M_unicode , only : sort , unicode_type , assignment (=) use M_unicode , only : ut => unicode_type , write ( formatted ) use M_unicode , only : ch => character implicit none character ( len = * ), parameter :: g = ' ( * ( g0 , 1 x )) ' integer , parameter :: isz = 4 type ( unicode_type ) :: rr ( isz ) integer :: ii ( isz ) integer :: i ! write ( stdout , g ) ' sort array with sort ( 3 f ) ' rr =[ & ut ( \"the\" ), & ut ( \"quick\" ), & ut ( \"brown\" ), & ut ( \"fox\" ) ] ! write ( stdout , g ) ' original order ' write ( stdout , g ) ch ( rr ) ! call sort ( rr , ii ) ! write ( stdout , g ) ' sorted order ' ! convert to character do i = 1 , size ( rr ) write ( stdout , ' ( i3 .3 , 1 x , a ) ' ) i , rr ( ii ( i )) % character () enddo ! write ( stdout , g ) ' reorder original ' rr = rr ( ii ) write ( stdout , g ) ch ( rr ) end program demo_sort Results: > sort array with sort(3f)\n> original order\n> the quick brown fox\n> sorted order\n> 001 brown\n> 002 fox\n> 003 quick\n> 004 the\n> reorder original\n> brown fox quick the AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: data (:) integer(kind=int32), intent(out) :: indx (:) public        interface split private impure subroutine split_first_last(string, set, first, last) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set integer, intent(out), allocatable :: first (:) integer, intent(out), allocatable :: last (:) private impure subroutine split_first_last_uaii(string, set, first, last) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string character(len=*), intent(in) :: set integer, intent(out), allocatable :: first (:) integer, intent(out), optional, allocatable :: last (:) private impure subroutine split_pos(string, set, pos, back) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set integer, intent(inout) :: pos logical, intent(in), optional :: back private impure subroutine split_pos_uail(string, set, pos, back) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string character(len=*), intent(in) :: set integer, intent(inout) :: pos logical, intent(in), optional :: back private impure subroutine split_tokens(string, set, tokens, separator) NAME SPLIT(3f) - [M_unicode:PARSE] parse a string into tokens, one at a time.\n   (LICENSE:MIT) SYNOPSIS call split (string, set, pos [, back]) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set integer , intent ( inout ) :: pos logical , intent ( in ), optional :: back CHARACTERISTICS STRING is a scalar character variable SET is a scalar string variable DESCRIPTION Find the extent of consecutive tokens in a string. given a string and\n   a position to start looking for a token return the position of the\n   end of the token. a set of separator characters may be specified as\n   well as the direction of parsing. typically consecutive calls are used to parse a string into a set of\n   tokens by stepping through the start and end positions of each token. OPTIONS STRING : the string to search for tokens in. SET : Each character in set is a token delimiter. a sequence of\n     zero or more characters in string delimited by any token delimiter,\n     or the beginning or end of string, comprise a token. thus, two\n     consecutive token delimiters in STRING, or a token delimiter in the\n     first or last character of STRING, indicate a token with zero length. POS : on input, the position from which to start looking for the next\n     separator from. This is typically the first character or the last\n     returned value of POS if searching from left to right (ie. back is\n     absent or .true.) or the last character or the last returned value\n     of POS when searching from right to left (ie. when back is .FALSE.). If BACK is present with the value .TRUE., the value of pos shall be\n in the range 0 < POS <= len(STRING)+1; otherwise it shall be in the\n range 0 <= POS <= len(STRING). So POS on input is typically an end of the string or the position\n of a separator, probably from a previous call to split but POS on\n input can be any position in the range 1 <= POS <= len(STRING). if\n POS points to a non-separator character in the string the call is\n still valid but it will start searching from the specified position\n and that will result (somewhat obviously) in the string from POS on\n input to the returned POS being a partial token. BACK : If BACK is absent or is present with the value .FALSE., POS is\n     assigned the position of the leftmost token delimiter in string\n     whose position is greater than POS, or if there is no such character,\n     it is assigned a value one greater than the length of string. this\n     identifies a token with starting position one greater than the value\n     of POS on invocation, and ending position one less than the value\n     of POS on return. If BACK is present with the value .TRUE., POS is assigned the\n position of the rightmost token delimiter in string whose position\n is less than POS, or if there is no such character, it is assigned\n the value zero. This identifies a token with ending position one\n less than the value of POS on invocation, and starting position one\n greater than the value of POS  on return. EXAMPLE sample program: program demo_split use iso_fortran_env , only : stdout => output_unit use M_unicode , only : unicode_type , assignment (=) use M_unicode , only : split , len , character use M_unicode , only : ut => unicode_type implicit none character ( len = * ), parameter :: g = ' ( * ( g0 , 1 x )) ' type ( ut ) :: proverb type ( ut ) :: delims type ( ut ), allocatable :: array (:) integer :: first integer :: last integer :: pos integer :: i ! delims = ' = | ; ' ! proverb = \"M√°s vale p√°jaro en mano, que ciento volando.\" call printwords ( proverb ) ! there really are not spaces between these glyphs array =[ & ut ( \"‰∏ÉËª¢„Å≥ÂÖ´Ëµ∑„Åç„ÄÇ\" ), & ut ( \"Ëª¢„Çì„Åß„ÇÇ„Åæ„ÅüÁ´ã„Å°‰∏ä„Åå„Çã„ÄÇ\" ), & ut ( \"„Åè„Åò„Åë„Åö„Å´Ââç„ÇíÂêë„ÅÑ„Å¶Ê≠©„ÅÑ„Å¶„ÅÑ„Åì„ÅÜ„ÄÇ\" )] call printwords ( array ) ! write ( stdout , g ) ' OOP ' array = proverb % split ( ut ( ' ' )) write ( stdout , ' ( * (: \"[\" , a , \"]\" )) ' )( character ( array ( i )), i = 1 , size ( array )) contains impure elemental subroutine printwords ( line ) type ( ut ), intent ( in ) :: line pos = 0 write ( stdout , g ) line % character (), len ( line ) do while ( pos < len ( line )) first = pos + 1 call split ( line , delims , pos ) last = pos - 1 print g , line % character ( first , last ), first , last , pos end do end subroutine printwords end program demo_split Results: > Project is up to date > M√°s vale p√°jaro en mano , que ciento volando . 44 > M√°s 1 3 4 > vale 5 8 9 > p√°jaro 10 15 16 > en 17 18 19 > mano , 20 24 25 > que 26 28 29 > ciento 30 35 36 > volando . 37 44 45 > ‰∏ÉËª¢„Å≥ÂÖ´Ëµ∑„Åç „ÄÇ 7 > ‰∏ÉËª¢„Å≥ÂÖ´Ëµ∑„Åç „ÄÇ 1 7 8 > Ëª¢„Çì„Åß„ÇÇ„Åæ„ÅüÁ´ã„Å°‰∏ä„Åå„Çã „ÄÇ 12 > Ëª¢„Çì„Åß„ÇÇ„Åæ„ÅüÁ´ã„Å°‰∏ä„Åå„Çã „ÄÇ 1 12 13 > „Åè„Åò„Åë„Åö„Å´Ââç„ÇíÂêë„ÅÑ„Å¶Ê≠©„ÅÑ„Å¶„ÅÑ„Åì„ÅÜ „ÄÇ 17 > „Åè„Åò„Åë„Åö„Å´Ââç„ÇíÂêë„ÅÑ„Å¶Ê≠©„ÅÑ„Å¶„ÅÑ„Åì„ÅÜ „ÄÇ 1 17 18 > OOP > [ M√°s ][ vale ][ p√°jaro ][ en ][ mano, ][ que ][ ciento ][ volando. ] SEE ALSO tokenize(3) - parse a string into tokens index(3) - position of a substring within a string scan(3) - scan a string for the presence of a set of characters verify(3)  -  position  of a character in a string of characters that does\n     not appear in a given set of characters. AUTHOR Milan Curcic , \"milancurcic@hey.com\" John S . Urban -- UTF-8 version LICENSE MIT NAME TOKENIZE(3f) - [M_unicode:PARSE] Parse a string into tokens.\n   (LICENSE:MIT) SYNOPSIS TOKEN form (returns array of strings) subroutine tokenize ( string , set , tokens [, separator ]) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set type ( unicode_type ), allocatable , intent ( out ) :: tokens (:) type ( unicode_type ), allocatable , intent ( out ), optional :: separator (:) ARRAY BOUNDS form (returns arrays defining token positions) subroutine tokenize ( string , set , first , last ) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set integer , allocatable , intent ( out ) :: first (:) integer , allocatable , intent ( out ) :: last (:) CHARACTERISTICS STRING ‚Äê a scalar of type string. It is an INTENT(IN)\n      argument. SET ‚Äê a scalar of type string with the same kind type\n      parameter as STRING. It is an INTENT(IN) argument. SEPARATOR ‚Äê (optional) shall be of type string. It is an\n      INTENT(OUT)argument. It shall not be a coarray or a coindexed object. TOKENS ‚Äê of type string. It is an INTENT(OUT) argument. It shall\n      not be a coarray or a coindexed object. FIRST,LAST ‚Äê an allocatable array of type integer and rank\n      one. It is an INTENT(OUT) argument. It shall not be a coarray or a\n      coindexed object. DESCRIPTION TOKENIZE(3) parses a string into tokens. There are two forms of the\n   subroutine TOKENIZE(3). The token form returns an array with one token per element,\n      all of the same length as the longest token. The array bounds form returns two integer arrays. One\n      contains the beginning position of the tokens and the other the end\n      positions. Since the token form pads all the tokens to the same length the\n   original number of trailing spaces of each token accept for the\n   longest is lost. The array bounds form retains information regarding the exact token\n   length even when padded by spaces. OPTIONS ‚Ä¢  STRING : The string to parse into tokens. SET :  Each character in SET is a token delimiter. A\n      sequence of zero or more characters in STRING delimited by any token\n      delimiter, or the beginning or end of STRING, comprise a token. Thus,\n      two consecutive token delimiters in STRING, or a token delimiter\n      in the first or last character of STRING, indicate a token with\n      zero length. TOKENS : It shall be an allocatable array of rank one with\n      deferred length. It is allocated with the lower bound equal to one\n      and the upper bound equal to the number of tokens in STRING, and\n      with character length equal to the length of the longest token. The tokens in STRING are assigned in the order found, as if by\n  intrinsic assignment, to the elements of TOKENS, in array element\n  order. FIRST : shall be an allocatable array of type integer and rank one.\n      It is an INTENT(OUT) argument. It shall not be a coarray or\n      a coindexed object. It is allocated with the lower bound equal to one and the upper\n  bound equal to the number of tokens in STRING. Each element is\n  assigned, in array element order, the starting position of each\n  token in STRING, in the order found. If a token has zero length, the starting position is equal to\n  one if the token is at the beginning of STRING, and one greater\n  than the position of the preceding delimiter otherwise. LAST : It is allocated with the lower bound equal to one and the\n      upper bound equal to the number of tokens in STRING. Each\n      element is assigned, in array element order, the ending position\n      of each token in STRING, in the order found. If a token has zero length, the ending position is one less than\n  the starting position. EXAMPLES Sample of uses program demo_tokenize use M_unicode , only : tokenize , ut => unicode_type , ch => character use M_unicode , only : assignment (=), operator ( /= ) implicit none ! ! some useful formats character ( len = * ), parameter :: & & brackets = ' ( * ( \"[\" , g0 , \"]\" :, \",\" )) ' , & & a_commas = ' ( a , * ( g0 :, \",\" )) ' , & & gen = ' ( * ( g0 )) ' ! ! Execution of TOKEN form ( return array of tokens ) ! block type ( ut ) :: string type ( ut ), allocatable :: tokens (:) integer :: i string = ' first , second , third ' call tokenize ( string , set = ' ;, ' , tokens = tokens ) write ( * , brackets ) ch ( tokens ) string = ' first , second , third ' call tokenize ( string , set = ' , ' , tokens = tokens ) write ( * , brackets )( tokens ( i ) % character (), i = 1 , size ( tokens )) ! remove blank tokens tokens = pack ( tokens , tokens /= '' ) write ( * , brackets ) ch ( tokens ) ! endblock ! ! Execution of BOUNDS form ( return position of tokens ) ! block type ( ut ) :: string character ( len = * ), parameter :: set = \" ,\" integer , allocatable :: first (:), last (:) write ( * , gen ) repeat ( ' 1234567890 ' , 6 ) string = ' first , second ,, fourth ' write ( * , gen ) ch ( string ) call tokenize ( string , set , first , last ) write ( * , a_commas ) ' FIRST = ' , first write ( * , a_commas ) ' LAST = ' , last write ( * , a_commas ) ' HAS LENGTH = ' , last - first . gt .0 endblock ! end program demo_tokenize Results: > [ first ] , [ second ] , [ third ] > [] , [ first ] , [] , [] , [ second ] , [] , [ third ] , [] , [] , [] , [] , [] > [ first ] , [ second ] , [ third ] > 123456789012345678901234567890123456789012345678901234567890 > first , second ,, fourth > FIRST = 1 , 7 , 14 , 15 > LAST = 5 , 12 , 13 , 20 > HAS LENGTH = T , T , F , T SEE ALSO SPLIT(3) ‚Äê return tokens from a string, one at a time INDEX(3) ‚Äê Position of a substring within a string SCAN(3) ‚Äê Scan a string for the presence of a set of characters VERIFY(3) ‚Äê Position of a character in a string of characters\n                  that does not appear in a given set of characters. AUTHOR Milan Curcic , \"milancurcic@hey.com\" John S . Urban -- UTF-8 version LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set type( unicode_type ), intent(out), allocatable :: tokens (:) type( unicode_type ), intent(out), optional, allocatable :: separator (:) private impure subroutine split_tokens_uauu(string, set, tokens, separator) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string character(len=*), intent(in) :: set type( unicode_type ), intent(out), allocatable :: tokens (:) type( unicode_type ), intent(out), optional, allocatable :: separator (:) public        interface tokenize private impure subroutine split_first_last(string, set, first, last) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set integer, intent(out), allocatable :: first (:) integer, intent(out), allocatable :: last (:) private impure subroutine split_first_last_uaii(string, set, first, last) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string character(len=*), intent(in) :: set integer, intent(out), allocatable :: first (:) integer, intent(out), optional, allocatable :: last (:) private impure subroutine split_pos(string, set, pos, back) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set integer, intent(inout) :: pos logical, intent(in), optional :: back private impure subroutine split_pos_uail(string, set, pos, back) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string character(len=*), intent(in) :: set integer, intent(inout) :: pos logical, intent(in), optional :: back private impure subroutine split_tokens(string, set, tokens, separator) NAME SPLIT(3f) - [M_unicode:PARSE] parse a string into tokens, one at a time.\n   (LICENSE:MIT) SYNOPSIS call split (string, set, pos [, back]) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set integer , intent ( inout ) :: pos logical , intent ( in ), optional :: back CHARACTERISTICS STRING is a scalar character variable SET is a scalar string variable DESCRIPTION Find the extent of consecutive tokens in a string. given a string and\n   a position to start looking for a token return the position of the\n   end of the token. a set of separator characters may be specified as\n   well as the direction of parsing. typically consecutive calls are used to parse a string into a set of\n   tokens by stepping through the start and end positions of each token. OPTIONS STRING : the string to search for tokens in. SET : Each character in set is a token delimiter. a sequence of\n     zero or more characters in string delimited by any token delimiter,\n     or the beginning or end of string, comprise a token. thus, two\n     consecutive token delimiters in STRING, or a token delimiter in the\n     first or last character of STRING, indicate a token with zero length. POS : on input, the position from which to start looking for the next\n     separator from. This is typically the first character or the last\n     returned value of POS if searching from left to right (ie. back is\n     absent or .true.) or the last character or the last returned value\n     of POS when searching from right to left (ie. when back is .FALSE.). If BACK is present with the value .TRUE., the value of pos shall be\n in the range 0 < POS <= len(STRING)+1; otherwise it shall be in the\n range 0 <= POS <= len(STRING). So POS on input is typically an end of the string or the position\n of a separator, probably from a previous call to split but POS on\n input can be any position in the range 1 <= POS <= len(STRING). if\n POS points to a non-separator character in the string the call is\n still valid but it will start searching from the specified position\n and that will result (somewhat obviously) in the string from POS on\n input to the returned POS being a partial token. BACK : If BACK is absent or is present with the value .FALSE., POS is\n     assigned the position of the leftmost token delimiter in string\n     whose position is greater than POS, or if there is no such character,\n     it is assigned a value one greater than the length of string. this\n     identifies a token with starting position one greater than the value\n     of POS on invocation, and ending position one less than the value\n     of POS on return. If BACK is present with the value .TRUE., POS is assigned the\n position of the rightmost token delimiter in string whose position\n is less than POS, or if there is no such character, it is assigned\n the value zero. This identifies a token with ending position one\n less than the value of POS on invocation, and starting position one\n greater than the value of POS  on return. EXAMPLE sample program: program demo_split use iso_fortran_env , only : stdout => output_unit use M_unicode , only : unicode_type , assignment (=) use M_unicode , only : split , len , character use M_unicode , only : ut => unicode_type implicit none character ( len = * ), parameter :: g = ' ( * ( g0 , 1 x )) ' type ( ut ) :: proverb type ( ut ) :: delims type ( ut ), allocatable :: array (:) integer :: first integer :: last integer :: pos integer :: i ! delims = ' = | ; ' ! proverb = \"M√°s vale p√°jaro en mano, que ciento volando.\" call printwords ( proverb ) ! there really are not spaces between these glyphs array =[ & ut ( \"‰∏ÉËª¢„Å≥ÂÖ´Ëµ∑„Åç„ÄÇ\" ), & ut ( \"Ëª¢„Çì„Åß„ÇÇ„Åæ„ÅüÁ´ã„Å°‰∏ä„Åå„Çã„ÄÇ\" ), & ut ( \"„Åè„Åò„Åë„Åö„Å´Ââç„ÇíÂêë„ÅÑ„Å¶Ê≠©„ÅÑ„Å¶„ÅÑ„Åì„ÅÜ„ÄÇ\" )] call printwords ( array ) ! write ( stdout , g ) ' OOP ' array = proverb % split ( ut ( ' ' )) write ( stdout , ' ( * (: \"[\" , a , \"]\" )) ' )( character ( array ( i )), i = 1 , size ( array )) contains impure elemental subroutine printwords ( line ) type ( ut ), intent ( in ) :: line pos = 0 write ( stdout , g ) line % character (), len ( line ) do while ( pos < len ( line )) first = pos + 1 call split ( line , delims , pos ) last = pos - 1 print g , line % character ( first , last ), first , last , pos end do end subroutine printwords end program demo_split Results: > Project is up to date > M√°s vale p√°jaro en mano , que ciento volando . 44 > M√°s 1 3 4 > vale 5 8 9 > p√°jaro 10 15 16 > en 17 18 19 > mano , 20 24 25 > que 26 28 29 > ciento 30 35 36 > volando . 37 44 45 > ‰∏ÉËª¢„Å≥ÂÖ´Ëµ∑„Åç „ÄÇ 7 > ‰∏ÉËª¢„Å≥ÂÖ´Ëµ∑„Åç „ÄÇ 1 7 8 > Ëª¢„Çì„Åß„ÇÇ„Åæ„ÅüÁ´ã„Å°‰∏ä„Åå„Çã „ÄÇ 12 > Ëª¢„Çì„Åß„ÇÇ„Åæ„ÅüÁ´ã„Å°‰∏ä„Åå„Çã „ÄÇ 1 12 13 > „Åè„Åò„Åë„Åö„Å´Ââç„ÇíÂêë„ÅÑ„Å¶Ê≠©„ÅÑ„Å¶„ÅÑ„Åì„ÅÜ „ÄÇ 17 > „Åè„Åò„Åë„Åö„Å´Ââç„ÇíÂêë„ÅÑ„Å¶Ê≠©„ÅÑ„Å¶„ÅÑ„Åì„ÅÜ „ÄÇ 1 17 18 > OOP > [ M√°s ][ vale ][ p√°jaro ][ en ][ mano, ][ que ][ ciento ][ volando. ] SEE ALSO tokenize(3) - parse a string into tokens index(3) - position of a substring within a string scan(3) - scan a string for the presence of a set of characters verify(3)  -  position  of a character in a string of characters that does\n     not appear in a given set of characters. AUTHOR Milan Curcic , \"milancurcic@hey.com\" John S . Urban -- UTF-8 version LICENSE MIT NAME TOKENIZE(3f) - [M_unicode:PARSE] Parse a string into tokens.\n   (LICENSE:MIT) SYNOPSIS TOKEN form (returns array of strings) subroutine tokenize ( string , set , tokens [, separator ]) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set type ( unicode_type ), allocatable , intent ( out ) :: tokens (:) type ( unicode_type ), allocatable , intent ( out ), optional :: separator (:) ARRAY BOUNDS form (returns arrays defining token positions) subroutine tokenize ( string , set , first , last ) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set integer , allocatable , intent ( out ) :: first (:) integer , allocatable , intent ( out ) :: last (:) CHARACTERISTICS STRING ‚Äê a scalar of type string. It is an INTENT(IN)\n      argument. SET ‚Äê a scalar of type string with the same kind type\n      parameter as STRING. It is an INTENT(IN) argument. SEPARATOR ‚Äê (optional) shall be of type string. It is an\n      INTENT(OUT)argument. It shall not be a coarray or a coindexed object. TOKENS ‚Äê of type string. It is an INTENT(OUT) argument. It shall\n      not be a coarray or a coindexed object. FIRST,LAST ‚Äê an allocatable array of type integer and rank\n      one. It is an INTENT(OUT) argument. It shall not be a coarray or a\n      coindexed object. DESCRIPTION TOKENIZE(3) parses a string into tokens. There are two forms of the\n   subroutine TOKENIZE(3). The token form returns an array with one token per element,\n      all of the same length as the longest token. The array bounds form returns two integer arrays. One\n      contains the beginning position of the tokens and the other the end\n      positions. Since the token form pads all the tokens to the same length the\n   original number of trailing spaces of each token accept for the\n   longest is lost. The array bounds form retains information regarding the exact token\n   length even when padded by spaces. OPTIONS ‚Ä¢  STRING : The string to parse into tokens. SET :  Each character in SET is a token delimiter. A\n      sequence of zero or more characters in STRING delimited by any token\n      delimiter, or the beginning or end of STRING, comprise a token. Thus,\n      two consecutive token delimiters in STRING, or a token delimiter\n      in the first or last character of STRING, indicate a token with\n      zero length. TOKENS : It shall be an allocatable array of rank one with\n      deferred length. It is allocated with the lower bound equal to one\n      and the upper bound equal to the number of tokens in STRING, and\n      with character length equal to the length of the longest token. The tokens in STRING are assigned in the order found, as if by\n  intrinsic assignment, to the elements of TOKENS, in array element\n  order. FIRST : shall be an allocatable array of type integer and rank one.\n      It is an INTENT(OUT) argument. It shall not be a coarray or\n      a coindexed object. It is allocated with the lower bound equal to one and the upper\n  bound equal to the number of tokens in STRING. Each element is\n  assigned, in array element order, the starting position of each\n  token in STRING, in the order found. If a token has zero length, the starting position is equal to\n  one if the token is at the beginning of STRING, and one greater\n  than the position of the preceding delimiter otherwise. LAST : It is allocated with the lower bound equal to one and the\n      upper bound equal to the number of tokens in STRING. Each\n      element is assigned, in array element order, the ending position\n      of each token in STRING, in the order found. If a token has zero length, the ending position is one less than\n  the starting position. EXAMPLES Sample of uses program demo_tokenize use M_unicode , only : tokenize , ut => unicode_type , ch => character use M_unicode , only : assignment (=), operator ( /= ) implicit none ! ! some useful formats character ( len = * ), parameter :: & & brackets = ' ( * ( \"[\" , g0 , \"]\" :, \",\" )) ' , & & a_commas = ' ( a , * ( g0 :, \",\" )) ' , & & gen = ' ( * ( g0 )) ' ! ! Execution of TOKEN form ( return array of tokens ) ! block type ( ut ) :: string type ( ut ), allocatable :: tokens (:) integer :: i string = ' first , second , third ' call tokenize ( string , set = ' ;, ' , tokens = tokens ) write ( * , brackets ) ch ( tokens ) string = ' first , second , third ' call tokenize ( string , set = ' , ' , tokens = tokens ) write ( * , brackets )( tokens ( i ) % character (), i = 1 , size ( tokens )) ! remove blank tokens tokens = pack ( tokens , tokens /= '' ) write ( * , brackets ) ch ( tokens ) ! endblock ! ! Execution of BOUNDS form ( return position of tokens ) ! block type ( ut ) :: string character ( len = * ), parameter :: set = \" ,\" integer , allocatable :: first (:), last (:) write ( * , gen ) repeat ( ' 1234567890 ' , 6 ) string = ' first , second ,, fourth ' write ( * , gen ) ch ( string ) call tokenize ( string , set , first , last ) write ( * , a_commas ) ' FIRST = ' , first write ( * , a_commas ) ' LAST = ' , last write ( * , a_commas ) ' HAS LENGTH = ' , last - first . gt .0 endblock ! end program demo_tokenize Results: > [ first ] , [ second ] , [ third ] > [] , [ first ] , [] , [] , [ second ] , [] , [ third ] , [] , [] , [] , [] , [] > [ first ] , [ second ] , [ third ] > 123456789012345678901234567890123456789012345678901234567890 > first , second ,, fourth > FIRST = 1 , 7 , 14 , 15 > LAST = 5 , 12 , 13 , 20 > HAS LENGTH = T , T , F , T SEE ALSO SPLIT(3) ‚Äê return tokens from a string, one at a time INDEX(3) ‚Äê Position of a substring within a string SCAN(3) ‚Äê Scan a string for the presence of a set of characters VERIFY(3) ‚Äê Position of a character in a string of characters\n                  that does not appear in a given set of characters. AUTHOR Milan Curcic , \"milancurcic@hey.com\" John S . Urban -- UTF-8 version LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set type( unicode_type ), intent(out), allocatable :: tokens (:) type( unicode_type ), intent(out), optional, allocatable :: separator (:) private impure subroutine split_tokens_uauu(string, set, tokens, separator) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string character(len=*), intent(in) :: set type( unicode_type ), intent(out), allocatable :: tokens (:) type( unicode_type ), intent(out), optional, allocatable :: separator (:) public        interface transliterate private impure function transliterate_uuu(instr, old_set, new_set) result(outstr) NAME transliterate(3f) - [M_unicode:EDITING] replace characters from old\n                     set with new set\n (LICENSE:PD) SYNOPSIS impure function transliterate ( instr , old_set , new_set ) result ( outstr ) type ( unicode_type ), intent ( in ) :: instr type ( unicode_type ), intent ( in ) :: old_set type ( unicode_type ), intent ( in ) :: new_set type ( unicode_type ) :: outstr CHARACTERISTICS Although a conversion might occur on each call, the input values\nmay be CHARACTER as well as TYPE(UNICODE_TYPE). DESCRIPTION Translate or delete characters from an input string. OPTIONS instr    input string to change\n   old_set  list of glyphs to change in INSTR if found Each glyph in the input string that matches a glyph\n        in the old set is replaced. new_set  list of glyphs to replace glyphs in OLD_SET with. If NEW_SET is the empty set glyphs in INSTR that\n        match any in OLD_SET are deleted.\n\n        If NEW_SET is shorter than OLD_SET the last glyph\n        in NEW_SET is used to replace the remaining glyphs\n        in NEW_SET. RETURNS outstr  INSTR with substitutions applied EXAMPLES Sample Program: program demo_transliterate use M_unicode , only : transliterate , ut => unicode_type use M_unicode , only : write ( formatted ), ch => character use M_unicode , only : assignment (=) implicit none character ( len = * ), parameter :: u = ' ( DT ) ' type ( ut ) :: STRING , UPPER , LOWER type ( ut ) :: MIDDLE_DOT STRING = ' aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ ' LOWER = ' abcdefghijklmnopqrstuvwxyz ' UPPER = ' ABCDEFGHIJKLMNOPQRSTUVWXYZ ' call callit () print u print u , ut ( ' Greek ' ) ! ! | Œë Œ± | Œí Œ≤ | Œì Œ≥ | Œî Œ¥ | Œï Œµ | Œñ Œ∂ | ! | Œó Œ∑ | Œò Œ∏ | Œô Œπ | Œö Œ∫ | Œõ Œª | Œú Œº | ! | Œù ŒΩ | Œû Œæ | Œü Œø | Œ† œÄ | Œ° œÅ | Œ£ œÉ œÇ | ! | Œ§ œÑ | Œ• œÖ | Œ¶ œÜ | Œß œá | Œ® œà | Œ© œâ | ! STRING = ' ŒëŒ±ŒíŒ≤ŒìŒ≥ŒîŒ¥ŒïŒµŒñŒ∂ŒóŒ∑ŒòŒ∏ŒôŒπŒöŒ∫ŒõŒªŒúŒºŒùŒΩŒûŒæŒüŒøŒ†œÄŒ°œÅŒ£œÉœÇŒ§œÑŒ•œÖŒ¶œÜŒßœáŒ®œàŒ©œâ ' ! ignoring œÇ for simplicity UPPER = ' ŒëŒíŒìŒîŒïŒñŒóŒòŒôŒöŒõŒúŒùŒûŒüŒ†Œ°Œ£Œ§Œ•Œ¶ŒßŒ®Œ© ' LOWER = ' Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÉœÑœÖœÜœáœàœâ ' call callit () ! OOP print u print u , ut ( ' OOP ! ' ) print u , STRING % TRANSLITERATE ( UPPER , '_' ) ! U + 00 B7 Middle Dot Unicode Character print u , STRING % TRANSLITERATE ( LOWER , '¬∑' ) ! ASCII bytes print u , STRING % TRANSLITERATE ( LOWER , ut ( '¬∑' )) ! cast MIDDLE_DOT = int ( z ' 00 B7 ' ) print u , STRING % TRANSLITERATE ( LOWER , MIDDLE_DOT ) ! hexadecimal contains subroutine callit () print u , STRING ! convert - 7 string to uppercase : print u , TRANSLITERATE ( STRING , LOWER , UPPER ) ! change all miniscule letters to a colon ( \":\" ): print u , TRANSLITERATE ( STRING , LOWER , ':' ) ! delete all miniscule letters print u , TRANSLITERATE ( STRING , LOWER , '' ) end subroutine callit end program demo_transliterate Results: > aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ > AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYYZZ > :A:B:C:D:E:F:G:H:I:J:K:L:M:N:O:P:Q:R:S:T:U:V:W:X:Y:Z > ABCDEFGHIJKLMNOPQRSTUVWXYZ > > Greek > ŒëŒ±ŒíŒ≤ŒìŒ≥ŒîŒ¥ŒïŒµŒñŒ∂ŒóŒ∑ŒòŒ∏ŒôŒπŒöŒ∫ŒõŒªŒúŒºŒùŒΩŒûŒæŒüŒøŒ†œÄŒ°œÅŒ£œÉœÇŒ§œÑŒ•œÖŒ¶œÜŒßœáŒ®œàŒ©œâ > ŒëŒëŒíŒíŒìŒìŒîŒîŒïŒïŒñŒñŒóŒóŒòŒòŒôŒôŒöŒöŒõŒõŒúŒúŒùŒùŒûŒûŒüŒüŒ†Œ†Œ°Œ°Œ£Œ£œÇŒ§Œ§Œ•Œ•Œ¶Œ¶ŒßŒßŒ®Œ®Œ©Œ© > Œë:Œí:Œì:Œî:Œï:Œñ:Œó:Œò:Œô:Œö:Œõ:Œú:Œù:Œû:Œü:Œ†:Œ°:Œ£:œÇŒ§:Œ•:Œ¶:Œß:Œ®:Œ©: > ŒëŒíŒìŒîŒïŒñŒóŒòŒôŒöŒõŒúŒùŒûŒüŒ†Œ°Œ£œÇŒ§Œ•Œ¶ŒßŒ®Œ© > > OOP! > _Œ±_Œ≤_Œ≥_Œ¥_Œµ_Œ∂_Œ∑_Œ∏_Œπ_Œ∫_Œª_Œº_ŒΩ_Œæ_Œø_œÄ_œÅ_œÉœÇ_œÑ_œÖ_œÜ_œá_œà_œâ > Œë¬∑Œí¬∑Œì¬∑Œî¬∑Œï¬∑Œñ¬∑Œó¬∑Œò¬∑Œô¬∑Œö¬∑Œõ¬∑Œú¬∑Œù¬∑Œû¬∑Œü¬∑Œ†¬∑Œ°¬∑Œ£¬∑œÇŒ§¬∑Œ•¬∑Œ¶¬∑Œß¬∑Œ®¬∑Œ©¬∑ > Œë¬∑Œí¬∑Œì¬∑Œî¬∑Œï¬∑Œñ¬∑Œó¬∑Œò¬∑Œô¬∑Œö¬∑Œõ¬∑Œú¬∑Œù¬∑Œû¬∑Œü¬∑Œ†¬∑Œ°¬∑Œ£¬∑œÇŒ§¬∑Œ•¬∑Œ¶¬∑Œß¬∑Œ®¬∑Œ©¬∑ > Œë¬∑Œí¬∑Œì¬∑Œî¬∑Œï¬∑Œñ¬∑Œó¬∑Œò¬∑Œô¬∑Œö¬∑Œõ¬∑Œú¬∑Œù¬∑Œû¬∑Œü¬∑Œ†¬∑Œ°¬∑Œ£¬∑œÇŒ§¬∑Œ•¬∑Œ¶¬∑Œß¬∑Œ®¬∑Œ©¬∑ AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: instr type( unicode_type ), intent(in) :: old_set type( unicode_type ), intent(in) :: new_set Return Value type( unicode_type ) private  function transliterate_uua(instr, old_set, new_set) result(outstr) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: instr type( unicode_type ), intent(in) :: old_set character(len=*), intent(in) :: new_set Return Value type( unicode_type ) private  function transliterate_uaa(instr, old_set, new_set) result(outstr) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: instr character(len=*), intent(in) :: old_set character(len=*), intent(in) :: new_set Return Value type( unicode_type ) private  function transliterate_uau(instr, old_set, new_set) result(outstr) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: instr character(len=*), intent(in) :: old_set type( unicode_type ), intent(in) :: new_set Return Value type( unicode_type ) private  function transliterate_aaa(instr, old_set, new_set) result(outstr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: instr character(len=*), intent(in) :: old_set character(len=*), intent(in) :: new_set Return Value type( unicode_type ) private  function transliterate_aua(instr, old_set, new_set) result(outstr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: instr type( unicode_type ), intent(in) :: old_set character(len=*), intent(in) :: new_set Return Value type( unicode_type ) private  function transliterate_aau(instr, old_set, new_set) result(outstr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: instr character(len=*), intent(in) :: old_set type( unicode_type ), intent(in) :: new_set Return Value type( unicode_type ) private  function transliterate_auu(instr, old_set, new_set) result(outstr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: instr type( unicode_type ), intent(in) :: old_set type( unicode_type ), intent(in) :: new_set Return Value type( unicode_type ) public        interface trim private elemental function trim_str(string) result(trimmed_str) NAME TRIM(3f) - [M_unicode:WHITESPACE] remove trailing blank characters from\n              a string\n              (LICENSE:MIT) SYNOPSIS result = trim(string) type ( unicode_type ) function trim ( string ) type ( unicode_type ), intent ( in ) :: string CHARACTERISTICS the result is a string. DESCRIPTION trim(3) removes trailing blank characters from a string. OPTIONS string : a string to trim RESULT the result is the same as string except trailing blanks are removed. if string is composed entirely of blanks or has zero length, the\n   result has zero length. EXAMPLES sample program: program demo_trim use M_unicode , only : ut => unicode_type , assignment (=) use M_unicode , only : trim , len use M_unicode , only : write ( formatted ) implicit none type ( ut ) :: str type ( ut ), allocatable :: strs (:) character ( len = * ), parameter :: brackets = ' ( * ( \"[\" , DT , \"]\" :, 1 x ) ) ' integer :: i ! str = ' trailing ' print brackets , str , trim ( str ) ! trims it ! str = ' leading ' print brackets , str , trim ( str ) ! no effect ! str = ' ' print brackets , str , trim ( str ) ! becomes zero length print * , len ( str ), len ( trim ( ' ' )) ! strs =[ ut ( \"Z \" ), ut ( \" a b c\" ), ut ( \"ABC   \" ), ut ( \"\" )] ! write ( * , * ) ' untrimmed : ' print brackets , ( strs ( i ), i = 1 , size ( strs )) print brackets , strs ! write ( * , * ) ' trimmed : ' ! everything prints trimmed print brackets , ( trim ( strs ( i )), i = 1 , size ( strs )) print brackets , trim ( strs ) ! end program demo_trim results: > [ trailing ] [ trailing ] > [ leading ] [ leading ] > [ ] [] > 12 0 > untrimmed : > [ Z ] [ a b c ] [ ABC ] [] > [ Z ] [ a b c ] [ ABC ] [] > trimmed : > [ Z ] [ a b c ] [ ABC ] [] > [ Z ] [ a b c ] [ ABC ] [] SEE ALSO Functions that perform operations on character strings, return\n   lengths of arguments, and search for certain arguments: elemental: adjustl(3), adjustr(3), index(3), scan(3), verify(3) nonelemental: len_trim(3), len(3), repeat(3), trim(3) AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value type( unicode_type ) public        interface unicode_type private module function new_codes(codes) result(new) Arguments Type Intent Optional Attributes Name integer, intent(in) :: codes (:) Return Value type( unicode_type ) private elemental module function new_str(string) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Return Value type( unicode_type ) private module function new_strs(strings) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: strings (:) Return Value type( unicode_type ), (size(strings)) public        interface utf8_to_codepoints private pure subroutine utf8_to_codepoints_str(utf8, codepoints, nerr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: utf8 integer, intent(out), allocatable :: codepoints (:) integer, intent(out) :: nerr private pure subroutine utf8_to_codepoints_chars(utf8, codepoints, nerr) NAME UTF8_TO_CODEPOINTS(3f) - [M_unicode:CONVERSION] Convert UTF-8-encoded\n   data to Unicode codepoints\n   (LICENSE:MIT) SYNOPSIS pure subroutine utf8_to_codepoints(utf8,codepoints,nerr)\n\n character(len=1),intent(in)     :: utf8(:)\n !  or\n character(len=*),intent(in)     :: utf8\n !\n integer,allocatable,intent(out) :: codepoints(:)\n integer,intent(out)             :: nerr CHARACTERISTICS UTF8 is a scalar CHARACTER variable or array of single-byte\n     CHARACTER values the returned values in CODEPOINTS are of default INTEGER kind the error flag NERR is default integer kind DESCRIPTION UTF8_TO_CODEPOINTS(3f) takes either a scalar CHARACTER variable or\n   an array of CHARACTER(LEN=1) bytes which are treated as a stream of\n   bytes representing UTF-8-encoded data and converted to an INTEGER\n   array containing Unicode codepoint values for each glyph. In fact, this routine is also able to decode an ISOLATIN string OPTIONS UTF8 :  Scalar CHARACTER string or single-character array of CHARACTER\n             variables assumed to represent a stream of bytes containing\n             data encoded at UTF-8 text. CODEPOINTS :  An INTEGER array of Unicode codepoint values\n                   representing the glyphs found in STRING NERR :  Zero if no error occurred. If not zero the stream of bytes\n             could not be completely converted to UTF-8 characters. EXAMPLES Sample program program demo_utf8_to_codepoints use m_unicode , only : utf8_to_codepoints implicit none character ( len = * ), parameter :: string = ' Noho me ka hau ‚Äô oli ' !( Be happy ) character ( len = 1 ), allocatable :: bytes (:) character ( len = * ), parameter :: solid = ' ( * ( g0 )) ' character ( len = * ), parameter :: space = ' ( * ( g0 , 1 x )) ' character ( len = * ), parameter :: z = ' ( a , * ( z0 , 1 x )) ' integer , allocatable :: codepoints (:) integer :: nerr integer :: i ! BASIC USAGE : SCALAR CHARACTER VARIABLE write ( * , solid ) ' STRING : ' , string call utf8_to_codepoints ( string , codepoints , nerr ) write ( * , space ) ' CODEPOINTS : ' , codepoints write ( * , z ) ' HEXADECIMAL CODEPOINTS : ' , codepoints ! write ( * , space ) ' How long is this string in glyphs ? ' write ( * , space ) size ( codepoints ) write ( * , space ) ' How long is this string in bytes ? ' write ( * , space ) len ( string ) ! ! BASIC USAGE : ARRAY OF BYTES bytes =[( string ( i : i ), i = 1 , len ( string ))] write ( * , solid ) ' STRING : ' , bytes call utf8_to_codepoints ( bytes , codepoints , nerr ) write ( * , space ) ' CODEPOINTS : ' , codepoints write ( * , z ) ' HEXADECIMAL CODEPOINTS : ' , codepoints ! write ( * , space ) ' How long is this string in glyphs ? ' write ( * , space ) size ( codepoints ) write ( * , space ) ' How long is this string in bytes ? ' write ( * , space ) size ( bytes ) ! end program demo_utf8_to_codepoints Results: > STRING:Noho me ka hau‚Äôoli\n > CODEPOINTS: 78 111 104 111 32 109 101 32 107 97 32 104 97 117 ...\n > 8217 111 108 105\n > 48 4E 6F 68 6F 20 6D 65 20 6B 61 20 68 61 75 2019 6F 6C 69\n > How long is this string in glyphs?\n > 18\n > How long is this string in bytes?\n > 20\n > STRING:Noho me ka hau‚Äôoli\n > CODEPOINTS: 78 111 104 111 32 109 101 32 107 97 32 104 97 117 ...\n > 8217 111 108 105\n > 48 4E 6F 68 6F 20 6D 65 20 6B 61 20 68 61 75 2019 6F 6C 69\n > How long is this string in glyphs?\n > 18\n > How long is this string in bytes?\n > 20 SEE ALSO functions that perform operations on character strings: elemental: adjustl(3), adjustr(3), index(3), scan(3), verify(3) non-elemental: len_trim(3), repeat(3), trim(3), codepoints_to_utf8(3) AUTHOR John S. Urban Francois Jacq - enhancements and Latin support from Francois Jacq, 2025-08 LICENSE MIT Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: utf8 (:) integer, intent(out), allocatable :: codepoints (:) integer, intent(out) :: nerr public        interface verify private impure elemental function verify_uu(string, set, back) result(result) NAME VERIFY(3f) - [M_unicode:SEARCH] Position of a character in a string of\n   characters that does not appear in a given set of characters.\n   (LICENSE:MIT) SYNOPSIS result = verify(string, set [,back] [,kind] ) elemental integer function verify ( string , set , back , KIND ) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set or character ( len = * ), intent ( in ) :: set logical , intent ( in ), optional :: back CHARACTERISTICS STRING  must be of type string SET  must be of type string or character. BACK shall be of type logical. A default integer kind is returned. DESCRIPTION VERIFY(3) verifies that all the characters in STRING belong to the set of\n   characters in SET by identifying the position of the first character in the\n   string that is not in the set. This makes it easy to verify strings are all uppercase or lowercase, follow a\n   basic syntax, only contain printable characters, and many of the conditions\n   tested for with the C routines ISALNUM(3c), ISALPHA(3c), ISASCII(3c),\n   ISBLANK(3c), ISCNTRL(3c), ISDIGIT(3c), ISGRAPH(3c), ISLOWER(3c), ISPRINT(3c),\n   ISPUNCT(3c), ISSPACE(3c), ISUPPER(3c), and ISXDIGIT(3c); but for a string as\n   well as an array of strings. OPTIONS STRING : The string to search in for an unmatched character. SET : The set of characters that must be matched. BACK : The direction to look for an unmatched character. The left‚Äêmost\n      unmatched character position isreturned unless BACK is present and\n      .false., which causes the position of the right‚Äêmost unmatched character\n      to be returned instead of the left‚Äêmost unmatched character. RESULT If all characters of STRING are found in SET, the result is zero. If STRING is of zero length a zero (0) is always returned. Otherwise, if an unmatched character is found The position of the first or\n   last (if BACK is .false.) unmatched character in STRING is returned, starting\n   with position one on the left end of the string. EXAMPLES Sample program I: program demo_verify ! general examples use M_unicode , only : assignment (=) use M_unicode , only : ut => unicode_type , ch => character use M_unicode , only : write ( formatted ) use M_unicode , only : operator ( == ) use M_unicode , only : verify , replace use M_unicode , only : operator ( //) implicit none ! some useful character sets character , parameter :: & & int * ( * ) = \"1234567890\" , & & low * ( * ) = \"abcdefghijklmnopqrstuvwxyz\" , & & upp * ( * ) = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" , & & punc * ( * ) = \"!\"\"#$%&'()*+,‚Äê./:;<=>?@['_‚Äò{|}Àú\" , & & blank * ( * ) = \" \" , & & tab = char ( 11 ), & & prnt * ( * ) = int //low//upp//blank//punc ! type ( ut ) :: stru integer :: i print * , \"basics:\" print * , VERIFY ( \"ABBA\" , \"A\" ) ! has the value 2 . print * , VERIFY ( \"ABBA\" , \"A\" , BACK = . TRUE .) ! has the value 3 . print * , VERIFY ( \"ABBA\" , \"AB\" ) ! has the value 0 . ! print * , \"find first non‚Äêuppercase letter\" ! will produce the location of \"d\" , because there is no match in UPP write ( * , * ) \"something unmatched\" , verify ( ut ( \"ABCdEFG\" ), upp ) ! print * , \"if everything is matched return zero\" ! will produce 0 as all letters have a match write ( * , * ) & & \"everything matched\" , verify ( ut ( \"ffoorrttrraann\" ), \"nartrof\" ) ! print * , \"easily categorize strings as uppercase, lowercase, ...\" ! C - like functionality but does entire strings not just characters write ( * , * ) \"isdigit 123?\" , verify ( ut ( \"123\" ), int ) == 0 write ( * , * ) \"islower abc?\" , verify ( ut ( \"abc\" ), low ) == 0 write ( * , * ) \"isalpha aBc?\" , verify ( ut ( \"aBc\" ), low //upp) == 0 write ( * , * ) \"isblank aBc dEf?\" , verify ( ut ( \"aBc dEf\" ), blank //tab ) /= 0 ! check if all printable characters stru = \"aB;cde,fgHI!Jklmno PQRSTU vwxyz\" write ( * , * ) \"isprint?\" , verify ( stru , prnt ) == 0 ! ! this now has a nonprintable tab character in it stru = replace ( stru , 10 , 10 , ut ( char ( 11 ))) write ( * , * ) \"isprint?\" , verify ( stru , prnt ) == 0 ! print * , \"VERIFY(3) is very powerful using expressions as masks\" ! verify ( 3 ) is often used in a logical expression stru = \" This is NOT all UPPERCASE \" write ( * , * ) \"all uppercase/spaces?\" , verify ( stru , blank //upp) == 0 stru = \" This IS all uppercase \" write ( * , * ) \"stru=[\" //stru//\"]\" write ( * , * ) \"all uppercase/spaces?\" , verify ( stru , blank //upp) == 0 ! ! set and show complex stru to be tested stru = \"  Check this out. Let me know  \" ! show the stru being examined write ( * , * ) \"stru=[\" //stru//\"]\" write ( * , * ) \"        \" //repeat(int,4) ! number line ! ! function returns a position just not a logical like C print * , \"returning a position not just a logical is useful\" ! which can be very useful for parsing strings write ( * , * ) \"first non‚Äêblank character\" , verify ( stru , blank ) write ( * , * ) \"last non‚Äêblank character\" , verify ( stru , blank , back =. true .) write ( * , * ) \"first non‚Äêletter non‚Äêblank\" , verify ( stru , low //upp//blank) ! ! VERIFY ( 3 ) is elemental ( can check an array of strings in one call ) print * , \"elemental\" ! are strings all letters ( or blanks )? write ( * , * ) \"array of strings\" , verify ( & ! strings must all be same length , so force to length 10 & [ character ( len = 10 ) :: \"YES\" , \"ok\" , \"000\" , \"good one\" , \"Nope!\" ], & & low //upp//blank) == 0 ! ! rarer , but the set can be an array , not just the strings to test ! you could do ISPRINT () this ( harder ) way :> write ( * , * ) \"isprint?\" , & & . not . all ( verify ( ut ( \"aBc\" ), [( char ( i ), i = 32 , 126 )]) == 1 ) ! instead of this way write ( * , * ) \"isprint?\" , verify ( ut ( \"aBc\" ), prnt ) == 0 ! end program demo_verify Results: > basics : > 2 > 3 > 0 > find first non ‚Äê uppercase letter > something unmatched 4 > if everything is matched return zero > everything matched 0 > easily categorize strings as uppercase , lowercase , ... > isdigit 123 ? T > islower abc ? T > isalpha aBc ? T > isblank aBc dEf ? T > isprint ? T > isprint ? F > VERIFY ( 3 ) is very powerful using expressions as masks > all uppercase / spaces ? F > string = [ This IS all uppercase ] > all uppercase / spaces ? F > string = [ Check this out . Let me know ] > 1234567890123456789012345678901234567890 > returning a position not just a logical is useful > first non ‚Äê blank character 3 > last non ‚Äê blank character 29 > first non ‚Äê letter non ‚Äê blank 17 > elemental > array of strings T T F T F > isprint ? T > isprint ? T Sample program II: Determine if strings are valid integer representations program fortran_ints use M_unicode , only : ut => unicode_type , assignment (=) use M_unicode , only : adjustr , verify , trim , len use M_unicode , only : write ( formatted ) use M_unicode , only : operator (. cat .) use M_unicode , only : operator ( == ) implicit none integer :: i character ( len = * ), parameter :: asciiints ( * )=[ character ( len = 10 ) :: & \"+1 \" , & \"3044848 \" , & \"30.40 \" , & \"September \" , & \"1 2 3\" , & \"  -3000 \" , & \" \" ] type ( ut ), allocatable :: ints (:) if ( allocated ( ints )) deallocate ( ints ) allocate ( ints ( size ( asciiints ))) ! gfortran bug ints = asciiints ints = trim ( ints ) ! show if strings pass or fail the test done by isint ( 3 ) write ( * , \"('is integer?')\" ) do i = 1 , size ( ints ) write ( * , ' ( \"|\" , DT , T14 , \"|\" , l1 , \"|\" ) ' ) ints ( i ), isint ( ints ( i )) enddo ! elemental write ( * , \"(*(g0,1x))\" ) isint ( ints ) contains impure elemental function isint ( line ) result ( lout ) use M_unicode , only : adjustl , verify , trim ! ! determine if string is a valid integer representation ! ignoring trailing spaces and leading spaces ! character ( len = * ), parameter :: digits = \"0123456789\" type ( ut ), intent ( in ) :: line type ( ut ) :: name logical :: lout lout =. false . ! make sure at least two characters long to simplify tests name = adjustl ( line ). cat . ' ' ! blank string if ( name == '' ) return ! allow one leading sign if ( verify ( name % sub ( 1 , 1 ), ut ( ' + ‚Äê - ' )) == 0 ) name = name % sub ( 2 , len ( name )) ! was just a sign if ( name == '' ) return lout = verify ( trim ( name ), digits ) == 0 end function isint end program fortran_ints Results: > is integer?\n > |+1          |T|\n > |3044848     |T|\n > |30.40       |F|\n > |September   |F|\n > |1 2 3       |F|\n > |  ‚Äê3000     |T|\n > |            |F|\n > T T F F F T F Sample program III: Determine if strings represent valid Fortran symbol names program fortran_symbol_name use M_unicode , only : ut => unicode_type , trim , verify , len use M_unicode , only : ch => character use M_unicode , only : write ( formatted ) implicit none integer :: i type ( ut ), allocatable :: symbols (:) symbols =[ & ut ( ' A_ ' ), ut ( ' 10 ' ), ut ( ' a10 ' ), ut ( ' September ' ), ut ( ' A B ' ), & ut ( ' _A ' ), ut ( ' ' )] do i = 1 , size ( symbols ) write ( * , ' ( 1 x , DT , T11 , \"|\" , l2 ) ' ) symbols ( i ), fortran_name ( symbols ( i )) enddo contains impure elemental function fortran_name ( line ) result ( lout ) ! ! determine if a string is a valid Fortran name ! ignoring trailing spaces ( but not leading spaces ) ! character ( len = * ), parameter :: int = \"0123456789\" character ( len = * ), parameter :: lower = \"abcdefghijklmnopqrstuvwxyz\" character ( len = * ), parameter :: upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" character ( len = * ), parameter :: allowed = upper //lower//int//\"_\" type ( ut ), intent ( in ) :: line type ( ut ) :: name logical :: lout name = trim ( line ) if ( len ( name ). ne .0 ) then ! first character is alphameric lout = verify ( name % sub ( 1 , 1 ), lower //upper) == 0  & ! other characters are allowed in a symbol name & . and . verify ( name , allowed ) == 0 & ! allowable length & . and . len ( name ) <= 63 else lout = . false . endif end function fortran_name end program fortran_symbol_name Results: > A_       | T > 10       | F > a10      | T > September| T > A B      | F > _A       | F > | F Sample program IV: check if string is of form NN‚ÄêHHHHH program form ! ! check if string is of form NN ‚Äê HHHHH ! use iso_fortran_env , only : stdout => output_unit use M_unicode , only : verify , unicode_type , assignment (=) use M_unicode , only : ut => unicode_type implicit none character ( len = * ), parameter :: g = ' ( * ( g0 , 1 x )) ' ! character ( len = * ), parameter :: int = ' 1234567890 ' character ( len = * ), parameter :: hex = ' abcdefABCDEF0123456789 ' logical :: lout type ( unicode_type ) :: chars type ( unicode_type ) :: str ! chars = ' 32 ‚Äê af43d ' lout =. true . ! ! are the first two characters integer characters ? str = chars % character ( 1 , 2 ) lout = ( verify ( str , ut ( int ) ) == 0 ) . and . lout ! ! is the third character a dash ? str = chars % character ( 3 , 3 ) lout = ( verify ( str , ut ( '‚Äê - ' ) ) == 0 ) . and . lout ! ! is remaining string a valid representation of a hex value ? str = chars % character ( 4 , 8 ) lout = ( verify ( str , ut ( hex ) ) == 0 ) . and . lout ! if ( lout ) then write ( stdout , g ) trim ( chars % character ()), ' passed ' else write ( stdout , g ) trim ( chars % character ()), ' failed ' endif end program form Results: 32‚Äêaf43d passed Sample program V: exploring uses of elemental functionality and dusty corners program more_verify use M_unicode , only : ut => unicode_type , verify use M_unicode , only : assignment (=) use M_unicode , only : ch => character implicit none character ( len = * ), parameter :: & & low = \"abcdefghijklmnopqrstuvwxyz\" , & & upp = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" , & & blank = \" \" ! note character variables in an array have to be of the same length type ( ut ), allocatable :: strings (:) type ( ut ), allocatable :: sets (:) strings =[ ut ( \"Go\" ), ut ( \"right\" ), ut ( \"home!\" )] sets =[ ut ( \"do\" ), ut ( \"re\" ), ut ( \"me\" )] ! elemental ‚Äê‚Äê you can use arrays for both strings and for sets ! check each string from right to left for non ‚Äê letter / non ‚Äê blank write ( * , * ) \"last non‚Äêletter\" , verify ( strings , upp //low//blank,back=.true.) ! even BACK can be an array ! find last non ‚Äê uppercase character in \"Go\" ! and first non ‚Äê lowercase in \"right\" write ( * , * ) verify ( strings ( 1 : 2 ),[ upp , low ], back =[. true .,. false .]) ! using a null string for a set is not well defined . Avoid it write ( * , * ) \"null\" , verify ( \"for tran \" , \"\" , . true .) ! 8 , length of string ? ! probably what you expected write ( * , * ) \"blank\" , verify ( \"for tran \" , \" \" , . true .) ! 7 , found ‚Äô n ‚Äô ! first character in \"Go    \" not in \"do\" , ! and first letter in \"right \" not in \"ri\" ! and first letter in \"home! \" not in \"me\" write ( * , * ) verify ( strings , sets ) end program more_verify Results: >  last non‚Äêletter 0 0 5\n>  2 0\n>  null 9\n>  blank 8\n>  1 2 1 SEE ALSO Functions that perform operations on character strings, return\n   lengths of arguments, and search for certain arguments: ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), SCAN(3), NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3) AUTHOR John S. Urban LICENSE MIT Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer private impure elemental function verify_ua(string, set, back) result(result) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer private impure elemental function verify_au(string, set, back) result(result) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( unicode_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer public        interface write(formatted) private  subroutine write_formatted(string, unit, iotype, v_list, iostat, iomsg) Write string to connected formatted unit. Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: string integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Derived Types type, public¬†:: unicode_type Constructor private\n\n                    module\n                    function new_codes (codes) private\n\n                    elemental, module\n                    function new_str (string) private\n\n                    module\n                    function new_strs (strings) Type-Bound Procedures procedure, public :: adjustl => oop_adjustl procedure, public :: adjustr => oop_adjustr procedure, public :: byte => oop_byte procedure, public :: ch => oop_character procedure, public :: character => oop_character procedure, public :: codepoint => oop_codepoint procedure, public :: escape => oop_escape procedure, public :: expandtabs => oop_expandtabs procedure, public :: fmt => oop_fmt procedure, public :: get_arg => oop_get_arg_iu procedure, public :: get_env => oop_get_env_uu procedure, public :: ichar => oop_ichar procedure, public :: index => oop_index procedure, public :: join => oop_join procedure, public :: len => oop_len procedure, public :: len_trim => oop_len_trim procedure, public :: lower => oop_lower procedure, public :: oop_get_env_ua procedure, public :: pad => oop_pad generic, public :: replace => oop_replace_uuu, oop_replace_uaa, oop_replace_uau, oop_replace_uua, oop_section_uu, oop_section_ua procedure, public :: scan => oop_scan procedure, public :: split => oop_split procedure, public :: sub => oop_sub procedure, public :: tokenize => oop_tokenize generic, public :: transliterate => oop_transliterate_uu, oop_transliterate_aa, oop_transliterate_au, oop_transliterate_ua procedure, public :: trim => oop_trim procedure, public :: upper => oop_upper procedure, public :: verify => oop_verify Functions public recursive function afmt (generic, format) result(line) Read more‚Ä¶ Arguments Type Intent Optional Attributes Name class(*), intent(in) :: generic character(len=*), intent(in), optional :: format Return Value character(len=:), allocatable public elemental function expandtabs (instr, tab_size) result(out) Sample program: Read more‚Ä¶ Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: instr integer, intent(in), optional :: tab_size Return Value type( unicode_type ) public impure function join (str, sep, clip) result(string) Sample program: Read more‚Ä¶ Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: str (:) type( unicode_type ), intent(in), optional :: sep logical, intent(in), optional :: clip Return Value type( unicode_type ) public pure elemental function lower (str) result(string) Sample program: Read more‚Ä¶ Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: str Return Value type( unicode_type ) public impure elemental function pad (line, length, pattern, right, clip) result(out) Sample Program: Read more‚Ä¶ Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: line integer, intent(in) :: length type( unicode_type ), intent(in), optional :: pattern logical, intent(in), optional :: right logical, intent(in), optional :: clip Return Value type( unicode_type ) public  function readline (lun, iostat) result(line) Read more‚Ä¶ Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: lun integer, intent(out), optional :: iostat Return Value type( unicode_type ) public  function sub (str, start, end, step) result(section) Sample Program: Read more‚Ä¶ Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: str integer, intent(in), optional :: start integer, intent(in), optional :: end integer, intent(in), optional :: step Return Value type( unicode_type ) public pure elemental function upper (str) result(string) UPPER(3f) - [M_unicode:CASE] changes a string to uppercase\n  (LICENSE:MIT) Read more‚Ä¶ Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: str Return Value type( unicode_type )","tags":"","url":"module/m_unicode.html"},{"title":"testsuite_M_unicode ‚Äì M_unicode","text":"Uses iso_fortran_env M_unicode Variables Type Visibility Attributes Name Initial logical, public, parameter :: F = .false. logical, public, parameter :: T = .true. character(len=*), public, parameter :: g0 = '(*(g0))' character(len=*), public, parameter :: g1 = '(*(g0,1x))' integer, public :: total Functions public  function random_ascii_string (chars, length) result(out) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: chars integer, intent(in) :: length Return Value character(len=:), allocatable Subroutines public  subroutine check (label, test, description) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label logical, intent(in) :: test character(len=*), intent(in), optional :: description public  subroutine checkit (label, aline, answer, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label character(len=*), intent(in) :: aline character(len=*), intent(in) :: answer character(len=*), intent(in) :: expected public  subroutine checkits (label, aline, answer, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label character(len=*), intent(in) :: aline character(len=*), intent(in) :: answer (:) character(len=*), intent(in) :: expected (:) public  subroutine checkits_l (label, aline, answer, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label character(len=*), intent(in) :: aline logical, intent(in) :: answer (:) logical, intent(in) :: expected (:) public  subroutine programming_environment () Arguments None public  subroutine test_adjustl () Arguments None public  subroutine test_adjustr () Arguments None public  subroutine test_concatenate () Arguments None public  subroutine test_escape () Arguments None public  subroutine test_expandtabs () Arguments None public  subroutine test_fmt () Arguments None public  subroutine test_ichar () Arguments None public  subroutine test_index () Arguments None public  subroutine test_join () Arguments None public  subroutine test_len () Arguments None public  subroutine test_len_trim () Arguments None public  subroutine test_lower () Arguments None public  subroutine test_operators () Arguments None public  subroutine test_other () Arguments None public  subroutine test_pad () Arguments None public  subroutine test_repeat () Arguments None public  subroutine test_replace () Arguments None public  subroutine test_scan () Arguments None public  subroutine test_sort () Arguments None public  subroutine test_split () Arguments None public  subroutine test_sub () Arguments None public  subroutine test_tokenize () Arguments None public  subroutine test_transliterate () Arguments None public  subroutine test_trim () Arguments None public  subroutine test_upper () Arguments None public  subroutine test_verify () Arguments None","tags":"","url":"module/testsuite_m_unicode.html"},{"title":"testit ‚Äì M_unicode","text":"Uses iso_fortran_env M_unicode Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0))' character(len=*), parameter :: gh = '(*(z0,1x))' character(len=*), parameter :: gx = '(*(g0,1x))' type( unicode_type ) :: ustr Source Code program testit use , intrinsic :: iso_fortran_env , only : stdout => output_unit ! user-defined type to hold Unicode text use M_unicode , only : unicode_type ! convert unicode_type to CHARACTER variables use M_unicode , only : character ! intrinsic overloads use M_unicode , only : adjustl , adjustr use M_unicode , only : trim , len , len_trim use M_unicode , only : index , scan , verify use M_unicode , only : repeat use M_unicode , only : split , tokenize use M_unicode , only : upper , lower use M_unicode , only : sort ! operators (and overloads) and assignment use M_unicode , only : assignment ( = ) use M_unicode , only : operator ( <= ), lle use M_unicode , only : operator ( < ), llt use M_unicode , only : operator ( /= ), lne use M_unicode , only : operator ( == ), leq use M_unicode , only : operator ( > ), lgt use M_unicode , only : operator ( >= ), lge use M_unicode , only : operator ( // ) ! low-level text conversion to integer codepoint arrays: use M_unicode , only : utf8_to_codepoints , codepoints_to_utf8 ! example usage: implicit none type ( unicode_type ) :: ustr character ( len =* ), parameter :: g = '(*(g0))' character ( len =* ), parameter :: gx = '(*(g0,1x))' character ( len =* ), parameter :: gh = '(*(z0,1x))' ! Constructors ! UNICODE_VARIABLE= UNICODE_VARIABLE|CHARACTER(LEN=*)|INTEGER_ARRAY ! ! VARIABLE%CHARACTER(start,end,step) returns a CHARACTER string ! VARIABLE%BYTE() returns an array of CHARACTER(len=1) values ustr = 'Hello World and Ni Hao -- ‰Ω†Â•Ω  ' write ( stdout , g ) character ( ustr ) ! convert to intrinsic CHARACTER variable write ( stdout , g ) len ( ustr ) write ( stdout , g ) len_trim ( ustr ) write ( stdout , g ) index ( ustr , '‰Ω†' ) ! OOPS write ( stdout , g ) ustr % character () ! convert to CHARACTER variable write ( stdout , g ) ustr % character ( 27 , 28 ) ! similar to LINE(27:28) for CHARACTER write ( stdout , g ) ustr % character ( len ( ustr ), 1 , - 1 ) ! reverse string write ( stdout , g ) ustr % byte () ! convert to CHARACTER(LEN=1) type ! print write ( stdout , gx ) ustr % codepoint () ! convert to Unicode codepoints write ( stdout , gh ) ustr % codepoint () ! convert to Unicode codepoints end program testit","tags":"","url":"program/testit.html"},{"title":"demo_scan ‚Äì M_unicode","text":"Uses iso_fortran_env M_unicode Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0,1x))' type( unicode_type ) :: line type( unicode_type ) :: set Source Code program demo_scan use iso_fortran_env , only : stdout => output_unit use M_unicode , only : scan , unicode_type , assignment ( = ) use M_unicode , only : ut => unicode_type implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' type ( ut ) :: line type ( ut ) :: set ! write ( * , * ) scan ( \"fortran\" , \"ao\" ) ! 2, found ‚Äôo‚Äô write ( * , * ) scan ( \"fortran\" , \"ao\" , . true .) ! 6, found ‚Äôa‚Äô write ( * , * ) scan ( \"fortran\" , \"c++\" ) ! 0, found none ! line = 'parsleyüòÉsageüòÉrosemaryüòÉüòÉthyme' set = 'üòÉ' write ( stdout , g ) '12345678901234567890123456789012345678901234567890' write ( stdout , g ) line % character () write ( stdout , g ) scan ( line , set ) write ( stdout , g ) scan ( line , set , back = . true .) write ( stdout , g ) scan ( line , set , back = . false .) write ( stdout , g ) scan ( line , unicode_type ( \"NOT\" )) write ( stdout , g ) 'OOP' write ( stdout , g ) line % scan ( set ) write ( stdout , g ) line % scan ( ut ( \"o\" )) end program demo_scan","tags":"","url":"program/demo_scan.html"},{"title":"demo_adjustr ‚Äì M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial type( unicode_type ), allocatable :: array (:) character(len=*), parameter :: bracket = '(\"[\",DT,\"]\")' integer :: i type( unicode_type ) :: str Subroutines subroutine numberline (ireps) Arguments Type Intent Optional Attributes Name integer, intent(in) :: ireps Source Code program demo_adjustr use M_unicode , only : ut => unicode_type use M_unicode , only : adjustr , len use M_unicode , only : write ( formatted ) use M_unicode , only : assignment ( = ) implicit none type ( ut ) :: str type ( ut ), allocatable :: array (:) integer :: i character ( len =* ), parameter :: bracket = '(\"[\",DT,\"]\")' ! call numberline ( 2 ) ! ! basic usage str = '  sample string     ' write ( * , bracket ) str str = adjustr ( str ) write ( * , bracket ) str ! call numberline ( 5 ) ! ! elemental array = ut ([ character ( len = 50 ) :: & '    ‡§è‡§ï (ek) ' , & '       ‡§¶‡•ã (do) ' , & '          ‡§§‡•Ä‡§®(teen) ' ]) ! ! print array unadjusted write ( * , bracket ) array !do i=1,size(array) !   write(*,'(*(g0,1x))')array(i)%codepoint() !enddo ! note 50 bytes is not necessarily 50 glyphs write ( * , '(*(g0,1x))' ) 'length in glyphs=' , len ( array ) write ( * , '(*(g0,1x))' ) 'length in bytes=' ,( len ( array ( i )% character ()), i = 1 , size ( array )) ! call numberline ( 5 ) ! ! print array right-justified write ( * , bracket ) adjustr ( array ) ! call numberline ( 5 ) ! ! print array right-justified specifying number of glyphs write ( * , * ) 'set to 50' write ( * , bracket ) adjustr ( array , 50 ) ! write ( * , * ) 'set to 60' call numberline ( 6 ) write ( * , bracket ) adjustr ( array , 60 ) write ( * , * ) 'set to 40' call numberline ( 4 ) write ( * , bracket ) adjustr ( array , 40 ) write ( * , * ) 'set to 10' call numberline ( 1 ) write ( * , bracket ) adjustr ( array , 10 ) write ( * , * ) 'set to 5' write ( * , bracket ) adjustr ( array , 5 ) write ( * , * ) 'set to 4' write ( * , bracket ) adjustr ( array , 4 ) write ( * , * ) 'set to 1' write ( * , bracket ) adjustr ( array , 1 ) contains ! subroutine numberline ( ireps ) integer , intent ( in ) :: ireps write ( * , '(1x,a)' ) repeat ( '1234567890' , ireps ) end subroutine numberline end program demo_adjustr","tags":"","url":"program/demo_adjustr.html"},{"title":"crow_and_fox ‚Äì M_unicode","text":"Uses iso_fortran_env M_unicode Variables Type Attributes Name Initial integer :: i type(unicode_type), allocatable :: poem (:) Source Code program crow_and_fox use iso_fortran_env , only : stdout => output_unit use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : byte => int8 use M_unicode , only : unicode_type , ut => unicode_type , character , len implicit none type ( unicode_type ), allocatable :: poem (:) integer :: i ! ‚ÄúThe Crow and the Fox‚Äù by Jean de la Fontaine write ( stdout , '(a,/)' ) 'Le Corbeau et le Renard -- Jean de la Fontaine' poem = [& ut ( 'Le Corbeau et le Renard' ), & ut ( '' ), & ut ( 'Ma√Ætre Corbeau, sur un arbre perch√©,' ), & ut ( 'Tenait en son bec un fromage.' ), & ut ( 'Ma√Ætre Renard, par l‚Äôodeur all√©ch√©,' ), & ut ( 'Lui tint √† peu pr√®s ce langage :' ), & ut ( '¬´H√© ! bonjour, Monsieur du Corbeau.' ), & ut ( 'Que vous √™tes joli ! que vous me semblez beau !' ), & ut ( 'Sans mentir, si votre ramage' ), & ut ( 'Se rapporte √† votre plumage,' ), & ut ( 'Vous √™tes le Ph√©nix des h√¥tes de ces bois.¬ª' ), & ut ( 'A ces mots le Corbeau ne se sent pas de joie ;' ), & ut ( 'Et pour montrer sa belle voix,' ), & ut ( 'Il ouvre un large bec, laisse tomber sa proie.' ), & ut ( 'Le Renard s‚Äôen saisit, et dit : ¬´Mon bon Monsieur,' ), & ut ( 'Apprenez que tout flatteur' ), & ut ( 'Vit aux d√©pens de celui qui l‚Äô√©coute :' ), & ut ( 'Cette le√ßon vaut bien un fromage, sans doute.¬ª' ), & ut ( 'Le Corbeau, honteux et confus,' ), & ut ( 'Jura, mais un peu tard, qu‚Äôon ne l‚Äôy prendrait plus.' ), & ut ( ' -- Jean de la Fontaine' )] write ( stdout , '(a)' ) 'LINES' write ( stdout , '(g0)' )( character ( poem ( i )), i = 1 , size ( poem )) write ( stdout , '(a)' ) 'BYTES' write ( stdout , '(*(a))' )( poem ( i )% byte (), new_line ( 'a' ), i = 1 , size ( poem )) write ( stdout , '(a)' ) 'WITH LENGTH IN GLYPHS AND BYTES' do i = 1 , size ( poem ) write ( stdout , '(1x,i4.4,1x,i4.4,1x,*(g0))' ) len ( poem ( i )), len ( poem ( i )% character ()), character ( poem ( i )) enddo end program crow_and_fox","tags":"","url":"program/crow_and_fox.html"},{"title":"test_id ‚Äì M_unicode","text":"Functions function inset (string) result(longer) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=:), allocatable Subroutines subroutine platform () Arguments None Source Code program test_id implicit none call platform () contains subroutine platform () use , intrinsic :: iso_fortran_env , only : compiler_version use , intrinsic :: iso_fortran_env , only : compiler_options implicit none character ( len = :), allocatable :: version , options character ( len =* ), parameter :: nl = new_line ( 'a' ) integer :: where , start , break , i , last , col version = compiler_version () // ' ' options = ' ' // compiler_options () start = 1 do where = index ( options ( start :), ' -' ) if ( where . eq . 0 ) exit break = where + start - 1 options ( break : break ) = nl start = where enddo if ( start . eq . 1 ) then do where = index ( options ( start :), ' /' ) if ( where . eq . 0 ) exit break = where + start - 1 options ( break : break ) = nl start = where enddo endif last = len_trim ( version ) + 1 col = 0 do i = 1 , len_trim ( version ) col = col + 1 if ( version ( i : i ). eq . ' ' ) last = i if ( col . gt . 76 ) then version ( last : last ) = nl col = 0 endif enddo print '(a,/,3x,*(a))' , 'This file was compiled by :' , inset ( version ) if ( options . ne . '' ) then print '(*(a))' , 'using the options :' , inset ( options ) endif end subroutine platform function inset ( string ) result ( longer ) character ( len =* ), intent ( in ) :: string character ( len = :), allocatable :: longer character ( len =* ), parameter :: nl = new_line ( 'a' ) integer :: i longer = '' do i = 1 , len ( string ) longer = longer // string ( i : i ) if ( string ( i : i ). eq . nl ) then longer = longer // '   ' endif enddo end function inset end program test_id","tags":"","url":"program/test_id.html"},{"title":"demo_utf8_to_codepoints ‚Äì M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=1), allocatable :: bytes (:) integer, allocatable :: codepoints (:) integer :: i integer :: nerr character(len=*), parameter :: solid = '(*(g0))' character(len=*), parameter :: space = '(*(g0,1x))' character(len=*), parameter :: string = 'Noho me ka hau‚Äôoli' character(len=*), parameter :: z = '(a,*(z0,1x))' Source Code program demo_utf8_to_codepoints use m_unicode , only : utf8_to_codepoints implicit none character ( len =* ), parameter :: string = 'Noho me ka hau‚Äôoli' !(Be happy) character ( len = 1 ), allocatable :: bytes (:) character ( len =* ), parameter :: solid = '(*(g0))' character ( len =* ), parameter :: space = '(*(g0,1x))' character ( len =* ), parameter :: z = '(a,*(z0,1x))' integer , allocatable :: codepoints (:) integer :: nerr integer :: i ! BASIC USAGE: SCALAR CHARACTER VARIABLE write ( * , solid ) 'STRING:' , string call utf8_to_codepoints ( string , codepoints , nerr ) write ( * , space ) 'CODEPOINTS:' , codepoints write ( * , z ) 'HEXADECIMAL CODEPOINTS:' , codepoints ! write ( * , space ) 'How long is this string in glyphs? ' write ( * , space ) size ( codepoints ) write ( * , space ) 'How long is this string in bytes? ' write ( * , space ) len ( string ) ! ! BASIC USAGE: ARRAY OF BYTES bytes = [( string ( i : i ), i = 1 , len ( string ))] write ( * , solid ) 'STRING:' , bytes call utf8_to_codepoints ( bytes , codepoints , nerr ) write ( * , space ) 'CODEPOINTS:' , codepoints write ( * , z ) 'HEXADECIMAL CODEPOINTS:' , codepoints ! write ( * , space ) 'How long is this string in glyphs? ' write ( * , space ) size ( codepoints ) write ( * , space ) 'How long is this string in bytes? ' write ( * , space ) size ( bytes ) ! end program demo_utf8_to_codepoints","tags":"","url":"program/demo_utf8_to_codepoints.html"},{"title":"testit ‚Äì M_unicode","text":"Uses iso_fortran_env M_unicode Variables Type Attributes Name Initial type( unicode_type ) :: low type( unicode_type ) :: upp Source Code program testit use iso_fortran_env , only : stdout => output_unit use M_unicode implicit none type ( unicode_type ) :: upp , low ! ! remember unicode characters are multi-byte so be careful ! with older compilers to not exceed 132 bytes per line ! low = '& &abcdefghijklmnopqrstuvwxyz√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨& &√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∏√π√∫√ª√º√Ω√æ√øƒÅƒÉƒÖƒáƒâƒãƒçƒèƒëƒìƒïƒóƒôƒõƒùƒüƒ°ƒ£ƒ•ƒßƒ©ƒ´ƒ≠& &ƒØƒ±ƒ≥ƒµƒ∑ƒ∫ƒºƒæ≈Ä≈Ç≈Ñ≈Ü≈à≈ã≈ç≈è≈ë≈ì≈ï≈ó≈ô≈õ≈ù≈ü≈°≈£≈•≈ß≈©≈´≈≠≈Ø≈±≈≥≈µ≈∑≈∫≈º≈æ& &∆É∆Ö∆à∆å∆í∆ô∆°∆£∆•∆®∆≠∆∞∆¥∆∂∆π∆Ω«Ü«â«å«é«ê«í«î«ñ«ò«ö«ú«ü«°«£«•«ß«©«´«≠«Ø«≥«µ«ª«Ω«ø& &»Å»É»Ö»á»â»ã»ç»è»ë»ì»ï»ó…ì…î…ó…ò…ô…õ…†…£…®…©…Ø…≤…µ É à ä ã íŒ¨Œ≠ŒÆŒØ& &Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÉœÑœÖœÜœáœàœâœäœãœåœçœéœ£œ•œßœ©œ´œ≠œØ–∞–±–≤–≥–¥–µ–∂–∑–∏–π& &–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è—ë—í—ì—î—ï—ñ—ó—ò—ô—ö—õ—ú—û—ü& &—°—£—•—ß—©—´—≠—Ø—±—≥—µ—∑—π—ª—Ω—ø“Å“ë“ì“ï“ó“ô“õ“ù“ü“°“£“•“ß“©“´“≠“Ø“±“≥“µ“∑“π“ª“Ω“ø”Ç”Ñ”à& &”å”ë”ì”ï”ó”ô”õ”ù”ü”°”£”•”ß”©”´”Ø”±”≥”µ”π’°’¢’£’§’•’¶’ß’®’©’™’´’¨’≠’Æ’Ø’∞’±’≤& &’≥’¥’µ’∂’∑’∏’π’∫’ª’º’Ω’æ’ø÷Ä÷Å÷Ç÷É÷Ñ÷Ö÷Ü·Éê·Éë·Éí·Éì·Éî·Éï·Éñ·Éó·Éò·Éô·Éö·Éõ·Éú·Éù·Éû·Éü·É†·É°·É¢·É£·É§·É•& &·É¶·Éß·É®·É©·É™·É´·É¨·É≠·ÉÆ·ÉØ·É∞·É±·É≤·É≥·É¥·Éµ·∏Å·∏É·∏Ö·∏á·∏â·∏ã·∏ç·∏è·∏ë·∏ì·∏ï·∏ó·∏ô·∏õ·∏ù·∏ü·∏°·∏£·∏•·∏ß& &·∏©·∏´·∏≠·∏Ø·∏±·∏≥·∏µ·∏∑·∏π·∏ª·∏Ω·∏ø·πÅ·πÉ·πÖ·πá·πâ·πã·πç·πè·πë·πì·πï·πó·πô& &·πõ·πù·πü·π°·π£·π•·πß·π©·π´·π≠·πØ·π±·π≥·πµ·π∑·ππ·πª·πΩ·πø& &·∫Å·∫É·∫Ö·∫á·∫â·∫ã·∫ç·∫è·∫ë·∫ì·∫ï·∫°·∫£·∫•·∫ß·∫©·∫´·∫≠·∫Ø·∫±·∫≥·∫µ·∫∑·∫π·∫ª·∫Ω·∫ø·ªÅ·ªÉ·ªÖ·ªá·ªâ·ªã·ªç·ªè·ªë·ªì·ªï·ªó& &·ªô·ªõ·ªù·ªü·ª°·ª£·ª•·ªß·ª©·ª´·ª≠·ªØ·ª±·ª≥·ªµ·ª∑·ªπ·ºÄ·ºÅ·ºÇ·ºÉ·ºÑ·ºÖ·ºÜ·ºá·ºê·ºë·ºí·ºì·ºî·ºï·º†·º°·º¢·º£·º§·º•·º¶·ºß·º∞·º±& &·º≤·º≥·º¥·ºµ·º∂·º∑·ΩÄ·ΩÅ·ΩÇ·ΩÉ·ΩÑ·ΩÖ·Ωë·Ωì·Ωï·Ωó·Ω†·Ω°·Ω¢·Ω£·Ω§·Ω•·Ω¶·Ωß·æÄ·æÅ·æÇ·æÉ·æÑ·æÖ·æÜ·æá·æê·æë·æí·æì·æî·æï·æñ·æó& &·æ†·æ°·æ¢·æ£·æ§·æ•·æ¶·æß·æ∞·æ±·øê·øë·ø†·ø°‚ìê‚ìë‚ìí‚ìì‚ìî‚ìï‚ìñ‚ìó‚ìò‚ìô‚ìö‚ìõ‚ìú‚ìù‚ìû‚ìü‚ì†‚ì°‚ì¢‚ì£‚ì§‚ì•‚ì¶‚ìß‚ì®‚ì©& &ÔΩÅÔΩÇÔΩÉÔΩÑÔΩÖÔΩÜÔΩáÔΩàÔΩâÔΩäÔΩãÔΩåÔΩçÔΩéÔΩèÔΩêÔΩëÔΩíÔΩìÔΩîÔΩïÔΩñÔΩóÔΩòÔΩôÔΩö' upp = '& &ABCDEFGHIJKLMNOPQRSTUVWXYZ√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã& &√å√ç√é√è√ê√ë√í√ì√î√ï√ñ√ò√ô√ö√õ√ú√ù√û≈∏ƒÄƒÇƒÑƒÜƒàƒäƒåƒéƒêƒíƒîƒñƒòƒöƒúƒûƒ†ƒ¢ƒ§ƒ¶ƒ®ƒ™ƒ¨& &ƒÆIƒ≤ƒ¥ƒ∂ƒπƒªƒΩƒø≈Å≈É≈Ö≈á≈ä≈å≈é≈ê≈í≈î≈ñ≈ò≈ö≈ú≈û≈†≈¢≈§≈¶≈®≈™≈¨≈Æ≈∞≈≤≈¥≈∂≈π≈ª& &≈Ω∆Ç∆Ñ∆á∆ã∆ë∆ò∆†∆¢∆§∆ß∆¨∆Ø∆≥∆µ∆∏∆º«Ñ«á«ä«ç«è«ë«ì«ï«ó«ô«õ«û«†«¢«§«¶«®«™«¨«Æ«±«¥«∫«º«æ& &»Ä»Ç»Ñ»Ü»à»ä»å»é»ê»í»î»ñ∆Å∆Ü∆ä∆é∆è∆ê∆ì∆î∆ó∆ñ∆ú∆ù∆ü∆©∆Æ∆±∆≤∆∑ŒÜŒàŒâŒäŒëŒíŒìŒîŒïŒñŒóŒò& &ŒôŒöŒõŒúŒùŒûŒüŒ†Œ°Œ£Œ§Œ•Œ¶ŒßŒ®Œ©Œ™Œ´ŒåŒéŒèœ¢œ§œ¶œ®œ™œ¨œÆ–ê–ë–í–ì–î–ï–ñ–ó–ò–ô& &–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–Å–Ç–É–Ñ–Ö–Ü–á–à–â–ä–ã–å–é–è—†—¢—§—¶—®—™—¨& &—Æ—∞—≤—¥—∂—∏—∫—º—æ“Ä“ê“í“î“ñ“ò“ö“ú“û“†“¢“§“¶“®“™“¨“Æ“∞“≤“¥“∂“∏“∫“º“æ”Å”É”á& &”ã”ê”í”î”ñ”ò”ö”ú”û”†”¢”§”¶”®”™”Æ”∞”≤”¥”∏‘±‘≤‘≥‘¥‘µ‘∂‘∑‘∏‘π‘∫‘ª‘º‘Ω‘æ‘ø’Ä’Å’Ç’É’Ñ& &’Ö’Ü’á’à’â’ä’ã’å’ç’é’è’ê’ë’í’ì’î’ï’ñ·Ç†·Ç°·Ç¢·Ç£·Ç§·Ç•·Ç¶·Çß·Ç®·Ç©·Ç™·Ç´·Ç¨·Ç≠·ÇÆ·ÇØ·Ç∞·Ç±·Ç≤·Ç≥·Ç¥·Çµ& &·Ç∂·Ç∑·Ç∏·Çπ·Ç∫·Çª·Çº·ÇΩ·Çæ·Çø·ÉÄ·ÉÅ·ÉÇ·ÉÉ·ÉÑ·ÉÖ·∏Ä·∏Ç·∏Ñ·∏Ü·∏à·∏ä·∏å·∏é·∏ê·∏í·∏î·∏ñ·∏ò·∏ö·∏ú·∏û·∏†·∏¢·∏§·∏¶·∏®·∏™·∏¨·∏Æ& &·∏∞·∏≤·∏¥·∏∂·∏∏·∏∫·∏º·∏æ·πÄ·πÇ·πÑ·πÜ·πà·πä·πå·πé·πê·πí·πî·πñ·πò·πö·πú·πû·π†·π¢·π§·π¶·π®·π™·π¨·πÆ·π∞·π≤·π¥·π∂·π∏·π∫·πº·πæ& &·∫Ä·∫Ç·∫Ñ·∫Ü·∫à·∫ä·∫å·∫é·∫ê·∫í·∫î·∫†·∫¢·∫§·∫¶·∫®·∫™·∫¨·∫Æ·∫∞·∫≤·∫¥·∫∂·∫∏·∫∫·∫º·∫æ·ªÄ·ªÇ·ªÑ·ªÜ·ªà·ªä& &·ªå·ªé·ªê·ªí·ªî·ªñ·ªò·ªö·ªú·ªû·ª†·ª¢·ª§·ª¶·ª®·ª™·ª¨·ªÆ·ª∞·ª≤·ª¥·ª∂·ª∏& &·ºà·ºâ·ºä·ºã·ºå·ºç·ºé·ºè·ºò·ºô·ºö·ºõ·ºú·ºù·º®·º©·º™·º´·º¨·º≠·ºÆ·ºØ·º∏·ºπ& &·º∫·ºª·ºº·ºΩ·ºæ·ºø·Ωà·Ωâ·Ωä·Ωã·Ωå·Ωç·Ωô·Ωõ·Ωù·Ωü·Ω®·Ω©·Ω™·Ω´·Ω¨·Ω≠·ΩÆ·ΩØ& &·æà·æâ·æä·æã·æå·æç·æé·æè·æò·æô·æö·æõ·æú·æù·æû·æü·æ®·æ©·æ™·æ´·æ¨·æ≠·æÆ·æØ·æ∏·æπ& &·øò·øô·ø®·ø©‚í∂‚í∑‚í∏‚íπ‚í∫‚íª‚íº‚íΩ‚íæ‚íø‚ìÄ‚ìÅ‚ìÇ‚ìÉ‚ìÑ‚ìÖ‚ìÜ‚ìá‚ìà‚ìâ‚ìä‚ìã‚ìå‚ìç‚ìé‚ìè& &Ôº°Ôº¢Ôº£Ôº§Ôº•Ôº¶ÔºßÔº®Ôº©Ôº™Ôº´Ôº¨Ôº≠ÔºÆÔºØÔº∞Ôº±Ôº≤Ôº≥Ôº¥ÔºµÔº∂Ôº∑Ôº∏ÔºπÔº∫' write ( stdout , '(g0)' ) low % character () write ( stdout , '(g0)' ) character ( upper ( low )) write ( stdout , '(g0)' ) character ( upp ) write ( stdout , '(g0)' ) character ( upp % lower ()) write ( stdout , '(g0)' ) 'Note \"i\" and \"I\" are a special case;' write ( stdout , '(g0)' ) 'uppercase of \"i\" is \"I\" (dotless) by default and' write ( stdout , '(g0)' ) 'lowercase of \"I\" (dotless) is \"i\" (dotted) by default.' write ( stdout , '(g0)' ) 'For the others LETTER=lower(upper(LETTER)) and LETTER=upper(lower(LETTER))' end program testit","tags":"","url":"program/testit~2.html"},{"title":"demo_upper ‚Äì M_unicode","text":"Uses iso_fortran_env M_unicode Variables Type Attributes Name Initial type( unicode_type ) :: diacritics type( unicode_type ) :: expected character(len=*), parameter :: g = '(*(g0))' type( unicode_type ) :: pangram Subroutines subroutine test (in, expected) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: in type( unicode_type ), intent(in) :: expected Source Code program demo_upper use iso_fortran_env , only : stdout => output_unit use M_unicode , only : upper , unicode_type , assignment ( = ) use M_unicode , only : ut => unicode_type , operator ( == ) implicit none character ( len =* ), parameter :: g = '(*(g0))' type ( unicode_type ) :: pangram type ( unicode_type ) :: diacritics type ( unicode_type ) :: expected ! ! a sentence containing every letter of the English alphabet ! often used to test telegraphs since the advent of the 19th century ! and as an exercise repetitively generated in typing classes pangram = \"The quick brown fox jumps over the lazy dog.\" expected = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.\" call test ( pangram , expected ) ! ! Slovak pangram pangram = 'Vyp√§t√° dc√©ra gr√≥fa Maxwella s IQ ni≈æ≈°√≠m ako & &k√¥≈à n√∫ti ƒçeƒæaƒè hr√Ωz≈• h≈ïbu jabƒ∫k.' expected = 'VYP√ÑT√Å DC√âRA GR√ìFA MAXWELLA S IQ NI≈Ω≈†√çM AKO & &K√î≈á N√öTI ƒåEƒΩAƒé HR√ùZ≈§ H≈îBU JABƒπK.' call test ( pangram , expected ) ! ! contains each special Czech letter with diacritics exactly once print g , '(\"A horse that was too yellow-ish moaned devilish odes\")' diacritics = 'P≈ô√≠li≈° ≈ælu≈•ouƒçk√Ω k≈Ø≈à √∫pƒõl ƒè√°belsk√© √≥dy.' expected = 'P≈ò√çLI≈† ≈ΩLU≈§OUƒåK√ù K≈Æ≈á √öPƒöL ƒé√ÅBELSK√â √ìDY.' call test ( diacritics , expected ) contains subroutine test ( in , expected ) type ( unicode_type ), intent ( in ) :: in type ( unicode_type ), intent ( in ) :: expected type ( unicode_type ) :: uppercase character ( len =* ), parameter :: nl = new_line ( 'A' ) write ( stdout , g ) in % character () uppercase = upper ( in ) write ( stdout , g ) uppercase % character () write ( stdout , g ) merge ( 'PASSED' , 'FAILED' , uppercase == expected ), nl end subroutine test end program demo_upper","tags":"","url":"program/demo_upper.html"},{"title":"assign_exe ‚Äì M_unicode","text":"Uses iso_fortran_env M_unicode Variables Type Attributes Name Initial character(len=*), parameter :: bracket = '(*(\"[\",g0,\"]\":))' character(len=*), parameter :: cat = '(*(g0))' character(len=*), parameter :: dash = '(*(g0,\"-\"))' character(len=*), parameter :: gap = '(*(g0,1x))' type( unicode_type ) :: substring type( unicode_type ) :: uline Subroutines subroutine showme (uline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: uline Source Code program assign_exe use iso_fortran_env , only : stdout => output_unit use M_unicode , only : len , len_trim , repeat , trim , adjustr , adjustl use M_unicode , only : character use M_unicode , only : assignment ( = ), unicode_type implicit none character ( len =* ), parameter :: cat = '(*(g0))' ,& gap = '(*(g0,1x))' ,& dash = '(*(g0,\"-\"))' ,& bracket = '(*(\"[\",g0,\"]\":))' type ( unicode_type ) :: uline , substring uline = \"   Until you stop, you won't be able to.   \" call showme ( uline ) uline = \"   –î–æ–∫–∏ –Ω–µ –≤–ø—Ä—ñ—Ç–∏, –¥–æ—Ç–∏ –Ω–µ –≤–º—ñ—Ç–∏.   \" call showme ( uline ) print * write ( stdout , gap ) 'third word is: ' , character ( uline , 12 , 17 ) ! substring substring = character ( uline , 20 , 32 ) write ( stdout , gap ) 'substring is: ' , character ( substring ) ! can set with codepoints uline = [ 32 , 160 , 8192 , 8193 , 8194 , 8195 , 8196 , 8197 , 8198 , 8199 , 8200 , 8201 , 8202 , 8239 , 8287 , 12288 ] write ( stdout , gap ) 'different kinds of spaces:' , uline % character () contains subroutine showme ( uline ) type ( unicode_type ), intent ( in ) :: uline integer :: i write ( stdout , cat ) ' ' , repeat ( '1234567890' , len ( uline ) / 10 + 1 ) write ( stdout , bracket ) character ( uline ) write ( stdout , cat ) 'length in bytes is: ' , len ( uline % character ()) write ( stdout , cat ) 'length in glyphs is: ' , len ( uline ) write ( stdout , cat ) 'trimmed length in glyphs is: ' , len_trim ( uline ) write ( stdout , cat ) 'adjustr:[' , character ( adjustr ( uline )), ']' write ( stdout , cat ) 'adjustl:[' , character ( adjustl ( uline )), ']' write ( stdout , cat ) 'cropped:[' , character ( trim ( adjustl ( uline ))), ']' write ( stdout , gap ) 'codepoints:' , uline % codepoint () write ( stdout , dash ) 'glyphs:' ,( character ( uline % sub ( i , i )), i = 1 , len ( uline )) write ( stdout , * ) end subroutine showme end program assign_exe","tags":"","url":"program/assign_exe.html"},{"title":"more_verify ‚Äì M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=*), parameter :: blank = \" \" character(len=*), parameter :: low = \"abcdefghijklmnopqrstuvwxyz\" type( unicode_type ), allocatable :: sets (:) type( unicode_type ), allocatable :: strings (:) character(len=*), parameter :: upp = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" Source Code program more_verify use M_unicode , only : ut => unicode_type , verify use M_unicode , only : assignment ( = ) use M_unicode , only : ch => character implicit none character ( len =* ), parameter :: & & low = \"abcdefghijklmnopqrstuvwxyz\" , & & upp = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" , & & blank = \" \" ! note character variables in an array have to be of the same length type ( ut ), allocatable :: strings (:) type ( ut ), allocatable :: sets (:) strings = [ ut ( \"Go\" ), ut ( \"right\" ), ut ( \"home!\" )] sets = [ ut ( \"do\" ), ut ( \"re\" ), ut ( \"me\" )] ! elemental ‚Äê‚Äê you can use arrays for both strings and for sets ! check each string from right to left for non‚Äêletter/non‚Äêblank write ( * , * ) \"last non‚Äêletter\" , verify ( strings , upp // low // blank , back = . true .) ! even BACK can be an array ! find last non‚Äêuppercase character in \"Howdy \" ! and first non‚Äêlowercase in \"there \" write ( * , * ) verify ( strings ( 1 : 2 ),[ upp , low ], back = [. true .,. false .]) ! using a null string for a set is not well defined. Avoid it write ( * , * ) \"null\" , verify ( \"for tran \" , \"\" , . true .) ! 8,length of string? ! probably what you expected write ( * , * ) \"blank\" , verify ( \"for tran \" , \" \" , . true .) ! 7,found ‚Äôn‚Äô ! first character in  \"Go    \" not in \"do\", ! and first letter in \"right \" not in \"ri\" ! and first letter in \"home! \" not in \"me\" write ( * , * ) verify ( strings , sets ) end program more_verify","tags":"","url":"program/more_verify.html"},{"title":"demo_replace ‚Äì M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial type( unicode_type ) :: line Source Code program demo_replace use M_unicode , only : ut => unicode_type use M_unicode , only : unicode_type use M_unicode , only : character , replace use M_unicode , only : write ( formatted ) implicit none type ( unicode_type ) :: line ! write ( * , '(DT)' ) & & replace ( ut ( 'Xis is Xe string' ), ut ( 'X' ), ut ( 'th' ) ) write ( * , '(DT)' ) & & replace ( ut ( 'Xis is xe string' ), ut ( 'x' ), ut ( 'th' ), ignorecase = . true .) write ( * , '(DT)' ) & & replace ( ut ( 'Xis is xe string' ), ut ( 'X' ), ut ( 'th' ), ignorecase = . false .) ! ! a null old substring means \"at beginning of line\" write ( * , '(DT)' ) & & replace ( ut ( 'my line of text' ), ut ( '' ), ut ( 'BEFORE:' )) ! ! a null new string deletes occurrences of the old substring write ( * , '(DT)' ) replace ( ut ( 'I wonder i ii iii' ), ut ( 'i' ), ut ( '' )) ! ! Examples of the use of RANGE ! line = replace ( ut ( 'aaaaaaaaa' ), ut ( 'a' ), ut ( 'A' ), occurrence = 1 , repeat = 1 ) write ( * , * ) 'replace first a with A [' // line % character () // ']' ! line = replace ( ut ( 'aaaaaaaaa' ), ut ( 'a' ), ut ( 'A' ), occurrence = 3 , repeat = 3 ) write ( * , * ) 'replace a with A for 3rd to 5th occurrence [' & & // line % character () // ']' ! line = replace ( ut ( 'ababababa' ), ut ( 'a' ), ut ( '' ), occurrence = 3 , repeat = 3 ) write ( * , * ) 'replace a with null instances 3 to 5 [' // & & line % character () // ']' ! line = replace ( & & ut ( 'a b ab baaa aaaa aa aa a a a aa aaaaaa' ),& & ut ( 'aa' ), ut ( 'CCCC' ), occurrence =- 1 , repeat = 1 ) write ( * , * ) 'replace lastaa with CCCC [' // line % character () // ']' ! write ( * , '(DT)' ) replace ( ut ( 'myf90stuff.f90.f90' ),& & ut ( 'f90' ), ut ( 'for' ), occurrence =- 1 , repeat = 1 ) write ( * , '(DT)' ) replace ( ut ( 'myf90stuff.f90.f90' ),& & ut ( 'f90' ), ut ( 'for' ), occurrence =- 2 , repeat = 2 ) ! end program demo_replace","tags":"","url":"program/demo_replace.html"},{"title":"concatenate ‚Äì M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=:), allocatable :: line type( unicode_type ) :: string integer :: ten = 10 integer :: twenty = 20 Source Code program concatenate use M_unicode , only : operator ( // ) use M_unicode , only : ut => unicode_type , ch => character type ( ut ) :: string integer :: ten = 10 , twenty = 20 character ( len = :), allocatable :: line ! ifx requires (), flang_new and gfortran do not at the moment string = 'so ' // ten // '+' // twenty // '=' // ( ten + twenty ) write ( * , * ) string % character () string = 10 // ' ' // 20 // ' ' // 3.14159265 // ' ' // ( 3 , 4 ) // ' ' // . true . // ( 1.0d0 / 3.0d0 ) write ( * , * ) string % character () string = 10 // 20 write ( * , * ) string % character () line = 'abc' // 'def' write ( * , * ) line string = 'abc' // ten write ( * , * ) string % character () string = ten // 'abc' write ( * , * ) string % character () end program concatenate","tags":"","url":"program/concatenate.html"},{"title":"uview ‚Äì M_unicode","text":"Uses iso_fortran_env M_unicode Variables Type Attributes Name Initial character(len=:), allocatable :: argument integer :: ends (2) character(len=*), parameter :: form = '(1x,\"char(int(z''\",z0,\"''),kind=ucs4)\":,\"// &\")' character(len=*), parameter :: form_M = '(1x,\"int(z''\",z0,\"'')\":,\", &\")' character(len=*), parameter :: form_html = '(1x,*(:\"&#\",i0,\";\"))' character(len=*), parameter :: form_zhtml = '(1x,*(:\"&#x\",z0,\";\"))' character(len=*), parameter :: g = '(*(g0))' integer :: i type( unicode_type ) :: ustr Functions function getarg (arg) result(argument) Arguments Type Intent Optional Attributes Name integer, intent(in) :: arg Return Value character(len=:), allocatable Source Code program uview ! @(#) given starting and ending codepoint show unicode characters in various formats use , intrinsic :: iso_fortran_env , only : stdout => output_unit use M_unicode , only : unicode_type , assignment ( = ), len use M_unicode , only : ut => unicode_type , ch => character implicit none character ( len =* ), parameter :: & & form = '(1x,\"char(int(z''\",z0,\"''),kind=ucs4)\":,\"// &\")' , & & form_M = '(1x,\"int(z''\",z0,\"'')\":,\", &\")' , & & form_zhtml = '(1x,*(:\"&#x\",z0,\";\"))' , & & form_html = '(1x,*(:\"&#\",i0,\";\"))' character ( len =* ), parameter :: g = '(*(g0))' integer :: i integer :: ends ( 2 ) character ( len = :), allocatable :: argument type ( unicode_type ) :: ustr ends = 0 do i = 1 , min ( 2 , command_argument_count ()) argument = getarg ( i ) read ( argument , * ) ends ( i ) enddo if ( i . eq . 2 ) ends ( 2 ) = ends ( 1 ) write ( stdout , g ) 'START=' , ends ( 1 ), ' END=' , ends ( 2 ) do i = ends ( 1 ), ends ( 2 ) ustr = i write ( stdout , '(1x,i0)' , advance = 'no' ) i ! codepoint write ( stdout , '(1x,a)' , advance = 'no' ) ch ( ustr ) ! character write ( stdout , '(1x,''U\\'' , z8 . 8 ) ',advance=' no ')i  ! U\\00000064 write(stdout,form_zhtml,advance=' no ')i          ! &#x4EBA; write(stdout,form_html,advance=' no ')i           ! &#20154; write(stdout,form,advance=' no ')i                ! char(int(z' nnn ',kind=ucs4)) write(stdout,form_M,advance=' no ')i              ! int(z' nnn ' ) write ( stdout , * ) enddo contains function getarg ( arg ) result ( argument ) integer , intent ( in ) :: arg integer :: length character ( len = :), allocatable :: argument call get_command_argument ( arg , length = length ) ! get command line argument length allocate ( character ( len = length ) :: argument ) ! allocate string big enough to hold argument call get_command_argument ( arg , argument ) ! get command line argument as a string end function getarg end program uview","tags":"","url":"program/uview.html"},{"title":"demo_verify_1 ‚Äì M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=1), parameter :: blank *(*) = \" \" integer :: i character(len=1), parameter :: int *(*) = \"1234567890\" character(len=1), parameter :: low *(*) = \"abcdefghijklmnopqrstuvwxyz\" character(len=1), parameter :: prnt *(*) = int//low//upp//blank//punc character(len=1), parameter :: punc *(*) = \"!\"\"#$%&'()*+,‚Äê./:;<=>?@['_‚Äò{|}Àú\" type( unicode_type ) :: stru character(len=1), parameter :: tab = char(11) character(len=1), parameter :: upp *(*) = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" Source Code program demo_verify_1 use M_unicode , only : assignment ( = ) use M_unicode , only : ut => unicode_type , ch => character use M_unicode , only : write ( formatted ) use M_unicode , only : operator ( == ) use M_unicode , only : verify , replace use M_unicode , only : operator ( // ) implicit none ! some useful character sets character , parameter :: & & int * ( * ) = \"1234567890\" , & & low * ( * ) = \"abcdefghijklmnopqrstuvwxyz\" , & & upp * ( * ) = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" , & & punc * ( * ) = \"!\"\"#$%&'()*+,‚Äê./:;<=>?@['_‚Äò{|}Àú\" , & & blank * ( * ) = \" \" , & & tab = char ( 11 ), & & prnt * ( * ) = int // low // upp // blank // punc type ( ut ) :: stru integer :: i print * , \"basics:\" print * , VERIFY ( \"ABBA\" , \"A\" ) ! has the value 2. print * , VERIFY ( \"ABBA\" , \"A\" , BACK = . TRUE .) ! has the value 3. print * , VERIFY ( \"ABBA\" , \"AB\" ) ! has the value 0. print * , \"find first non‚Äêuppercase letter\" ! will produce the location of \"d\", because there is no match in UPP write ( * , * ) \"something unmatched\" , verify ( ut ( \"ABCdEFG\" ), upp ) print * , \"if everything is matched return zero\" ! will produce 0 as all letters have a match write ( * , * ) & & \"everything matched\" , verify ( ut ( \"ffoorrttrraann\" ), \"nartrof\" ) print * , \"easily categorize strings as uppercase, lowercase, ...\" ! C-like functionality but does entire strings not just characters write ( * , * ) \"isdigit 123?\" , verify ( ut ( \"123\" ), int ) == 0 write ( * , * ) \"islower abc?\" , verify ( ut ( \"abc\" ), low ) == 0 write ( * , * ) \"isalpha aBc?\" , verify ( ut ( \"aBc\" ), low // upp ) == 0 write ( * , * ) \"isblank aBc dEf?\" , verify ( ut ( \"aBc dEf\" ), blank // tab ) /= 0 ! check if all printable characters stru = \"aB;cde,fgHI!Jklmno PQRSTU vwxyz\" write ( * , * ) \"isprint?\" , verify ( stru , prnt ) == 0 ! this now has a nonprintable tab character in it stru = replace ( stru , 10 , 10 , ut ( char ( 11 ))) write ( * , * ) \"isprint?\" , verify ( stru , prnt ) == 0 print * , \"VERIFY(3) is very powerful using expressions as masks\" ! verify(3) is often used in a logical expression stru = \" This is NOT all UPPERCASE \" write ( * , * ) \"all uppercase/spaces?\" , verify ( stru , blank // upp ) == 0 stru = \" This IS all uppercase \" write ( * , * ) \"stru=[\" // stru // \"]\" write ( * , * ) \"all uppercase/spaces?\" , verify ( stru , blank // upp ) == 0 ! set and show complex stru to be tested stru = \"  Check this out. Let me know  \" ! show the stru being examined write ( * , * ) \"stru=[\" // stru // \"]\" write ( * , * ) \"        \" // repeat ( int , 4 ) ! number line ! function returns a position just not a logical like C print * , \"returning a position not just a logical is useful\" ! which can be very useful for parsing strings write ( * , * ) \"first non‚Äêblank character\" , verify ( stru , blank ) write ( * , * ) \"last non‚Äêblank character\" , verify ( stru , blank , back = . true .) write ( * , * ) \"first non‚Äêletter non‚Äêblank\" , verify ( stru , low // upp // blank ) !VERIFY(3) is elemental (can check an array of strings in one call) print * , \"elemental\" ! are strings all letters (or blanks)? write ( * , * ) \"array of strings\" , verify ( & ! strings must all be same length, so force to length 10 & [ character ( len = 10 ) :: \"YES\" , \"ok\" , \"000\" , \"good one\" , \"Nope!\" ], & & low // upp // blank ) == 0 ! rarer, but the set can be an array, not just the strings to test ! you could do ISPRINT() this (harder) way :> write ( * , * ) \"isprint?\" , & & . not . all ( verify ( ut ( \"aBc\" ), [( char ( i ), i = 32 , 126 )]) == 1 ) ! instead of this way write ( * , * ) \"isprint?\" , verify ( ut ( \"aBc\" ), prnt ) == 0 end program demo_verify_1","tags":"","url":"program/demo_verify_1.html"},{"title":"demo_tokenize ‚Äì M_unicode","text":"Uses iso_fortran_env M_unicode Variables Type Attributes Name Initial integer, allocatable, dimension(:) :: begins type( unicode_type ) :: delims integer, allocatable, dimension(:) :: ends character(len=*), parameter :: g0 = '(*(g0))' character(len=*), parameter :: g1 = '(*(g0,1x))' type( unicode_type ) :: herbs integer :: i type( unicode_type ), allocatable :: separators (:) type( unicode_type ), allocatable :: tokens (:) Source Code program demo_tokenize use iso_fortran_env , only : stdout => output_unit use M_unicode , only : assignment ( = ), unicode_type , tokenize , len , character implicit none character ( len =* ), parameter :: g0 = '(*(g0))' character ( len =* ), parameter :: g1 = '(*(g0,1x))' type ( unicode_type ), allocatable :: tokens (:) type ( unicode_type ), allocatable :: separators (:) type ( unicode_type ) :: delims type ( unicode_type ) :: herbs integer , allocatable , dimension (:) :: begins integer , allocatable , dimension (:) :: ends integer :: i delims = ',&' herbs = 'parsley,sage,rosemary,&thyme' write ( stdout , * ) herbs % character () write ( stdout , g0 ) write ( stdout , g0 ) 'expecting' write ( stdout , g0 ) ' tokens    =[parsley][sage][rosemary][][thyme]' write ( stdout , g0 ) ' separators=,,,&' CALL TOKENIZE ( herbs , delims , tokens , separators ) write ( stdout , g0 ) 'got' write ( stdout , g0 ) \" tokens    =\" ,( '[' // tokens ( i )% character (), ']' , i = 1 , size ( tokens )) write ( stdout , g0 ) \" separators=\" ,( separators ( i )% character (), i = 1 , size ( separators )) write ( stdout , g0 ) write ( stdout , g0 ) 'expecting' write ( stdout , * ) 'begins=' ,[ 1 , 9 , 14 , 23 , 24 ] write ( stdout , * ) 'ends=  ' ,[ 7 , 12 , 21 , 22 , 28 ] CALL TOKENIZE ( herbs , delims , begins , ends ) write ( stdout , g0 ) 'got' write ( stdout , * ) 'begins=' , begins write ( stdout , * ) 'ends=  ' , ends write ( stdout , g0 ) write ( stdout , g0 ) 'OOP' tokens = herbs % tokenize ( delims ) write ( stdout , g0 ) \" tokens    =\" ,( '[' // tokens ( i )% character (), ']' , i = 1 , size ( tokens )) herbs = 'parsley/sage/rosemary//thyme' delims = '/' tokens = herbs % tokenize ( delims ) write ( stdout , g0 ) \" tokens    =\" ,( '[' // tokens ( i )% character (), ']' , i = 1 , size ( tokens )) herbs = 'parsleyüòÉsageüòÉrosemaryüòÉüòÉthyme' delims = 'üòÉ' write ( stdout , g0 ) ' ' , delims % character () write ( stdout , g1 ) ' ' , delims % codepoint () tokens = herbs % tokenize ( delims ) write ( stdout , g0 ) \" tokens    =\" ,( '[' // tokens ( i )% character (), ']' , i = 1 , size ( tokens )) end program demo_tokenize","tags":"","url":"program/demo_tokenize.html"},{"title":"demo_readline ‚Äì M_unicode","text":"Uses iso_fortran_env M_unicode Variables Type Attributes Name Initial character(len=:), allocatable :: aline integer, allocatable :: ints (:) integer :: iostat type( unicode_type ) :: line Source Code program demo_readline use , intrinsic :: iso_fortran_env , only : stdin => input_unit use , intrinsic :: iso_fortran_env , only : iostat_end use M_unicode , only : readline , len , trim use M_unicode , only : assignment ( = ), ch => character , ut => unicode_type implicit none type ( ut ) :: line character ( len = :), allocatable :: aline integer , allocatable :: ints (:) integer :: iostat open ( unit = stdin , pad = 'yes' ) ! INFINITE : do line = readline ( iostat = iostat ) if ( iostat . ne . 0 ) exit ! write the length, line in brackets and its Unicode codepoints write ( * , '(*(g0,1x))' ) len ( line ), '[' // ch ( line ) // ']' , line % codepoint () ! or assign the string to an allocatable array of integers ints = line ! and the string to a character variable aline = line write ( * , '(*(g0,1x))' ) len ( line ), '[' // ch ( line ) // ']' , ints enddo INFINITE ! if ( iostat /= iostat_end ) then write ( * , * ) 'error reading input:' , ch ( trim ( line )) endif ! end program demo_readline","tags":"","url":"program/demo_readline.html"},{"title":"demo_trim ‚Äì M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=*), parameter :: brackets = '( *(\"[\",DT,\"]\":,1x) )' integer :: i type( unicode_type ) :: str type( unicode_type ), allocatable :: strs (:) Source Code program demo_trim use M_unicode , only : ut => unicode_type , assignment ( = ) use M_unicode , only : trim , len use M_unicode , only : write ( formatted ) implicit none type ( ut ) :: str type ( ut ), allocatable :: strs (:) character ( len =* ), parameter :: brackets = '( *(\"[\",DT,\"]\":,1x) )' integer :: i ! str = '   trailing    ' print brackets , str , trim ( str ) ! trims it ! str = '   leading' print brackets , str , trim ( str ) ! no effect ! str = '            ' print brackets , str , trim ( str ) ! becomes zero length print * , len ( str ), len ( trim ( '               ' )) ! strs = [ ut ( \"Z \" ), ut ( \" a b c\" ), ut ( \"ABC   \" ), ut ( \"\" )] ! write ( * , * ) 'untrimmed:' print brackets , ( strs ( i ), i = 1 , size ( strs )) print brackets , strs ! write ( * , * ) 'trimmed:' ! everything prints trimmed print brackets , ( trim ( strs ( i )), i = 1 , size ( strs )) print brackets , trim ( strs ) ! end program demo_trim","tags":"","url":"program/demo_trim.html"},{"title":"demo_adjustl ‚Äì M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=*), parameter :: adt = '(a,\"[\",DT,\"]\")' integer :: iend integer :: istart type( unicode_type ) :: uout type( unicode_type ) :: usample Source Code program demo_adjustl use M_unicode , only : ut => unicode_type use M_unicode , only : ch => character use M_unicode , only : adjustl , trim , len_trim , verify use M_unicode , only : write ( formatted ) use M_unicode , only : assignment ( = ) implicit none type ( ut ) :: usample , uout integer :: istart , iend character ( len =* ), parameter :: adt = '(a,\"[\",DT,\"]\")' ! ! basic use usample = '   sample string   ' write ( * , adt ) 'original: ' , usample ! ! note a string stays the same length ! and is not trimmed by just an adjustl(3) call. write ( * , adt ) 'adjusted: ' , adjustl ( usample ) ! ! a fixed‚Äêlength string can be trimmed using trim(3) uout = trim ( adjustl ( usample )) write ( * , adt ) 'trimmed:  ' , uout ! ! or alternatively you can select a substring without adjusting istart = max ( 1 , verify ( usample , ' ' )) ! first non‚Äêblank character iend = len_trim ( usample ) write ( * , adt ) 'substring:' , usample % sub ( istart , iend ) ! write ( * , adt ) 'substring:' , adjustl ( usample , 30 ) write ( * , adt ) 'substring:' , adjustl ( usample , 20 ) write ( * , adt ) 'substring:' , adjustl ( usample , 10 ) write ( * , adt ) 'substring:' , adjustl ( usample , 0 ) end program demo_adjustl","tags":"","url":"program/demo_adjustl.html"},{"title":"demo_ichar ‚Äì M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial integer :: i integer, allocatable :: ilets (:) type( unicode_type ), allocatable :: lets (:) type( unicode_type ) :: string Source Code program demo_ichar use M_unicode , only : assignment ( = ), ch => character use M_unicode , only : ut => unicode_type , write ( formatted ) use M_unicode , only : ichar , escape , len implicit none type ( ut ) :: string type ( ut ), allocatable :: lets (:) integer , allocatable :: ilets (:) integer :: i ! ! create a string containing multibyte characters string = [ 949 , 8021 , 961 , 951 , 954 , 945 , 33 ] ! eureka write ( * , '(*(DT,1x,\"(AKA. eureka!)\"))' ) string ! ! call ichar(3) on each glyph of the string to convert ! the string to an array of integer codepoints ilets = [( ichar ( string % sub ( i , i )), i = 1 , len ( string ))] write ( * , '(*(z0,1x))' ) ilets ! ! note that the %codepoint method is commonly used to ! convert a string to an integer array of codepoints write ( * , '(*(z0,1x))' ) string % codepoint () ! elemental write ( * , '(\"WRITING ISSUES:\")' ) ! ! define an array LETS with escape codes with one glyph per element lets = [ ut ( '\\U03B5' ), ut ( '\\U1F55' ), ut ( '\\U03C1' ), ut ( '\\U03B7' ), & & ut ( '\\U03BA' ), ut ( '\\U03B1' ), ut ( '\\U0021' )] lets = escape ( lets ) ! convert escape codes to glyphs ! ! look at issues with converting to CHARACTER for simple printing ! write ( * , '(\"each element is a single glyph \",*(g0,1x))' ) len ( lets ) ! ! notice if you convert to an array of intrinsic CHARACTER type the ! strings are all the same length in bytes; but unicode characters ! can take various numbers of bytes write ( * , '(*(g0,\":\"))' ) 'CHARACTER array elements have same length' ,& & len ( ch ( lets )) ! this will not appear correctly because all elements are padded to ! the same length in bytes write ( * , '(*(a,\":\"))' ) ch ( lets ) ! one element at a time will retain the size of each element write ( * , '(*(a,\":\"))' )( ch ( lets ( i : i )), i = 1 , size ( lets )) ! ! the FIRST LETTER of each element is converted to a codepoint so ! for the special case where each string element is a single glyph ! an elemental approach works write ( * , '(\"ELEMENTAL:\",*(z0,1x))' ) ichar ( lets ) ! OOPS write ( * , '(\"OOPS:\",*(z0,1x))' ) lets % ichar () end program demo_ichar","tags":"","url":"program/demo_ichar.html"},{"title":"demo_len ‚Äì M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial integer :: ii type( unicode_type ), allocatable :: many_strings (:) type( unicode_type ) :: string Subroutines subroutine passed (str) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: str Source Code program demo_len use M_unicode , only : assignment ( = ), ut => unicode_type , len use M_unicode , only : write ( formatted ) implicit none type ( ut ) :: string type ( ut ), allocatable :: many_strings (:) integer :: ii ! BASIC USAGE string = 'Noho me ka hau‚Äôoli' ! (Be happy.) ii = len ( string ) write ( * , '(DT,*(g0))' ) string , ' LEN=' , ii ! string = ' How long is this allocatable string? ' write ( * , '(DT,*(g0))' ) string , ' LEN=' , len ( string ) ! ! STRINGS IN AN ARRAY MAY BE OF DIFFERENT LENGTHS many_strings = [ ut ( 'Tom' ), ut ( 'Dick' ), ut ( 'Harry' ) ] write ( * , '(*(g0,1x))' ) 'length of elements of array=' , len ( many_strings ) ! write ( * , '(*(g0))' ) 'length from type parameter inquiry=' , string % len () ! ! LOOK AT HOW A PASSED STRING CAN BE USED ... call passed ( ut ( ' how long? ' )) ! contains ! subroutine passed ( str ) type ( ut ), intent ( in ) :: str ! you can query the length of the passed variable ! when an interface is present write ( * , '(*(g0))' ) 'length of passed value is ' , len ( str ) end subroutine passed ! end program demo_len","tags":"","url":"program/demo_len.html"},{"title":"demo_character ‚Äì M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=*), parameter :: all = '(*(g0))' type( unicode_type ), allocatable :: array (:) integer :: i type( unicode_type ) :: ustr Source Code program demo_character use M_unicode , only : ut => unicode_type , ch => character , trim , len , pad use M_unicode , only : write ( formatted ), assignment ( = ) type ( ut ) :: ustr type ( ut ), allocatable :: array (:) integer :: i character ( len =* ), parameter :: all = '(*(g0))' ustr = [ 949 , 8021 , 961 , 951 , 954 , 945 , 33 ] ! eureka in codepoints ! when doing I/O using DT might be the most intuitive ! but sometimes converting to intrinsic character variables ! is preferred write ( * , all ) ch ( ustr ) ! convert to CHARACTER variable write ( * , all ) ustr % character () ! convert to CHARACTER variable ! you can select a range of glyphs write ( * , all ) ustr % character ( 3 , 4 ) ! similar to LINE(3:4) for ! CHARACTER variables ! and even reverse a string write ( * , all ) ustr % character ( len ( ustr ), 1 , - 1 ) ! reverse string ! note that OOP syntax provides a few other options write ( * , all ) ustr % byte () ! convert to CHARACTER(LEN=1) type ! arrays ! ! using this syntax make sure to make the LEN value large enough ! that glyphs can take up to four bytes array = ut ([ character ( len = 60 ) :: & 'Confucius never claimed to be a prophet, ' ,& 'but I think he foresaw AI! He said ' ,& '' ,& ' \"Â≠¶ËÄå‰∏çÊÄùÂàôÁΩîÔºåÊÄùËÄå‰∏çÂ≠¶ÂàôÊÆÜ\"' ,& 'or' ,& ' (xu√© √©r b√π sƒ´ z√© w«éng, sƒ´ √©r b√π xu√© z√© d√†i),' ,& 'which is also' ,& ' \"To learn without thinking is to be lost, ' ,& ' to think without learning is to be in danger\".' ]) ! write ( * , '(*(:,\"[\",g0,\"]\",/))' ) ch ( array ) ! all elements will be the same length in bytes but not necessarily !in glyphs write ( * , '(a,*(i0,1x))' ) 'all elements the same length in BYTES:' , & & len ( ch ( array )) write ( * , '(a,*(i0,1x))' ) 'lengths (in glyphs):' , len ( array ) array = trim ( array ) write ( * , '(a,*(i0,1x))' ) 'lengths after trimming (in glyphs):' , & & len ( array ) write ( * , '(:*(:,\"[\",g0,\"]\",/))' ) ch ( array ) write ( * , * ) ! ! using this syntax the elements will be of different lengths array = [ & ut ( 'Confucius never claimed to be a prophet,' ) ,& ut ( 'but I think he foresaw AI! He said' ) ,& ut ( '' ) ,& ut ( ' \"Â≠¶ËÄå‰∏çÊÄùÂàôÁΩîÔºåÊÄùËÄå‰∏çÂ≠¶ÂàôÊÆÜ\"' ) ,& ut ( 'or' ) ,& ut ( ' (xu√© √©r b√π sƒ´ z√© w«éng, sƒ´ √©r b√π xu√© z√© d√†i),' ) ,& ut ( 'which is also' ) ,& ut ( ' \"To learn without thinking is to be lost,' ) ,& ut ( ' to think without learning is to be in danger\".' )] ! but using the CHARACTER function will still make them the same ! length in bytes so you might want to print them individually ! for certain effects, subject to font properties such as varying ! glyph widths. write ( * , '(*(\"[\",g0,\"]\",/))' )( ch ( array ( i )), i = 1 , size ( array )) write ( * , '(*(\"[\",g0,\"]\",/))' )( ch ( pad ( array ( i ), 60 )), i = 1 , size ( array )) ! end program demo_character","tags":"","url":"program/demo_character.html"},{"title":"demo_get_arg ‚Äì M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=*), parameter :: bracket = '(1x,*(\"[\",a,\"]\",:))' type( unicode_type ) :: default integer :: i integer :: position type( unicode_type ) :: smiley type( unicode_type ) :: value Source Code program demo_get_arg use M_unicode , only : get_arg , ut => unicode_type , ch => character use M_unicode , only : assignment ( = ), operator ( // ), write ( formatted ) implicit none integer :: position type ( ut ) :: default type ( ut ) :: value type ( ut ) :: smiley integer :: i character ( len =* ), parameter :: bracket = '(1x,*(\"[\",a,\"]\",:))' ! smiley = 128515 ! set with Unicode code point default = 'Wish I was first ' // smiley // '!' ! set with unicode_type ! ! arguments can be type(unicode_type) or character ! but type(unicode_type) is always returned do position = 0 , command_argument_count () value = get_arg ( position , default ) value = get_arg ( position , default % character () ) ! write ( * , * ) value % character () write ( * , '(DT)' ) default % get_arg ( position ) ! ! print each glyph surrounded by brackets write ( * , bracket )( value % character ( i , i ), i = 1 , value % len ()) enddo ! end program demo_get_arg","tags":"","url":"program/demo_get_arg.html"},{"title":"codepoints ‚Äì M_unicode","text":"Uses iso_fortran_env M_unicode Variables Type Attributes Name Initial integer, allocatable :: codes (:) character(len=:), allocatable :: command_line character(len=*), parameter :: form = '(\"char(int(z''\",z0,\"''),kind=ucs4)\":,\"// &\")' character(len=*), parameter :: form_M = '(\"int(z''\",z0,\"'')\":,\", &\")' character(len=*), parameter :: form_codepoint = '(*(:\"\",i0,:\",\"))' character(len=*), parameter :: form_html = '(*(:\"&#\",i0,\";\"))' character(len=*), parameter :: form_zhtml = '(*(:\"&#x\",z0,\";\"))' character(len=*), parameter :: g = '(*(g0))' integer :: i type( unicode_type ) :: ustr Functions function getargs () result(command_line) Arguments None Return Value character(len=:), allocatable Source Code program codepoints ! @(#) take command line argument utf-8 text and generate Fortran statement that represents the string use , intrinsic :: iso_fortran_env , only : stdout => output_unit use M_unicode , only : unicode_type , assignment ( = ), len implicit none character ( len =* ), parameter :: form = '(\"char(int(z''\",z0,\"''),kind=ucs4)\":,\"// &\")' character ( len =* ), parameter :: form_M = '(\"int(z''\",z0,\"'')\":,\", &\")' character ( len =* ), parameter :: form_zhtml = '(*(:\"&#x\",z0,\";\"))' character ( len =* ), parameter :: form_html = '(*(:\"&#\",i0,\";\"))' character ( len =* ), parameter :: form_codepoint = '(*(:\"\",i0,:\",\"))' character ( len =* ), parameter :: g = '(*(g0))' integer :: i integer , allocatable :: codes (:) character ( len = :), allocatable :: command_line type ( unicode_type ) :: ustr command_line = getargs () ! get string containing all command arguments as CHARACTER bytes ustr = command_line ! convert bytes to internal Fortran Unicode representation !open (stdout, encoding='UTF-8') ! write the command line out as a Fortran variable expression using the CHAR() function write ( stdout , g ) 'program fortran_unicode' write ( stdout , g ) 'use,intrinsic :: iso_fortran_env, only: stdout => output_unit' write ( stdout , g ) 'implicit none' write ( stdout , g ) \"integer,parameter :: ucs4 = selected_char_kind('ISO_10646')\" write ( stdout , g ) 'character(kind=ucs4,len=:),allocatable :: ustr2' write ( stdout , g ) '! ISO-10646 ENCODING:' , command_line write ( stdout , g ) 'character(len=*,kind=ucs4),parameter :: ustr= &' write ( stdout , form )( ustr % codepoint ( i , i ), i = 1 , len ( ustr )) write ( stdout , g ) 'integer :: i' write ( stdout , g ) \"   open(stdout,encoding='utf-8')\" write ( stdout , g ) '   write(stdout,*)ustr' write ( stdout , g ) '   ! can do internal writes, substrings, character intrinsics ...' write ( stdout , g ) '   allocate(character(len=len(ustr),kind=ucs4) :: ustr2)' write ( stdout , g ) \"   write(ustr2,'(*(a))')[(ustr(i:i),i=len(ustr),1,-1)]\" write ( stdout , g ) '   write(stdout,*)ustr2' write ( stdout , g ) 'end program fortran_unicode' write ( stdout , g ) write ( stdout , g ) 'program fortran_M_unicode' write ( stdout , g ) 'use,intrinsic :: iso_fortran_env, only: stdout => output_unit' write ( stdout , g ) 'use M_unicode, only: unicode_type, assignment(=), len' write ( stdout , g ) 'implicit none' write ( stdout , g ) 'type(unicode_type) :: ustr' write ( stdout , g ) 'type(unicode_type) :: ustr2' write ( stdout , g ) '! GLYPH UNICODE ENCODING:' , command_line write ( stdout , g ) 'integer,parameter :: codes(*)= [&' write ( stdout , form_M , advance = 'no' ) ustr % codepoint () write ( stdout , g ) ']' write ( stdout , g ) 'integer :: i' write ( stdout , g ) 'integer :: iostat' write ( stdout , g ) \"   open(stdout,encoding='utf-8',iostat=iostat)\" write ( stdout , g ) '   ustr = codes' write ( stdout , g ) '   write(stdout,*)ustr%character()' write ( stdout , g ) '   ! can do substrings, character intrinsics ...' write ( stdout , g ) '   ustr2 = ustr%character(len(ustr),1,-1)' write ( stdout , g ) '   write(stdout,*)ustr2%character()' write ( stdout , g , advance = 'no' ) '   ustr=[' write ( stdout , form_codepoint , advance = 'no' ) ustr % codepoint () write ( stdout , g ) ']' write ( stdout , g ) '   write(stdout,*)ustr%character()' write ( stdout , g ) '   ustr=\"' , ustr % character (), '\"' write ( stdout , g ) '   write(stdout,*)ustr%character()' write ( stdout , g ) 'end program fortran_M_unicode' write ( stdout , g ) write ( stdout , g ) '#include <iostream>' write ( stdout , g ) '#include <string>' write ( stdout , g ) 'int main() {' write ( stdout , g , advance = 'no' ) '   std::u32string mystring = U\"' codes = ustr % codepoint () do i = 1 , size ( codes ) if ( codes ( i ). lt . 127 ) then write ( stdout , g , advance = 'no' ) achar ( codes ( i )) else write ( stdout , '(''U\\'' , z8 . 8 ) ',advance=' no ') codes(i) endif enddo write(stdout,g) ' \";' write(stdout,g) '   // Outputting these directly might depend on console/terminal support' write(stdout,g) \" // and may require conversion to the system 's preferred encoding.\" write(stdout,g) ' return 0 ; ' write(stdout,g) ' } ' write(stdout,g) write(stdout,g) \"<!-- HTML Entities for \",ustr%character(),\"-->\" write(stdout,g) ' < pre > ' write(stdout,g)ustr%character() write(stdout,form_zhtml)ustr%codepoint() ! &#x4EBA; write(stdout,form_html)ustr%codepoint()  ! &#20154; write(stdout,g) ' </ pre > ' write ( stdout , g ) contains function getargs () result ( command_line ) integer :: length character ( len = :), allocatable :: command_line call get_command ( length = length ) ! get command line length allocate ( character ( len = length ) :: command_line ) ! allocate string big enough to hold command line call get_command ( command = command_line ) ! get command line as a string call get_command_argument ( 0 , length = length ) ! remove argument 0 command_line = adjustl ( command_line ( length + 2 :)) end function getargs end program codepoints","tags":"","url":"program/codepoints.html"},{"title":"upside_down ‚Äì M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=128) :: ascii7 character(len=:), allocatable :: cmdline integer :: i type( unicode_type ) :: uline Functions function downside_up (string) result(uline) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value type( unicode_type ) function getargs () result(command_line) Arguments None Return Value character(len=:), allocatable Source Code program upside_down use M_unicode !use M_unicode, only : assignment(=), ch=>character, ut=>unicode_type use M_unicode , only : ch => character , ut => unicode_type type ( ut ) :: uline integer :: i character ( len = 128 ) :: ascii7 character ( len = :), allocatable :: cmdline cmdline = getargs () if ( cmdline . eq . '' ) then do i = 0 , 127 ascii7 ( i + 1 : i + 1 ) = char ( i ) enddo uline = downside_up ( ascii7 ( 32 : 126 )) write ( * , * ) uline % codepoint () write ( * , * ) ch ( uline ) else uline = downside_up ( cmdline ) write ( * , * ) ch ( uline ) endif !   do i=int(z'A4d0'),int(z'A4FF') ! Lisu (Fraser script) Unicode block !      uline = i !      write(*,'(i0,1x,z0,1x,a)')i,i,ch(uline) !   enddo contains function downside_up ( string ) result ( uline ) character ( len =* ), intent ( in ) :: string type ( ut ) :: uline character ( len = 1 ) :: letter integer :: i integer :: which integer :: ichr integer :: ichrs ( len ( string )) which = 1 do i = 1 , len ( string ) letter = string ( i : i ) select case ( letter ) case ( ' ' ); ichr = iachar ( ' ' ) case ( '!' ); ichr = int ( z '00A1' ) case ( '\"' ); ichr = int ( z '201E' ) case ( '#' ); ichr = iachar ( '#' ) case ( '$' ); ichr = iachar ( '$' ) case ( '%' ); ichr = iachar ( '%' ) case ( '&' ); ichr = int ( z '214B' ) case ( '''' ); ichr = int ( z '002C' ) case ( '(' ); ichr = int ( z '0029' ) case ( ')' ); ichr = iachar ( '(' ) case ( '*' ); ichr = iachar ( '*' ) case ( '+' ); ichr = iachar ( '+' ) case ( ',' ); ichr = iachar ( '''' ) case ( '-' ); ichr = iachar ( '-' ) case ( '.' ); ichr = int ( z '02D9' ) case ( '/' ); ichr = iachar ( '/' ) case ( '0' ); ichr = iachar ( '0' ) case ( '1' ); ichr = int ( z '0196' ) case ( '2' ); ichr = int ( z '1105' ) case ( '3' ); ichr = int ( z '0190' ) case ( '4' ); ichr = int ( z '152D' ) if ( which . eq . 2 ) ichr = int ( z '3123' ) if ( which . eq . 3 ) ichr = iachar ( 'h' ) case ( '5' ); ichr = int ( z '03DB' ) case ( '6' ); ichr = iachar ( '9' ) case ( '7' ); ichr = int ( z '2C62' ) if ( which . eq . 2 ) ichr = int ( z '3125' ) case ( '8' ); ichr = iachar ( '8' ) case ( '9' ); ichr = iachar ( '6' ) case ( ':' ); ichr = iachar ( ':' ) case ( ';' ); ichr = int ( z '061B' ) case ( '<' ); ichr = iachar ( '>' ) case ( '=' ); ichr = iachar ( '=' ) case ( '>' ); ichr = iachar ( '<' ) case ( '?' ); ichr = int ( z '00BF' ) case ( '@' ); ichr = iachar ( '@' ) ! Default ‚àÄêêí‚ÜÉ‚óñ∆é‚Ñ≤‚ÖÅHI≈ø‚ãä‚ÖÇW·¥éO‘ÄŒå·¥öS‚ä•‚à©·¥ßMX‚ÖÑZ case ( 'A' ); ichr = int ( z '2200' ) if ( which . eq . 4 ) ichr = int ( z 'A4EF' ) ! ÍìØ case ( 'B' ); ichr = int ( z '00010412' ) if ( which . eq . 4 ) ichr = int ( z 'A4ED' ) ! Íì≠ case ( 'C' ); ichr = int ( z '2183' ) if ( which . eq . 2 ) ichr = int ( z '0186' ) ichr = int ( z 'A4DB' ) ! Íìõ case ( 'D' ); ichr = int ( z '25D6' ) ichr = int ( z 'A4F7' ) ! Íì∑ case ( 'E' ); ichr = int ( z '018E' ) ichr = int ( z 'A4F1' ) ! Íì± case ( 'F' ); ichr = int ( z '2132' ) if ( which . eq . 4 ) ichr = int ( z 'A4DE' ) ! Íìû case ( 'G' ); ichr = int ( z '2141' ) ichr = int ( z 'A4E8' ) ! Íì® if ( which . eq . 2 ) ichr = int ( z '05E4' ) case ( 'H' ); ichr = iachar ( 'H' ) ichr = int ( z 'A4E7' ) ! Íìß case ( 'I' ); ichr = iachar ( 'I' ) ichr = int ( z 'A4F2' ) ! Íì≤ case ( 'J' ); ichr = int ( z '017F' ) ichr = int ( z 'A4E9' ) ! Íì© case ( 'K' ); ichr = int ( z '22CA' ) ichr = int ( z 'A4D8' ) ! Íìò case ( 'L' ); ichr = int ( z '2142' ) if ( which . eq . 4 ) ichr = int ( z 'A4F6' ) ! Íì∂ if ( which . eq . 2 ) ichr = int ( z '02E5' ) case ( 'M' ); ichr = ichar ( 'W' ) ichr = int ( z 'A4EA' ) ! Íì™ case ( 'N' ); ichr = int ( z '1D0E' ) ichr = int ( z 'A4E0' ) ! Íì† case ( 'O' ); ichr = iachar ( 'O' ) ichr = int ( z 'A4F3' ) ! Íì≥ case ( 'P' ); ichr = int ( z '0500' ) ichr = int ( z 'A4D2' ) ! Íìí case ( 'Q' ); ichr = int ( z '038C' ) case ( 'R' ); ichr = int ( z '1D1A' ) ichr = int ( z 'A4E4' ) ! Íì§ case ( 'S' ); ichr = iachar ( 'S' ) ichr = int ( z 'A4E2' ) ! Íì¢ case ( 'T' ); ichr = int ( z '22A5' ) ichr = int ( z 'A4D5' ) ! Íìï if ( which . eq . 2 ) ichr = int ( z '2534' ) case ( 'U' ); ichr = int ( z '2229' ) ichr = int ( z 'A4F5' ) ! Íìµ case ( 'V' ); ichr = int ( z '1D27' ) ichr = int ( z 'A4E5' ) ! Íì• if ( which . eq . 2 ) ichr = int ( z '039B' ) case ( 'W' ); ichr = iachar ( 'M' ) ichr = int ( z 'A4DF' ) ! Íìü case ( 'X' ); ichr = iachar ( 'X' ) ichr = int ( z 'A4EB' ) ! Íì´ case ( 'Y' ); ichr = int ( z '2144' ) case ( 'Z' ); ichr = iachar ( 'Z' ) ichr = int ( z 'A4DC' ) ! Íìú case ( '[' ); ichr = iachar ( ']' ) case ( '\\'); ichr=iachar(' \\ ') case(' ] '); ichr=iachar(' [ ') case(' &#94; '); ichr=iachar(' v ') case(' _ '); ichr=int(z' 20 3 E ') case(' ` '); ichr=iachar(' , ') case(' a '); ichr=int(z' 0250 ') case(' b '); ichr=iachar(' q ') case(' c '); ichr=int(z' 0254 ') case(' d '); ichr=iachar(' p ') case(' e '); ichr=int(z' 01 DD ') case(' f '); ichr=int(z' 025 F ') case(' g '); ichr=int(z' 0183 ') case(' h '); ichr=int(z' 0265 ') case(' i '); ichr=int(z' 0131 ') if(which.eq.2)ichr=int(z' 1 D09 ') case(' j '); ichr=int(z' 02 7 E ') case(' k '); ichr=int(z' 02 9 E ') case(' l '); ichr=int(z' 0283 ') case(' m '); ichr=int(z' 026 F ') case(' n '); ichr=iachar(' u ') case(' o '); ichr=iachar(' o ') case(' p '); ichr=iachar(' d ') case(' q '); ichr=iachar(' b ') case(' r '); ichr=int(z' 0279 ') case(' s '); ichr=iachar(' s ') case(' t '); ichr=int(z' 0287 ') case(' u '); ichr=iachar(' n ') case(' v '); ichr=int(z' 028 C ') case(' w '); ichr=int(z' 028 D ') case(' x '); ichr=iachar(' x ') case(' y '); ichr=int(z' 02 8 E ') case(' z '); ichr=iachar(' z ') case(' { '); ichr=iachar(' } ') case(' | '); ichr=iachar(' | ') case(' } '); ichr=iachar(' { ') case(' ~ '); ichr=iachar(' ~' ) case default ichr = iachar ( letter ) end select ichrs ( size ( ichrs ) - i + 1 ) = ichr enddo uline = ichrs end function downside_up function getargs () result ( command_line ) integer :: length character ( len = :), allocatable :: command_line call get_command ( length = length ) ! get command line length allocate ( character ( len = length ) :: command_line ) ! allocate string big enough to hold command line call get_command ( command = command_line ) ! get command line as a string call get_command_argument ( 0 , length = length ) ! remove argument 0 command_line = adjustl ( command_line ( length + 2 :)) end function getargs end program upside_down","tags":"","url":"program/upside_down.html"},{"title":"uni_to_ftn ‚Äì M_unicode","text":"Uses iso_fortran_env Variables Type Attributes Name Initial character(len=:), allocatable :: command_line character(len=*), parameter :: form = '(\"char(int(z''\",z0,\"''))\":,\"// &\")' character(len=*), parameter :: g = '(*(g0))' integer :: i Functions function getargs () result(command_line) Arguments None Return Value character(len=:), allocatable Source Code program uni_to_ftn ! @(#) take command line argument utf-8 text and generate Fortran statement that represents the string use , intrinsic :: iso_fortran_env , only : stdout => output_unit implicit none character ( len =* ), parameter :: form = '(\"char(int(z''\",z0,\"''))\":,\"// &\")' character ( len =* ), parameter :: g = '(*(g0))' integer :: i character ( len = :), allocatable :: command_line command_line = getargs () ! get string containing all command arguments as CHARACTER bytes ! write the command line out as a Fortran variable expression using the CHAR() function write ( stdout , g ) '! ENCODING:[' , command_line // ']' write ( stdout , g ) 'character(len=*),parameter :: variable= &' write ( stdout , form )( ichar ( command_line ( i : i )), i = 1 , len ( command_line )) contains function getargs () result ( command_line ) integer :: length character ( len = :), allocatable :: command_line call get_command ( length = length ) ! get command line length allocate ( character ( len = length ) :: command_line ) ! allocate string big enough to hold command line call get_command ( command = command_line ) ! get command line as a string call get_command_argument ( 0 , length = length ) ! remove argument 0 command_line = command_line ( length + 2 :) end function getargs end program uni_to_ftn","tags":"","url":"program/uni_to_ftn.html"},{"title":"demo_codepoints_to_utf8 ‚Äì M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=1), allocatable :: bytes (:) integer, parameter :: codepoints (*) = [78, 111, 104, 111, 32, 109, 101, 32, 107, 97, 32, 104, 97, 117, 8217, 111, 108, 105] integer :: nerr character(len=*), parameter :: solid = '(*(g0))' character(len=*), parameter :: space = '(*(g0,1x))' character(len=:), allocatable :: string character(len=*), parameter :: z = '(a,*(z0,1x))' Source Code program demo_codepoints_to_utf8 use m_unicode , only : codepoints_to_utf8 implicit none !'Noho me ka hau‚Äôoli' !(Be happy) integer , parameter :: codepoints ( * ) = [ & & 78 , 111 , 104 , 111 ,& & 32 , 109 , 101 , & & 32 , 107 , 97 , & & 32 , 104 , 97 , 117 , 8217 , 111 , 108 , 105 ] character ( len = :), allocatable :: string character ( len = 1 ), allocatable :: bytes (:) character ( len =* ), parameter :: solid = '(*(g0))' character ( len =* ), parameter :: space = '(*(g0,1x))' character ( len =* ), parameter :: z = '(a,*(z0,1x))' integer :: nerr ! BASIC USAGE: SCALAR CHARACTER VARIABLE write ( * , space ) 'CODEPOINTS:' , codepoints write ( * , z ) 'HEXADECIMAL CODEPOINTS:' , codepoints call codepoints_to_utf8 ( codepoints , string , nerr ) write ( * , solid ) 'STRING:' , string ! write ( * , space ) 'How long is this string in glyphs? ' write ( * , space ) size ( codepoints ) write ( * , space ) 'How long is this string in bytes? ' write ( * , space ) len ( string ) ! ! BASIC USAGE: ARRAY OF BYTES call codepoints_to_utf8 ( codepoints , bytes , nerr ) write ( * , solid ) 'STRING:' , bytes ! write ( * , space ) 'How long is this string in glyphs? ' write ( * , space ) size ( codepoints ) write ( * , space ) 'How long is this string in bytes? ' write ( * , space ) size ( bytes ) ! end program demo_codepoints_to_utf8","tags":"","url":"program/demo_codepoints_to_utf8.html"},{"title":"demo_verify ‚Äì M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=1), parameter :: blank *(*) = \" \" integer :: i character(len=1), parameter :: int *(*) = \"1234567890\" character(len=1), parameter :: low *(*) = \"abcdefghijklmnopqrstuvwxyz\" character(len=1), parameter :: prnt *(*) = int//low//upp//blank//punc character(len=1), parameter :: punc *(*) = \"!\"\"#$%&'()*+,‚Äê./:;<=>?@['_‚Äò{|}Àú\" type( unicode_type ) :: stru character(len=1), parameter :: tab = char(11) character(len=1), parameter :: upp *(*) = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" Source Code program demo_verify ! general examples use M_unicode , only : assignment ( = ) use M_unicode , only : ut => unicode_type , ch => character use M_unicode , only : write ( formatted ) use M_unicode , only : operator ( == ) use M_unicode , only : verify , replace use M_unicode , only : operator ( // ) implicit none ! some useful character sets character , parameter :: & & int * ( * ) = \"1234567890\" , & & low * ( * ) = \"abcdefghijklmnopqrstuvwxyz\" , & & upp * ( * ) = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" , & & punc * ( * ) = \"!\"\"#$%&'()*+,‚Äê./:;<=>?@['_‚Äò{|}Àú\" , & & blank * ( * ) = \" \" , & & tab = char ( 11 ), & & prnt * ( * ) = int // low // upp // blank // punc ! type ( ut ) :: stru integer :: i print * , \"basics:\" print * , VERIFY ( \"ABBA\" , \"A\" ) ! has the value 2. print * , VERIFY ( \"ABBA\" , \"A\" , BACK = . TRUE .) ! has the value 3. print * , VERIFY ( \"ABBA\" , \"AB\" ) ! has the value 0. ! print * , \"find first non‚Äêuppercase letter\" ! will produce the location of \"d\", because there is no match in UPP write ( * , * ) \"something unmatched\" , verify ( ut ( \"ABCdEFG\" ), upp ) ! print * , \"if everything is matched return zero\" ! will produce 0 as all letters have a match write ( * , * ) & & \"everything matched\" , verify ( ut ( \"ffoorrttrraann\" ), \"nartrof\" ) ! print * , \"easily categorize strings as uppercase, lowercase, ...\" ! C-like functionality but does entire strings not just characters write ( * , * ) \"isdigit 123?\" , verify ( ut ( \"123\" ), int ) == 0 write ( * , * ) \"islower abc?\" , verify ( ut ( \"abc\" ), low ) == 0 write ( * , * ) \"isalpha aBc?\" , verify ( ut ( \"aBc\" ), low // upp ) == 0 write ( * , * ) \"isblank aBc dEf?\" , verify ( ut ( \"aBc dEf\" ), blank // tab ) /= 0 ! check if all printable characters stru = \"aB;cde,fgHI!Jklmno PQRSTU vwxyz\" write ( * , * ) \"isprint?\" , verify ( stru , prnt ) == 0 ! ! this now has a nonprintable tab character in it stru = replace ( stru , 10 , 10 , ut ( char ( 11 ))) write ( * , * ) \"isprint?\" , verify ( stru , prnt ) == 0 ! print * , \"VERIFY(3) is very powerful using expressions as masks\" ! verify(3) is often used in a logical expression stru = \" This is NOT all UPPERCASE \" write ( * , * ) \"all uppercase/spaces?\" , verify ( stru , blank // upp ) == 0 stru = \" This IS all uppercase \" write ( * , * ) \"stru=[\" // stru // \"]\" write ( * , * ) \"all uppercase/spaces?\" , verify ( stru , blank // upp ) == 0 ! ! set and show complex stru to be tested stru = \"  Check this out. Let me know  \" ! show the stru being examined write ( * , * ) \"stru=[\" // stru // \"]\" write ( * , * ) \"        \" // repeat ( int , 4 ) ! number line ! ! function returns a position just not a logical like C print * , \"returning a position not just a logical is useful\" ! which can be very useful for parsing strings write ( * , * ) \"first non‚Äêblank character\" , verify ( stru , blank ) write ( * , * ) \"last non‚Äêblank character\" , verify ( stru , blank , back = . true .) write ( * , * ) \"first non‚Äêletter non‚Äêblank\" , verify ( stru , low // upp // blank ) ! !VERIFY(3) is elemental (can check an array of strings in one call) print * , \"elemental\" ! are strings all letters (or blanks)? write ( * , * ) \"array of strings\" , verify ( & ! strings must all be same length, so force to length 10 & [ character ( len = 10 ) :: \"YES\" , \"ok\" , \"000\" , \"good one\" , \"Nope!\" ], & & low // upp // blank ) == 0 ! ! rarer, but the set can be an array, not just the strings to test ! you could do ISPRINT() this (harder) way :> write ( * , * ) \"isprint?\" , & & . not . all ( verify ( ut ( \"aBc\" ), [( char ( i ), i = 32 , 126 )]) == 1 ) ! instead of this way write ( * , * ) \"isprint?\" , verify ( ut ( \"aBc\" ), prnt ) == 0 ! end program demo_verify","tags":"","url":"program/demo_verify.html"},{"title":"demo_M_unicode ‚Äì M_unicode","text":"Uses iso_fortran_env M_unicode Variables Type Attributes Name Initial character(len=*), parameter :: all = '(g0)' type( unicode_type ), allocatable :: array (:) type( unicode_type ) :: lowercase type( unicode_type ) :: numeric type( unicode_type ) :: string type( unicode_type ) :: uppercase Source Code program demo_M_unicode use , intrinsic :: iso_fortran_env , only : stdout => output_unit use M_unicode , only : tokenize , replace , character , upper , lower , len use M_unicode , only : unicode_type , assignment ( = ), operator ( // ) use M_unicode , only : ut => unicode_type , ch => character use M_unicode , only : write ( formatted ) type ( unicode_type ) :: string type ( unicode_type ) :: numeric , uppercase , lowercase type ( unicode_type ), allocatable :: array (:) character ( len =* ), parameter :: all = '(g0)' !character(len=*),parameter     :: uni='(DT)' uppercase = '–ê–ë–í–ì“ê–î–ï–Ñ–ñ–ó–ò–Ü–á–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–¨–Æ–Ø' lowercase = '–∞–±–≤–≥“ë–¥–µ—î–∂–∑–∏—ñ—ó–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—å—é—è' numeric = '0123456789' ! string = uppercase // numeric // lowercase ! print all , 'Original string:' print all , ch ( string ) print all , 'length in bytes :' , len ( string % character ()) print all , 'length in glyphs:' , len ( string ) print all ! print all , 'convert to all uppercase:' print all , ch ( UPPER ( string ) ) print all ! print all , 'convert to all lowercase:' print all , ch ( string % LOWER () ) print all ! print all , 'tokenize on spaces ... ' call TOKENIZE ( string , ut ( ' ' ), array ) print all , '... writing with A or G format:' , character ( array ) !print uni, ut('... writing with DT format'),array print all ! print all , 'case-insensitive replace:' print all , ch ( & & REPLACE ( string , & & ut ( '–∫–ª–º–Ω–æ–ø—Ä—Å' ), & & ut ( '--------' ), & & ignorecase = . true .) ) ! print all ! end program demo_M_unicode","tags":"","url":"program/demo_m_unicode.html"},{"title":"demo_fmt ‚Äì M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=:), allocatable :: Aformat character(len=:), allocatable :: Astr type( unicode_type ) :: Ustr Source Code program demo_fmt use :: M_unicode , only : fmt , assignment ( = ) use :: M_unicode , only : ut => unicode_type , ch => character implicit none character ( len = :), allocatable :: Astr , Aformat type ( ut ) :: Ustr ! format can be CHARACTER Aformat = \"('[',i0,']')\" Astr = fmt ( 10 , Aformat ) write ( * , * ) 'result is ' , Astr ! format can be string Astr = fmt ( 1 0.0 / 3.0 , ut ( \"'[',g0.5,']'\" )) write ( * , * ) 'result is ' , Astr ! Output is a string, so use ch() write ( * , * ) 'result is ' , ch ( fmt (. true ., \"'The answer is [',g0,']'\" )) ! OOP Ustr = 'A B C' Ustr = Ustr % fmt ( \"'[',g0,']'\" ) write ( * , * ) 'result is ' , ch ( Ustr ) end program demo_fmt","tags":"","url":"program/demo_fmt.html"},{"title":"demo_index ‚Äì M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=*), parameter :: all = '(*(g0))' integer :: ii type( unicode_type ) :: str Source Code program demo_index use M_unicode , only : ut => unicode_type use M_unicode , only : assignment ( = ) use M_unicode , only : index implicit none type ( ut ) :: str character ( len =* ), parameter :: all = '(*(g0))' integer :: ii ! str = 'Huli i kƒìia kaula no kƒìia  ª≈çlelo' !bug!print all, index(str,'kƒìia').eq.8 ii = index ( str , 'kƒìia' ); print all , ii . eq . 8 ! ! return value is counted from the left end even if BACK=.TRUE. !bug!print all, index(str,'kƒìia',back=.true.).eq.22 ii = index ( str , 'kƒìia' , back = . true .); print all , ii . eq . 22 ! ! INDEX is case-sensitive !bug!print all, index(str,'Kƒìia').eq.0 ii = index ( str , 'Kƒìia' ); print all , ii . eq . 0 !<<<<<<<<<< !ifx bug: ifx (IFX) 2024.1.0 20240308 ! !example/demo_index.f90(17): error #6766: A binary defined OPERATOR !definition is missing or incorrect.   [EQ] !        print all, index(str,'k  ia',back=.true.).eq.22 !--------------------------------------------------&#94; !Original works with gfortran and flang_new and this works with ifx !        ii=ndex(str,'k  ia',back=.true.) !    print all, ii.eq.22 !>>>>>>>>>> end program demo_index","tags":"","url":"program/demo_index.html"},{"title":"demo_expandtabs ‚Äì M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=:), allocatable :: dat integer :: i type( unicode_type ) :: in type( unicode_type ) :: inexpanded Source Code program demo_expandtabs use M_unicode , only : expandtabs , ch => character , replace use M_unicode , only : assignment ( = ), ut => unicode_type implicit none type ( ut ) :: in type ( ut ) :: inexpanded character ( len = :), allocatable :: dat integer :: i dat = '  this is my string  ' ! change spaces to tabs to make a sample input do i = 1 , len ( dat ) if ( dat ( i : i ) == ' ' ) dat ( i : i ) = char ( 9 ) enddo in = dat ! inexpanded = expandtabs ( in ) write ( * , '(\"[\",a,\"]\")' ) ch ( inexpanded ) inexpanded = replace ( inexpanded , ut ( ' ' ), ut ( '_' )) write ( * , '(\"[\",a,\"]\")' ) ch ( inexpanded ) ! write ( * , '(\"[\",a,\"]\")' ) ch ( in % expandtabs ()) write ( * , '(\"[\",a,\"]\")' ) ch ( in % expandtabs ( tab_size = 8 )) write ( * , '(\"[\",a,\"]\")' ) ch ( in % expandtabs ( tab_size = 1 )) write ( * , '(\"[\",a,\"]\")' ) ch ( in % expandtabs ( tab_size = 0 )) ! end program demo_expandtabs","tags":"","url":"program/demo_expandtabs.html"},{"title":"demo_get_env ‚Äì M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=*), parameter :: bracket = '(1x,*(\"[\",a,\"]\",:))' type( unicode_type ) :: default integer :: i type( unicode_type ) :: name type( unicode_type ) :: smiley type( unicode_type ) :: value Source Code program demo_get_env use M_unicode , only : get_env , ut => unicode_type use M_unicode , only : assignment ( = ), operator ( // ) implicit none type ( ut ) :: name type ( ut ) :: default type ( ut ) :: value type ( ut ) :: smiley integer :: i character ( len =* ), parameter :: bracket = '(1x,*(\"[\",a,\"]\",:))' ! smiley = 128515 ! set with Unicode code point name = 'UTF8' ! set with ASCII default = 'Have a nice day ' // smiley // '!' ! set with unicode_type ! ! arguments can be type(unicode_type) or character ! but type(unicode_type) is always returned value = get_env ( name , default ) value = get_env ( name % character (), default % character () ) value = get_env ( name , default % character () ) value = get_env ( name % character (), default ) ! write ( * , * ) value % character () ! ! print each glyph surrounded by brackets write ( * , bracket )( value % character ( i , i ), i = 1 , value % len ()) ! end program demo_get_env","tags":"","url":"program/demo_get_env.html"},{"title":"test_for_iso_10646 ‚Äì M_unicode","text":"Uses iso_fortran_env M_unicode Variables Type Attributes Name Initial type( unicode_type ) :: smiley Source Code program test_for_iso_10646 use M_unicode use iso_fortran_env , only : stdout => output_unit implicit none type ( unicode_type ) :: smiley smiley = [ int ( z '1F603' )] write ( stdout , * ) 'Smiling face with open mouth' , smiley % character () ! üòÉ smiley = 'üòÉ' write ( stdout , * ) 'one CHARACTER string to one UNICODE_TYPE string' , smiley % character () smiley = [ '1üòÉ' , '2üòÉ' , '3üòÉ' , '4üòÉ' ] write ( stdout , * ) 'four CHARACTER strings becomes one UNICODE_TYPE string ' , smiley % character () smiley = 128515 write ( stdout , * ) 'one codepoint ' , smiley % character (), smiley % codepoint () smiley = [ 128515 , 128515 ] write ( stdout , * ) 'array of codepoint ' , smiley % character (), smiley % codepoint () end program test_for_iso_10646","tags":"","url":"program/test_for_iso_10646.html"},{"title":"bom_exe ‚Äì M_unicode","text":"Uses iso_fortran_env M_unicode Variables Type Attributes Name Initial type( unicode_type ) :: UT_bom Source Code program bom_exe ! ! Create a Fortran source file starting with a utf-8 BOM to see if your ! compiler will compile it or fail because a character is not in the ! Fortran character set outside of a comment or literal string. ! ! When the first character of a file the BOM character indicates the file ! is UTF-8 encoded to some applications, although it is not universally ! required. ! ! Does your compiler compile the output file generated by this program? ! ! The Unicode value for the Byte Order Mark (BOM) character is ! U+FEFF. While it was originally used as a \"Zero Width No-Break Space,\" ! its modern purpose is solely to act as a BOM, indicating the file is ! Unicode encoded and, in the case of UTF-16 and UTF-32, its byte order ! (endianness). The BOM is often presented at the beginning of a file, ! though its use in UTF-8 files is primarily to signal the encoding, not ! to address byte order issues (which does not apply to UTF-8 encoding). ! ! if on a ULS (Unix-like system) the file(1) command should produce ! !     bom_start >>xx.f90 !     file xx.f90 !     xx.f90: Unicode text, UTF-8 (with BOM) text ! use iso_fortran_env , only : stdout => output_unit use M_unicode , only : unicode_type , assignment ( = ), unicode implicit none type ( unicode_type ) :: UT_bom UT_bom = 65279 ! the codepoint value for the BOM character UT_bom = int ( z 'FEFF' ) ! or equivalently UT_bom = unicode % bom ! alternatively use constant from module ! place BOM character at beginning of output write ( stdout , '(a)' , advance = 'no' ) UT_bom % character () ! add a minimal Fortran program to make a test program source write ( stdout , '(a)' ) & ! Note: making the first line a comment precludes it being a cpp(1) directive !       preventing the directive from failing because something precedes the \"#\" '!fortran ' ,& 'program testit ! Unicode BOM encoded to utf-8 bytes by Fortran' ,& '   write(*,*)\"This source file starts with BOM character\"' ,& '   write(*,*)\"(Unicode codepoint z\"\"FEFF\"\")!\"' ,& 'end program testit' end program bom_exe","tags":"","url":"program/bom_exe.html"},{"title":"demo_pad ‚Äì M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial type( unicode_type ) :: answer integer :: i type( unicode_type ) :: string character(len=*), parameter :: u = '(*(g0))' Source Code program demo_pad use M_unicode , only : pad , assignment ( = ) !use M_unicode, only : write(formatted) use M_unicode , only : len use M_unicode , only : ch => character use M_unicode , only : ut => unicode_type implicit none type ( ut ) :: string type ( ut ) :: answer integer :: i !character(len=*),parameter :: u='(*(DT))' character ( len =* ), parameter :: u = '(*(g0))' ! string = 'abcdefghij' ! write ( * , * ) 'pad on right till 20 characters long' answer = pad ( string , 20 ) write ( * , '(\"[\",g0,\"]\",/)' ) answer % character () ! write ( * , * ) 'original is not trimmed for short length requests' answer = pad ( string , 5 ) write ( * , '(\"[\",g0,\"]\",/)' ) answer % character () ! i = 30 write ( * , * ) 'pad with specified string and left-justified integers' write ( * , '(1x,g0,1x,i0)' ) & & ch ( pad ( ut ( 'CHAPTER 1 : The beginning ' ), i , ut ( '.' ) )), 1 , & & ch ( pad ( ut ( 'CHAPTER 2 : The end ' ), i , ut ( '.' ) )), 1234 , & & ch ( pad ( ut ( 'APPENDIX ' ), i , ut ( '.' ) )), 1235 ! write ( * , * ) 'pad with specified string and right-justified integers' write ( * , '(1x,g0,i7)' ) & & ch ( pad ( ut ( 'CHAPTER 1 : The beginning ' ), i , ut ( '.' ) )), 1 , & & ch ( pad ( ut ( 'CHAPTER 2 : The end ' ), i , ut ( '.' ) )), 1234 , & & ch ( pad ( ut ( 'APPENDIX ' ), i , ut ( '.' ) )), 1235 ! write ( * , * ) 'pad on left with zeros' write ( * , u ) ch ( pad ( ut ( '12' ), 5 , ut ( '0' ), right = . false .)) ! write ( * , * ) 'various lengths with clip .true. and .false.' write ( * , u ) ch ( pad ( ut ( '12345 ' ), 30 , ut ( '_' ), right = . false .)) write ( * , u ) ch ( pad ( ut ( '12345 ' ), 30 , ut ( '_' ), right = . false ., clip = . true .)) write ( * , u ) ch ( pad ( ut ( '12345 ' ), 7 , ut ( '_' ), right = . false .)) write ( * , u ) ch ( pad ( ut ( '12345 ' ), 7 , ut ( '_' ), right = . false ., clip = . true .)) write ( * , u ) ch ( pad ( ut ( '12345 ' ), 6 , ut ( '_' ), right = . false .)) write ( * , u ) ch ( pad ( ut ( '12345 ' ), 6 , ut ( '_' ), right = . false ., clip = . true .)) write ( * , u ) ch ( pad ( ut ( '12345 ' ), 5 , ut ( '_' ), right = . false .)) write ( * , u ) ch ( pad ( ut ( '12345 ' ), 5 , ut ( '_' ), right = . false ., clip = . true .)) write ( * , u ) ch ( pad ( ut ( '12345 ' ), 4 , ut ( '_' ), right = . false .)) write ( * , u ) ch ( pad ( ut ( '12345 ' ), 4 , ut ( '_' ), right = . false ., clip = . true .)) end program demo_pad","tags":"","url":"program/demo_pad.html"},{"title":"demo_len_trim ‚Äì M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial integer :: i type( unicode_type ) :: string Source Code program demo_len_trim use M_unicode , only : ut => unicode_type , assignment ( = ) use M_unicode , only : len , len_trim use M_unicode , only : write ( formatted ) implicit none type ( ut ) :: string integer :: i ! basic usage string = \" how long is this string?     \" print '(DT)' , string print * , 'untrimmed length=' , len ( string ) print * , 'trimmed length=' , len_trim ( string ) ! ! print string, then print substring of string string = 'xxxxx   ' write ( * , '(*(DT))' ) string , string , string i = len_trim ( string ) print '(*(DT))' , string % sub ( 1 , i ), string % sub ( 1 , i ), string % sub ( 1 , i ) ! ! elemental example ele : block ! an array of strings may be used type ( ut ), allocatable :: tablet (:) tablet = [ & & ut ( ' how long is this string?     ' ),& & ut ( 'and this one?' )] write ( * , * ) 'untrimmed length=  ' , len ( tablet ) write ( * , * ) 'trimmed length=    ' , len_trim ( tablet ) write ( * , * ) 'sum trimmed length=' , sum ( len_trim ( tablet )) endblock ele ! end program demo_len_trim","tags":"","url":"program/demo_len_trim.html"},{"title":"demo_construct ‚Äì M_unicode","text":"Uses iso_fortran_env M_unicode Variables Type Attributes Name Initial character(len=*), parameter :: all = '(*(g0))' character(len=:), allocatable :: astr character(len=80), parameter :: fmts (*) = [character(len=80)::'(*(g0,1x))', '(*(z0,1x))', \"(8('int(z\"\"',z0,'\"\")',:,','))\"] integer :: i integer, allocatable :: iarr (:) type( unicode_type ), allocatable :: uarr (:) type( unicode_type ) :: ustr Source Code program demo_construct use , intrinsic :: iso_fortran_env , only : stdout => output_unit use M_unicode type ( unicode_type ) :: ustr type ( unicode_type ), allocatable :: uarr (:) character ( len = :), allocatable :: astr integer :: i integer , allocatable :: iarr (:) character ( len =* ), parameter :: all = '(*(g0))' character ( len = 80 ), parameter :: fmts ( * ) = [ character ( len = 80 ) :: & '(*(g0,1x))' ,& '(*(z0,1x))' ,& \"(8('int(z\"\"',z0,'\"\")',:,','))\" ] ! Constructors ! UNICODE_VARIABLE = CHARACTER(LEN=*)|UNICODE_VARIABLE|INTEGER_ARRAY ! Using a character array to define a string array uarr = unicode_type ([ character ( len = 80 ) :: & 'Confucius never claimed to be a prophet, ' ,& 'but I think he foresaw AI! He said ' ,& '' ,& ' \"Â≠¶ËÄå‰∏çÊÄùÂàôÁΩîÔºåÊÄùËÄå‰∏çÂ≠¶ÂàôÊÆÜ\"' ,& 'or' ,& ' (xu√© √©r b√π sƒ´ z√© w«éng, sƒ´ √©r b√π xu√© z√© d√†i),' ,& 'which is also' ,& ' \"To learn without thinking is to be lost, ' ,& ' to think without learning is to be in danger\".' ]) uarr = trim ( uarr ) ! trim fixed-length bytes to ragged array do i = 1 , size ( uarr ) ! show lengths in glyphs astr = uarr ( i ) ! assign string to character write ( * , '(i3,\": \",a)' ) len ( uarr ( i )), astr enddo print * ! string to integer array of codepoints iarr = uarr ( 4 )% sub ( 3 , 10 ) do i = 1 , 3 print fmts ( i ), iarr enddo print * ! assign character variable to string ustr = 'Hello World and Ni Hao -- ‰Ω†Â•Ω  ' ! convert to intrinsic CHARACTER variable write ( * , all ) character ( ustr ) ! use intrinsic function names on strings write ( * , all ) len ( ustr ) write ( * , all ) len_trim ( ustr ) write ( * , all ) index ( ustr , '‰Ω†' ) print all , 'OOPS' ! VARIABLE%CHARACTER(start,end,step) returns a CHARACTER string ! VARIABLE%BYTE() returns an array of CHARACTER(len=1) values ! VARIABLE%CODEPOINT() returns an integer array of Unicode values write ( * , all ) ustr % character () ! convert to CHARACTER variable write ( * , all ) ustr % character ( 27 , 28 ) ! similar to LINE(27:28) write ( * , all ) ustr % character ( len ( ustr ), 1 , - 1 ) ! reverse string write ( * , all ) ustr % byte () ! convert to CHARACTER(LEN=1) type do i = 1 , size ( fmts ) write ( * , fmts ( i )) ustr % codepoint ( 27 , 28 ) ! convert to Unicode codepoints enddo end program demo_construct","tags":"","url":"program/demo_construct.html"},{"title":"count_glyphs ‚Äì M_unicode","text":"Uses iso_fortran_env M_unicode Variables Type Attributes Name Initial character(len=1024) :: aline character(len=*), parameter :: g = '(*(g0))' character(len=255) :: iomsg integer :: iostat integer :: length integer :: length_ascii type( unicode_type ) :: uline Source Code program count_glyphs ! @(#) read a utf-8 file and write it out with lines prefixed with glyph count of the line use , intrinsic :: iso_fortran_env , only : output_unit , input_unit use M_unicode implicit none intrinsic is_iostat_end character ( len =* ), parameter :: g = '(*(g0))' integer :: length integer :: length_ascii integer :: iostat character ( len = 1024 ) :: aline type ( unicode_type ) :: uline character ( len = 255 ) :: iomsg do read ( input_unit , '(a)' , iostat = iostat , iomsg = iomsg ) aline if ( iostat . eq . 0 ) then uline = trim ( aline ) length = len_trim ( uline ) length_ascii = len_trim ( uline % character ()) write ( output_unit , '(i5,\": \",i5,\": \",a)' ) length , length_ascii , uline % character ( 1 , length ) elseif ( is_iostat_end ( iostat )) then exit else write ( output_unit , g ) '<ERROR>' , trim ( iomsg ) exit endif enddo end program count_glyphs","tags":"","url":"program/count_glyphs.html"},{"title":"demo_tokenize ‚Äì M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=*), parameter :: a_commas = '(a,*(g0:,\",\"))' character(len=*), parameter :: brackets = '(*(\"[\",g0,\"]\":,\",\"))' character(len=*), parameter :: gen = '(*(g0))' Source Code program demo_tokenize use M_unicode , only : tokenize , ut => unicode_type , ch => character use M_unicode , only : assignment ( = ), operator ( /= ) implicit none ! ! some useful formats character ( len =* ), parameter :: & & brackets = '(*(\"[\",g0,\"]\":,\",\"))' ,& & a_commas = '(a,*(g0:,\",\"))' ,& & gen = '(*(g0))' ! ! Execution of TOKEN form (return array of tokens) ! block type ( ut ) :: string type ( ut ), allocatable :: tokens (:) integer :: i string = '  first,second ,third       ' call tokenize ( string , set = ';,' , tokens = tokens ) write ( * , brackets ) ch ( tokens ) string = '  first , second ,third       ' call tokenize ( string , set = ' ,' , tokens = tokens ) write ( * , brackets )( tokens ( i )% character (), i = 1 , size ( tokens )) ! remove blank tokens tokens = pack ( tokens , tokens /= '' ) write ( * , brackets ) ch ( tokens ) ! endblock ! ! Execution of BOUNDS form (return position of tokens) ! block type ( ut ) :: string character ( len =* ), parameter :: set = \" ,\" integer , allocatable :: first (:), last (:) write ( * , gen ) repeat ( '1234567890' , 6 ) string = 'first,second,,fourth' write ( * , gen ) ch ( string ) call tokenize ( string , set , first , last ) write ( * , a_commas ) 'FIRST=' , first write ( * , a_commas ) 'LAST=' , last write ( * , a_commas ) 'HAS LENGTH=' , last - first . gt . 0 endblock ! end program demo_tokenize","tags":"","url":"program/demo_tokenize~2.html"},{"title":"demo_split ‚Äì M_unicode","text":"Uses iso_fortran_env M_unicode Variables Type Attributes Name Initial type( unicode_type ), allocatable :: array (:) type( unicode_type ) :: delims integer :: first character(len=*), parameter :: g = '(*(g0,1x))' integer :: i integer :: last integer :: pos type( unicode_type ) :: proverb Subroutines impure elemental subroutine printwords (line) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: line Source Code program demo_split use iso_fortran_env , only : stdout => output_unit use M_unicode , only : unicode_type , assignment ( = ) use M_unicode , only : split , len , character use M_unicode , only : ut => unicode_type implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' type ( ut ) :: proverb type ( ut ) :: delims type ( ut ), allocatable :: array (:) integer :: first integer :: last integer :: pos integer :: i ! delims = '=|; ' ! proverb = \"M√°s vale p√°jaro en mano, que ciento volando.\" call printwords ( proverb ) ! there really are not spaces between these glyphs array = [ & ut ( \"‰∏ÉËª¢„Å≥ÂÖ´Ëµ∑„Åç„ÄÇ\" ), & ut ( \"Ëª¢„Çì„Åß„ÇÇ„Åæ„ÅüÁ´ã„Å°‰∏ä„Åå„Çã„ÄÇ\" ), & ut ( \"„Åè„Åò„Åë„Åö„Å´Ââç„ÇíÂêë„ÅÑ„Å¶Ê≠©„ÅÑ„Å¶„ÅÑ„Åì„ÅÜ„ÄÇ\" )] call printwords ( array ) ! write ( stdout , g ) 'OOP' array = proverb % split ( ut ( ' ' )) write ( stdout , '(*(:\"[\",a,\"]\"))' )( character ( array ( i )), i = 1 , size ( array )) contains impure elemental subroutine printwords ( line ) type ( ut ), intent ( in ) :: line pos = 0 write ( stdout , g ) line % character (), len ( line ) do while ( pos < len ( line )) first = pos + 1 call split ( line , delims , pos ) last = pos - 1 print g , line % character ( first , last ), first , last , pos end do end subroutine printwords end program demo_split","tags":"","url":"program/demo_split.html"},{"title":"note ‚Äì M_unicode","text":"Uses iso_fortran_env M_unicode Variables Type Attributes Name Initial integer, parameter :: manicules (*) = [int(z'261A'), int(z'261B')] type( unicode_type ) :: uline Source Code program note use , intrinsic :: iso_fortran_env , only : stdout => output_unit use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use M_unicode implicit none integer , parameter :: manicules ( * ) = [ int ( z '261A' ), int ( z '261B' ) ] type ( unicode_type ) :: uline ! ! manicule ! ! Miscellaneous Symbols block: ! !     U+261A ‚òö BLACK LEFT POINTING INDEX !     U+261B ‚òõ BLACK RIGHT POINTING INDEX !     U+261C ‚òú WHITE LEFT POINTING INDEX !     U+261D ‚òù WHITE UP POINTING INDEX !     U+261E ‚òû WHITE RIGHT POINTING INDEX !     U+261F ‚òü WHITE DOWN POINTING INDEX ! ! Unicode 6.0 (2010) included four more pointing hands in Miscellaneous Symbols and Pictographs: ! !     U+1F446 üëÜ WHITE UP POINTING BACKHAND INDEX !     U+1F447 üëá WHITE DOWN POINTING BACKHAND INDEX !     U+1F448 üëà WHITE LEFT POINTING BACKHAND INDEX !     U+1F449 üëâ WHITE RIGHT POINTING BACKHAND INDEX ! ! Unicode 7.0 (2014) added several more indices to the Miscellaneous Symbols and Pictographs block, sourced from the Wingdings 2 font: ! !     U+1F597 üñó WHITE DOWN POINTING LEFT HAND INDEX !     U+1F598 üñò SIDEWAYS WHITE LEFT POINTING INDEX !     U+1F599 üñô SIDEWAYS WHITE RIGHT POINTING INDEX !     U+1F59A üñö SIDEWAYS BLACK LEFT POINTING INDEX !     U+1F59B üñõ SIDEWAYS BLACK RIGHT POINTING INDEX !     U+1F59C üñú BLACK LEFT POINTING BACKHAND INDEX !     U+1F59D üñù BLACK RIGHT POINTING BACKHAND INDEX !     U+1F59E üñû SIDEWAYS WHITE UP POINTING INDEX !     U+1F59F üñü SIDEWAYS WHITE DOWN POINTING INDEX !     U+1F5A0 üñ† SIDEWAYS BLACK UP POINTING INDEX !     U+1F5A1 üñ° SIDEWAYS BLACK DOWN POINTING INDEX !     U+1F5A2 üñ¢ BLACK UP POINTING BACKHAND INDEX !     U+1F5A3 üñ£ BLACK DOWN POINTING BACKHAND INDEX ! ! Unicode 13.0 (2020) added a three-part index (üØÅüØÇüØÉ) in the Symbols for Legacy Computing block: ! !     U+1FBC1 üØÅ LEFT THIRD WHITE RIGHT POINTING INDEX !     U+1FBC2 üØÇ MIDDLE THIRD WHITE RIGHT POINTING INDEX !     U+1FBC3 üØÉ RIGHT THIRD WHITE RIGHT POINTING INDEX ! ! Emoji ! ! Five Unicode manicule characters are emoji, including one of those in ! Unicode 1.0 and all four introduced in Unicode 6.0.[15][16] All five ! have standardized variants for text and emoji presentation.[17] ! ! Emoji variation sequences U+ \t261D \t1F446 \t1F447 \t1F448 \t1F449 ! default presentation \ttext \temoji \temoji \temoji \temoji ! base code point \t‚òù \tüëÜ \tüëá \tüëà \tüëâ ! base+VS15 (text) \t‚òùÔ∏é \tüëÜÔ∏é \tüëáÔ∏é \tüëàÔ∏é \tüëâÔ∏é ! base+VS16 (emoji) \t‚òùÔ∏è \tüëÜÔ∏è \tüëáÔ∏è \tüëàÔ∏è \tüëâÔ∏è ! See also ! !     Arrow (symbol) !     V sign !     Obelus (historic text pointer) !     Hand (hieroglyph) ‚Äì Egyptian hieroglyph ! ! Notes ! ! Although the canonical name is Black left pointing index, Unicode uses ! the word 'black' to mean 'solid' and 'white' to mean 'outlined'. The ! actual colour is a user choice, for example ‚òö and ‚òû. uline = manicules write ( stdout , '(*(g0))' ) uline % character () write ( stdout , '(\"CHARACTER STRING  :\",*(g0))' ) uline % character () write ( stdout , '(\"SINGLE CHARACTERS :\",*(g0))' ) uline % byte () write ( stdout , '(\"HEX BYTES         :\",*(z0,1x))' ) ichar ( uline % byte ()) write ( stdout , '(\"UNICODE CODEPOINTS:\",*(g0,1x))' ) uline % codepoint () write ( stdout , '(\"HEX CODEPOINTS    :\",*(z0,1x))' ) uline % codepoint () end program note","tags":"","url":"program/note.html"},{"title":"demo_repeat ‚Äì M_unicode","text":"Uses M_unicode Source Code program demo_repeat use M_unicode , only : ut => unicode_type , repeat , escape , write ( formatted ) implicit none write ( * , '(DT)' ) repeat ( escape ( \"\\u2025*\" ), 35 ) write ( * , '(DT)' ) repeat ( ut ( \"_\" ), 70 ) ! line break write ( * , '(DT)' ) repeat ( ut ( \"1234567890\" ), 7 ) ! number line write ( * , '(DT)' ) repeat ( ut ( \"         |\" ), 7 ) ! end program demo_repeat","tags":"","url":"program/demo_repeat.html"},{"title":"demo_lower ‚Äì M_unicode","text":"Uses iso_fortran_env M_unicode Variables Type Attributes Name Initial type( unicode_type ) :: diacritics type( unicode_type ) :: expected character(len=*), parameter :: g = '(*(g0))' type( unicode_type ) :: pangram Subroutines subroutine test (in, expected) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: in type( unicode_type ), intent(in) :: expected Source Code program demo_lower use iso_fortran_env , only : stdout => output_unit use M_unicode , only : lower , unicode_type , assignment ( = ), trim use M_unicode , only : ut => unicode_type , operator ( == ) implicit none character ( len =* ), parameter :: g = '(*(g0))' type ( unicode_type ) :: pangram type ( unicode_type ) :: diacritics type ( unicode_type ) :: expected ! ! a sentence containing every letter of the English alphabet pangram = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\" expected = \"the quick brown fox jumps over the lazy dog\" call test ( pangram , expected ) ! ! Slovak pangram PANGRAM = 'VYP√ÑT√Å DC√âRA GR√ìFA MAXWELLA S IQ NI≈Ω≈†√çM AKO & &K√î≈á N√öTI ƒåEƒΩAƒé HR√ùZ≈§ H≈îBU JABƒπK.' expected = 'vyp√§t√° dc√©ra gr√≥fa maxwella s iq ni≈æ≈°√≠m ako & &k√¥≈à n√∫ti ƒçeƒæaƒè hr√Ωz≈• h≈ïbu jabƒ∫k.' call test ( pangram , expected ) ! ! contains each special Czech letter with diacritics exactly once DIACRITICS = 'P≈ò√çLI≈† ≈ΩLU≈§OUƒåK√ù K≈Æ≈á √öPƒöL ƒé√ÅBELSK√â √ìDY.' expected = 'p≈ô√≠li≈° ≈ælu≈•ouƒçk√Ω k≈Ø≈à √∫pƒõl ƒè√°belsk√© √≥dy.' print g , '(\"A horse that was too yellow-ish moaned devilish odes\")' call test ( diacritics , expected ) contains subroutine test ( in , expected ) type ( unicode_type ), intent ( in ) :: in type ( unicode_type ), intent ( in ) :: expected type ( unicode_type ) :: lowercase character ( len =* ), parameter :: nl = new_line ( 'A' ) write ( stdout , g ) in % character () lowercase = lower ( in ) write ( stdout , g ) lowercase % character () write ( stdout , g ) merge ( 'PASSED' , 'FAILED' , lowercase == expected ), nl end subroutine test end program demo_lower","tags":"","url":"program/demo_lower.html"},{"title":"demo_join ‚Äì M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=20), allocatable :: proverb (:) type( unicode_type ), allocatable :: s (:) type( unicode_type ), allocatable :: sep character(len=*), parameter :: w = '((g0,/,g0))' Source Code program demo_join use M_unicode , only : join , ut => unicode_type , ch => character , assignment ( = ) !use M_unicode, only : write(formatted) implicit none character ( len =* ), parameter :: w = '((g0,/,g0))' !character(len=*),parameter   :: v='((g0,/,DT))' character ( len = 20 ), allocatable :: proverb (:) type ( ut ), allocatable :: s (:) type ( ut ), allocatable :: sep ! proverb = [ character ( len = 13 ) :: & & ' United' ,& & '  we' ,& & '   stand,' ,& & '    divided' ,& & '     we fall.' ] ! if ( allocated ( s )) deallocate ( s ) allocate ( s ( size ( proverb ))) ! avoid GNU Fortran (GCC) 16.0.0 bug s = proverb write ( * , w ) 'SIMPLE JOIN:         ' , ch ( join ( s ) ) write ( * , w ) 'JOIN WITH SEPARATOR: ' , ch ( join ( s , sep = ut ( ' ' )) ) write ( * , w ) 'CUSTOM SEPARATOR:    ' , ch ( join ( s , sep = ut ( '<-->' )) ) write ( * , w ) 'NO TRIMMING:         ' , ch ( join ( s , clip = . false .) ) ! sep = ut () write ( * , w ) 'SIMPLE JOIN:         ' , ch ( sep % join ( s ) ) sep = ' ' write ( * , w ) 'JOIN WITH SEPARATOR: ' , ch ( sep % join ( s ) ) sep = '<-->' write ( * , w ) 'CUSTOM SEPARATOR:    ' , ch ( sep % join ( s ) ) sep = '' write ( * , w ) 'NO TRIMMING:         ' , ch ( sep % join ( s , clip = . false .) ) end program demo_join","tags":"","url":"program/demo_join.html"},{"title":"multi_line ‚Äì M_unicode","text":"Uses iso_fortran_env M_unicode Variables Type Attributes Name Initial integer :: i integer :: longest type( unicode_type ), allocatable :: upagain (:) Source Code program multi_line use iso_fortran_env , only : stdout => output_unit use M_unicode use M_unicode , only : ut => unicode_type implicit none integer :: i , longest type ( ut ), allocatable :: upagain (:) upagain = [ & ! ROMANIZATION                         ! ENGLISH ut ( \"‰∏ÉËª¢„Å≥ÂÖ´Ëµ∑„Åç„ÄÇ\" ), & ! Nanakorobi yaoki.                    ! Fall seven times, stand up eight. ut ( \"Ëª¢„Çì„Åß„ÇÇ„Åæ„ÅüÁ´ã„Å°‰∏ä„Åå„Çã„ÄÇ\" ), & ! Koronde mo mata tachiagaru.          ! Even if you fall down, you will get up again. ut ( \"„Åè„Åò„Åë„Åö„Å´Ââç„ÇíÂêë„ÅÑ„Å¶Ê≠©„ÅÑ„Å¶„ÅÑ„Åì„ÅÜ„ÄÇ\" )] ! Kujikezu ni mae o muite aruite ikou. ! Don't be discouraged, just keep walking forward. ! longest = 0 ! get longest trimmed line do i = 1 , size ( upagain ) longest = max ( longest , len_trim ( upagain ( i ))) write ( stdout , * ) 'LEN=' , len_trim ( upagain ( i )) enddo write ( stdout , * ) 'longest=' , longest write ( stdout , * ) do i = 1 , size ( upagain ) write ( stdout , '(g0)' ) character ( upagain ( i )), len_trim ( upagain ( i )) enddo end program multi_line","tags":"","url":"program/multi_line.html"},{"title":"demo_sort ‚Äì M_unicode","text":"Uses iso_fortran_env M_unicode Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0,1x))' integer :: i integer :: ii (isz) integer, parameter :: isz = 4 type( unicode_type ) :: rr (isz) Source Code program demo_sort use iso_fortran_env , only : stdout => output_unit use M_unicode , only : sort , unicode_type , assignment ( = ) use M_unicode , only : ut => unicode_type , write ( formatted ) use M_unicode , only : ch => character implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , parameter :: isz = 4 type ( unicode_type ) :: rr ( isz ) integer :: ii ( isz ) integer :: i ! write ( stdout , g ) 'sort array with sort(3f)' rr = [ & ut ( \"the\" ), & ut ( \"quick\" ), & ut ( \"brown\" ), & ut ( \"fox\" ) ] ! write ( stdout , g ) 'original order' write ( stdout , g ) ch ( rr ) ! call sort ( rr , ii ) ! write ( stdout , g ) 'sorted order' ! convert to character do i = 1 , size ( rr ) write ( stdout , '(i3.3,1x,a)' ) i , rr ( ii ( i ))% character () enddo ! write ( stdout , g ) 'reorder original' rr = rr ( ii ) write ( stdout , g ) ch ( rr ) end program demo_sort","tags":"","url":"program/demo_sort.html"},{"title":"demo_escape ‚Äì M_unicode","text":"Uses iso_fortran_env M_unicode Variables Type Attributes Name Initial integer :: i type( unicode_type ), allocatable :: poem (:) type( unicode_type ) :: test (5) Source Code program demo_escape ! demonstrate filter to expand C-like escape sequences in input lines use iso_fortran_env , only : stdout => output_unit use M_unicode , only : ut => unicode_type , ch => character , len , escape use M_unicode , only : assignment ( = ), trim implicit none type ( ut ), allocatable :: poem (:) type ( ut ) :: test ( 5 ) integer :: i ! ! ‚ÄúThe Crow and the Fox‚Äù by Jean de la Fontaine write ( stdout , '(a,/)' ) & 'Le Corbeau et le Renard -- Jean de la Fontaine' ! poem = [& ut ( 'Le Corbeau et le Renard' ),& ut ( '' ),& ut ( 'Ma\\u00EEtre Corbeau, sur un arbre perch\\u00E9,' ),& ut ( 'Tenait en son bec un fromage.' ),& ut ( 'Ma\\u00EEtre Renard, par l\\u2019odeur all\\u00E9ch\\u00E9,' ),& ut ( 'Lui tint \\U000000E0 peu pr\\U000000E8s ce langage :' ),& ut ( '\\U000000ABH\\U000000E9 ! bonjour, Monsieur du Corbeau.' ),& ut ( 'Que vous \\U000000EAtes joli ! que vous me semblez beau !' ),& ut ( 'Sans mentir, si votre ramage' ),& ut ( 'Se rapporte \\U000000E0 votre plumage,' ),& ut ( 'Vous \\xEAtes le Ph\\xE9nix des h\\xF4tes de ces bois.\\xBB' ),& ut ( 'A ces mots le Corbeau ne se sent pas de joie ;' ),& ut ( 'Et pour montrer sa belle voix,' ),& ut ( 'Il ouvre un large bec, laisse tomber sa proie.' ),& ut ( 'Le Renard s\\u2019en saisit, et dit : \\xABMon bon Monsieur,' ),& ut ( 'Apprenez que tout flatteur' ),& ut ( 'Vit aux d\\xE9pens de celui qui l\\U00002019\\u00E9coute :' ),& ut ( 'Cette le\\xE7on vaut bien un fromage, sans doute.\\xBB' ),& ut ( 'Le Corbeau, honteux et confus,' ),& ut ( & 'Jura, mais un peu tard, qu\\u2019on ne l\\u2019y prendrait plus.' ),& ut ( ' -- Jean de la Fontaine' )] ! poem = escape ( poem ) write ( stdout , '(g0)' ) ch ( poem ) ! test = [ & '\\e[H\\e[2J           ' ,& ! home cursor and clear screen ! on ANSI terminals '\\tABC\\tabc          ' ,& ! write some tabs in the output '\\tA\\a               ' ,& ! ring bell at end if supported '\\nONE\\nTWO\\nTHREE   ' ,& ! place one word per line '\\\\                  ' ] test = trim ( escape ( test )) write ( * , '(a)' )( test ( i )% character (), i = 1 , size ( test )) ! end program demo_escape","tags":"","url":"program/demo_escape.html"},{"title":"fortran_ints ‚Äì M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=*), parameter :: asciiints (*) = [character(len=10)::\"+1 \", \"3044848 \", \"30.40 \", \"September \", \"1 2 3\", \"¬†¬†-3000 \", \" \"] integer :: i type( unicode_type ), allocatable :: ints (:) Functions impure elemental function isint (line) result(lout) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: line Return Value logical Source Code program fortran_ints use M_unicode , only : ut => unicode_type , assignment ( = ) use M_unicode , only : adjustr , verify , trim , len use M_unicode , only : write ( formatted ) use M_unicode , only : operator (. cat .) use M_unicode , only : operator ( == ) implicit none integer :: i character ( len =* ), parameter :: asciiints ( * ) = [ character ( len = 10 ) :: & \"+1 \" , & \"3044848 \" , & \"30.40 \" , & \"September \" , & \"1 2 3\" , & \"  -3000 \" , & \" \" ] type ( ut ), allocatable :: ints (:) allocate ( ints ( size ( asciiints ))) ! gfortran bug ints = asciiints ints = trim ( ints ) ! show if strings pass or fail the test done by isint(3) write ( * , \"('is integer?')\" ) do i = 1 , size ( ints ) write ( * , '(\"|\",DT,T14,\"|\",l1,\"|\")' ) ints ( i ), isint ( ints ( i )) enddo ! elemental write ( * , \"(*(g0,1x))\" ) isint ( ints ) contains impure elemental function isint ( line ) result ( lout ) use M_unicode , only : adjustl , verify , trim ! ! determine if string is a valid integer representation ! ignoring trailing spaces and leading spaces ! character ( len =* ), parameter :: digits = \"0123456789\" type ( ut ), intent ( in ) :: line type ( ut ) :: name logical :: lout lout = . false . ! make sure at least two characters long to simplify tests name = adjustl ( line ). cat . '  ' ! blank string if ( name == '' ) return ! allow one leading sign if ( verify ( name % sub ( 1 , 1 ), ut ( '+‚Äê-' )) == 0 ) name = name % sub ( 2 , len ( name )) ! was just a sign if ( name == '' ) return lout = verify ( trim ( name ), digits ) == 0 end function isint end program fortran_ints","tags":"","url":"program/fortran_ints.html"},{"title":"fortran_symbol_name ‚Äì M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial integer :: i type( unicode_type ), allocatable :: symbols (:) Functions impure elemental function fortran_name (line) result(lout) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: line Return Value logical Source Code program fortran_symbol_name use M_unicode , only : ut => unicode_type , trim , verify , len use M_unicode , only : ch => character use M_unicode , only : write ( formatted ) implicit none integer :: i type ( ut ), allocatable :: symbols (:) symbols = [ & ut ( 'A_' ), ut ( '10' ), ut ( 'a10' ), ut ( 'September' ), ut ( 'A B' ), & ut ( '_A' ), ut ( ' ' )] do i = 1 , size ( symbols ) write ( * , '(1x,DT,T11,\"|\",l2)' ) symbols ( i ), fortran_name ( symbols ( i )) enddo contains impure elemental function fortran_name ( line ) result ( lout ) ! ! determine if a string is a valid Fortran name ! ignoring trailing spaces (but not leading spaces) ! character ( len =* ), parameter :: int = \"0123456789\" character ( len =* ), parameter :: lower = \"abcdefghijklmnopqrstuvwxyz\" character ( len =* ), parameter :: upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" character ( len =* ), parameter :: allowed = upper // lower // int // \"_\" type ( ut ), intent ( in ) :: line type ( ut ) :: name logical :: lout name = trim ( line ) if ( len ( name ). ne . 0 ) then ! first character is alphameric lout = verify ( name % sub ( 1 , 1 ), lower // upper ) == 0 & ! other characters are allowed in a symbol name & . and . verify ( name , allowed ) == 0 & ! allowable length & . and . len ( name ) <= 63 else lout = . false . endif end function fortran_name end program fortran_symbol_name","tags":"","url":"program/fortran_symbol_name.html"},{"title":"demo_transliterate ‚Äì M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial type( unicode_type ) :: LOWER type( unicode_type ) :: MIDDLE_DOT type( unicode_type ) :: STRING type( unicode_type ) :: UPPER character(len=*), parameter :: u = '(DT)' Subroutines subroutine callit () Arguments None Source Code program demo_transliterate use M_unicode , only : transliterate , ut => unicode_type use M_unicode , only : write ( formatted ), ch => character use M_unicode , only : assignment ( = ) implicit none character ( len =* ), parameter :: u = '(DT)' type ( ut ) :: STRING , UPPER , LOWER type ( ut ) :: MIDDLE_DOT STRING = 'aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ' LOWER = 'abcdefghijklmnopqrstuvwxyz' UPPER = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' call callit () print u print u , ut ( 'Greek' ) ! ! | Œë Œ± | Œí Œ≤ | Œì Œ≥ | Œî Œ¥ | Œï Œµ | Œñ Œ∂       | ! | Œó Œ∑ | Œò Œ∏ | Œô Œπ | Œö Œ∫ | Œõ Œª | Œú Œº       | ! | Œù ŒΩ | Œû Œæ | Œü Œø | Œ† œÄ | Œ° œÅ | Œ£ œÉ œÇ | ! | Œ§ œÑ | Œ• œÖ | Œ¶ œÜ | Œß œá | Œ® œà | Œ© œâ       | ! STRING = 'ŒëŒ±ŒíŒ≤ŒìŒ≥ŒîŒ¥ŒïŒµŒñŒ∂ŒóŒ∑ŒòŒ∏ŒôŒπŒöŒ∫ŒõŒªŒúŒºŒùŒΩŒûŒæŒüŒøŒ†œÄŒ°œÅŒ£œÉœÇŒ§œÑŒ•œÖŒ¶œÜŒßœáŒ®œàŒ©œâ' ! ignoring œÇ for simplicity UPPER = 'ŒëŒíŒìŒîŒïŒñŒóŒòŒôŒöŒõŒúŒùŒûŒüŒ†Œ°Œ£Œ§Œ•Œ¶ŒßŒ®Œ©' LOWER = 'Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÉœÑœÖœÜœáœàœâ' call callit () ! OOP print u print u , ut ( 'OOP!' ) print u , STRING % TRANSLITERATE ( UPPER , '_' ) ! U+00B7 Middle Dot Unicode Character print u , STRING % TRANSLITERATE ( LOWER , '¬∑' ) ! ASCII bytes print u , STRING % TRANSLITERATE ( LOWER , ut ( '¬∑' )) ! cast MIDDLE_DOT = int ( z '00B7' ) print u , STRING % TRANSLITERATE ( LOWER , MIDDLE_DOT ) ! hexadecimal contains subroutine callit () print u , STRING ! convert -7 string to uppercase: print u , TRANSLITERATE ( STRING , LOWER , UPPER ) ! change all miniscule letters to a colon (\":\"): print u , TRANSLITERATE ( STRING , LOWER , ':' ) ! delete all miniscule letters print u , TRANSLITERATE ( STRING , LOWER , '' ) end subroutine callit end program demo_transliterate","tags":"","url":"program/demo_transliterate.html"},{"title":"test_M_unicode ‚Äì M_unicode","text":"Uses testsuite_M_unicode Source Code program test_M_unicode use testsuite_M_unicode total = 0 !write(*,g0)'encoding can be altered on an open file' !open (output_unit, encoding='UTF-8') call programming_environment () call test_adjustl () call test_adjustr () call test_trim () call test_len_trim () call test_len () call test_index () call test_repeat () call test_transliterate () call test_upper () call test_lower () call test_tokenize () call test_sort () call test_operators () call test_split () call test_scan () call test_verify () call test_ichar () call test_replace () call test_sub () call test_pad () call test_join () call test_expandtabs () call test_fmt () call test_escape () call test_concatenate () call test_other () write ( * , g0 ) if ( total . ne . 0 ) then write ( * , g0 ) total , ' failures' stop 1 else write ( * , g0 ) 'all passed' endif end program test_M_unicode","tags":"","url":"program/test_m_unicode.html"},{"title":"demo_sub ‚Äì M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial type( unicode_type ) :: piece type( unicode_type ) :: string Subroutines subroutine printme (label) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label Source Code program demo_sub use M_unicode , only : sub , assignment ( = ) use M_unicode , only : len use M_unicode , only : ut => unicode_type implicit none type ( ut ) :: string type ( ut ) :: piece ! string = 'abcdefghij' ! piece = sub ( string , 3 , 5 ) call printme ( 'selected range:' ) piece = sub ( string , 6 ) call printme ( 'from character to end:' ) piece = sub ( string , 5 , 5 ) call printme ( 'single character:' ) piece = sub ( string , step =- 1 ) call printme ( 'reverse string:' ) contains subroutine printme ( label ) character ( len =* ), intent ( in ) :: label write ( * , '(a,\"[\",g0,\"]\",/)' ) label , piece % character () end subroutine printme end program demo_sub","tags":"","url":"program/demo_sub.html"},{"title":"demo_use.f90 ‚Äì M_unicode","text":"Source Code program testit use , intrinsic :: iso_fortran_env , only : stdout => output_unit ! user-defined type to hold Unicode text use M_unicode , only : unicode_type ! convert unicode_type to CHARACTER variables use M_unicode , only : character ! intrinsic overloads use M_unicode , only : adjustl , adjustr use M_unicode , only : trim , len , len_trim use M_unicode , only : index , scan , verify use M_unicode , only : repeat use M_unicode , only : split , tokenize use M_unicode , only : upper , lower use M_unicode , only : sort ! operators (and overloads) and assignment use M_unicode , only : assignment ( = ) use M_unicode , only : operator ( <= ), lle use M_unicode , only : operator ( < ), llt use M_unicode , only : operator ( /= ), lne use M_unicode , only : operator ( == ), leq use M_unicode , only : operator ( > ), lgt use M_unicode , only : operator ( >= ), lge use M_unicode , only : operator ( // ) ! low-level text conversion to integer codepoint arrays: use M_unicode , only : utf8_to_codepoints , codepoints_to_utf8 ! example usage: implicit none type ( unicode_type ) :: ustr character ( len =* ), parameter :: g = '(*(g0))' character ( len =* ), parameter :: gx = '(*(g0,1x))' character ( len =* ), parameter :: gh = '(*(z0,1x))' ! Constructors ! UNICODE_VARIABLE= UNICODE_VARIABLE|CHARACTER(LEN=*)|INTEGER_ARRAY ! ! VARIABLE%CHARACTER(start,end,step) returns a CHARACTER string ! VARIABLE%BYTE() returns an array of CHARACTER(len=1) values ustr = 'Hello World and Ni Hao -- ‰Ω†Â•Ω  ' write ( stdout , g ) character ( ustr ) ! convert to intrinsic CHARACTER variable write ( stdout , g ) len ( ustr ) write ( stdout , g ) len_trim ( ustr ) write ( stdout , g ) index ( ustr , '‰Ω†' ) ! OOPS write ( stdout , g ) ustr % character () ! convert to CHARACTER variable write ( stdout , g ) ustr % character ( 27 , 28 ) ! similar to LINE(27:28) for CHARACTER write ( stdout , g ) ustr % character ( len ( ustr ), 1 , - 1 ) ! reverse string write ( stdout , g ) ustr % byte () ! convert to CHARACTER(LEN=1) type ! print write ( stdout , gx ) ustr % codepoint () ! convert to Unicode codepoints write ( stdout , gh ) ustr % codepoint () ! convert to Unicode codepoints end program testit","tags":"","url":"sourcefile/demo_use.f90.html"},{"title":"demo_scan.f90 ‚Äì M_unicode","text":"Source Code program demo_scan use iso_fortran_env , only : stdout => output_unit use M_unicode , only : scan , unicode_type , assignment ( = ) use M_unicode , only : ut => unicode_type implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' type ( ut ) :: line type ( ut ) :: set ! write ( * , * ) scan ( \"fortran\" , \"ao\" ) ! 2, found ‚Äôo‚Äô write ( * , * ) scan ( \"fortran\" , \"ao\" , . true .) ! 6, found ‚Äôa‚Äô write ( * , * ) scan ( \"fortran\" , \"c++\" ) ! 0, found none ! line = 'parsleyüòÉsageüòÉrosemaryüòÉüòÉthyme' set = 'üòÉ' write ( stdout , g ) '12345678901234567890123456789012345678901234567890' write ( stdout , g ) line % character () write ( stdout , g ) scan ( line , set ) write ( stdout , g ) scan ( line , set , back = . true .) write ( stdout , g ) scan ( line , set , back = . false .) write ( stdout , g ) scan ( line , unicode_type ( \"NOT\" )) write ( stdout , g ) 'OOP' write ( stdout , g ) line % scan ( set ) write ( stdout , g ) line % scan ( ut ( \"o\" )) end program demo_scan","tags":"","url":"sourcefile/demo_scan.f90.html"},{"title":"demo_adjustr.f90 ‚Äì M_unicode","text":"Source Code program demo_adjustr use M_unicode , only : ut => unicode_type use M_unicode , only : adjustr , len use M_unicode , only : write ( formatted ) use M_unicode , only : assignment ( = ) implicit none type ( ut ) :: str type ( ut ), allocatable :: array (:) integer :: i character ( len =* ), parameter :: bracket = '(\"[\",DT,\"]\")' ! call numberline ( 2 ) ! ! basic usage str = '  sample string     ' write ( * , bracket ) str str = adjustr ( str ) write ( * , bracket ) str ! call numberline ( 5 ) ! ! elemental array = ut ([ character ( len = 50 ) :: & '    ‡§è‡§ï (ek) ' , & '       ‡§¶‡•ã (do) ' , & '          ‡§§‡•Ä‡§®(teen) ' ]) ! ! print array unadjusted write ( * , bracket ) array !do i=1,size(array) !   write(*,'(*(g0,1x))')array(i)%codepoint() !enddo ! note 50 bytes is not necessarily 50 glyphs write ( * , '(*(g0,1x))' ) 'length in glyphs=' , len ( array ) write ( * , '(*(g0,1x))' ) 'length in bytes=' ,( len ( array ( i )% character ()), i = 1 , size ( array )) ! call numberline ( 5 ) ! ! print array right-justified write ( * , bracket ) adjustr ( array ) ! call numberline ( 5 ) ! ! print array right-justified specifying number of glyphs write ( * , * ) 'set to 50' write ( * , bracket ) adjustr ( array , 50 ) ! write ( * , * ) 'set to 60' call numberline ( 6 ) write ( * , bracket ) adjustr ( array , 60 ) write ( * , * ) 'set to 40' call numberline ( 4 ) write ( * , bracket ) adjustr ( array , 40 ) write ( * , * ) 'set to 10' call numberline ( 1 ) write ( * , bracket ) adjustr ( array , 10 ) write ( * , * ) 'set to 5' write ( * , bracket ) adjustr ( array , 5 ) write ( * , * ) 'set to 4' write ( * , bracket ) adjustr ( array , 4 ) write ( * , * ) 'set to 1' write ( * , bracket ) adjustr ( array , 1 ) contains ! subroutine numberline ( ireps ) integer , intent ( in ) :: ireps write ( * , '(1x,a)' ) repeat ( '1234567890' , ireps ) end subroutine numberline end program demo_adjustr","tags":"","url":"sourcefile/demo_adjustr.f90.html"},{"title":"fox_and_crow.f90 ‚Äì M_unicode","text":"Source Code program crow_and_fox use iso_fortran_env , only : stdout => output_unit use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : byte => int8 use M_unicode , only : unicode_type , ut => unicode_type , character , len implicit none type ( unicode_type ), allocatable :: poem (:) integer :: i ! ‚ÄúThe Crow and the Fox‚Äù by Jean de la Fontaine write ( stdout , '(a,/)' ) 'Le Corbeau et le Renard -- Jean de la Fontaine' poem = [& ut ( 'Le Corbeau et le Renard' ), & ut ( '' ), & ut ( 'Ma√Ætre Corbeau, sur un arbre perch√©,' ), & ut ( 'Tenait en son bec un fromage.' ), & ut ( 'Ma√Ætre Renard, par l‚Äôodeur all√©ch√©,' ), & ut ( 'Lui tint √† peu pr√®s ce langage :' ), & ut ( '¬´H√© ! bonjour, Monsieur du Corbeau.' ), & ut ( 'Que vous √™tes joli ! que vous me semblez beau !' ), & ut ( 'Sans mentir, si votre ramage' ), & ut ( 'Se rapporte √† votre plumage,' ), & ut ( 'Vous √™tes le Ph√©nix des h√¥tes de ces bois.¬ª' ), & ut ( 'A ces mots le Corbeau ne se sent pas de joie ;' ), & ut ( 'Et pour montrer sa belle voix,' ), & ut ( 'Il ouvre un large bec, laisse tomber sa proie.' ), & ut ( 'Le Renard s‚Äôen saisit, et dit : ¬´Mon bon Monsieur,' ), & ut ( 'Apprenez que tout flatteur' ), & ut ( 'Vit aux d√©pens de celui qui l‚Äô√©coute :' ), & ut ( 'Cette le√ßon vaut bien un fromage, sans doute.¬ª' ), & ut ( 'Le Corbeau, honteux et confus,' ), & ut ( 'Jura, mais un peu tard, qu‚Äôon ne l‚Äôy prendrait plus.' ), & ut ( ' -- Jean de la Fontaine' )] write ( stdout , '(a)' ) 'LINES' write ( stdout , '(g0)' )( character ( poem ( i )), i = 1 , size ( poem )) write ( stdout , '(a)' ) 'BYTES' write ( stdout , '(*(a))' )( poem ( i )% byte (), new_line ( 'a' ), i = 1 , size ( poem )) write ( stdout , '(a)' ) 'WITH LENGTH IN GLYPHS AND BYTES' do i = 1 , size ( poem ) write ( stdout , '(1x,i4.4,1x,i4.4,1x,*(g0))' ) len ( poem ( i )), len ( poem ( i )% character ()), character ( poem ( i )) enddo end program crow_and_fox","tags":"","url":"sourcefile/fox_and_crow.f90.html"},{"title":"fid.f90 ‚Äì M_unicode","text":"Source Code program test_id implicit none call platform () contains subroutine platform () use , intrinsic :: iso_fortran_env , only : compiler_version use , intrinsic :: iso_fortran_env , only : compiler_options implicit none character ( len = :), allocatable :: version , options character ( len =* ), parameter :: nl = new_line ( 'a' ) integer :: where , start , break , i , last , col version = compiler_version () // ' ' options = ' ' // compiler_options () start = 1 do where = index ( options ( start :), ' -' ) if ( where . eq . 0 ) exit break = where + start - 1 options ( break : break ) = nl start = where enddo if ( start . eq . 1 ) then do where = index ( options ( start :), ' /' ) if ( where . eq . 0 ) exit break = where + start - 1 options ( break : break ) = nl start = where enddo endif last = len_trim ( version ) + 1 col = 0 do i = 1 , len_trim ( version ) col = col + 1 if ( version ( i : i ). eq . ' ' ) last = i if ( col . gt . 76 ) then version ( last : last ) = nl col = 0 endif enddo print '(a,/,3x,*(a))' , 'This file was compiled by :' , inset ( version ) if ( options . ne . '' ) then print '(*(a))' , 'using the options :' , inset ( options ) endif end subroutine platform function inset ( string ) result ( longer ) character ( len =* ), intent ( in ) :: string character ( len = :), allocatable :: longer character ( len =* ), parameter :: nl = new_line ( 'a' ) integer :: i longer = '' do i = 1 , len ( string ) longer = longer // string ( i : i ) if ( string ( i : i ). eq . nl ) then longer = longer // '   ' endif enddo end function inset end program test_id","tags":"","url":"sourcefile/fid.f90.html"},{"title":"demo_utf8_to_codepoints.f90 ‚Äì M_unicode","text":"Source Code program demo_utf8_to_codepoints use m_unicode , only : utf8_to_codepoints implicit none character ( len =* ), parameter :: string = 'Noho me ka hau‚Äôoli' !(Be happy) character ( len = 1 ), allocatable :: bytes (:) character ( len =* ), parameter :: solid = '(*(g0))' character ( len =* ), parameter :: space = '(*(g0,1x))' character ( len =* ), parameter :: z = '(a,*(z0,1x))' integer , allocatable :: codepoints (:) integer :: nerr integer :: i ! BASIC USAGE: SCALAR CHARACTER VARIABLE write ( * , solid ) 'STRING:' , string call utf8_to_codepoints ( string , codepoints , nerr ) write ( * , space ) 'CODEPOINTS:' , codepoints write ( * , z ) 'HEXADECIMAL CODEPOINTS:' , codepoints ! write ( * , space ) 'How long is this string in glyphs? ' write ( * , space ) size ( codepoints ) write ( * , space ) 'How long is this string in bytes? ' write ( * , space ) len ( string ) ! ! BASIC USAGE: ARRAY OF BYTES bytes = [( string ( i : i ), i = 1 , len ( string ))] write ( * , solid ) 'STRING:' , bytes call utf8_to_codepoints ( bytes , codepoints , nerr ) write ( * , space ) 'CODEPOINTS:' , codepoints write ( * , z ) 'HEXADECIMAL CODEPOINTS:' , codepoints ! write ( * , space ) 'How long is this string in glyphs? ' write ( * , space ) size ( codepoints ) write ( * , space ) 'How long is this string in bytes? ' write ( * , space ) size ( bytes ) ! end program demo_utf8_to_codepoints","tags":"","url":"sourcefile/demo_utf8_to_codepoints.f90.html"},{"title":"uplow.f90 ‚Äì M_unicode","text":"Source Code program testit use iso_fortran_env , only : stdout => output_unit use M_unicode implicit none type ( unicode_type ) :: upp , low ! ! remember unicode characters are multi-byte so be careful ! with older compilers to not exceed 132 bytes per line ! low = '& &abcdefghijklmnopqrstuvwxyz√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨& &√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∏√π√∫√ª√º√Ω√æ√øƒÅƒÉƒÖƒáƒâƒãƒçƒèƒëƒìƒïƒóƒôƒõƒùƒüƒ°ƒ£ƒ•ƒßƒ©ƒ´ƒ≠& &ƒØƒ±ƒ≥ƒµƒ∑ƒ∫ƒºƒæ≈Ä≈Ç≈Ñ≈Ü≈à≈ã≈ç≈è≈ë≈ì≈ï≈ó≈ô≈õ≈ù≈ü≈°≈£≈•≈ß≈©≈´≈≠≈Ø≈±≈≥≈µ≈∑≈∫≈º≈æ& &∆É∆Ö∆à∆å∆í∆ô∆°∆£∆•∆®∆≠∆∞∆¥∆∂∆π∆Ω«Ü«â«å«é«ê«í«î«ñ«ò«ö«ú«ü«°«£«•«ß«©«´«≠«Ø«≥«µ«ª«Ω«ø& &»Å»É»Ö»á»â»ã»ç»è»ë»ì»ï»ó…ì…î…ó…ò…ô…õ…†…£…®…©…Ø…≤…µ É à ä ã íŒ¨Œ≠ŒÆŒØ& &Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÉœÑœÖœÜœáœàœâœäœãœåœçœéœ£œ•œßœ©œ´œ≠œØ–∞–±–≤–≥–¥–µ–∂–∑–∏–π& &–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è—ë—í—ì—î—ï—ñ—ó—ò—ô—ö—õ—ú—û—ü& &—°—£—•—ß—©—´—≠—Ø—±—≥—µ—∑—π—ª—Ω—ø“Å“ë“ì“ï“ó“ô“õ“ù“ü“°“£“•“ß“©“´“≠“Ø“±“≥“µ“∑“π“ª“Ω“ø”Ç”Ñ”à& &”å”ë”ì”ï”ó”ô”õ”ù”ü”°”£”•”ß”©”´”Ø”±”≥”µ”π’°’¢’£’§’•’¶’ß’®’©’™’´’¨’≠’Æ’Ø’∞’±’≤& &’≥’¥’µ’∂’∑’∏’π’∫’ª’º’Ω’æ’ø÷Ä÷Å÷Ç÷É÷Ñ÷Ö÷Ü·Éê·Éë·Éí·Éì·Éî·Éï·Éñ·Éó·Éò·Éô·Éö·Éõ·Éú·Éù·Éû·Éü·É†·É°·É¢·É£·É§·É•& &·É¶·Éß·É®·É©·É™·É´·É¨·É≠·ÉÆ·ÉØ·É∞·É±·É≤·É≥·É¥·Éµ·∏Å·∏É·∏Ö·∏á·∏â·∏ã·∏ç·∏è·∏ë·∏ì·∏ï·∏ó·∏ô·∏õ·∏ù·∏ü·∏°·∏£·∏•·∏ß& &·∏©·∏´·∏≠·∏Ø·∏±·∏≥·∏µ·∏∑·∏π·∏ª·∏Ω·∏ø·πÅ·πÉ·πÖ·πá·πâ·πã·πç·πè·πë·πì·πï·πó·πô& &·πõ·πù·πü·π°·π£·π•·πß·π©·π´·π≠·πØ·π±·π≥·πµ·π∑·ππ·πª·πΩ·πø& &·∫Å·∫É·∫Ö·∫á·∫â·∫ã·∫ç·∫è·∫ë·∫ì·∫ï·∫°·∫£·∫•·∫ß·∫©·∫´·∫≠·∫Ø·∫±·∫≥·∫µ·∫∑·∫π·∫ª·∫Ω·∫ø·ªÅ·ªÉ·ªÖ·ªá·ªâ·ªã·ªç·ªè·ªë·ªì·ªï·ªó& &·ªô·ªõ·ªù·ªü·ª°·ª£·ª•·ªß·ª©·ª´·ª≠·ªØ·ª±·ª≥·ªµ·ª∑·ªπ·ºÄ·ºÅ·ºÇ·ºÉ·ºÑ·ºÖ·ºÜ·ºá·ºê·ºë·ºí·ºì·ºî·ºï·º†·º°·º¢·º£·º§·º•·º¶·ºß·º∞·º±& &·º≤·º≥·º¥·ºµ·º∂·º∑·ΩÄ·ΩÅ·ΩÇ·ΩÉ·ΩÑ·ΩÖ·Ωë·Ωì·Ωï·Ωó·Ω†·Ω°·Ω¢·Ω£·Ω§·Ω•·Ω¶·Ωß·æÄ·æÅ·æÇ·æÉ·æÑ·æÖ·æÜ·æá·æê·æë·æí·æì·æî·æï·æñ·æó& &·æ†·æ°·æ¢·æ£·æ§·æ•·æ¶·æß·æ∞·æ±·øê·øë·ø†·ø°‚ìê‚ìë‚ìí‚ìì‚ìî‚ìï‚ìñ‚ìó‚ìò‚ìô‚ìö‚ìõ‚ìú‚ìù‚ìû‚ìü‚ì†‚ì°‚ì¢‚ì£‚ì§‚ì•‚ì¶‚ìß‚ì®‚ì©& &ÔΩÅÔΩÇÔΩÉÔΩÑÔΩÖÔΩÜÔΩáÔΩàÔΩâÔΩäÔΩãÔΩåÔΩçÔΩéÔΩèÔΩêÔΩëÔΩíÔΩìÔΩîÔΩïÔΩñÔΩóÔΩòÔΩôÔΩö' upp = '& &ABCDEFGHIJKLMNOPQRSTUVWXYZ√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã& &√å√ç√é√è√ê√ë√í√ì√î√ï√ñ√ò√ô√ö√õ√ú√ù√û≈∏ƒÄƒÇƒÑƒÜƒàƒäƒåƒéƒêƒíƒîƒñƒòƒöƒúƒûƒ†ƒ¢ƒ§ƒ¶ƒ®ƒ™ƒ¨& &ƒÆIƒ≤ƒ¥ƒ∂ƒπƒªƒΩƒø≈Å≈É≈Ö≈á≈ä≈å≈é≈ê≈í≈î≈ñ≈ò≈ö≈ú≈û≈†≈¢≈§≈¶≈®≈™≈¨≈Æ≈∞≈≤≈¥≈∂≈π≈ª& &≈Ω∆Ç∆Ñ∆á∆ã∆ë∆ò∆†∆¢∆§∆ß∆¨∆Ø∆≥∆µ∆∏∆º«Ñ«á«ä«ç«è«ë«ì«ï«ó«ô«õ«û«†«¢«§«¶«®«™«¨«Æ«±«¥«∫«º«æ& &»Ä»Ç»Ñ»Ü»à»ä»å»é»ê»í»î»ñ∆Å∆Ü∆ä∆é∆è∆ê∆ì∆î∆ó∆ñ∆ú∆ù∆ü∆©∆Æ∆±∆≤∆∑ŒÜŒàŒâŒäŒëŒíŒìŒîŒïŒñŒóŒò& &ŒôŒöŒõŒúŒùŒûŒüŒ†Œ°Œ£Œ§Œ•Œ¶ŒßŒ®Œ©Œ™Œ´ŒåŒéŒèœ¢œ§œ¶œ®œ™œ¨œÆ–ê–ë–í–ì–î–ï–ñ–ó–ò–ô& &–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–Å–Ç–É–Ñ–Ö–Ü–á–à–â–ä–ã–å–é–è—†—¢—§—¶—®—™—¨& &—Æ—∞—≤—¥—∂—∏—∫—º—æ“Ä“ê“í“î“ñ“ò“ö“ú“û“†“¢“§“¶“®“™“¨“Æ“∞“≤“¥“∂“∏“∫“º“æ”Å”É”á& &”ã”ê”í”î”ñ”ò”ö”ú”û”†”¢”§”¶”®”™”Æ”∞”≤”¥”∏‘±‘≤‘≥‘¥‘µ‘∂‘∑‘∏‘π‘∫‘ª‘º‘Ω‘æ‘ø’Ä’Å’Ç’É’Ñ& &’Ö’Ü’á’à’â’ä’ã’å’ç’é’è’ê’ë’í’ì’î’ï’ñ·Ç†·Ç°·Ç¢·Ç£·Ç§·Ç•·Ç¶·Çß·Ç®·Ç©·Ç™·Ç´·Ç¨·Ç≠·ÇÆ·ÇØ·Ç∞·Ç±·Ç≤·Ç≥·Ç¥·Çµ& &·Ç∂·Ç∑·Ç∏·Çπ·Ç∫·Çª·Çº·ÇΩ·Çæ·Çø·ÉÄ·ÉÅ·ÉÇ·ÉÉ·ÉÑ·ÉÖ·∏Ä·∏Ç·∏Ñ·∏Ü·∏à·∏ä·∏å·∏é·∏ê·∏í·∏î·∏ñ·∏ò·∏ö·∏ú·∏û·∏†·∏¢·∏§·∏¶·∏®·∏™·∏¨·∏Æ& &·∏∞·∏≤·∏¥·∏∂·∏∏·∏∫·∏º·∏æ·πÄ·πÇ·πÑ·πÜ·πà·πä·πå·πé·πê·πí·πî·πñ·πò·πö·πú·πû·π†·π¢·π§·π¶·π®·π™·π¨·πÆ·π∞·π≤·π¥·π∂·π∏·π∫·πº·πæ& &·∫Ä·∫Ç·∫Ñ·∫Ü·∫à·∫ä·∫å·∫é·∫ê·∫í·∫î·∫†·∫¢·∫§·∫¶·∫®·∫™·∫¨·∫Æ·∫∞·∫≤·∫¥·∫∂·∫∏·∫∫·∫º·∫æ·ªÄ·ªÇ·ªÑ·ªÜ·ªà·ªä& &·ªå·ªé·ªê·ªí·ªî·ªñ·ªò·ªö·ªú·ªû·ª†·ª¢·ª§·ª¶·ª®·ª™·ª¨·ªÆ·ª∞·ª≤·ª¥·ª∂·ª∏& &·ºà·ºâ·ºä·ºã·ºå·ºç·ºé·ºè·ºò·ºô·ºö·ºõ·ºú·ºù·º®·º©·º™·º´·º¨·º≠·ºÆ·ºØ·º∏·ºπ& &·º∫·ºª·ºº·ºΩ·ºæ·ºø·Ωà·Ωâ·Ωä·Ωã·Ωå·Ωç·Ωô·Ωõ·Ωù·Ωü·Ω®·Ω©·Ω™·Ω´·Ω¨·Ω≠·ΩÆ·ΩØ& &·æà·æâ·æä·æã·æå·æç·æé·æè·æò·æô·æö·æõ·æú·æù·æû·æü·æ®·æ©·æ™·æ´·æ¨·æ≠·æÆ·æØ·æ∏·æπ& &·øò·øô·ø®·ø©‚í∂‚í∑‚í∏‚íπ‚í∫‚íª‚íº‚íΩ‚íæ‚íø‚ìÄ‚ìÅ‚ìÇ‚ìÉ‚ìÑ‚ìÖ‚ìÜ‚ìá‚ìà‚ìâ‚ìä‚ìã‚ìå‚ìç‚ìé‚ìè& &Ôº°Ôº¢Ôº£Ôº§Ôº•Ôº¶ÔºßÔº®Ôº©Ôº™Ôº´Ôº¨Ôº≠ÔºÆÔºØÔº∞Ôº±Ôº≤Ôº≥Ôº¥ÔºµÔº∂Ôº∑Ôº∏ÔºπÔº∫' write ( stdout , '(g0)' ) low % character () write ( stdout , '(g0)' ) character ( upper ( low )) write ( stdout , '(g0)' ) character ( upp ) write ( stdout , '(g0)' ) character ( upp % lower ()) write ( stdout , '(g0)' ) 'Note \"i\" and \"I\" are a special case;' write ( stdout , '(g0)' ) 'uppercase of \"i\" is \"I\" (dotless) by default and' write ( stdout , '(g0)' ) 'lowercase of \"I\" (dotless) is \"i\" (dotted) by default.' write ( stdout , '(g0)' ) 'For the others LETTER=lower(upper(LETTER)) and LETTER=upper(lower(LETTER))' end program testit","tags":"","url":"sourcefile/uplow.f90.html"},{"title":"demo_upper.f90 ‚Äì M_unicode","text":"Source Code program demo_upper use iso_fortran_env , only : stdout => output_unit use M_unicode , only : upper , unicode_type , assignment ( = ) use M_unicode , only : ut => unicode_type , operator ( == ) implicit none character ( len =* ), parameter :: g = '(*(g0))' type ( unicode_type ) :: pangram type ( unicode_type ) :: diacritics type ( unicode_type ) :: expected ! ! a sentence containing every letter of the English alphabet ! often used to test telegraphs since the advent of the 19th century ! and as an exercise repetitively generated in typing classes pangram = \"The quick brown fox jumps over the lazy dog.\" expected = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.\" call test ( pangram , expected ) ! ! Slovak pangram pangram = 'Vyp√§t√° dc√©ra gr√≥fa Maxwella s IQ ni≈æ≈°√≠m ako & &k√¥≈à n√∫ti ƒçeƒæaƒè hr√Ωz≈• h≈ïbu jabƒ∫k.' expected = 'VYP√ÑT√Å DC√âRA GR√ìFA MAXWELLA S IQ NI≈Ω≈†√çM AKO & &K√î≈á N√öTI ƒåEƒΩAƒé HR√ùZ≈§ H≈îBU JABƒπK.' call test ( pangram , expected ) ! ! contains each special Czech letter with diacritics exactly once print g , '(\"A horse that was too yellow-ish moaned devilish odes\")' diacritics = 'P≈ô√≠li≈° ≈ælu≈•ouƒçk√Ω k≈Ø≈à √∫pƒõl ƒè√°belsk√© √≥dy.' expected = 'P≈ò√çLI≈† ≈ΩLU≈§OUƒåK√ù K≈Æ≈á √öPƒöL ƒé√ÅBELSK√â √ìDY.' call test ( diacritics , expected ) contains subroutine test ( in , expected ) type ( unicode_type ), intent ( in ) :: in type ( unicode_type ), intent ( in ) :: expected type ( unicode_type ) :: uppercase character ( len =* ), parameter :: nl = new_line ( 'A' ) write ( stdout , g ) in % character () uppercase = upper ( in ) write ( stdout , g ) uppercase % character () write ( stdout , g ) merge ( 'PASSED' , 'FAILED' , uppercase == expected ), nl end subroutine test end program demo_upper","tags":"","url":"sourcefile/demo_upper.f90.html"},{"title":"sample.f90 ‚Äì M_unicode","text":"Source Code program assign_exe use iso_fortran_env , only : stdout => output_unit use M_unicode , only : len , len_trim , repeat , trim , adjustr , adjustl use M_unicode , only : character use M_unicode , only : assignment ( = ), unicode_type implicit none character ( len =* ), parameter :: cat = '(*(g0))' ,& gap = '(*(g0,1x))' ,& dash = '(*(g0,\"-\"))' ,& bracket = '(*(\"[\",g0,\"]\":))' type ( unicode_type ) :: uline , substring uline = \"   Until you stop, you won't be able to.   \" call showme ( uline ) uline = \"   –î–æ–∫–∏ –Ω–µ –≤–ø—Ä—ñ—Ç–∏, –¥–æ—Ç–∏ –Ω–µ –≤–º—ñ—Ç–∏.   \" call showme ( uline ) print * write ( stdout , gap ) 'third word is: ' , character ( uline , 12 , 17 ) ! substring substring = character ( uline , 20 , 32 ) write ( stdout , gap ) 'substring is: ' , character ( substring ) ! can set with codepoints uline = [ 32 , 160 , 8192 , 8193 , 8194 , 8195 , 8196 , 8197 , 8198 , 8199 , 8200 , 8201 , 8202 , 8239 , 8287 , 12288 ] write ( stdout , gap ) 'different kinds of spaces:' , uline % character () contains subroutine showme ( uline ) type ( unicode_type ), intent ( in ) :: uline integer :: i write ( stdout , cat ) ' ' , repeat ( '1234567890' , len ( uline ) / 10 + 1 ) write ( stdout , bracket ) character ( uline ) write ( stdout , cat ) 'length in bytes is: ' , len ( uline % character ()) write ( stdout , cat ) 'length in glyphs is: ' , len ( uline ) write ( stdout , cat ) 'trimmed length in glyphs is: ' , len_trim ( uline ) write ( stdout , cat ) 'adjustr:[' , character ( adjustr ( uline )), ']' write ( stdout , cat ) 'adjustl:[' , character ( adjustl ( uline )), ']' write ( stdout , cat ) 'cropped:[' , character ( trim ( adjustl ( uline ))), ']' write ( stdout , gap ) 'codepoints:' , uline % codepoint () write ( stdout , dash ) 'glyphs:' ,( character ( uline % sub ( i , i )), i = 1 , len ( uline )) write ( stdout , * ) end subroutine showme end program assign_exe","tags":"","url":"sourcefile/sample.f90.html"},{"title":"demo_verify_5.f90 ‚Äì M_unicode","text":"Source Code program more_verify use M_unicode , only : ut => unicode_type , verify use M_unicode , only : assignment ( = ) use M_unicode , only : ch => character implicit none character ( len =* ), parameter :: & & low = \"abcdefghijklmnopqrstuvwxyz\" , & & upp = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" , & & blank = \" \" ! note character variables in an array have to be of the same length type ( ut ), allocatable :: strings (:) type ( ut ), allocatable :: sets (:) strings = [ ut ( \"Go\" ), ut ( \"right\" ), ut ( \"home!\" )] sets = [ ut ( \"do\" ), ut ( \"re\" ), ut ( \"me\" )] ! elemental ‚Äê‚Äê you can use arrays for both strings and for sets ! check each string from right to left for non‚Äêletter/non‚Äêblank write ( * , * ) \"last non‚Äêletter\" , verify ( strings , upp // low // blank , back = . true .) ! even BACK can be an array ! find last non‚Äêuppercase character in \"Howdy \" ! and first non‚Äêlowercase in \"there \" write ( * , * ) verify ( strings ( 1 : 2 ),[ upp , low ], back = [. true .,. false .]) ! using a null string for a set is not well defined. Avoid it write ( * , * ) \"null\" , verify ( \"for tran \" , \"\" , . true .) ! 8,length of string? ! probably what you expected write ( * , * ) \"blank\" , verify ( \"for tran \" , \" \" , . true .) ! 7,found ‚Äôn‚Äô ! first character in  \"Go    \" not in \"do\", ! and first letter in \"right \" not in \"ri\" ! and first letter in \"home! \" not in \"me\" write ( * , * ) verify ( strings , sets ) end program more_verify","tags":"","url":"sourcefile/demo_verify_5.f90.html"},{"title":"demo_replace.f90 ‚Äì M_unicode","text":"Source Code program demo_replace use M_unicode , only : ut => unicode_type use M_unicode , only : unicode_type use M_unicode , only : character , replace use M_unicode , only : write ( formatted ) implicit none type ( unicode_type ) :: line ! write ( * , '(DT)' ) & & replace ( ut ( 'Xis is Xe string' ), ut ( 'X' ), ut ( 'th' ) ) write ( * , '(DT)' ) & & replace ( ut ( 'Xis is xe string' ), ut ( 'x' ), ut ( 'th' ), ignorecase = . true .) write ( * , '(DT)' ) & & replace ( ut ( 'Xis is xe string' ), ut ( 'X' ), ut ( 'th' ), ignorecase = . false .) ! ! a null old substring means \"at beginning of line\" write ( * , '(DT)' ) & & replace ( ut ( 'my line of text' ), ut ( '' ), ut ( 'BEFORE:' )) ! ! a null new string deletes occurrences of the old substring write ( * , '(DT)' ) replace ( ut ( 'I wonder i ii iii' ), ut ( 'i' ), ut ( '' )) ! ! Examples of the use of RANGE ! line = replace ( ut ( 'aaaaaaaaa' ), ut ( 'a' ), ut ( 'A' ), occurrence = 1 , repeat = 1 ) write ( * , * ) 'replace first a with A [' // line % character () // ']' ! line = replace ( ut ( 'aaaaaaaaa' ), ut ( 'a' ), ut ( 'A' ), occurrence = 3 , repeat = 3 ) write ( * , * ) 'replace a with A for 3rd to 5th occurrence [' & & // line % character () // ']' ! line = replace ( ut ( 'ababababa' ), ut ( 'a' ), ut ( '' ), occurrence = 3 , repeat = 3 ) write ( * , * ) 'replace a with null instances 3 to 5 [' // & & line % character () // ']' ! line = replace ( & & ut ( 'a b ab baaa aaaa aa aa a a a aa aaaaaa' ),& & ut ( 'aa' ), ut ( 'CCCC' ), occurrence =- 1 , repeat = 1 ) write ( * , * ) 'replace lastaa with CCCC [' // line % character () // ']' ! write ( * , '(DT)' ) replace ( ut ( 'myf90stuff.f90.f90' ),& & ut ( 'f90' ), ut ( 'for' ), occurrence =- 1 , repeat = 1 ) write ( * , '(DT)' ) replace ( ut ( 'myf90stuff.f90.f90' ),& & ut ( 'f90' ), ut ( 'for' ), occurrence =- 2 , repeat = 2 ) ! end program demo_replace","tags":"","url":"sourcefile/demo_replace.f90.html"},{"title":"concatenate.f90 ‚Äì M_unicode","text":"Source Code program concatenate use M_unicode , only : operator ( // ) use M_unicode , only : ut => unicode_type , ch => character type ( ut ) :: string integer :: ten = 10 , twenty = 20 character ( len = :), allocatable :: line ! ifx requires (), flang_new and gfortran do not at the moment string = 'so ' // ten // '+' // twenty // '=' // ( ten + twenty ) write ( * , * ) string % character () string = 10 // ' ' // 20 // ' ' // 3.14159265 // ' ' // ( 3 , 4 ) // ' ' // . true . // ( 1.0d0 / 3.0d0 ) write ( * , * ) string % character () string = 10 // 20 write ( * , * ) string % character () line = 'abc' // 'def' write ( * , * ) line string = 'abc' // ten write ( * , * ) string % character () string = ten // 'abc' write ( * , * ) string % character () end program concatenate","tags":"","url":"sourcefile/concatenate.f90.html"},{"title":"encode_codepoints.f90 ‚Äì M_unicode","text":"Source Code program uview ! @(#) given starting and ending codepoint show unicode characters in various formats use , intrinsic :: iso_fortran_env , only : stdout => output_unit use M_unicode , only : unicode_type , assignment ( = ), len use M_unicode , only : ut => unicode_type , ch => character implicit none character ( len =* ), parameter :: & & form = '(1x,\"char(int(z''\",z0,\"''),kind=ucs4)\":,\"// &\")' , & & form_M = '(1x,\"int(z''\",z0,\"'')\":,\", &\")' , & & form_zhtml = '(1x,*(:\"&#x\",z0,\";\"))' , & & form_html = '(1x,*(:\"&#\",i0,\";\"))' character ( len =* ), parameter :: g = '(*(g0))' integer :: i integer :: ends ( 2 ) character ( len = :), allocatable :: argument type ( unicode_type ) :: ustr ends = 0 do i = 1 , min ( 2 , command_argument_count ()) argument = getarg ( i ) read ( argument , * ) ends ( i ) enddo if ( i . eq . 2 ) ends ( 2 ) = ends ( 1 ) write ( stdout , g ) 'START=' , ends ( 1 ), ' END=' , ends ( 2 ) do i = ends ( 1 ), ends ( 2 ) ustr = i write ( stdout , '(1x,i0)' , advance = 'no' ) i ! codepoint write ( stdout , '(1x,a)' , advance = 'no' ) ch ( ustr ) ! character write ( stdout , '(1x,''U\\'' , z8 . 8 ) ',advance=' no ')i  ! U\\00000064 write(stdout,form_zhtml,advance=' no ')i          ! &#x4EBA; write(stdout,form_html,advance=' no ')i           ! &#20154; write(stdout,form,advance=' no ')i                ! char(int(z' nnn ',kind=ucs4)) write(stdout,form_M,advance=' no ')i              ! int(z' nnn ' ) write ( stdout , * ) enddo contains function getarg ( arg ) result ( argument ) integer , intent ( in ) :: arg integer :: length character ( len = :), allocatable :: argument call get_command_argument ( arg , length = length ) ! get command line argument length allocate ( character ( len = length ) :: argument ) ! allocate string big enough to hold argument call get_command_argument ( arg , argument ) ! get command line argument as a string end function getarg end program uview","tags":"","url":"sourcefile/encode_codepoints.f90.html"},{"title":"demo_verify_1.f90 ‚Äì M_unicode","text":"Source Code program demo_verify_1 use M_unicode , only : assignment ( = ) use M_unicode , only : ut => unicode_type , ch => character use M_unicode , only : write ( formatted ) use M_unicode , only : operator ( == ) use M_unicode , only : verify , replace use M_unicode , only : operator ( // ) implicit none ! some useful character sets character , parameter :: & & int * ( * ) = \"1234567890\" , & & low * ( * ) = \"abcdefghijklmnopqrstuvwxyz\" , & & upp * ( * ) = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" , & & punc * ( * ) = \"!\"\"#$%&'()*+,‚Äê./:;<=>?@['_‚Äò{|}Àú\" , & & blank * ( * ) = \" \" , & & tab = char ( 11 ), & & prnt * ( * ) = int // low // upp // blank // punc type ( ut ) :: stru integer :: i print * , \"basics:\" print * , VERIFY ( \"ABBA\" , \"A\" ) ! has the value 2. print * , VERIFY ( \"ABBA\" , \"A\" , BACK = . TRUE .) ! has the value 3. print * , VERIFY ( \"ABBA\" , \"AB\" ) ! has the value 0. print * , \"find first non‚Äêuppercase letter\" ! will produce the location of \"d\", because there is no match in UPP write ( * , * ) \"something unmatched\" , verify ( ut ( \"ABCdEFG\" ), upp ) print * , \"if everything is matched return zero\" ! will produce 0 as all letters have a match write ( * , * ) & & \"everything matched\" , verify ( ut ( \"ffoorrttrraann\" ), \"nartrof\" ) print * , \"easily categorize strings as uppercase, lowercase, ...\" ! C-like functionality but does entire strings not just characters write ( * , * ) \"isdigit 123?\" , verify ( ut ( \"123\" ), int ) == 0 write ( * , * ) \"islower abc?\" , verify ( ut ( \"abc\" ), low ) == 0 write ( * , * ) \"isalpha aBc?\" , verify ( ut ( \"aBc\" ), low // upp ) == 0 write ( * , * ) \"isblank aBc dEf?\" , verify ( ut ( \"aBc dEf\" ), blank // tab ) /= 0 ! check if all printable characters stru = \"aB;cde,fgHI!Jklmno PQRSTU vwxyz\" write ( * , * ) \"isprint?\" , verify ( stru , prnt ) == 0 ! this now has a nonprintable tab character in it stru = replace ( stru , 10 , 10 , ut ( char ( 11 ))) write ( * , * ) \"isprint?\" , verify ( stru , prnt ) == 0 print * , \"VERIFY(3) is very powerful using expressions as masks\" ! verify(3) is often used in a logical expression stru = \" This is NOT all UPPERCASE \" write ( * , * ) \"all uppercase/spaces?\" , verify ( stru , blank // upp ) == 0 stru = \" This IS all uppercase \" write ( * , * ) \"stru=[\" // stru // \"]\" write ( * , * ) \"all uppercase/spaces?\" , verify ( stru , blank // upp ) == 0 ! set and show complex stru to be tested stru = \"  Check this out. Let me know  \" ! show the stru being examined write ( * , * ) \"stru=[\" // stru // \"]\" write ( * , * ) \"        \" // repeat ( int , 4 ) ! number line ! function returns a position just not a logical like C print * , \"returning a position not just a logical is useful\" ! which can be very useful for parsing strings write ( * , * ) \"first non‚Äêblank character\" , verify ( stru , blank ) write ( * , * ) \"last non‚Äêblank character\" , verify ( stru , blank , back = . true .) write ( * , * ) \"first non‚Äêletter non‚Äêblank\" , verify ( stru , low // upp // blank ) !VERIFY(3) is elemental (can check an array of strings in one call) print * , \"elemental\" ! are strings all letters (or blanks)? write ( * , * ) \"array of strings\" , verify ( & ! strings must all be same length, so force to length 10 & [ character ( len = 10 ) :: \"YES\" , \"ok\" , \"000\" , \"good one\" , \"Nope!\" ], & & low // upp // blank ) == 0 ! rarer, but the set can be an array, not just the strings to test ! you could do ISPRINT() this (harder) way :> write ( * , * ) \"isprint?\" , & & . not . all ( verify ( ut ( \"aBc\" ), [( char ( i ), i = 32 , 126 )]) == 1 ) ! instead of this way write ( * , * ) \"isprint?\" , verify ( ut ( \"aBc\" ), prnt ) == 0 end program demo_verify_1","tags":"","url":"sourcefile/demo_verify_1.f90.html"},{"title":"more_tokenize.f90 ‚Äì M_unicode","text":"Source Code program demo_tokenize use iso_fortran_env , only : stdout => output_unit use M_unicode , only : assignment ( = ), unicode_type , tokenize , len , character implicit none character ( len =* ), parameter :: g0 = '(*(g0))' character ( len =* ), parameter :: g1 = '(*(g0,1x))' type ( unicode_type ), allocatable :: tokens (:) type ( unicode_type ), allocatable :: separators (:) type ( unicode_type ) :: delims type ( unicode_type ) :: herbs integer , allocatable , dimension (:) :: begins integer , allocatable , dimension (:) :: ends integer :: i delims = ',&' herbs = 'parsley,sage,rosemary,&thyme' write ( stdout , * ) herbs % character () write ( stdout , g0 ) write ( stdout , g0 ) 'expecting' write ( stdout , g0 ) ' tokens    =[parsley][sage][rosemary][][thyme]' write ( stdout , g0 ) ' separators=,,,&' CALL TOKENIZE ( herbs , delims , tokens , separators ) write ( stdout , g0 ) 'got' write ( stdout , g0 ) \" tokens    =\" ,( '[' // tokens ( i )% character (), ']' , i = 1 , size ( tokens )) write ( stdout , g0 ) \" separators=\" ,( separators ( i )% character (), i = 1 , size ( separators )) write ( stdout , g0 ) write ( stdout , g0 ) 'expecting' write ( stdout , * ) 'begins=' ,[ 1 , 9 , 14 , 23 , 24 ] write ( stdout , * ) 'ends=  ' ,[ 7 , 12 , 21 , 22 , 28 ] CALL TOKENIZE ( herbs , delims , begins , ends ) write ( stdout , g0 ) 'got' write ( stdout , * ) 'begins=' , begins write ( stdout , * ) 'ends=  ' , ends write ( stdout , g0 ) write ( stdout , g0 ) 'OOP' tokens = herbs % tokenize ( delims ) write ( stdout , g0 ) \" tokens    =\" ,( '[' // tokens ( i )% character (), ']' , i = 1 , size ( tokens )) herbs = 'parsley/sage/rosemary//thyme' delims = '/' tokens = herbs % tokenize ( delims ) write ( stdout , g0 ) \" tokens    =\" ,( '[' // tokens ( i )% character (), ']' , i = 1 , size ( tokens )) herbs = 'parsleyüòÉsageüòÉrosemaryüòÉüòÉthyme' delims = 'üòÉ' write ( stdout , g0 ) ' ' , delims % character () write ( stdout , g1 ) ' ' , delims % codepoint () tokens = herbs % tokenize ( delims ) write ( stdout , g0 ) \" tokens    =\" ,( '[' // tokens ( i )% character (), ']' , i = 1 , size ( tokens )) end program demo_tokenize","tags":"","url":"sourcefile/more_tokenize.f90.html"},{"title":"demo_readline.f90 ‚Äì M_unicode","text":"Source Code program demo_readline use , intrinsic :: iso_fortran_env , only : stdin => input_unit use , intrinsic :: iso_fortran_env , only : iostat_end use M_unicode , only : readline , len , trim use M_unicode , only : assignment ( = ), ch => character , ut => unicode_type implicit none type ( ut ) :: line character ( len = :), allocatable :: aline integer , allocatable :: ints (:) integer :: iostat open ( unit = stdin , pad = 'yes' ) ! INFINITE : do line = readline ( iostat = iostat ) if ( iostat . ne . 0 ) exit ! write the length, line in brackets and its Unicode codepoints write ( * , '(*(g0,1x))' ) len ( line ), '[' // ch ( line ) // ']' , line % codepoint () ! or assign the string to an allocatable array of integers ints = line ! and the string to a character variable aline = line write ( * , '(*(g0,1x))' ) len ( line ), '[' // ch ( line ) // ']' , ints enddo INFINITE ! if ( iostat /= iostat_end ) then write ( * , * ) 'error reading input:' , ch ( trim ( line )) endif ! end program demo_readline","tags":"","url":"sourcefile/demo_readline.f90.html"},{"title":"demo_trim.f90 ‚Äì M_unicode","text":"Source Code program demo_trim use M_unicode , only : ut => unicode_type , assignment ( = ) use M_unicode , only : trim , len use M_unicode , only : write ( formatted ) implicit none type ( ut ) :: str type ( ut ), allocatable :: strs (:) character ( len =* ), parameter :: brackets = '( *(\"[\",DT,\"]\":,1x) )' integer :: i ! str = '   trailing    ' print brackets , str , trim ( str ) ! trims it ! str = '   leading' print brackets , str , trim ( str ) ! no effect ! str = '            ' print brackets , str , trim ( str ) ! becomes zero length print * , len ( str ), len ( trim ( '               ' )) ! strs = [ ut ( \"Z \" ), ut ( \" a b c\" ), ut ( \"ABC   \" ), ut ( \"\" )] ! write ( * , * ) 'untrimmed:' print brackets , ( strs ( i ), i = 1 , size ( strs )) print brackets , strs ! write ( * , * ) 'trimmed:' ! everything prints trimmed print brackets , ( trim ( strs ( i )), i = 1 , size ( strs )) print brackets , trim ( strs ) ! end program demo_trim","tags":"","url":"sourcefile/demo_trim.f90.html"},{"title":"demo_adjustl.f90 ‚Äì M_unicode","text":"Source Code program demo_adjustl use M_unicode , only : ut => unicode_type use M_unicode , only : ch => character use M_unicode , only : adjustl , trim , len_trim , verify use M_unicode , only : write ( formatted ) use M_unicode , only : assignment ( = ) implicit none type ( ut ) :: usample , uout integer :: istart , iend character ( len =* ), parameter :: adt = '(a,\"[\",DT,\"]\")' ! ! basic use usample = '   sample string   ' write ( * , adt ) 'original: ' , usample ! ! note a string stays the same length ! and is not trimmed by just an adjustl(3) call. write ( * , adt ) 'adjusted: ' , adjustl ( usample ) ! ! a fixed‚Äêlength string can be trimmed using trim(3) uout = trim ( adjustl ( usample )) write ( * , adt ) 'trimmed:  ' , uout ! ! or alternatively you can select a substring without adjusting istart = max ( 1 , verify ( usample , ' ' )) ! first non‚Äêblank character iend = len_trim ( usample ) write ( * , adt ) 'substring:' , usample % sub ( istart , iend ) ! write ( * , adt ) 'substring:' , adjustl ( usample , 30 ) write ( * , adt ) 'substring:' , adjustl ( usample , 20 ) write ( * , adt ) 'substring:' , adjustl ( usample , 10 ) write ( * , adt ) 'substring:' , adjustl ( usample , 0 ) end program demo_adjustl","tags":"","url":"sourcefile/demo_adjustl.f90.html"},{"title":"demo_ichar.f90 ‚Äì M_unicode","text":"Source Code program demo_ichar use M_unicode , only : assignment ( = ), ch => character use M_unicode , only : ut => unicode_type , write ( formatted ) use M_unicode , only : ichar , escape , len implicit none type ( ut ) :: string type ( ut ), allocatable :: lets (:) integer , allocatable :: ilets (:) integer :: i ! ! create a string containing multibyte characters string = [ 949 , 8021 , 961 , 951 , 954 , 945 , 33 ] ! eureka write ( * , '(*(DT,1x,\"(AKA. eureka!)\"))' ) string ! ! call ichar(3) on each glyph of the string to convert ! the string to an array of integer codepoints ilets = [( ichar ( string % sub ( i , i )), i = 1 , len ( string ))] write ( * , '(*(z0,1x))' ) ilets ! ! note that the %codepoint method is commonly used to ! convert a string to an integer array of codepoints write ( * , '(*(z0,1x))' ) string % codepoint () ! elemental write ( * , '(\"WRITING ISSUES:\")' ) ! ! define an array LETS with escape codes with one glyph per element lets = [ ut ( '\\U03B5' ), ut ( '\\U1F55' ), ut ( '\\U03C1' ), ut ( '\\U03B7' ), & & ut ( '\\U03BA' ), ut ( '\\U03B1' ), ut ( '\\U0021' )] lets = escape ( lets ) ! convert escape codes to glyphs ! ! look at issues with converting to CHARACTER for simple printing ! write ( * , '(\"each element is a single glyph \",*(g0,1x))' ) len ( lets ) ! ! notice if you convert to an array of intrinsic CHARACTER type the ! strings are all the same length in bytes; but unicode characters ! can take various numbers of bytes write ( * , '(*(g0,\":\"))' ) 'CHARACTER array elements have same length' ,& & len ( ch ( lets )) ! this will not appear correctly because all elements are padded to ! the same length in bytes write ( * , '(*(a,\":\"))' ) ch ( lets ) ! one element at a time will retain the size of each element write ( * , '(*(a,\":\"))' )( ch ( lets ( i : i )), i = 1 , size ( lets )) ! ! the FIRST LETTER of each element is converted to a codepoint so ! for the special case where each string element is a single glyph ! an elemental approach works write ( * , '(\"ELEMENTAL:\",*(z0,1x))' ) ichar ( lets ) ! OOPS write ( * , '(\"OOPS:\",*(z0,1x))' ) lets % ichar () end program demo_ichar","tags":"","url":"sourcefile/demo_ichar.f90.html"},{"title":"demo_len.f90 ‚Äì M_unicode","text":"Source Code program demo_len use M_unicode , only : assignment ( = ), ut => unicode_type , len use M_unicode , only : write ( formatted ) implicit none type ( ut ) :: string type ( ut ), allocatable :: many_strings (:) integer :: ii ! BASIC USAGE string = 'Noho me ka hau‚Äôoli' ! (Be happy.) ii = len ( string ) write ( * , '(DT,*(g0))' ) string , ' LEN=' , ii ! string = ' How long is this allocatable string? ' write ( * , '(DT,*(g0))' ) string , ' LEN=' , len ( string ) ! ! STRINGS IN AN ARRAY MAY BE OF DIFFERENT LENGTHS many_strings = [ ut ( 'Tom' ), ut ( 'Dick' ), ut ( 'Harry' ) ] write ( * , '(*(g0,1x))' ) 'length of elements of array=' , len ( many_strings ) ! write ( * , '(*(g0))' ) 'length from type parameter inquiry=' , string % len () ! ! LOOK AT HOW A PASSED STRING CAN BE USED ... call passed ( ut ( ' how long? ' )) ! contains ! subroutine passed ( str ) type ( ut ), intent ( in ) :: str ! you can query the length of the passed variable ! when an interface is present write ( * , '(*(g0))' ) 'length of passed value is ' , len ( str ) end subroutine passed ! end program demo_len","tags":"","url":"sourcefile/demo_len.f90.html"},{"title":"demo_character.f90 ‚Äì M_unicode","text":"Source Code program demo_character use M_unicode , only : ut => unicode_type , ch => character , trim , len , pad use M_unicode , only : write ( formatted ), assignment ( = ) type ( ut ) :: ustr type ( ut ), allocatable :: array (:) integer :: i character ( len =* ), parameter :: all = '(*(g0))' ustr = [ 949 , 8021 , 961 , 951 , 954 , 945 , 33 ] ! eureka in codepoints ! when doing I/O using DT might be the most intuitive ! but sometimes converting to intrinsic character variables ! is preferred write ( * , all ) ch ( ustr ) ! convert to CHARACTER variable write ( * , all ) ustr % character () ! convert to CHARACTER variable ! you can select a range of glyphs write ( * , all ) ustr % character ( 3 , 4 ) ! similar to LINE(3:4) for ! CHARACTER variables ! and even reverse a string write ( * , all ) ustr % character ( len ( ustr ), 1 , - 1 ) ! reverse string ! note that OOP syntax provides a few other options write ( * , all ) ustr % byte () ! convert to CHARACTER(LEN=1) type ! arrays ! ! using this syntax make sure to make the LEN value large enough ! that glyphs can take up to four bytes array = ut ([ character ( len = 60 ) :: & 'Confucius never claimed to be a prophet, ' ,& 'but I think he foresaw AI! He said ' ,& '' ,& ' \"Â≠¶ËÄå‰∏çÊÄùÂàôÁΩîÔºåÊÄùËÄå‰∏çÂ≠¶ÂàôÊÆÜ\"' ,& 'or' ,& ' (xu√© √©r b√π sƒ´ z√© w«éng, sƒ´ √©r b√π xu√© z√© d√†i),' ,& 'which is also' ,& ' \"To learn without thinking is to be lost, ' ,& ' to think without learning is to be in danger\".' ]) ! write ( * , '(*(:,\"[\",g0,\"]\",/))' ) ch ( array ) ! all elements will be the same length in bytes but not necessarily !in glyphs write ( * , '(a,*(i0,1x))' ) 'all elements the same length in BYTES:' , & & len ( ch ( array )) write ( * , '(a,*(i0,1x))' ) 'lengths (in glyphs):' , len ( array ) array = trim ( array ) write ( * , '(a,*(i0,1x))' ) 'lengths after trimming (in glyphs):' , & & len ( array ) write ( * , '(:*(:,\"[\",g0,\"]\",/))' ) ch ( array ) write ( * , * ) ! ! using this syntax the elements will be of different lengths array = [ & ut ( 'Confucius never claimed to be a prophet,' ) ,& ut ( 'but I think he foresaw AI! He said' ) ,& ut ( '' ) ,& ut ( ' \"Â≠¶ËÄå‰∏çÊÄùÂàôÁΩîÔºåÊÄùËÄå‰∏çÂ≠¶ÂàôÊÆÜ\"' ) ,& ut ( 'or' ) ,& ut ( ' (xu√© √©r b√π sƒ´ z√© w«éng, sƒ´ √©r b√π xu√© z√© d√†i),' ) ,& ut ( 'which is also' ) ,& ut ( ' \"To learn without thinking is to be lost,' ) ,& ut ( ' to think without learning is to be in danger\".' )] ! but using the CHARACTER function will still make them the same ! length in bytes so you might want to print them individually ! for certain effects, subject to font properties such as varying ! glyph widths. write ( * , '(*(\"[\",g0,\"]\",/))' )( ch ( array ( i )), i = 1 , size ( array )) write ( * , '(*(\"[\",g0,\"]\",/))' )( ch ( pad ( array ( i ), 60 )), i = 1 , size ( array )) ! end program demo_character","tags":"","url":"sourcefile/demo_character.f90.html"},{"title":"demo_get_arg.f90 ‚Äì M_unicode","text":"Source Code program demo_get_arg use M_unicode , only : get_arg , ut => unicode_type , ch => character use M_unicode , only : assignment ( = ), operator ( // ), write ( formatted ) implicit none integer :: position type ( ut ) :: default type ( ut ) :: value type ( ut ) :: smiley integer :: i character ( len =* ), parameter :: bracket = '(1x,*(\"[\",a,\"]\",:))' ! smiley = 128515 ! set with Unicode code point default = 'Wish I was first ' // smiley // '!' ! set with unicode_type ! ! arguments can be type(unicode_type) or character ! but type(unicode_type) is always returned do position = 0 , command_argument_count () value = get_arg ( position , default ) value = get_arg ( position , default % character () ) ! write ( * , * ) value % character () write ( * , '(DT)' ) default % get_arg ( position ) ! ! print each glyph surrounded by brackets write ( * , bracket )( value % character ( i , i ), i = 1 , value % len ()) enddo ! end program demo_get_arg","tags":"","url":"sourcefile/demo_get_arg.f90.html"},{"title":"show_as_codepoints.f90 ‚Äì M_unicode","text":"Source Code program codepoints ! @(#) take command line argument utf-8 text and generate Fortran statement that represents the string use , intrinsic :: iso_fortran_env , only : stdout => output_unit use M_unicode , only : unicode_type , assignment ( = ), len implicit none character ( len =* ), parameter :: form = '(\"char(int(z''\",z0,\"''),kind=ucs4)\":,\"// &\")' character ( len =* ), parameter :: form_M = '(\"int(z''\",z0,\"'')\":,\", &\")' character ( len =* ), parameter :: form_zhtml = '(*(:\"&#x\",z0,\";\"))' character ( len =* ), parameter :: form_html = '(*(:\"&#\",i0,\";\"))' character ( len =* ), parameter :: form_codepoint = '(*(:\"\",i0,:\",\"))' character ( len =* ), parameter :: g = '(*(g0))' integer :: i integer , allocatable :: codes (:) character ( len = :), allocatable :: command_line type ( unicode_type ) :: ustr command_line = getargs () ! get string containing all command arguments as CHARACTER bytes ustr = command_line ! convert bytes to internal Fortran Unicode representation !open (stdout, encoding='UTF-8') ! write the command line out as a Fortran variable expression using the CHAR() function write ( stdout , g ) 'program fortran_unicode' write ( stdout , g ) 'use,intrinsic :: iso_fortran_env, only: stdout => output_unit' write ( stdout , g ) 'implicit none' write ( stdout , g ) \"integer,parameter :: ucs4 = selected_char_kind('ISO_10646')\" write ( stdout , g ) 'character(kind=ucs4,len=:),allocatable :: ustr2' write ( stdout , g ) '! ISO-10646 ENCODING:' , command_line write ( stdout , g ) 'character(len=*,kind=ucs4),parameter :: ustr= &' write ( stdout , form )( ustr % codepoint ( i , i ), i = 1 , len ( ustr )) write ( stdout , g ) 'integer :: i' write ( stdout , g ) \"   open(stdout,encoding='utf-8')\" write ( stdout , g ) '   write(stdout,*)ustr' write ( stdout , g ) '   ! can do internal writes, substrings, character intrinsics ...' write ( stdout , g ) '   allocate(character(len=len(ustr),kind=ucs4) :: ustr2)' write ( stdout , g ) \"   write(ustr2,'(*(a))')[(ustr(i:i),i=len(ustr),1,-1)]\" write ( stdout , g ) '   write(stdout,*)ustr2' write ( stdout , g ) 'end program fortran_unicode' write ( stdout , g ) write ( stdout , g ) 'program fortran_M_unicode' write ( stdout , g ) 'use,intrinsic :: iso_fortran_env, only: stdout => output_unit' write ( stdout , g ) 'use M_unicode, only: unicode_type, assignment(=), len' write ( stdout , g ) 'implicit none' write ( stdout , g ) 'type(unicode_type) :: ustr' write ( stdout , g ) 'type(unicode_type) :: ustr2' write ( stdout , g ) '! GLYPH UNICODE ENCODING:' , command_line write ( stdout , g ) 'integer,parameter :: codes(*)= [&' write ( stdout , form_M , advance = 'no' ) ustr % codepoint () write ( stdout , g ) ']' write ( stdout , g ) 'integer :: i' write ( stdout , g ) 'integer :: iostat' write ( stdout , g ) \"   open(stdout,encoding='utf-8',iostat=iostat)\" write ( stdout , g ) '   ustr = codes' write ( stdout , g ) '   write(stdout,*)ustr%character()' write ( stdout , g ) '   ! can do substrings, character intrinsics ...' write ( stdout , g ) '   ustr2 = ustr%character(len(ustr),1,-1)' write ( stdout , g ) '   write(stdout,*)ustr2%character()' write ( stdout , g , advance = 'no' ) '   ustr=[' write ( stdout , form_codepoint , advance = 'no' ) ustr % codepoint () write ( stdout , g ) ']' write ( stdout , g ) '   write(stdout,*)ustr%character()' write ( stdout , g ) '   ustr=\"' , ustr % character (), '\"' write ( stdout , g ) '   write(stdout,*)ustr%character()' write ( stdout , g ) 'end program fortran_M_unicode' write ( stdout , g ) write ( stdout , g ) '#include <iostream>' write ( stdout , g ) '#include <string>' write ( stdout , g ) 'int main() {' write ( stdout , g , advance = 'no' ) '   std::u32string mystring = U\"' codes = ustr % codepoint () do i = 1 , size ( codes ) if ( codes ( i ). lt . 127 ) then write ( stdout , g , advance = 'no' ) achar ( codes ( i )) else write ( stdout , '(''U\\'' , z8 . 8 ) ',advance=' no ') codes(i) endif enddo write(stdout,g) ' \";' write(stdout,g) '   // Outputting these directly might depend on console/terminal support' write(stdout,g) \" // and may require conversion to the system 's preferred encoding.\" write(stdout,g) ' return 0 ; ' write(stdout,g) ' } ' write(stdout,g) write(stdout,g) \"<!-- HTML Entities for \",ustr%character(),\"-->\" write(stdout,g) ' < pre > ' write(stdout,g)ustr%character() write(stdout,form_zhtml)ustr%codepoint() ! &#x4EBA; write(stdout,form_html)ustr%codepoint()  ! &#20154; write(stdout,g) ' </ pre > ' write(stdout,g) contains function getargs() result(command_line) integer                                :: length character(len=:),allocatable           :: command_line call get_command(length=length)                 ! get command line length allocate(character(len=length) :: command_line) ! allocate string big enough to hold command line call get_command(command=command_line)          ! get command line as a string call get_command_argument(0,length=length)      ! remove argument 0 command_line=adjustl(command_line(length+2:)) end function getargs end program codepoints ! ! An example run; using the famous Confucian expression ! \"Â∑±ÊâÄ‰∏çÊ¨≤ÔºåÂãøÊñΩÊñº‰∫∫\" (j«ê su«í b√π y√π, w√π shƒ´ y√∫ r√©n) or ! \"What you do not want done to yourself, do not do to others\": ! !    codepoints \"Â∑±ÊâÄ‰∏çÊ¨≤ÔºåÂãøÊñΩÊñº‰∫∫\" ! ! Odd that hexadecimal values can be used directly and much more compactly in a DATA statement ! but multiple BOZ values in INT() are not allowed, perhaps because DATA assumes the values are ! for the type being initialized; and no syntax to allow DATA to initialize a parameter (?) ! integer,save :: codes(9) ! data codes/ z' 5 DF1 ',z' 6240 ',z' 4E0 D ',z' 6 B32 ',z' FF0C ',z' 52 FF ',z' 65 BD ',z' 65 BC ',z' 4 EBA ' /","tags":"","url":"sourcefile/show_as_codepoints.f90.html"},{"title":"upside_down.f90 ‚Äì M_unicode","text":"Source Code program upside_down use M_unicode !use M_unicode, only : assignment(=), ch=>character, ut=>unicode_type use M_unicode , only : ch => character , ut => unicode_type type ( ut ) :: uline integer :: i character ( len = 128 ) :: ascii7 character ( len = :), allocatable :: cmdline cmdline = getargs () if ( cmdline . eq . '' ) then do i = 0 , 127 ascii7 ( i + 1 : i + 1 ) = char ( i ) enddo uline = downside_up ( ascii7 ( 32 : 126 )) write ( * , * ) uline % codepoint () write ( * , * ) ch ( uline ) else uline = downside_up ( cmdline ) write ( * , * ) ch ( uline ) endif !   do i=int(z'A4d0'),int(z'A4FF') ! Lisu (Fraser script) Unicode block !      uline = i !      write(*,'(i0,1x,z0,1x,a)')i,i,ch(uline) !   enddo contains function downside_up ( string ) result ( uline ) character ( len =* ), intent ( in ) :: string type ( ut ) :: uline character ( len = 1 ) :: letter integer :: i integer :: which integer :: ichr integer :: ichrs ( len ( string )) which = 1 do i = 1 , len ( string ) letter = string ( i : i ) select case ( letter ) case ( ' ' ); ichr = iachar ( ' ' ) case ( '!' ); ichr = int ( z '00A1' ) case ( '\"' ); ichr = int ( z '201E' ) case ( '#' ); ichr = iachar ( '#' ) case ( '$' ); ichr = iachar ( '$' ) case ( '%' ); ichr = iachar ( '%' ) case ( '&' ); ichr = int ( z '214B' ) case ( '''' ); ichr = int ( z '002C' ) case ( '(' ); ichr = int ( z '0029' ) case ( ')' ); ichr = iachar ( '(' ) case ( '*' ); ichr = iachar ( '*' ) case ( '+' ); ichr = iachar ( '+' ) case ( ',' ); ichr = iachar ( '''' ) case ( '-' ); ichr = iachar ( '-' ) case ( '.' ); ichr = int ( z '02D9' ) case ( '/' ); ichr = iachar ( '/' ) case ( '0' ); ichr = iachar ( '0' ) case ( '1' ); ichr = int ( z '0196' ) case ( '2' ); ichr = int ( z '1105' ) case ( '3' ); ichr = int ( z '0190' ) case ( '4' ); ichr = int ( z '152D' ) if ( which . eq . 2 ) ichr = int ( z '3123' ) if ( which . eq . 3 ) ichr = iachar ( 'h' ) case ( '5' ); ichr = int ( z '03DB' ) case ( '6' ); ichr = iachar ( '9' ) case ( '7' ); ichr = int ( z '2C62' ) if ( which . eq . 2 ) ichr = int ( z '3125' ) case ( '8' ); ichr = iachar ( '8' ) case ( '9' ); ichr = iachar ( '6' ) case ( ':' ); ichr = iachar ( ':' ) case ( ';' ); ichr = int ( z '061B' ) case ( '<' ); ichr = iachar ( '>' ) case ( '=' ); ichr = iachar ( '=' ) case ( '>' ); ichr = iachar ( '<' ) case ( '?' ); ichr = int ( z '00BF' ) case ( '@' ); ichr = iachar ( '@' ) ! Default ‚àÄêêí‚ÜÉ‚óñ∆é‚Ñ≤‚ÖÅHI≈ø‚ãä‚ÖÇW·¥éO‘ÄŒå·¥öS‚ä•‚à©·¥ßMX‚ÖÑZ case ( 'A' ); ichr = int ( z '2200' ) if ( which . eq . 4 ) ichr = int ( z 'A4EF' ) ! ÍìØ case ( 'B' ); ichr = int ( z '00010412' ) if ( which . eq . 4 ) ichr = int ( z 'A4ED' ) ! Íì≠ case ( 'C' ); ichr = int ( z '2183' ) if ( which . eq . 2 ) ichr = int ( z '0186' ) ichr = int ( z 'A4DB' ) ! Íìõ case ( 'D' ); ichr = int ( z '25D6' ) ichr = int ( z 'A4F7' ) ! Íì∑ case ( 'E' ); ichr = int ( z '018E' ) ichr = int ( z 'A4F1' ) ! Íì± case ( 'F' ); ichr = int ( z '2132' ) if ( which . eq . 4 ) ichr = int ( z 'A4DE' ) ! Íìû case ( 'G' ); ichr = int ( z '2141' ) ichr = int ( z 'A4E8' ) ! Íì® if ( which . eq . 2 ) ichr = int ( z '05E4' ) case ( 'H' ); ichr = iachar ( 'H' ) ichr = int ( z 'A4E7' ) ! Íìß case ( 'I' ); ichr = iachar ( 'I' ) ichr = int ( z 'A4F2' ) ! Íì≤ case ( 'J' ); ichr = int ( z '017F' ) ichr = int ( z 'A4E9' ) ! Íì© case ( 'K' ); ichr = int ( z '22CA' ) ichr = int ( z 'A4D8' ) ! Íìò case ( 'L' ); ichr = int ( z '2142' ) if ( which . eq . 4 ) ichr = int ( z 'A4F6' ) ! Íì∂ if ( which . eq . 2 ) ichr = int ( z '02E5' ) case ( 'M' ); ichr = ichar ( 'W' ) ichr = int ( z 'A4EA' ) ! Íì™ case ( 'N' ); ichr = int ( z '1D0E' ) ichr = int ( z 'A4E0' ) ! Íì† case ( 'O' ); ichr = iachar ( 'O' ) ichr = int ( z 'A4F3' ) ! Íì≥ case ( 'P' ); ichr = int ( z '0500' ) ichr = int ( z 'A4D2' ) ! Íìí case ( 'Q' ); ichr = int ( z '038C' ) case ( 'R' ); ichr = int ( z '1D1A' ) ichr = int ( z 'A4E4' ) ! Íì§ case ( 'S' ); ichr = iachar ( 'S' ) ichr = int ( z 'A4E2' ) ! Íì¢ case ( 'T' ); ichr = int ( z '22A5' ) ichr = int ( z 'A4D5' ) ! Íìï if ( which . eq . 2 ) ichr = int ( z '2534' ) case ( 'U' ); ichr = int ( z '2229' ) ichr = int ( z 'A4F5' ) ! Íìµ case ( 'V' ); ichr = int ( z '1D27' ) ichr = int ( z 'A4E5' ) ! Íì• if ( which . eq . 2 ) ichr = int ( z '039B' ) case ( 'W' ); ichr = iachar ( 'M' ) ichr = int ( z 'A4DF' ) ! Íìü case ( 'X' ); ichr = iachar ( 'X' ) ichr = int ( z 'A4EB' ) ! Íì´ case ( 'Y' ); ichr = int ( z '2144' ) case ( 'Z' ); ichr = iachar ( 'Z' ) ichr = int ( z 'A4DC' ) ! Íìú case ( '[' ); ichr = iachar ( ']' ) case ( '\\'); ichr=iachar(' \\ ') case(' ] '); ichr=iachar(' [ ') case(' &#94; '); ichr=iachar(' v ') case(' _ '); ichr=int(z' 20 3 E ') case(' ` '); ichr=iachar(' , ') case(' a '); ichr=int(z' 0250 ') case(' b '); ichr=iachar(' q ') case(' c '); ichr=int(z' 0254 ') case(' d '); ichr=iachar(' p ') case(' e '); ichr=int(z' 01 DD ') case(' f '); ichr=int(z' 025 F ') case(' g '); ichr=int(z' 0183 ') case(' h '); ichr=int(z' 0265 ') case(' i '); ichr=int(z' 0131 ') if(which.eq.2)ichr=int(z' 1 D09 ') case(' j '); ichr=int(z' 02 7 E ') case(' k '); ichr=int(z' 02 9 E ') case(' l '); ichr=int(z' 0283 ') case(' m '); ichr=int(z' 026 F ') case(' n '); ichr=iachar(' u ') case(' o '); ichr=iachar(' o ') case(' p '); ichr=iachar(' d ') case(' q '); ichr=iachar(' b ') case(' r '); ichr=int(z' 0279 ') case(' s '); ichr=iachar(' s ') case(' t '); ichr=int(z' 0287 ') case(' u '); ichr=iachar(' n ') case(' v '); ichr=int(z' 028 C ') case(' w '); ichr=int(z' 028 D ') case(' x '); ichr=iachar(' x ') case(' y '); ichr=int(z' 02 8 E ') case(' z '); ichr=iachar(' z ') case(' { '); ichr=iachar(' } ') case(' | '); ichr=iachar(' | ') case(' } '); ichr=iachar(' { ') case(' ~ '); ichr=iachar(' ~' ) case default ichr = iachar ( letter ) end select ichrs ( size ( ichrs ) - i + 1 ) = ichr enddo uline = ichrs end function downside_up function getargs () result ( command_line ) integer :: length character ( len = :), allocatable :: command_line call get_command ( length = length ) ! get command line length allocate ( character ( len = length ) :: command_line ) ! allocate string big enough to hold command line call get_command ( command = command_line ) ! get command line as a string call get_command_argument ( 0 , length = length ) ! remove argument 0 command_line = adjustl ( command_line ( length + 2 :)) end function getargs end program upside_down","tags":"","url":"sourcefile/upside_down.f90.html"},{"title":"read_commandline.f90 ‚Äì M_unicode","text":"Source Code program uni_to_ftn ! @(#) take command line argument utf-8 text and generate Fortran statement that represents the string use , intrinsic :: iso_fortran_env , only : stdout => output_unit implicit none character ( len =* ), parameter :: form = '(\"char(int(z''\",z0,\"''))\":,\"// &\")' character ( len =* ), parameter :: g = '(*(g0))' integer :: i character ( len = :), allocatable :: command_line command_line = getargs () ! get string containing all command arguments as CHARACTER bytes ! write the command line out as a Fortran variable expression using the CHAR() function write ( stdout , g ) '! ENCODING:[' , command_line // ']' write ( stdout , g ) 'character(len=*),parameter :: variable= &' write ( stdout , form )( ichar ( command_line ( i : i )), i = 1 , len ( command_line )) contains function getargs () result ( command_line ) integer :: length character ( len = :), allocatable :: command_line call get_command ( length = length ) ! get command line length allocate ( character ( len = length ) :: command_line ) ! allocate string big enough to hold command line call get_command ( command = command_line ) ! get command line as a string call get_command_argument ( 0 , length = length ) ! remove argument 0 command_line = command_line ( length + 2 :) end function getargs end program uni_to_ftn","tags":"","url":"sourcefile/read_commandline.f90.html"},{"title":"demo_codepoints_to_utf8.f90 ‚Äì M_unicode","text":"Source Code program demo_codepoints_to_utf8 use m_unicode , only : codepoints_to_utf8 implicit none !'Noho me ka hau‚Äôoli' !(Be happy) integer , parameter :: codepoints ( * ) = [ & & 78 , 111 , 104 , 111 ,& & 32 , 109 , 101 , & & 32 , 107 , 97 , & & 32 , 104 , 97 , 117 , 8217 , 111 , 108 , 105 ] character ( len = :), allocatable :: string character ( len = 1 ), allocatable :: bytes (:) character ( len =* ), parameter :: solid = '(*(g0))' character ( len =* ), parameter :: space = '(*(g0,1x))' character ( len =* ), parameter :: z = '(a,*(z0,1x))' integer :: nerr ! BASIC USAGE: SCALAR CHARACTER VARIABLE write ( * , space ) 'CODEPOINTS:' , codepoints write ( * , z ) 'HEXADECIMAL CODEPOINTS:' , codepoints call codepoints_to_utf8 ( codepoints , string , nerr ) write ( * , solid ) 'STRING:' , string ! write ( * , space ) 'How long is this string in glyphs? ' write ( * , space ) size ( codepoints ) write ( * , space ) 'How long is this string in bytes? ' write ( * , space ) len ( string ) ! ! BASIC USAGE: ARRAY OF BYTES call codepoints_to_utf8 ( codepoints , bytes , nerr ) write ( * , solid ) 'STRING:' , bytes ! write ( * , space ) 'How long is this string in glyphs? ' write ( * , space ) size ( codepoints ) write ( * , space ) 'How long is this string in bytes? ' write ( * , space ) size ( bytes ) ! end program demo_codepoints_to_utf8","tags":"","url":"sourcefile/demo_codepoints_to_utf8.f90.html"},{"title":"demo_verify.f90 ‚Äì M_unicode","text":"Source Code program demo_verify ! general examples use M_unicode , only : assignment ( = ) use M_unicode , only : ut => unicode_type , ch => character use M_unicode , only : write ( formatted ) use M_unicode , only : operator ( == ) use M_unicode , only : verify , replace use M_unicode , only : operator ( // ) implicit none ! some useful character sets character , parameter :: & & int * ( * ) = \"1234567890\" , & & low * ( * ) = \"abcdefghijklmnopqrstuvwxyz\" , & & upp * ( * ) = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" , & & punc * ( * ) = \"!\"\"#$%&'()*+,‚Äê./:;<=>?@['_‚Äò{|}Àú\" , & & blank * ( * ) = \" \" , & & tab = char ( 11 ), & & prnt * ( * ) = int // low // upp // blank // punc ! type ( ut ) :: stru integer :: i print * , \"basics:\" print * , VERIFY ( \"ABBA\" , \"A\" ) ! has the value 2. print * , VERIFY ( \"ABBA\" , \"A\" , BACK = . TRUE .) ! has the value 3. print * , VERIFY ( \"ABBA\" , \"AB\" ) ! has the value 0. ! print * , \"find first non‚Äêuppercase letter\" ! will produce the location of \"d\", because there is no match in UPP write ( * , * ) \"something unmatched\" , verify ( ut ( \"ABCdEFG\" ), upp ) ! print * , \"if everything is matched return zero\" ! will produce 0 as all letters have a match write ( * , * ) & & \"everything matched\" , verify ( ut ( \"ffoorrttrraann\" ), \"nartrof\" ) ! print * , \"easily categorize strings as uppercase, lowercase, ...\" ! C-like functionality but does entire strings not just characters write ( * , * ) \"isdigit 123?\" , verify ( ut ( \"123\" ), int ) == 0 write ( * , * ) \"islower abc?\" , verify ( ut ( \"abc\" ), low ) == 0 write ( * , * ) \"isalpha aBc?\" , verify ( ut ( \"aBc\" ), low // upp ) == 0 write ( * , * ) \"isblank aBc dEf?\" , verify ( ut ( \"aBc dEf\" ), blank // tab ) /= 0 ! check if all printable characters stru = \"aB;cde,fgHI!Jklmno PQRSTU vwxyz\" write ( * , * ) \"isprint?\" , verify ( stru , prnt ) == 0 ! ! this now has a nonprintable tab character in it stru = replace ( stru , 10 , 10 , ut ( char ( 11 ))) write ( * , * ) \"isprint?\" , verify ( stru , prnt ) == 0 ! print * , \"VERIFY(3) is very powerful using expressions as masks\" ! verify(3) is often used in a logical expression stru = \" This is NOT all UPPERCASE \" write ( * , * ) \"all uppercase/spaces?\" , verify ( stru , blank // upp ) == 0 stru = \" This IS all uppercase \" write ( * , * ) \"stru=[\" // stru // \"]\" write ( * , * ) \"all uppercase/spaces?\" , verify ( stru , blank // upp ) == 0 ! ! set and show complex stru to be tested stru = \"  Check this out. Let me know  \" ! show the stru being examined write ( * , * ) \"stru=[\" // stru // \"]\" write ( * , * ) \"        \" // repeat ( int , 4 ) ! number line ! ! function returns a position just not a logical like C print * , \"returning a position not just a logical is useful\" ! which can be very useful for parsing strings write ( * , * ) \"first non‚Äêblank character\" , verify ( stru , blank ) write ( * , * ) \"last non‚Äêblank character\" , verify ( stru , blank , back = . true .) write ( * , * ) \"first non‚Äêletter non‚Äêblank\" , verify ( stru , low // upp // blank ) ! !VERIFY(3) is elemental (can check an array of strings in one call) print * , \"elemental\" ! are strings all letters (or blanks)? write ( * , * ) \"array of strings\" , verify ( & ! strings must all be same length, so force to length 10 & [ character ( len = 10 ) :: \"YES\" , \"ok\" , \"000\" , \"good one\" , \"Nope!\" ], & & low // upp // blank ) == 0 ! ! rarer, but the set can be an array, not just the strings to test ! you could do ISPRINT() this (harder) way :> write ( * , * ) \"isprint?\" , & & . not . all ( verify ( ut ( \"aBc\" ), [( char ( i ), i = 32 , 126 )]) == 1 ) ! instead of this way write ( * , * ) \"isprint?\" , verify ( ut ( \"aBc\" ), prnt ) == 0 ! end program demo_verify","tags":"","url":"sourcefile/demo_verify.f90.html"},{"title":"demo_M_unicode.f90 ‚Äì M_unicode","text":"Source Code program demo_M_unicode use , intrinsic :: iso_fortran_env , only : stdout => output_unit use M_unicode , only : tokenize , replace , character , upper , lower , len use M_unicode , only : unicode_type , assignment ( = ), operator ( // ) use M_unicode , only : ut => unicode_type , ch => character use M_unicode , only : write ( formatted ) type ( unicode_type ) :: string type ( unicode_type ) :: numeric , uppercase , lowercase type ( unicode_type ), allocatable :: array (:) character ( len =* ), parameter :: all = '(g0)' !character(len=*),parameter     :: uni='(DT)' uppercase = '–ê–ë–í–ì“ê–î–ï–Ñ–ñ–ó–ò–Ü–á–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–¨–Æ–Ø' lowercase = '–∞–±–≤–≥“ë–¥–µ—î–∂–∑–∏—ñ—ó–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—å—é—è' numeric = '0123456789' ! string = uppercase // numeric // lowercase ! print all , 'Original string:' print all , ch ( string ) print all , 'length in bytes :' , len ( string % character ()) print all , 'length in glyphs:' , len ( string ) print all ! print all , 'convert to all uppercase:' print all , ch ( UPPER ( string ) ) print all ! print all , 'convert to all lowercase:' print all , ch ( string % LOWER () ) print all ! print all , 'tokenize on spaces ... ' call TOKENIZE ( string , ut ( ' ' ), array ) print all , '... writing with A or G format:' , character ( array ) !print uni, ut('... writing with DT format'),array print all ! print all , 'case-insensitive replace:' print all , ch ( & & REPLACE ( string , & & ut ( '–∫–ª–º–Ω–æ–ø—Ä—Å' ), & & ut ( '--------' ), & & ignorecase = . true .) ) ! print all ! end program demo_M_unicode","tags":"","url":"sourcefile/demo_m_unicode.f90.html"},{"title":"demo_fmt.f90 ‚Äì M_unicode","text":"Source Code program demo_fmt use :: M_unicode , only : fmt , assignment ( = ) use :: M_unicode , only : ut => unicode_type , ch => character implicit none character ( len = :), allocatable :: Astr , Aformat type ( ut ) :: Ustr ! format can be CHARACTER Aformat = \"('[',i0,']')\" Astr = fmt ( 10 , Aformat ) write ( * , * ) 'result is ' , Astr ! format can be string Astr = fmt ( 1 0.0 / 3.0 , ut ( \"'[',g0.5,']'\" )) write ( * , * ) 'result is ' , Astr ! Output is a string, so use ch() write ( * , * ) 'result is ' , ch ( fmt (. true ., \"'The answer is [',g0,']'\" )) ! OOP Ustr = 'A B C' Ustr = Ustr % fmt ( \"'[',g0,']'\" ) write ( * , * ) 'result is ' , ch ( Ustr ) end program demo_fmt","tags":"","url":"sourcefile/demo_fmt.f90.html"},{"title":"demo_index.f90 ‚Äì M_unicode","text":"Source Code program demo_index use M_unicode , only : ut => unicode_type use M_unicode , only : assignment ( = ) use M_unicode , only : index implicit none type ( ut ) :: str character ( len =* ), parameter :: all = '(*(g0))' integer :: ii ! str = 'Huli i kƒìia kaula no kƒìia  ª≈çlelo' !bug!print all, index(str,'kƒìia').eq.8 ii = index ( str , 'kƒìia' ); print all , ii . eq . 8 ! ! return value is counted from the left end even if BACK=.TRUE. !bug!print all, index(str,'kƒìia',back=.true.).eq.22 ii = index ( str , 'kƒìia' , back = . true .); print all , ii . eq . 22 ! ! INDEX is case-sensitive !bug!print all, index(str,'Kƒìia').eq.0 ii = index ( str , 'Kƒìia' ); print all , ii . eq . 0 !<<<<<<<<<< !ifx bug: ifx (IFX) 2024.1.0 20240308 ! !example/demo_index.f90(17): error #6766: A binary defined OPERATOR !definition is missing or incorrect.   [EQ] !        print all, index(str,'k  ia',back=.true.).eq.22 !--------------------------------------------------&#94; !Original works with gfortran and flang_new and this works with ifx !        ii=ndex(str,'k  ia',back=.true.) !    print all, ii.eq.22 !>>>>>>>>>> end program demo_index","tags":"","url":"sourcefile/demo_index.f90.html"},{"title":"demo_expandtabs.f90 ‚Äì M_unicode","text":"Source Code program demo_expandtabs use M_unicode , only : expandtabs , ch => character , replace use M_unicode , only : assignment ( = ), ut => unicode_type implicit none type ( ut ) :: in type ( ut ) :: inexpanded character ( len = :), allocatable :: dat integer :: i dat = '  this is my string  ' ! change spaces to tabs to make a sample input do i = 1 , len ( dat ) if ( dat ( i : i ) == ' ' ) dat ( i : i ) = char ( 9 ) enddo in = dat ! inexpanded = expandtabs ( in ) write ( * , '(\"[\",a,\"]\")' ) ch ( inexpanded ) inexpanded = replace ( inexpanded , ut ( ' ' ), ut ( '_' )) write ( * , '(\"[\",a,\"]\")' ) ch ( inexpanded ) ! write ( * , '(\"[\",a,\"]\")' ) ch ( in % expandtabs ()) write ( * , '(\"[\",a,\"]\")' ) ch ( in % expandtabs ( tab_size = 8 )) write ( * , '(\"[\",a,\"]\")' ) ch ( in % expandtabs ( tab_size = 1 )) write ( * , '(\"[\",a,\"]\")' ) ch ( in % expandtabs ( tab_size = 0 )) ! end program demo_expandtabs","tags":"","url":"sourcefile/demo_expandtabs.f90.html"},{"title":"demo_get_env.f90 ‚Äì M_unicode","text":"Source Code program demo_get_env use M_unicode , only : get_env , ut => unicode_type use M_unicode , only : assignment ( = ), operator ( // ) implicit none type ( ut ) :: name type ( ut ) :: default type ( ut ) :: value type ( ut ) :: smiley integer :: i character ( len =* ), parameter :: bracket = '(1x,*(\"[\",a,\"]\",:))' ! smiley = 128515 ! set with Unicode code point name = 'UTF8' ! set with ASCII default = 'Have a nice day ' // smiley // '!' ! set with unicode_type ! ! arguments can be type(unicode_type) or character ! but type(unicode_type) is always returned value = get_env ( name , default ) value = get_env ( name % character (), default % character () ) value = get_env ( name , default % character () ) value = get_env ( name % character (), default ) ! write ( * , * ) value % character () ! ! print each glyph surrounded by brackets write ( * , bracket )( value % character ( i , i ), i = 1 , value % len ()) ! end program demo_get_env","tags":"","url":"sourcefile/demo_get_env.f90.html"},{"title":"codepoint.f90 ‚Äì M_unicode","text":"Source Code program test_for_iso_10646 use M_unicode use iso_fortran_env , only : stdout => output_unit implicit none type ( unicode_type ) :: smiley smiley = [ int ( z '1F603' )] write ( stdout , * ) 'Smiling face with open mouth' , smiley % character () ! üòÉ smiley = 'üòÉ' write ( stdout , * ) 'one CHARACTER string to one UNICODE_TYPE string' , smiley % character () smiley = [ '1üòÉ' , '2üòÉ' , '3üòÉ' , '4üòÉ' ] write ( stdout , * ) 'four CHARACTER strings becomes one UNICODE_TYPE string ' , smiley % character () smiley = 128515 write ( stdout , * ) 'one codepoint ' , smiley % character (), smiley % codepoint () smiley = [ 128515 , 128515 ] write ( stdout , * ) 'array of codepoint ' , smiley % character (), smiley % codepoint () end program test_for_iso_10646","tags":"","url":"sourcefile/codepoint.f90.html"},{"title":"bom_start.f90 ‚Äì M_unicode","text":"Source Code program bom_exe ! ! Create a Fortran source file starting with a utf-8 BOM to see if your ! compiler will compile it or fail because a character is not in the ! Fortran character set outside of a comment or literal string. ! ! When the first character of a file the BOM character indicates the file ! is UTF-8 encoded to some applications, although it is not universally ! required. ! ! Does your compiler compile the output file generated by this program? ! ! The Unicode value for the Byte Order Mark (BOM) character is ! U+FEFF. While it was originally used as a \"Zero Width No-Break Space,\" ! its modern purpose is solely to act as a BOM, indicating the file is ! Unicode encoded and, in the case of UTF-16 and UTF-32, its byte order ! (endianness). The BOM is often presented at the beginning of a file, ! though its use in UTF-8 files is primarily to signal the encoding, not ! to address byte order issues (which does not apply to UTF-8 encoding). ! ! if on a ULS (Unix-like system) the file(1) command should produce ! !     bom_start >>xx.f90 !     file xx.f90 !     xx.f90: Unicode text, UTF-8 (with BOM) text ! use iso_fortran_env , only : stdout => output_unit use M_unicode , only : unicode_type , assignment ( = ), unicode implicit none type ( unicode_type ) :: UT_bom UT_bom = 65279 ! the codepoint value for the BOM character UT_bom = int ( z 'FEFF' ) ! or equivalently UT_bom = unicode % bom ! alternatively use constant from module ! place BOM character at beginning of output write ( stdout , '(a)' , advance = 'no' ) UT_bom % character () ! add a minimal Fortran program to make a test program source write ( stdout , '(a)' ) & ! Note: making the first line a comment precludes it being a cpp(1) directive !       preventing the directive from failing because something precedes the \"#\" '!fortran ' ,& 'program testit ! Unicode BOM encoded to utf-8 bytes by Fortran' ,& '   write(*,*)\"This source file starts with BOM character\"' ,& '   write(*,*)\"(Unicode codepoint z\"\"FEFF\"\")!\"' ,& 'end program testit' end program bom_exe","tags":"","url":"sourcefile/bom_start.f90.html"},{"title":"demo_pad.f90 ‚Äì M_unicode","text":"Source Code program demo_pad use M_unicode , only : pad , assignment ( = ) !use M_unicode, only : write(formatted) use M_unicode , only : len use M_unicode , only : ch => character use M_unicode , only : ut => unicode_type implicit none type ( ut ) :: string type ( ut ) :: answer integer :: i !character(len=*),parameter :: u='(*(DT))' character ( len =* ), parameter :: u = '(*(g0))' ! string = 'abcdefghij' ! write ( * , * ) 'pad on right till 20 characters long' answer = pad ( string , 20 ) write ( * , '(\"[\",g0,\"]\",/)' ) answer % character () ! write ( * , * ) 'original is not trimmed for short length requests' answer = pad ( string , 5 ) write ( * , '(\"[\",g0,\"]\",/)' ) answer % character () ! i = 30 write ( * , * ) 'pad with specified string and left-justified integers' write ( * , '(1x,g0,1x,i0)' ) & & ch ( pad ( ut ( 'CHAPTER 1 : The beginning ' ), i , ut ( '.' ) )), 1 , & & ch ( pad ( ut ( 'CHAPTER 2 : The end ' ), i , ut ( '.' ) )), 1234 , & & ch ( pad ( ut ( 'APPENDIX ' ), i , ut ( '.' ) )), 1235 ! write ( * , * ) 'pad with specified string and right-justified integers' write ( * , '(1x,g0,i7)' ) & & ch ( pad ( ut ( 'CHAPTER 1 : The beginning ' ), i , ut ( '.' ) )), 1 , & & ch ( pad ( ut ( 'CHAPTER 2 : The end ' ), i , ut ( '.' ) )), 1234 , & & ch ( pad ( ut ( 'APPENDIX ' ), i , ut ( '.' ) )), 1235 ! write ( * , * ) 'pad on left with zeros' write ( * , u ) ch ( pad ( ut ( '12' ), 5 , ut ( '0' ), right = . false .)) ! write ( * , * ) 'various lengths with clip .true. and .false.' write ( * , u ) ch ( pad ( ut ( '12345 ' ), 30 , ut ( '_' ), right = . false .)) write ( * , u ) ch ( pad ( ut ( '12345 ' ), 30 , ut ( '_' ), right = . false ., clip = . true .)) write ( * , u ) ch ( pad ( ut ( '12345 ' ), 7 , ut ( '_' ), right = . false .)) write ( * , u ) ch ( pad ( ut ( '12345 ' ), 7 , ut ( '_' ), right = . false ., clip = . true .)) write ( * , u ) ch ( pad ( ut ( '12345 ' ), 6 , ut ( '_' ), right = . false .)) write ( * , u ) ch ( pad ( ut ( '12345 ' ), 6 , ut ( '_' ), right = . false ., clip = . true .)) write ( * , u ) ch ( pad ( ut ( '12345 ' ), 5 , ut ( '_' ), right = . false .)) write ( * , u ) ch ( pad ( ut ( '12345 ' ), 5 , ut ( '_' ), right = . false ., clip = . true .)) write ( * , u ) ch ( pad ( ut ( '12345 ' ), 4 , ut ( '_' ), right = . false .)) write ( * , u ) ch ( pad ( ut ( '12345 ' ), 4 , ut ( '_' ), right = . false ., clip = . true .)) end program demo_pad","tags":"","url":"sourcefile/demo_pad.f90.html"},{"title":"demo_len_trim.f90 ‚Äì M_unicode","text":"Source Code program demo_len_trim use M_unicode , only : ut => unicode_type , assignment ( = ) use M_unicode , only : len , len_trim use M_unicode , only : write ( formatted ) implicit none type ( ut ) :: string integer :: i ! basic usage string = \" how long is this string?     \" print '(DT)' , string print * , 'untrimmed length=' , len ( string ) print * , 'trimmed length=' , len_trim ( string ) ! ! print string, then print substring of string string = 'xxxxx   ' write ( * , '(*(DT))' ) string , string , string i = len_trim ( string ) print '(*(DT))' , string % sub ( 1 , i ), string % sub ( 1 , i ), string % sub ( 1 , i ) ! ! elemental example ele : block ! an array of strings may be used type ( ut ), allocatable :: tablet (:) tablet = [ & & ut ( ' how long is this string?     ' ),& & ut ( 'and this one?' )] write ( * , * ) 'untrimmed length=  ' , len ( tablet ) write ( * , * ) 'trimmed length=    ' , len_trim ( tablet ) write ( * , * ) 'sum trimmed length=' , sum ( len_trim ( tablet )) endblock ele ! end program demo_len_trim","tags":"","url":"sourcefile/demo_len_trim.f90.html"},{"title":"construct.f90 ‚Äì M_unicode","text":"Source Code program demo_construct use , intrinsic :: iso_fortran_env , only : stdout => output_unit use M_unicode type ( unicode_type ) :: ustr type ( unicode_type ), allocatable :: uarr (:) character ( len = :), allocatable :: astr integer :: i integer , allocatable :: iarr (:) character ( len =* ), parameter :: all = '(*(g0))' character ( len = 80 ), parameter :: fmts ( * ) = [ character ( len = 80 ) :: & '(*(g0,1x))' ,& '(*(z0,1x))' ,& \"(8('int(z\"\"',z0,'\"\")',:,','))\" ] ! Constructors ! UNICODE_VARIABLE = CHARACTER(LEN=*)|UNICODE_VARIABLE|INTEGER_ARRAY ! Using a character array to define a string array uarr = unicode_type ([ character ( len = 80 ) :: & 'Confucius never claimed to be a prophet, ' ,& 'but I think he foresaw AI! He said ' ,& '' ,& ' \"Â≠¶ËÄå‰∏çÊÄùÂàôÁΩîÔºåÊÄùËÄå‰∏çÂ≠¶ÂàôÊÆÜ\"' ,& 'or' ,& ' (xu√© √©r b√π sƒ´ z√© w«éng, sƒ´ √©r b√π xu√© z√© d√†i),' ,& 'which is also' ,& ' \"To learn without thinking is to be lost, ' ,& ' to think without learning is to be in danger\".' ]) uarr = trim ( uarr ) ! trim fixed-length bytes to ragged array do i = 1 , size ( uarr ) ! show lengths in glyphs astr = uarr ( i ) ! assign string to character write ( * , '(i3,\": \",a)' ) len ( uarr ( i )), astr enddo print * ! string to integer array of codepoints iarr = uarr ( 4 )% sub ( 3 , 10 ) do i = 1 , 3 print fmts ( i ), iarr enddo print * ! assign character variable to string ustr = 'Hello World and Ni Hao -- ‰Ω†Â•Ω  ' ! convert to intrinsic CHARACTER variable write ( * , all ) character ( ustr ) ! use intrinsic function names on strings write ( * , all ) len ( ustr ) write ( * , all ) len_trim ( ustr ) write ( * , all ) index ( ustr , '‰Ω†' ) print all , 'OOPS' ! VARIABLE%CHARACTER(start,end,step) returns a CHARACTER string ! VARIABLE%BYTE() returns an array of CHARACTER(len=1) values ! VARIABLE%CODEPOINT() returns an integer array of Unicode values write ( * , all ) ustr % character () ! convert to CHARACTER variable write ( * , all ) ustr % character ( 27 , 28 ) ! similar to LINE(27:28) write ( * , all ) ustr % character ( len ( ustr ), 1 , - 1 ) ! reverse string write ( * , all ) ustr % byte () ! convert to CHARACTER(LEN=1) type do i = 1 , size ( fmts ) write ( * , fmts ( i )) ustr % codepoint ( 27 , 28 ) ! convert to Unicode codepoints enddo end program demo_construct","tags":"","url":"sourcefile/construct.f90.html"},{"title":"count_glyphs.f90 ‚Äì M_unicode","text":"Source Code program count_glyphs ! @(#) read a utf-8 file and write it out with lines prefixed with glyph count of the line use , intrinsic :: iso_fortran_env , only : output_unit , input_unit use M_unicode implicit none intrinsic is_iostat_end character ( len =* ), parameter :: g = '(*(g0))' integer :: length integer :: length_ascii integer :: iostat character ( len = 1024 ) :: aline type ( unicode_type ) :: uline character ( len = 255 ) :: iomsg do read ( input_unit , '(a)' , iostat = iostat , iomsg = iomsg ) aline if ( iostat . eq . 0 ) then uline = trim ( aline ) length = len_trim ( uline ) length_ascii = len_trim ( uline % character ()) write ( output_unit , '(i5,\": \",i5,\": \",a)' ) length , length_ascii , uline % character ( 1 , length ) elseif ( is_iostat_end ( iostat )) then exit else write ( output_unit , g ) '<ERROR>' , trim ( iomsg ) exit endif enddo end program count_glyphs","tags":"","url":"sourcefile/count_glyphs.f90.html"},{"title":"M_unicode.F90 ‚Äì M_unicode","text":"Source Code !----------------------------------------------------------------------------------------------------------------------------------- #define  __INTEL_COMP        1 #define  __GFORTRAN_COMP     2 #define  __NVIDIA_COMP       3 #define  __NAG_COMP          4 #define  __flang__           5 #define  __UNKNOWN_COMP   9999 #define FLOAT128 #ifdef __INTEL_COMPILER #   define __COMPILER__ __INTEL_COMP #elif __GFORTRAN__ == 1 #   define __COMPILER__ __GFORTRAN_COMP #elif __flang__ #   undef FLOAT128 #   define __COMPILER__ __LLVM_FLANG_COMP #elif __NVCOMPILER #   undef FLOAT128 #   define __COMPILER__ __NVIDIA_COMP #else #   define __COMPILER__ __UNKNOWN_COMP #   warning  NOTE: UNKNOWN COMPILER #endif !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!     M_unicode(3f) - [M_unicode::INTRO] Unicode string module !!     (LICENSE:MIT) !! !!##DESCRIPTION !!    The M_unicode(3f) module is a collection of Fortran string !!    methods that work with UTF-8-encoded as well as ASCII-7 data via the !!    user-defined type \"unicode_type\". The type supports allocatable ragged !!    arrays where each element may be of differing length. !! !!    M_unicode(3f) includes routines for parsing, tokenizing, changing !!    case, substituting new strings for substrings, locating strings with !!    simple wildcard expressions, removing tabs and line terminators and !!    other string manipulations. !! !!    The M_unicode(3fm) module also supplements the Fortran built-in !!    intrinsics with overloads of operators and intrinsics that allow !!    type(unicode_type) to be used with intrinsic names in much the same !!    manner the intrinsics operate on CHARACTER variables. !! !!    Overloads of assignment, logical comparisons, and concatenation !!    using the // operator with strings (and other types) are included !!    as well as the intrinsics to make use of type(unicode_type) largely !!    consistent with standard CHARACTER string manipulations. !! !!    Nearly all the methods are available using OOP syntax as well as !!    procedurally. !! !!    The type components are not public to allow for use of the same !!    user code when using other modules such as M_utf8 which ultimately !!    will provide the same user interface but internally using ISO_10646 !!    internal encoding instead of an array of integers containing codepoints !!    (which is what M_unicode uses). This has the drawback of not permitting !!    easy use of array syntax directly on the codepoint array. Perhaps this !!    decision will change but in the meantime several methods such as REPLACE !!    and CHARACTER and SUB !! !!##SYNOPSIS !! !! !!   public methods: !! !!    TOKENS !! !!     split     subroutine parses string using specified delimiter !!               characters into tokens !!     tokenize  Parse a string into tokens. !! !!    EDITING !! !!     replace   function non-recursively globally replaces old !!               substring with new substring !! !!     transliterate  replace characters from old set with new set !! !!    CASE !! !!     upper   function converts string to uppercase !!     lower   function converts string to miniscule !! !!    STRING LENGTH !! !!     len        return the length of a string in glyphs !!     len_trim   find location of last non-whitespace glyph !! !!    PADDING !! !!     pad        pad string to at least specified length with pattern string !! !!    WHITE SPACE !! !!     trim         Remove trailing blank characters of a string !!     expandtabs   expand tab characters !!     adjustl      Left adjust a string !!     adjustr      Right adjust a string !! !!    ENCODING !! !!     character(STRING,start,end,inc)  converts a string to type CHARACTER. !! !!     escape                           expand C-like escape strings !! !!     codepoints_to_utf8(codepoints,utf8,nerr)  subroutine to convert !!                                               codepoints to UTF-8 bytes !!     utf8_to_codepoints(utf8,codepoints,nerr)  subroutine to convert !!                                               UTF-8 bytes to codepoints !! !!     STRING%character(start,end,inc)  OOP syntax for converting a string to !!                                      type CHARACTER. !!     STRING%bytes(start,end,inc)      Convert to an array of !!                                      CHARACTER(len=1) bytes. !!     STRING%codepoint(start,end,inc)  converts a string to an INTEGER !!                                      array of Unicode codepoints !! !! !!     char       converts an integer codepoint into a character !!     ichar      converts a type(unicode_type) glyph into an integer !!                codepoint !! !!    NUMERIC STRINGS !! !!     fmt       convert intrinsic to string using optional format !! !!    CHARACTER TESTS !! !!     ! based on Unicode codepoint, not dictionary order !! !!     lgt       Lexical greater than !!     lge       Lexical greater than or equal !!     leq       Lexical equal !!     lne       Lexical not equal !!     lle       Lexical less than or equal !!     llt       Lexical less than !! !! !!    IO !! !!     readline  read a text line from a file !! !!    LOCATION !! !!     index     Position of a substring within a string !!     scan      Scan a string for the presence of a set !!               of characters !!     verify    Scan a string for the absence of a set of characters !! !!    CONCATENATION !! !!    join              join elements of an array into a single string !!    operator(.cat.), !!    operator(//)      concatenate strings and/or convert intrinsics to !!                      strings and concatenate !! !!    SYSTEM !! !!     get_env    Get environment variable !!     get_arg    Get command line argument !! !!    MISCELLANEOUS !! !!     repeat        Repeated string concatenation !!     sort          Sort by Unicode codepoint value (not dictionary order) !! !!    BASE CONVERSION !!    QUOTES !!    NONALPHA !! !!    OOPS INTERFACE !! !!     An OOP (Object-Oriented Programming) interface to the M_unicode(3fm) !!     module provides an alternative interface to all the same procedures !!     except for SORT(3f) and CHAR(3f). !! !!##SEE ALSO !!     All the procedure descriptions are conglomerated into the single file !!     \"manual.txt\" for simple access not requiring access to man-pages or !!     browsers. !! !!     There are additional routines in other GPF modules for working with !!     expressions (M_calculator), time strings (M_time), random strings !!     (M_random, M_uuid), lists (M_list), and interfacing with the C regular !!     expression library (M_regex). !! !!##EXAMPLES !! !! !!     Each of the procedures includes an example program in the example/ !!     directory as well as a corresponding man(1) page for the procedure. !! !!  Sample program: !! !!    program demo_M_unicode !!    use,intrinsic :: iso_fortran_env, only : stdout=>output_unit !!    use M_unicode,only : tokenize, replace, character, upper, lower, len !!    use M_unicode,only : unicode_type, assignment(=), operator(//) !!    use M_unicode,only : ut => unicode_type, ch => character !!    use M_unicode,only : write(formatted) !!    type(unicode_type)             :: string !!    type(unicode_type)             :: numeric, uppercase, lowercase !!    type(unicode_type),allocatable :: array(:) !!    character(len=*),parameter     :: all='(g0)' !!    !character(len=*),parameter     :: uni='(DT)' !!    uppercase='–ê–ë–í–ì“ê–î–ï–Ñ–ñ–ó–ò–Ü–á–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–¨–Æ–Ø' !!    lowercase='–∞–±–≤–≥“ë–¥–µ—î–∂–∑–∏—ñ—ó–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—å—é—è' !!    numeric='0123456789' !!     ! !!     string=uppercase//numeric//lowercase !!     ! !!     print all, 'Original string:' !!     print all, ch(string) !!     print all, 'length in bytes :',len(string%character()) !!     print all, 'length in glyphs:',len(string) !!     print all !!     ! !!     print all, 'convert to all uppercase:' !!     print all, ch( UPPER(string) ) !!     print all !!     ! !!     print all, 'convert to all lowercase:' !!     print all, ch( string%LOWER() ) !!     print all !!     ! !!     print all, 'tokenize on spaces ... ' !!     call TOKENIZE(string,ut(' '),array) !!     print all, '... writing with A or G format:',character(array) !!     !print uni, ut('... writing with DT format'),array !!     print all !!     ! !!     print all, 'case-insensitive replace:' !!     print all, ch( & !!     & REPLACE(string, & !!     & ut('–∫–ª–º–Ω–æ–ø—Ä—Å'), & !!     & ut('--------'), & !!     & ignorecase=.true.) ) !!     ! !!     print all !!     ! !!    end program demo_M_unicode !! !!   Results: !! !!    > Original string: !!    > –ê–ë–í–ì“ê–î–ï–Ñ–ñ–ó–ò–Ü–á–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–¨–Æ–Ø0123456789 ... !!    > –∞–±–≤–≥“ë–¥–µ—î–∂–∑–∏—ñ—ó–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—å—é—è !!    > length in bytes : !!    > 144 !!    > length in glyphs: !!    > 78 !!    > !!    > convert to all uppercase: !!    > –ê–ë–í–ì“ê–î–ï–Ñ–ñ–ó–ò–Ü–á–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–¨–Æ–Ø0123456789 ... !!    > –ê–ë–í–ì“ê–î–ï–Ñ–ñ–ó–ò–Ü–á–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–¨–Æ–Ø !!    > !!    > !!    > tokenize on spaces ... !!    > ... writing with A or G format: !!    > –ê–ë–í–ì“ê–î–ï–Ñ–ñ–ó–ò–Ü–á–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–¨–Æ–Ø !!    > 0123456789 !!    > –∞–±–≤–≥“ë–¥–µ—î–∂–∑–∏—ñ—ó–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—å—é—è !!    > ... writing with DT format !!    > –ê–ë–í–ì“ê–î–ï–Ñ–ñ–ó–ò–Ü–á–ô–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–¨–Æ–Ø !!    > 0123456789 !!    > –∞–±–≤–≥“ë–¥–µ—î–∂–∑–∏—ñ—ó–π–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—å—é—è !!    > !!    > case-insensitive replace: !!    > –ê–ë–í–ì“ê–î–ï–Ñ–ñ–ó–ò–Ü–á–ô--------–¢–£–§–•–¶–ß–®–©–¨–Æ–Ø0123456789 ... !!    > –∞–±–≤–≥“ë–¥–µ—î–∂–∑–∏—ñ—ó–π--------—Ç—É—Ñ—Ö—Ü—á—à—â—å—é—è !! !!##AUTHOR !!     John S. Urban !! !!##LICENSE !!     MIT !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== module M_unicode ! ! Unicode-related procedures not requiring compiler support of ISO-10646 ! first presented in https://fortran-lang.discourse.group/t/how-to-use-utf-8-in-gfortran/9949 ! including enhancements and Latin support from Francois Jacq, 2025-08 ! use , intrinsic :: iso_fortran_env , only : stdin => input_unit use , intrinsic :: iso_fortran_env , only : stderr => error_unit use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none private PUBLIC :: unicode_type PUBLIC :: UTF8_TO_CODEPOINTS PUBLIC :: CODEPOINTS_TO_UTF8 public :: character public :: sort public :: upper public :: lower public :: expandtabs public :: escape public :: fmt PUBLIC :: AFMT public :: replace public :: transliterate public :: pad public :: join public :: readline public :: sub public :: adjustl public :: adjustr public :: index public :: len public :: len_trim public :: repeat public :: trim public :: split public :: tokenize public :: scan public :: verify public :: ichar public :: get_env public :: get_arg PUBLIC :: LLE , LLT , LNE , LEQ , LGT , LGE PUBLIC :: OPERATOR ( <= ), OPERATOR ( < ), OPERATOR ( /= ), OPERATOR ( == ), OPERATOR ( > ), OPERATOR ( >= ) public :: assignment ( = ) public :: operator (. cat .) public :: operator ( // ) PUBLIC :: write ( formatted ) ! just for use in the parent module for operator(//) and operator(.cat. ) private :: concat_g_g private :: concat_u_g , concat_g_u private :: concat_i_g , concat_g_i private :: concat_r_g , concat_g_r private :: concat_d_g , concat_g_d private :: concat_c_g , concat_g_c private :: concat_l_g , concat_g_l private :: concat_s_g , concat_g_s private :: a2s , s2a private :: binary_search private :: section_uu private :: section_ua private :: section_au private :: section_aa interface utf8_to_codepoints module procedure utf8_to_codepoints_str , utf8_to_codepoints_chars end interface utf8_to_codepoints interface codepoints_to_utf8 module procedure codepoints_to_utf8_str , codepoints_to_utf8_chars end interface codepoints_to_utf8 interface sort module procedure :: sort_quick_rx end interface sort interface verify module procedure :: verify_uu module procedure :: verify_ua module procedure :: verify_au end interface verify interface get_arg module procedure :: get_arg_ia module procedure :: get_arg_iu end interface get_arg interface get_env module procedure :: get_env_uu module procedure :: get_env_ua module procedure :: get_env_au module procedure :: get_env_aa end interface get_env interface escape module procedure :: escape_uu module procedure :: escape_ua module procedure :: escape_au module procedure :: escape_aa end interface escape interface scan module procedure :: scan_uu module procedure :: scan_ua end interface scan interface fmt module procedure :: fmt_ga , fmt_gs end interface fmt interface tokenize module procedure :: split_first_last , split_first_last_uaii , split_pos , split_pos_uail , split_tokens , split_tokens_uauu end interface tokenize interface split module procedure :: split_first_last , split_first_last_uaii , split_pos , split_pos_uail , split_tokens , split_tokens_uauu end interface split ! Assign a character sequence to a string. interface assignment ( = ) module procedure :: assign_str_char module procedure :: assign_strs_char module procedure :: assign_str_code module procedure :: assign_str_codes module procedure :: assign_char_str module procedure :: assign_ints_str end interface assignment ( = ) interface character module procedure :: str_to_char , strs_to_chars module procedure :: str_to_char_pos , strs_to_chars_pos module procedure :: str_to_char_range , strs_to_chars_range module procedure :: str_to_char_range_step , strs_to_chars_range_step end interface character interface replace module procedure :: replace_uuu , replace_uua , replace_uaa , replace_uau module procedure :: replace_aaa , replace_aua , replace_aau , replace_auu module procedure :: section_uu , section_ua , section_au , section_aa end interface replace interface transliterate module procedure :: transliterate_uuu , transliterate_uua , transliterate_uaa , transliterate_uau module procedure :: transliterate_aaa , transliterate_aua , transliterate_aau , transliterate_auu end interface transliterate ! INTRINSIC COMPATIBILITY interface adjustl ; module procedure :: adjustl_str ; end interface adjustl interface adjustr ; module procedure :: adjustr_str ; end interface adjustr interface len ; module procedure :: len_str ; end interface len interface len_trim ; module procedure :: len_trim_str ; end interface len_trim interface repeat ; module procedure :: repeat_str ; end interface repeat interface trim ; module procedure :: trim_str ; end interface trim interface ichar ; module procedure :: ichar_str ; end interface ichar interface index ; module procedure :: index_str_str , index_str_char , index_char_str ; end interface index interface lle ; module procedure :: lle_str_str , lle_str_char , lle_char_str ; end interface lle interface llt ; module procedure :: llt_str_str , llt_str_char , llt_char_str ; end interface llt interface lne ; module procedure :: lne_char_str , lne_str_char , lne_str_str ; end interface lne interface leq ; module procedure :: leq_char_str , leq_str_char , leq_str_str ; end interface leq interface lgt ; module procedure :: lgt_str_str , lgt_str_char , lgt_char_str ; end interface lgt interface lge ; module procedure :: lge_str_str , lge_str_char , lge_char_str ; end interface lge interface operator ( <= ); module procedure :: lle_str_str , lle_str_char , lle_char_str ; end interface operator ( <= ) interface operator ( < ); module procedure :: llt_str_str , llt_str_char , llt_char_str ; end interface operator ( < ) interface operator ( /= ); module procedure :: lne_char_str , lne_str_char , lne_str_str ; end interface operator ( /= ) interface operator ( == ); module procedure :: leq_char_str , leq_str_char , leq_str_str ; end interface operator ( == ) interface operator ( > ); module procedure :: lgt_str_str , lgt_str_char , lgt_char_str ; end interface operator ( > ) interface operator ( >= ); module procedure :: lge_str_str , lge_str_char , lge_char_str ; end interface operator ( >= ) ! ! F2023, 15.4.3.4.2p1: If the operator is an intrinsic-operator (R608), ! the number of dummy arguments shall be consistent with the intrinsic ! uses of that operator, and the types, kind type parameters, or ranks of ! the dummy arguments shall differ from those required for the intrinsic ! operation (10.1.5), treating a CLASS (*) dummy argument as not differing in type or kind. !                     ===================================================================== ! ! For example, how is the compiler supposed to know if it can call ! CONCAT_G_G for C1//C2 where both C1 and C2 are default character? It's ! ambiguous. ! Steve Lionel 2026-01-26 ! ! CONCAT_G_G worked with gfortran and flang because the default behavior is tried first ! and the overload is not tried unless the intrinsic cannot accept the arguments. ! a useful behavior, but an extension, so technically a bug as at least at the ! moment it is not flagged if ask for conformance to a standard. It means many little ! procedures need created instead to avoid the C1//C2 case. ! ! should expand the list to include additional non-default common kinds interface operator ( // ) module procedure :: concat_g_u , concat_u_g module procedure :: concat_g_i , concat_i_g module procedure :: concat_g_r , concat_r_g module procedure :: concat_g_d , concat_d_g module procedure :: concat_g_c , concat_c_g module procedure :: concat_g_l , concat_l_g !module procedure :: concat_g_s, concat_s_g end interface operator ( // ) interface operator (. cat .) module procedure :: concat_g_g !module procedure :: concat_uu_ end interface operator (. cat .) type :: unicode_type ! Unicode string type holding an arbitrary sequence of integer codes. !sequence ! not used for storage association; a kludge to prevent extending this type. private integer , allocatable :: codes (:) contains ! METHODS (type-bound procedures) : ! conversion procedure :: character => oop_character ! a single variable in UTF-8 encoding procedure :: ch => oop_character ! a single variable in UTF-8 encoding procedure :: codepoint => oop_codepoint ! codes of each glyph procedure :: byte => oop_byte ! stream of bytes in UTF-8 encoding procedure :: ichar => oop_ichar ! code of a single character ! intrinsics procedure :: adjustl => oop_adjustl procedure :: adjustr => oop_adjustr procedure :: index => oop_index procedure :: len => oop_len procedure :: len_trim => oop_len_trim procedure :: trim => oop_trim procedure :: split => oop_split procedure :: tokenize => oop_tokenize procedure :: scan => oop_scan procedure :: verify => oop_verify ! transform procedure :: upper => oop_upper procedure :: lower => oop_lower procedure :: expandtabs => oop_expandtabs procedure :: escape => oop_escape procedure :: fmt => oop_fmt procedure :: sub => oop_sub procedure :: pad => oop_pad procedure :: join => oop_join procedure :: get_env => oop_get_env_uu , oop_get_env_ua procedure :: get_arg => oop_get_arg_iu procedure , private :: oop_transliterate_uu , oop_transliterate_aa , oop_transliterate_au , oop_transliterate_ua generic , public :: transliterate => oop_transliterate_uu , oop_transliterate_aa , oop_transliterate_au , oop_transliterate_ua procedure , private :: oop_replace_uuu procedure , private :: oop_replace_uaa procedure , private :: oop_replace_uau procedure , private :: oop_replace_uua procedure , private :: oop_section_uu procedure , private :: oop_section_ua generic , public :: replace => oop_replace_uuu , oop_replace_uaa , oop_replace_uau , oop_replace_uua , & & oop_section_uu , oop_section_ua !DECLARATION OF OVERLOADED OPERATORS FOR TYPE(UNICODE_TYPE) procedure , private :: eq => oop_eq !   generic           :: operator(==) => oop_eq !   procedure,private :: ge => oop_ge !   generic           :: operator(>=) => oop_ge !   procedure,private :: lt => oop_lt !   generic           :: operator(<)  => oop_lt !   procedure,private :: gt => oop_gt !   generic           :: operator(>)  => oop_gt !   procedure,private :: le => oop_le !   generic           :: operator(<=) => oop_le !   procedure,private :: ne => oop_ne !   generic           :: operator(/=) => oop_ne !   procedure,private :: oop_g_g !   generic           :: operator(//) => oop_g_g end type unicode_type ! Constructor for new string instances interface unicode_type elemental module function new_str ( string ) result ( new ) character ( len =* ), intent ( in ), optional :: string type ( unicode_type ) :: new end function new_str module function new_strs ( strings ) result ( new ) character ( len =* ), intent ( in ) :: strings (:) type ( unicode_type ) :: new ( size ( strings )) end function new_strs module function new_codes ( codes ) result ( new ) integer , intent ( in ) :: codes (:) type ( unicode_type ) :: new end function new_codes end interface unicode_type ! space U+0020 32 Common Basic Latin Separator, Most common (normal ! ASCII space) ! ! no-break space U+00A0 160 Common Latin-1 Supplement Separator, ! Non-breaking space: identical to U+0020, but not a point at which a line ! may be broken. ! ! en quad U+2000 8192 General Punctuation Separator, Width of one en. U+2002 ! is canonically equivalent to this character; U+2002 is preferred. ! ! em quad U+2001 8193 ‚ÄÅ Common General Punctuation Separator, ! Also known as \"mutton quad\". Width of one em. U+2003 is ! canonically equivalent to this character; U+2003 is preferred. ! ! en space U+2002 8194   Common General Punctuation Separator, ! space Also known as \"nut\". Width of one en. U+2000 En Quad is ! canonically equivalent to this character; U+2002 is preferred. ! ! em space U+2003 8195  Common General Punctuation Separator, ! space Also known as \"mutton\". Width of one em. U+2001 Em Quad is ! canonically equivalent to this character; U+2003 is preferred. ! ! three-per-em space U+2004 8196 Common General Punctuation Separator, ! Also known as \"thick space\". One third of an em wide. ! ! four-per-em space U+2005 8197 Common General Punctuation Separator, ! space Also known as \"mid space\". One fourth of an em wide. ! ! six-per-em space U+2006 8198 Common General Punctuation Separator, ! space One sixth of an em wide. In computer typography, sometimes equated ! to U+2009. ! ! figure space U+2007 8199 Common General Punctuation Separator, In fonts ! with monospaced digits, equal to the width of one digit. ! ! punctuation space U+2008 8200 Common General Punctuation Separator, ! As wide as the narrow punctuation in a font, i.e. the advance width of ! the period or comma. ! ! thin space U+2009 8201 Common General Punctuation Separator, one-fifth ! (sometimes one-sixth) of an em wide. Recommended for use as a thousands ! separator for measures made with SI units. Unlike U+2002 to U+2008, ! its width may get adjusted in typesetting. ! ! hair space U+200A 8202 Common General Punctuation Separator, space ! Thinner than a thin space. ! ! narrow no-break space U+202F 8239 Common General Punctuation Separator, ! Similar in function to U+00A0 ! ! No-Break Space. When used with Mongolian, its width is usually one third ! of the normal space; in other context, its width sometimes resembles ! that of the Thin Space (U+2009). ! ! medium mathematical space U+205F 8287 ‚Åü Common General Punctuation ! Separator, space MMSP. Used in mathematical formulae. Four-eighteenths ! of an em. In mathematical typography, the widths of spaces are usually ! given in integral multiples of an eighteenth of an em, and 4/18 em ! may be used in several situations, for example between the a and the + ! and between the + and the b in the expression a + b. ! ! ideographic space U+3000 12288 „ÄÄ Yes No Common CJK Symbols and ! Punctuation Separator, As wide as a CJK character cell (fullwidth). Used, ! for example, in tai tou. integer , parameter :: G_SPACE = 32 integer , private , parameter :: spacescodes ( * ) = [ 32 , 160 , 8192 , 8193 , 8194 , 8195 , 8196 , 8197 , 8198 , 8199 , 8200 , 8201 , 8202 , 8239 , 8287 , 12288 ] ! Unicode lowercase to uppercase conversion mapping table ! The standard English lowercase \"i\" (U+0069) has a dot, which is called a \"tittle\". ! The uppercase dotted \"ƒ∞\" (U+0130) is a separate Unicode character that functions as the uppercase dotted \"i\". ! * U+0049 I LATIN CAPITAL LETTER I. ! * U+0130 ƒ∞ LATIN CAPITAL LETTER I WITH DOT ABOVE. ! * U+0069 i LATIN SMALL LETTER I. (dotted) ! * U+0131 ƒ± LATIN SMALL LETTER I DOTLESS ! So the problem is both \"LATIN SMALL LETTER I DOTLESS\" and \"LATIN SMALL LETTER I\" typically have uppercase \"LATIN CAPITAL LETTER I\" ! so a round trip will not put I back to a dotless I. Because doing ASCII outside of the table could have dotted as one set and ! undotted as another in the table but the routine would still have the same issue. integer , parameter :: lowhigh = 666 integer , parameter :: low_to_up ( lowhigh , 2 ) = reshape ([ & int ( z '0061' ), int ( z '0041' ), & ! LATIN SMALL LETTER A => LATIN CAPITAL LETTER A int ( z '0062' ), int ( z '0042' ), & ! LATIN SMALL LETTER B => LATIN CAPITAL LETTER B int ( z '0063' ), int ( z '0043' ), & ! LATIN SMALL LETTER C => LATIN CAPITAL LETTER C int ( z '0064' ), int ( z '0044' ), & ! LATIN SMALL LETTER D => LATIN CAPITAL LETTER D int ( z '0065' ), int ( z '0045' ), & ! LATIN SMALL LETTER E => LATIN CAPITAL LETTER E int ( z '0066' ), int ( z '0046' ), & ! LATIN SMALL LETTER F => LATIN CAPITAL LETTER F int ( z '0067' ), int ( z '0047' ), & ! LATIN SMALL LETTER G => LATIN CAPITAL LETTER G int ( z '0068' ), int ( z '0048' ), & ! LATIN SMALL LETTER H => LATIN CAPITAL LETTER H int ( z '0069' ), int ( z '0049' ), & ! LATIN SMALL LETTER I => LATIN CAPITAL LETTER I int ( z '006A' ), int ( z '004A' ), & ! LATIN SMALL LETTER J => LATIN CAPITAL LETTER J int ( z '006B' ), int ( z '004B' ), & ! LATIN SMALL LETTER K => LATIN CAPITAL LETTER K int ( z '006C' ), int ( z '004C' ), & ! LATIN SMALL LETTER L => LATIN CAPITAL LETTER L int ( z '006D' ), int ( z '004D' ), & ! LATIN SMALL LETTER M => LATIN CAPITAL LETTER M int ( z '006E' ), int ( z '004E' ), & ! LATIN SMALL LETTER N => LATIN CAPITAL LETTER N int ( z '006F' ), int ( z '004F' ), & ! LATIN SMALL LETTER O => LATIN CAPITAL LETTER O int ( z '0070' ), int ( z '0050' ), & ! LATIN SMALL LETTER P => LATIN CAPITAL LETTER P int ( z '0071' ), int ( z '0051' ), & ! LATIN SMALL LETTER Q => LATIN CAPITAL LETTER Q int ( z '0072' ), int ( z '0052' ), & ! LATIN SMALL LETTER R => LATIN CAPITAL LETTER R int ( z '0073' ), int ( z '0053' ), & ! LATIN SMALL LETTER S => LATIN CAPITAL LETTER S int ( z '0074' ), int ( z '0054' ), & ! LATIN SMALL LETTER T => LATIN CAPITAL LETTER T int ( z '0075' ), int ( z '0055' ), & ! LATIN SMALL LETTER U => LATIN CAPITAL LETTER U int ( z '0076' ), int ( z '0056' ), & ! LATIN SMALL LETTER V => LATIN CAPITAL LETTER V int ( z '0077' ), int ( z '0057' ), & ! LATIN SMALL LETTER W => LATIN CAPITAL LETTER W int ( z '0078' ), int ( z '0058' ), & ! LATIN SMALL LETTER X => LATIN CAPITAL LETTER X int ( z '0079' ), int ( z '0059' ), & ! LATIN SMALL LETTER Y => LATIN CAPITAL LETTER Y int ( z '007A' ), int ( z '005A' ), & ! LATIN SMALL LETTER Z => LATIN CAPITAL LETTER Z int ( z '00E0' ), int ( z '00C0' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A GRAVE int ( z '00E1' ), int ( z '00C1' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A ACUTE int ( z '00E2' ), int ( z '00C2' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A CIRCUMFLEX int ( z '00E3' ), int ( z '00C3' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A TILDE int ( z '00E4' ), int ( z '00C4' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A DIAERESIS int ( z '00E5' ), int ( z '00C5' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A RING int ( z '00E6' ), int ( z '00C6' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A E int ( z '00E7' ), int ( z '00C7' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER C CEDILLA int ( z '00E8' ), int ( z '00C8' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER E GRAVE int ( z '00E9' ), int ( z '00C9' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER E ACUTE int ( z '00EA' ), int ( z '00CA' ), & ! LATIN SMALL LETTER E CIRCUMFLEX => LATIN CAPITAL LETTER E CIRCUMFLEX int ( z '00EB' ), int ( z '00CB' ), & ! LATIN SMALL LETTER E DIAERESIS => LATIN CAPITAL LETTER E DIAERESIS int ( z '00EC' ), int ( z '00CC' ), & ! LATIN SMALL LETTER I GRAVE => LATIN CAPITAL LETTER I GRAVE int ( z '00ED' ), int ( z '00CD' ), & ! LATIN SMALL LETTER I ACUTE => LATIN CAPITAL LETTER I ACUTE int ( z '00EE' ), int ( z '00CE' ), & ! LATIN SMALL LETTER I CIRCUMFLEX => LATIN CAPITAL LETTER I CIRCUMFLEX int ( z '00EF' ), int ( z '00CF' ), & ! LATIN SMALL LETTER I DIAERESIS => LATIN CAPITAL LETTER I DIAERESIS int ( z '00F0' ), int ( z '00D0' ), & ! LATIN SMALL LETTER ETH => LATIN CAPITAL LETTER ETH int ( z '00F1' ), int ( z '00D1' ), & ! LATIN SMALL LETTER N TILDE => LATIN CAPITAL LETTER N TILDE int ( z '00F2' ), int ( z '00D2' ), & ! LATIN SMALL LETTER O GRAVE => LATIN CAPITAL LETTER O GRAVE int ( z '00F3' ), int ( z '00D3' ), & ! LATIN SMALL LETTER O ACUTE => LATIN CAPITAL LETTER O ACUTE int ( z '00F4' ), int ( z '00D4' ), & ! LATIN SMALL LETTER O CIRCUMFLEX => LATIN CAPITAL LETTER O CIRCUMFLEX int ( z '00F5' ), int ( z '00D5' ), & ! LATIN SMALL LETTER O TILDE => LATIN CAPITAL LETTER O TILDE int ( z '00F6' ), int ( z '00D6' ), & ! LATIN SMALL LETTER O DIAERESIS => LATIN CAPITAL LETTER O DIAERESIS int ( z '00F8' ), int ( z '00D8' ), & ! LATIN SMALL LETTER O SLASH => LATIN CAPITAL LETTER O SLASH int ( z '00F9' ), int ( z '00D9' ), & ! LATIN SMALL LETTER U GRAVE => LATIN CAPITAL LETTER U GRAVE int ( z '00FA' ), int ( z '00DA' ), & ! LATIN SMALL LETTER U ACUTE => LATIN CAPITAL LETTER U ACUTE int ( z '00FB' ), int ( z '00DB' ), & ! LATIN SMALL LETTER U CIRCUMFLEX => LATIN CAPITAL LETTER U CIRCUMFLEX int ( z '00FC' ), int ( z '00DC' ), & ! LATIN SMALL LETTER U DIAERESIS => LATIN CAPITAL LETTER U DIAERESIS int ( z '00FD' ), int ( z '00DD' ), & ! LATIN SMALL LETTER Y ACUTE => LATIN CAPITAL LETTER Y ACUTE int ( z '00FE' ), int ( z '00DE' ), & ! LATIN SMALL LETTER THORN => LATIN CAPITAL LETTER THORN int ( z '00FF' ), int ( z '0178' ), & ! LATIN SMALL LETTER Y DIAERESIS => LATIN CAPITAL LETTER Y WITH DIAERESIS int ( z '0101' ), int ( z '0100' ), & ! LATIN SMALL LETTER A WITH MACRON => LATIN CAPITAL LETTER A WITH MACRON int ( z '0103' ), int ( z '0102' ), & ! LATIN SMALL LETTER A WITH BREVE => LATIN CAPITAL LETTER A WITH BREVE int ( z '0105' ), int ( z '0104' ), & ! LATIN SMALL LETTER A WITH OGONEK => LATIN CAPITAL LETTER A WITH OGONEK int ( z '0107' ), int ( z '0106' ), & ! LATIN SMALL LETTER C WITH ACUTE => LATIN CAPITAL LETTER C WITH ACUTE int ( z '0109' ), int ( z '0108' ), & ! LATIN SMALL LETTER C WITH CIRCUMFLEX => LATIN CAPITAL LETTER C WITH CIRCUMFLEX int ( z '010B' ), int ( z '010A' ), & ! LATIN SMALL LETTER C WITH DOT ABOVE => LATIN CAPITAL LETTER C WITH DOT ABOVE int ( z '010D' ), int ( z '010C' ), & ! LATIN SMALL LETTER C WITH CARON => LATIN CAPITAL LETTER C WITH CARON int ( z '010F' ), int ( z '010E' ), & ! LATIN SMALL LETTER D WITH CARON => LATIN CAPITAL LETTER D WITH CARON int ( z '0111' ), int ( z '0110' ), & ! LATIN SMALL LETTER D WITH STROKE => LATIN CAPITAL LETTER D WITH STROKE int ( z '0113' ), int ( z '0112' ), & ! LATIN SMALL LETTER E WITH MACRON => LATIN CAPITAL LETTER E WITH MACRON int ( z '0115' ), int ( z '0114' ), & ! LATIN SMALL LETTER E WITH BREVE => LATIN CAPITAL LETTER E WITH BREVE int ( z '0117' ), int ( z '0116' ), & ! LATIN SMALL LETTER E WITH DOT ABOVE => LATIN CAPITAL LETTER E WITH DOT ABOVE int ( z '0119' ), int ( z '0118' ), & ! LATIN SMALL LETTER E WITH OGONEK => LATIN CAPITAL LETTER E WITH OGONEK int ( z '011B' ), int ( z '011A' ), & ! LATIN SMALL LETTER E WITH CARON => LATIN CAPITAL LETTER E WITH CARON int ( z '011D' ), int ( z '011C' ), & ! LATIN SMALL LETTER G WITH CIRCUMFLEX => LATIN CAPITAL LETTER G WITH CIRCUMFLEX int ( z '011F' ), int ( z '011E' ), & ! LATIN SMALL LETTER G WITH BREVE => LATIN CAPITAL LETTER G WITH BREVE int ( z '0121' ), int ( z '0120' ), & ! LATIN SMALL LETTER G WITH DOT ABOVE => LATIN CAPITAL LETTER G WITH DOT ABOVE int ( z '0123' ), int ( z '0122' ), & ! LATIN SMALL LETTER G WITH CEDILLA => LATIN CAPITAL LETTER G WITH CEDILLA int ( z '0125' ), int ( z '0124' ), & ! LATIN SMALL LETTER H WITH CIRCUMFLEX => LATIN CAPITAL LETTER H WITH CIRCUMFLEX int ( z '0127' ), int ( z '0126' ), & ! LATIN SMALL LETTER H WITH STROKE => LATIN CAPITAL LETTER H WITH STROKE int ( z '0129' ), int ( z '0128' ), & ! LATIN SMALL LETTER I WITH TILDE => LATIN CAPITAL LETTER I WITH TILDE int ( z '012B' ), int ( z '012A' ), & ! LATIN SMALL LETTER I WITH MACRON => LATIN CAPITAL LETTER I WITH MACRON int ( z '012D' ), int ( z '012C' ), & ! LATIN SMALL LETTER I WITH BREVE => LATIN CAPITAL LETTER I WITH BREVE int ( z '012F' ), int ( z '012E' ), & ! LATIN SMALL LETTER I WITH OGONEK => LATIN CAPITAL LETTER I WITH OGONEK int ( z '0131' ), int ( z '0049' ), & ! LATIN SMALL LETTER DOTLESS I => LATIN CAPITAL LETTER I int ( z '0133' ), int ( z '0132' ), & ! LATIN SMALL LIGATURE IJ => LATIN CAPITAL LIGATURE IJ int ( z '0135' ), int ( z '0134' ), & ! LATIN SMALL LETTER J WITH CIRCUMFLEX => LATIN CAPITAL LETTER J WITH CIRCUMFLEX int ( z '0137' ), int ( z '0136' ), & ! LATIN SMALL LETTER K WITH CEDILLA => LATIN CAPITAL LETTER K WITH CEDILLA int ( z '013A' ), int ( z '0139' ), & ! LATIN SMALL LETTER L WITH ACUTE => LATIN CAPITAL LETTER L WITH ACUTE int ( z '013C' ), int ( z '013B' ), & ! LATIN SMALL LETTER L WITH CEDILLA => LATIN CAPITAL LETTER L WITH CEDILLA int ( z '013E' ), int ( z '013D' ), & ! LATIN SMALL LETTER L WITH CARON => LATIN CAPITAL LETTER L WITH CARON int ( z '0140' ), int ( z '013F' ), & ! LATIN SMALL LETTER L WITH MIDDLE DOT => LATIN CAPITAL LETTER L WITH MIDDLE DOT int ( z '0142' ), int ( z '0141' ), & ! LATIN SMALL LETTER L WITH STROKE => LATIN CAPITAL LETTER L WITH STROKE int ( z '0144' ), int ( z '0143' ), & ! LATIN SMALL LETTER N WITH ACUTE => LATIN CAPITAL LETTER N WITH ACUTE int ( z '0146' ), int ( z '0145' ), & ! LATIN SMALL LETTER N WITH CEDILLA => LATIN CAPITAL LETTER N WITH CEDILLA int ( z '0148' ), int ( z '0147' ), & ! LATIN SMALL LETTER N WITH CARON => LATIN CAPITAL LETTER N WITH CARON int ( z '014B' ), int ( z '014A' ), & ! LATIN SMALL LETTER ENG (SAMI) => LATIN CAPITAL LETTER ENG (SAMI) int ( z '014D' ), int ( z '014C' ), & ! LATIN SMALL LETTER O WITH MACRON => LATIN CAPITAL LETTER O WITH MACRON int ( z '014F' ), int ( z '014E' ), & ! LATIN SMALL LETTER O WITH BREVE => LATIN CAPITAL LETTER O WITH BREVE int ( z '0151' ), int ( z '0150' ), & ! LATIN SMALL LETTER O WITH DOUBLE ACUTE => LATIN CAPITAL LETTER O WITH DOUBLE ACUTE int ( z '0153' ), int ( z '0152' ), & ! LATIN SMALL LIGATURE OE => LATIN CAPITAL LIGATURE OE int ( z '0155' ), int ( z '0154' ), & ! LATIN SMALL LETTER R WITH ACUTE => LATIN CAPITAL LETTER R WITH ACUTE int ( z '0157' ), int ( z '0156' ), & ! LATIN SMALL LETTER R WITH CEDILLA => LATIN CAPITAL LETTER R WITH CEDILLA int ( z '0159' ), int ( z '0158' ), & ! LATIN SMALL LETTER R WITH CARON => LATIN CAPITAL LETTER R WITH CARON int ( z '015B' ), int ( z '015A' ), & ! LATIN SMALL LETTER S WITH ACUTE => LATIN CAPITAL LETTER S WITH ACUTE int ( z '015D' ), int ( z '015C' ), & ! LATIN SMALL LETTER S WITH CIRCUMFLEX => LATIN CAPITAL LETTER S WITH CIRCUMFLEX int ( z '015F' ), int ( z '015E' ), & ! LATIN SMALL LETTER S WITH CEDILLA => LATIN CAPITAL LETTER S WITH CEDILLA int ( z '0161' ), int ( z '0160' ), & ! LATIN SMALL LETTER S WITH CARON => LATIN CAPITAL LETTER S WITH CARON int ( z '0163' ), int ( z '0162' ), & ! LATIN SMALL LETTER T WITH CEDILLA => LATIN CAPITAL LETTER T WITH CEDILLA int ( z '0165' ), int ( z '0164' ), & ! LATIN SMALL LETTER T WITH CARON => LATIN CAPITAL LETTER T WITH CARON int ( z '0167' ), int ( z '0166' ), & ! LATIN SMALL LETTER T WITH STROKE => LATIN CAPITAL LETTER T WITH STROKE int ( z '0169' ), int ( z '0168' ), & ! LATIN SMALL LETTER U WITH TILDE => LATIN CAPITAL LETTER U WITH TILDE int ( z '016B' ), int ( z '016A' ), & ! LATIN SMALL LETTER U WITH MACRON => LATIN CAPITAL LETTER U WITH MACRON int ( z '016D' ), int ( z '016C' ), & ! LATIN SMALL LETTER U WITH BREVE => LATIN CAPITAL LETTER U WITH BREVE int ( z '016F' ), int ( z '016E' ), & ! LATIN SMALL LETTER U WITH RING ABOVE => LATIN CAPITAL LETTER U WITH RING ABOVE int ( z '0171' ), int ( z '0170' ), & ! LATIN SMALL LETTER U WITH DOUBLE ACUTE => LATIN CAPITAL LETTER U WITH DOUBLE ACUTE int ( z '0173' ), int ( z '0172' ), & ! LATIN SMALL LETTER U WITH OGONEK => LATIN CAPITAL LETTER U WITH OGONEK int ( z '0175' ), int ( z '0174' ), & ! LATIN SMALL LETTER W WITH CIRCUMFLEX => LATIN CAPITAL LETTER W WITH CIRCUMFLEX int ( z '0177' ), int ( z '0176' ), & ! LATIN SMALL LETTER Y WITH CIRCUMFLEX => LATIN CAPITAL LETTER Y WITH CIRCUMFLEX int ( z '017A' ), int ( z '0179' ), & ! LATIN SMALL LETTER Z WITH ACUTE => LATIN CAPITAL LETTER Z WITH ACUTE int ( z '017C' ), int ( z '017B' ), & ! LATIN SMALL LETTER Z WITH DOT ABOVE => LATIN CAPITAL LETTER Z WITH DOT ABOVE int ( z '017E' ), int ( z '017D' ), & ! LATIN SMALL LETTER Z WITH CARON => LATIN CAPITAL LETTER Z WITH CARON int ( z '0183' ), int ( z '0182' ), & ! LATIN SMALL LETTER B WITH TOPBAR => LATIN CAPITAL LETTER B WITH TOPBAR int ( z '0185' ), int ( z '0184' ), & ! LATIN SMALL LETTER TONE SIX => LATIN CAPITAL LETTER TONE SIX int ( z '0188' ), int ( z '0187' ), & ! LATIN SMALL LETTER C WITH HOOK => LATIN CAPITAL LETTER C WITH HOOK int ( z '018C' ), int ( z '018B' ), & ! LATIN SMALL LETTER D WITH TOPBAR => LATIN CAPITAL LETTER D WITH TOPBAR int ( z '0192' ), int ( z '0191' ), & ! LATIN SMALL LETTER F WITH HOOK => LATIN CAPITAL LETTER F WITH HOOK int ( z '0199' ), int ( z '0198' ), & ! LATIN SMALL LETTER K WITH HOOK => LATIN CAPITAL LETTER K WITH HOOK int ( z '01A1' ), int ( z '01A0' ), & ! LATIN SMALL LETTER O WITH HORN => LATIN CAPITAL LETTER O WITH HORN int ( z '01A3' ), int ( z '01A2' ), & ! LATIN SMALL LETTER OI => LATIN CAPITAL LETTER OI int ( z '01A5' ), int ( z '01A4' ), & ! LATIN SMALL LETTER P WITH HOOK => LATIN CAPITAL LETTER P WITH HOOK int ( z '01A8' ), int ( z '01A7' ), & ! LATIN SMALL LETTER TONE TWO => LATIN CAPITAL LETTER TONE TWO int ( z '01AD' ), int ( z '01AC' ), & ! LATIN SMALL LETTER T WITH HOOK => LATIN CAPITAL LETTER T WITH HOOK int ( z '01B0' ), int ( z '01AF' ), & ! LATIN SMALL LETTER U WITH HORN => LATIN CAPITAL LETTER U WITH HORN int ( z '01B4' ), int ( z '01B3' ), & ! LATIN SMALL LETTER Y WITH HOOK => LATIN CAPITAL LETTER Y WITH HOOK int ( z '01B6' ), int ( z '01B5' ), & ! LATIN SMALL LETTER Z WITH STROKE => LATIN CAPITAL LETTER Z WITH STROKE int ( z '01B9' ), int ( z '01B8' ), & ! LATIN SMALL LETTER EZH REVERSED => LATIN CAPITAL LETTER EZH REVERSED int ( z '01BD' ), int ( z '01BC' ), & ! LATIN SMALL LETTER TONE FIVE => LATIN CAPITAL LETTER TONE FIVE int ( z '01C6' ), int ( z '01C4' ), & ! LATIN SMALL LETTER DZ WITH CARON => LATIN CAPITAL LETTER DZ WITH CARON int ( z '01C9' ), int ( z '01C7' ), & ! LATIN SMALL LETTER LJ => LATIN CAPITAL LETTER LJ int ( z '01CC' ), int ( z '01CA' ), & ! LATIN SMALL LETTER NJ => LATIN CAPITAL LETTER NJ int ( z '01CE' ), int ( z '01CD' ), & ! LATIN SMALL LETTER A WITH CARON => LATIN CAPITAL LETTER A WITH CARON int ( z '01D0' ), int ( z '01CF' ), & ! LATIN SMALL LETTER I WITH CARON => LATIN CAPITAL LETTER I WITH CARON int ( z '01D2' ), int ( z '01D1' ), & ! LATIN SMALL LETTER O WITH CARON => LATIN CAPITAL LETTER O WITH CARON int ( z '01D4' ), int ( z '01D3' ), & ! LATIN SMALL LETTER U WITH CARON => LATIN CAPITAL LETTER U WITH CARON int ( z '01D6' ), int ( z '01D5' ), & ! LATIN SMALL LETTER U WITH DIAERESIS AND MACRON => LATIN CAPITAL LETTER U WITH DIAERESIS AND MACRON int ( z '01D8' ), int ( z '01D7' ), & ! LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE => LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE int ( z '01DA' ), int ( z '01D9' ), & ! LATIN SMALL LETTER U WITH DIAERESIS AND CARON => LATIN CAPITAL LETTER U WITH DIAERESIS AND CARON int ( z '01DC' ), int ( z '01DB' ), & ! LATIN SMALL LETTER U WITH DIAERESIS AND GRAVE => LATIN CAPITAL LETTER U WITH DIAERESIS AND GRAVE int ( z '01DF' ), int ( z '01DE' ), & ! LATIN SMALL LETTER A WITH DIAERESIS AND MACRON => LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON int ( z '01E1' ), int ( z '01E0' ), & ! LATIN SMALL LETTER A WITH DOT ABOVE AND MACRON => LATIN CAPITAL LETTER A WITH DOT ABOVE AND MACRON int ( z '01E3' ), int ( z '01E2' ), & ! LATIN SMALL LIGATURE AE WITH MACRON => LATIN CAPITAL LIGATURE AE MTH MACRON int ( z '01E5' ), int ( z '01E4' ), & ! LATIN SMALL LETTER G WITH STROKE => LATIN CAPITAL LETTER G WITH STROKE int ( z '01E7' ), int ( z '01E6' ), & ! LATIN SMALL LETTER G WITH CARON => LATIN CAPITAL LETTER G WITH CARON int ( z '01E9' ), int ( z '01E8' ), & ! LATIN SMALL LETTER K WITH CARON => LATIN CAPITAL LETTER K WITH CARON int ( z '01EB' ), int ( z '01EA' ), & ! LATIN SMALL LETTER O WITH OGONEK => LATIN CAPITAL LETTER O WITH OGONEK int ( z '01ED' ), int ( z '01EC' ), & ! LATIN SMALL LETTER O WITH OGONEK AND MACRON => LATIN CAPITAL LETTER O WITH OGONEK AND MACRON int ( z '01EF' ), int ( z '01EE' ), & ! LATIN SMALL LETTER EZH WITH CARON => LATIN CAPITAL LETTER EZH WITH CARON int ( z '01F3' ), int ( z '01F1' ), & ! LATIN SMALL LETTER DZ => LATIN CAPITAL LETTER DZ int ( z '01F5' ), int ( z '01F4' ), & ! LATIN SMALL LETTER G WITH ACUTE => LATIN CAPITAL LETTER G WITH ACUTE int ( z '01FB' ), int ( z '01FA' ), & ! LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE => LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE int ( z '01FD' ), int ( z '01FC' ), & ! LATIN SMALL LIGATURE AE WITH ACUTE => LATIN CAPITAL LIGATURE AE WITH ACUTE int ( z '01FF' ), int ( z '01FE' ), & ! LATIN SMALL LETTER O WITH STROKE AND ACUTE => LATIN CAPITAL LETTER O WITH STROKE AND ACUTE int ( z '0201' ), int ( z '0200' ), & ! LATIN SMALL LETTER A WITH DOUBLE GRAVE => LATIN CAPITAL LETTER A WITH DOUBLE GRAVE int ( z '0203' ), int ( z '0202' ), & ! LATIN SMALL LETTER A WITH INVERTED BREVE => LATIN CAPITAL LETTER A WITH INVERTED BREVE int ( z '0205' ), int ( z '0204' ), & ! LATIN SMALL LETTER E WITH DOUBLE GRAVE => LATIN CAPITAL LETTER E WITH DOUBLE GRAVE int ( z '0207' ), int ( z '0206' ), & ! LATIN SMALL LETTER E WITH INVERTED BREVE => LATIN CAPITAL LETTER E WITH INVERTED BREVE int ( z '0209' ), int ( z '0208' ), & ! LATIN SMALL LETTER I WITH DOUBLE GRAVE => LATIN CAPITAL LETTER I WITH DOUBLE GRAVE int ( z '020B' ), int ( z '020A' ), & ! LATIN SMALL LETTER I WITH INVERTED BREVE => LATIN CAPITAL LETTER I WITH INVERTED BREVE int ( z '020D' ), int ( z '020C' ), & ! LATIN SMALL LETTER O WITH DOUBLE GRAVE => LATIN CAPITAL LETTER O WITH DOUBLE GRAVE int ( z '020F' ), int ( z '020E' ), & ! LATIN SMALL LETTER O WITH INVERTED BREVE => LATIN CAPITAL LETTER O WITH INVERTED BREVE int ( z '0211' ), int ( z '0210' ), & ! LATIN SMALL LETTER R WITH DOUBLE GRAVE => LATIN CAPITAL LETTER R WITH DOUBLE GRAVE int ( z '0213' ), int ( z '0212' ), & ! LATIN SMALL LETTER R WITH INVERTED BREVE => LATIN CAPITAL LETTER R WITH INVERTED BREVE int ( z '0215' ), int ( z '0214' ), & ! LATIN SMALL LETTER U WITH DOUBLE GRAVE => LATIN CAPITAL LETTER U WITH DOUBLE GRAVE int ( z '0217' ), int ( z '0216' ), & ! LATIN SMALL LETTER U WITH INVERTED BREVE => LATIN CAPITAL LETTER U WITH INVERTED BREVE int ( z '0253' ), int ( z '0181' ), & ! LATIN SMALL LETTER B WITH HOOK => LATIN CAPITAL LETTER B WITH HOOK int ( z '0254' ), int ( z '0186' ), & ! LATIN SMALL LETTER OPEN O => LATIN CAPITAL LETTER OPEN O int ( z '0257' ), int ( z '018A' ), & ! LATIN SMALL LETTER D WITH HOOK => LATIN CAPITAL LETTER D WITH HOOK int ( z '0258' ), int ( z '018E' ), & ! LATIN SMALL LETTER REVERSED E => LATIN CAPITAL LETTER REVERSED E int ( z '0259' ), int ( z '018F' ), & ! LATIN SMALL LETTER SCHWA => LATIN CAPITAL LETTER SCHWA int ( z '025B' ), int ( z '0190' ), & ! LATIN SMALL LETTER OPEN E => LATIN CAPITAL LETTER OPEN E int ( z '0260' ), int ( z '0193' ), & ! LATIN SMALL LETTER G WITH HOOK => LATIN CAPITAL LETTER G WITH HOOK int ( z '0263' ), int ( z '0194' ), & ! LATIN SMALL LETTER GAMMA => LATIN CAPITAL LETTER GAMMA int ( z '0268' ), int ( z '0197' ), & ! LATIN SMALL LETTER I WITH STROKE => LATIN CAPITAL LETTER I WITH STROKE int ( z '0269' ), int ( z '0196' ), & ! LATIN SMALL LETTER IOTA => LATIN CAPITAL LETTER IOTA int ( z '026F' ), int ( z '019C' ), & ! LATIN SMALL LETTER TURNED M => LATIN CAPITAL LETTER TURNED M int ( z '0272' ), int ( z '019D' ), & ! LATIN SMALL LETTER N WITH LEFT HOOK => LATIN CAPITAL LETTER N WITH LEFT HOOK int ( z '0275' ), int ( z '019F' ), & ! LATIN SMALL LETTER BARRED O => LATIN CAPITAL LETTER O WITH MIDDLE TILDE int ( z '0283' ), int ( z '01A9' ), & ! LATIN SMALL LETTER ESH => LATIN CAPITAL LETTER ESH int ( z '0288' ), int ( z '01AE' ), & ! LATIN SMALL LETTER T WITH RETROFLEX HOOK => LATIN CAPITAL LETTER T WITH RETROFLEX HOOK int ( z '028A' ), int ( z '01B1' ), & ! LATIN SMALL LETTER UPSILON => LATIN CAPITAL LETTER UPSILON int ( z '028B' ), int ( z '01B2' ), & ! LATIN SMALL LETTER V WITH HOOK => LATIN CAPITAL LETTER V WITH HOOK int ( z '0292' ), int ( z '01B7' ), & ! LATIN SMALL LETTER EZH => LATIN CAPITAL LETTER EZH int ( z '03AC' ), int ( z '0386' ), & ! GREEK SMALL LETTER ALPHA WITH TONOS => GREEK CAPITAL LETTER ALPHA WITH TONOS int ( z '03AD' ), int ( z '0388' ), & ! GREEK SMALL LETTER EPSILON WITH TONOS => GREEK CAPITAL LETTER EPSILON WITH TONOS int ( z '03AE' ), int ( z '0389' ), & ! GREEK SMALL LETTER ETA WITH TONOS => GREEK CAPITAL LETTER ETA WITH TONOS int ( z '03AF' ), int ( z '038A' ), & ! GREEK SMALL LETTER IOTA WITH TONOS => GREEK CAPITAL LETTER IOTA WITH TONOS int ( z '03B1' ), int ( z '0391' ), & ! GREEK SMALL LETTER ALPHA => GREEK CAPITAL LETTER ALPHA int ( z '03B2' ), int ( z '0392' ), & ! GREEK SMALL LETTER BETA => GREEK CAPITAL LETTER BETA int ( z '03B3' ), int ( z '0393' ), & ! GREEK SMALL LETTER GAMMA => GREEK CAPITAL LETTER GAMMA int ( z '03B4' ), int ( z '0394' ), & ! GREEK SMALL LETTER DELTA => GREEK CAPITAL LETTER DELTA int ( z '03B5' ), int ( z '0395' ), & ! GREEK SMALL LETTER EPSILON => GREEK CAPITAL LETTER EPSILON int ( z '03B6' ), int ( z '0396' ), & ! GREEK SMALL LETTER ZETA => GREEK CAPITAL LETTER ZETA int ( z '03B7' ), int ( z '0397' ), & ! GREEK SMALL LETTER ETA => GREEK CAPITAL LETTER ETA int ( z '03B8' ), int ( z '0398' ), & ! GREEK SMALL LETTER THETA => GREEK CAPITAL LETTER THETA int ( z '03B9' ), int ( z '0399' ), & ! GREEK SMALL LETTER IOTA => GREEK CAPITAL LETTER IOTA int ( z '03BA' ), int ( z '039A' ), & ! GREEK SMALL LETTER KAPPA => GREEK CAPITAL LETTER KAPPA int ( z '03BB' ), int ( z '039B' ), & ! GREEK SMALL LETTER LAMDA => GREEK CAPITAL LETTER LAMDA int ( z '03BC' ), int ( z '039C' ), & ! GREEK SMALL LETTER MU => GREEK CAPITAL LETTER MU int ( z '03BD' ), int ( z '039D' ), & ! GREEK SMALL LETTER NU => GREEK CAPITAL LETTER NU int ( z '03BE' ), int ( z '039E' ), & ! GREEK SMALL LETTER XI => GREEK CAPITAL LETTER XI int ( z '03BF' ), int ( z '039F' ), & ! GREEK SMALL LETTER OMICRON => GREEK CAPITAL LETTER OMICRON int ( z '03C0' ), int ( z '03A0' ), & ! GREEK SMALL LETTER PI => GREEK CAPITAL LETTER PI int ( z '03C1' ), int ( z '03A1' ), & ! GREEK SMALL LETTER RHO => GREEK CAPITAL LETTER RHO int ( z '03C3' ), int ( z '03A3' ), & ! GREEK SMALL LETTER SIGMA => GREEK CAPITAL LETTER SIGMA int ( z '03C4' ), int ( z '03A4' ), & ! GREEK SMALL LETTER TAU => GREEK CAPITAL LETTER TAU int ( z '03C5' ), int ( z '03A5' ), & ! GREEK SMALL LETTER UPSILON => GREEK CAPITAL LETTER UPSILON int ( z '03C6' ), int ( z '03A6' ), & ! GREEK SMALL LETTER PHI => GREEK CAPITAL LETTER PHI int ( z '03C7' ), int ( z '03A7' ), & ! GREEK SMALL LETTER CHI => GREEK CAPITAL LETTER CHI int ( z '03C8' ), int ( z '03A8' ), & ! GREEK SMALL LETTER PSI => GREEK CAPITAL LETTER PSI int ( z '03C9' ), int ( z '03A9' ), & ! GREEK SMALL LETTER OMEGA => GREEK CAPITAL LETTER OMEGA int ( z '03CA' ), int ( z '03AA' ), & ! GREEK SMALL LETTER IOTA WITH DIALYTIKA => GREEK CAPITAL LETTER IOTA WITH DIALYTIKA int ( z '03CB' ), int ( z '03AB' ), & ! GREEK SMALL LETTER UPSILON WITH DIALYTIKA => GREEK CAPITAL LETTER UPSILON WITH DIALYTIKA int ( z '03CC' ), int ( z '038C' ), & ! GREEK SMALL LETTER OMICRON WITH TONOS => GREEK CAPITAL LETTER OMICRON WITH TONOS int ( z '03CD' ), int ( z '038E' ), & ! GREEK SMALL LETTER UPSILON WITH TONOS => GREEK CAPITAL LETTER UPSILON WITH TONOS int ( z '03CE' ), int ( z '038F' ), & ! GREEK SMALL LETTER OMEGA WITH TONOS => GREEK CAPITAL LETTER OMEGA WITH TONOS int ( z '03E3' ), int ( z '03E2' ), & ! COPTIC SMALL LETTER SHEI => COPTIC CAPITAL LETTER SHEI int ( z '03E5' ), int ( z '03E4' ), & ! COPTIC SMALL LETTER FEI => COPTIC CAPITAL LETTER FEI int ( z '03E7' ), int ( z '03E6' ), & ! COPTIC SMALL LETTER KHEI => COPTIC CAPITAL LETTER KHEI int ( z '03E9' ), int ( z '03E8' ), & ! COPTIC SMALL LETTER HORI => COPTIC CAPITAL LETTER HORI int ( z '03EB' ), int ( z '03EA' ), & ! COPTIC SMALL LETTER GANGIA => COPTIC CAPITAL LETTER GANGIA int ( z '03ED' ), int ( z '03EC' ), & ! COPTIC SMALL LETTER SHIMA => COPTIC CAPITAL LETTER SHIMA int ( z '03EF' ), int ( z '03EE' ), & ! COPTIC SMALL LETTER DEI => COPTIC CAPITAL LETTER DEI int ( z '0430' ), int ( z '0410' ), & ! CYRILLIC SMALL LETTER A => CYRILLIC CAPITAL LETTER A int ( z '0431' ), int ( z '0411' ), & ! CYRILLIC SMALL LETTER BE => CYRILLIC CAPITAL LETTER BE int ( z '0432' ), int ( z '0412' ), & ! CYRILLIC SMALL LETTER VE => CYRILLIC CAPITAL LETTER VE int ( z '0433' ), int ( z '0413' ), & ! CYRILLIC SMALL LETTER GHE => CYRILLIC CAPITAL LETTER GHE int ( z '0434' ), int ( z '0414' ), & ! CYRILLIC SMALL LETTER DE => CYRILLIC CAPITAL LETTER DE int ( z '0435' ), int ( z '0415' ), & ! CYRILLIC SMALL LETTER IE => CYRILLIC CAPITAL LETTER IE int ( z '0436' ), int ( z '0416' ), & ! CYRILLIC SMALL LETTER ZHE => CYRILLIC CAPITAL LETTER ZHE int ( z '0437' ), int ( z '0417' ), & ! CYRILLIC SMALL LETTER ZE => CYRILLIC CAPITAL LETTER ZE int ( z '0438' ), int ( z '0418' ), & ! CYRILLIC SMALL LETTER I => CYRILLIC CAPITAL LETTER I int ( z '0439' ), int ( z '0419' ), & ! CYRILLIC SMALL LETTER SHORT I => CYRILLIC CAPITAL LETTER SHORT I int ( z '043A' ), int ( z '041A' ), & ! CYRILLIC SMALL LETTER KA => CYRILLIC CAPITAL LETTER KA int ( z '043B' ), int ( z '041B' ), & ! CYRILLIC SMALL LETTER EL => CYRILLIC CAPITAL LETTER EL int ( z '043C' ), int ( z '041C' ), & ! CYRILLIC SMALL LETTER EM => CYRILLIC CAPITAL LETTER EM int ( z '043D' ), int ( z '041D' ), & ! CYRILLIC SMALL LETTER EN => CYRILLIC CAPITAL LETTER EN int ( z '043E' ), int ( z '041E' ), & ! CYRILLIC SMALL LETTER O => CYRILLIC CAPITAL LETTER O int ( z '043F' ), int ( z '041F' ), & ! CYRILLIC SMALL LETTER PE => CYRILLIC CAPITAL LETTER PE int ( z '0440' ), int ( z '0420' ), & ! CYRILLIC SMALL LETTER ER => CYRILLIC CAPITAL LETTER ER int ( z '0441' ), int ( z '0421' ), & ! CYRILLIC SMALL LETTER ES => CYRILLIC CAPITAL LETTER ES int ( z '0442' ), int ( z '0422' ), & ! CYRILLIC SMALL LETTER TE => CYRILLIC CAPITAL LETTER TE int ( z '0443' ), int ( z '0423' ), & ! CYRILLIC SMALL LETTER U => CYRILLIC CAPITAL LETTER U int ( z '0444' ), int ( z '0424' ), & ! CYRILLIC SMALL LETTER EF => CYRILLIC CAPITAL LETTER EF int ( z '0445' ), int ( z '0425' ), & ! CYRILLIC SMALL LETTER HA => CYRILLIC CAPITAL LETTER HA int ( z '0446' ), int ( z '0426' ), & ! CYRILLIC SMALL LETTER TSE => CYRILLIC CAPITAL LETTER TSE int ( z '0447' ), int ( z '0427' ), & ! CYRILLIC SMALL LETTER CHE => CYRILLIC CAPITAL LETTER CHE int ( z '0448' ), int ( z '0428' ), & ! CYRILLIC SMALL LETTER SHA => CYRILLIC CAPITAL LETTER SHA int ( z '0449' ), int ( z '0429' ), & ! CYRILLIC SMALL LETTER SHCHA => CYRILLIC CAPITAL LETTER SHCHA int ( z '044A' ), int ( z '042A' ), & ! CYRILLIC SMALL LETTER HARD SIGN => CYRILLIC CAPITAL LETTER HARD SIGN int ( z '044B' ), int ( z '042B' ), & ! CYRILLIC SMALL LETTER YERU => CYRILLIC CAPITAL LETTER YERU int ( z '044C' ), int ( z '042C' ), & ! CYRILLIC SMALL LETTER SOFT SIGN => CYRILLIC CAPITAL LETTER SOFT SIGN int ( z '044D' ), int ( z '042D' ), & ! CYRILLIC SMALL LETTER E => CYRILLIC CAPITAL LETTER E int ( z '044E' ), int ( z '042E' ), & ! CYRILLIC SMALL LETTER YU => CYRILLIC CAPITAL LETTER YU int ( z '044F' ), int ( z '042F' ), & ! CYRILLIC SMALL LETTER YA => CYRILLIC CAPITAL LETTER YA int ( z '0451' ), int ( z '0401' ), & ! CYRILLIC SMALL LETTER IO => CYRILLIC CAPITAL LETTER IO int ( z '0452' ), int ( z '0402' ), & ! CYRILLIC SMALL LETTER DJE (SERBOCROATIAN) => CYRILLIC CAPITAL LETTER DJE (SERBOCROATIAN) int ( z '0453' ), int ( z '0403' ), & ! CYRILLIC SMALL LETTER GJE => CYRILLIC CAPITAL LETTER GJE int ( z '0454' ), int ( z '0404' ), & ! CYRILLIC SMALL LETTER UKRAINIAN IE => CYRILLIC CAPITAL LETTER UKRAINIAN IE int ( z '0455' ), int ( z '0405' ), & ! CYRILLIC SMALL LETTER DZE => CYRILLIC CAPITAL LETTER DZE int ( z '0456' ), int ( z '0406' ), & ! CYRILLIC SMALL LETTER BYELORUSSIAN-UKRAINIAN I => CYRILLIC CAPITAL LETTER BYELORUSSIAN_UKRAINIAN I int ( z '0457' ), int ( z '0407' ), & ! CYRILLIC SMALL LETTER YI (UKRAINIAN) => CYRILLIC CAPITAL LETTER YI (UKRAINIAN) int ( z '0458' ), int ( z '0408' ), & ! CYRILLIC SMALL LETTER JE => CYRILLIC CAPITAL LETTER JE int ( z '0459' ), int ( z '0409' ), & ! CYRILLIC SMALL LETTER LJE => CYRILLIC CAPITAL LETTER LJE int ( z '045A' ), int ( z '040A' ), & ! CYRILLIC SMALL LETTER NJE => CYRILLIC CAPITAL LETTER NJE int ( z '045B' ), int ( z '040B' ), & ! CYRILLIC SMALL LETTER TSHE (SERBOCROATIAN) => CYRILLIC CAPITAL LETTER TSHE (SERBOCROATIAN) int ( z '045C' ), int ( z '040C' ), & ! CYRILLIC SMALL LETTER KJE => CYRILLIC CAPITAL LETTER KJE int ( z '045E' ), int ( z '040E' ), & ! CYRILLIC SMALL LETTER SHORT U (BYELORUSSIAN) => CYRILLIC CAPITAL LETTER SHORT U (BYELORUSSIAN) int ( z '045F' ), int ( z '040F' ), & ! CYRILLIC SMALL LETTER DZHE => CYRILLIC CAPITAL LETTER DZHE int ( z '0461' ), int ( z '0460' ), & ! CYRILLIC SMALL LETTER OMEGA => CYRILLIC CAPITAL LETTER OMEGA int ( z '0463' ), int ( z '0462' ), & ! CYRILLIC SMALL LETTER YAT => CYRILLIC CAPITAL LETTER YAT int ( z '0465' ), int ( z '0464' ), & ! CYRILLIC SMALL LETTER IOTIFIED E => CYRILLIC CAPITAL LETTER IOTIFIED E int ( z '0467' ), int ( z '0466' ), & ! CYRILLIC SMALL LETTER LITTLE YUS => CYRILLIC CAPITAL LETTER LITTLE YUS int ( z '0469' ), int ( z '0468' ), & ! CYRILLIC SMALL LETTER IOTIFIED LITTLE YUS => CYRILLIC CAPITAL LETTER IOTIFIED LITTLE YUS int ( z '046B' ), int ( z '046A' ), & ! CYRILLIC SMALL LETTER BIG YUS => CYRILLIC CAPITAL LETTER BIG YUS int ( z '046D' ), int ( z '046C' ), & ! CYRILLIC SMALL LETTER IOTIFIED BIG YUS => CYRILLIC CAPITAL LETTER IOTIFIED BIG YUS int ( z '046F' ), int ( z '046E' ), & ! CYRILLIC SMALL LETTER KSI => CYRILLIC CAPITAL LETTER KSI int ( z '0471' ), int ( z '0470' ), & ! CYRILLIC SMALL LETTER PSI => CYRILLIC CAPITAL LETTER PSI int ( z '0473' ), int ( z '0472' ), & ! CYRILLIC SMALL LETTER FITA => CYRILLIC CAPITAL LETTER FITA int ( z '0475' ), int ( z '0474' ), & ! CYRILLIC SMALL LETTER IZHITSA => CYRILLIC CAPITAL LETTER IZHITSA int ( z '0477' ), int ( z '0476' ), & ! CYRILLIC SMALL LETTER IZHITSA WITH DOUBLE GRAVE ACCENT => CYRILLIC CAPITAL LETTER IZHITSA WITH DOUBLE GRAVE ACCENT int ( z '0479' ), int ( z '0478' ), & ! CYRILLIC SMALL LETTER UK => CYRILLIC CAPITAL LETTER UK int ( z '047B' ), int ( z '047A' ), & ! CYRILLIC SMALL LETTER ROUND OMEGA => CYRILLIC CAPITAL LETTER ROUND OMEGA int ( z '047D' ), int ( z '047C' ), & ! CYRILLIC SMALL LETTER OMEGA WITH TITLO => CYRILLIC CAPITAL LETTER OMEGA WITH TITLO int ( z '047F' ), int ( z '047E' ), & ! CYRILLIC SMALL LETTER OT => CYRILLIC CAPITAL LETTER OT int ( z '0481' ), int ( z '0480' ), & ! CYRILLIC SMALL LETTER KOPPA => CYRILLIC CAPITAL LETTER KOPPA int ( z '0491' ), int ( z '0490' ), & ! CYRILLIC SMALL LETTER GHE WITH UPTURN => CYRILLIC CAPITAL LETTER GHE WITH UPTURN int ( z '0493' ), int ( z '0492' ), & ! CYRILLIC SMALL LETTER GHE WITH STROKE => CYRILLIC CAPITAL LETTER GHE WITH STROKE int ( z '0495' ), int ( z '0494' ), & ! CYRILLIC SMALL LETTER GHE WITH MIDDLE HOOK => CYRILLIC CAPITAL LETTER GHE WITH MIDDLE HOOK int ( z '0497' ), int ( z '0496' ), & ! CYRILLIC SMALL LETTER ZHE WITH DESCENDER => CYRILLIC CAPITAL LETTER ZHE WITH DESCENDER int ( z '0499' ), int ( z '0498' ), & ! CYRILLIC SMALL LETTER ZE WITH DESCENDER => CYRILLIC CAPITAL LETTER ZE WITH DESCENDER int ( z '049B' ), int ( z '049A' ), & ! CYRILLIC SMALL LETTER KA WITH DESCENDER => CYRILLIC CAPITAL LETTER KA WITH DESCENDER int ( z '049D' ), int ( z '049C' ), & ! CYRILLIC SMALL LETTER KA WITH VERTICAL STROKE => CYRILLIC CAPITAL LETTER KA WITH VERTICAL STROKE int ( z '049F' ), int ( z '049E' ), & ! CYRILLIC SMALL LETTER KA WITH STROKE => CYRILLIC CAPITAL LETTER KA WITH STROKE int ( z '04A1' ), int ( z '04A0' ), & ! CYRILLIC SMALL LETTER EASHKIR KA => CYRILLIC CAPITAL LETTER BASHKIR KA int ( z '04A3' ), int ( z '04A2' ), & ! CYRILLIC SMALL LETTER EN WITH DESCENOER => CYRILLIC CAPITAL LETTER EN WITH DESCENDER int ( z '04A5' ), int ( z '04A4' ), & ! CYRILLIC SMALL LIGATURE EN GHE => CYRILLIC CAPITAL LIGATURE EN GHF int ( z '04A7' ), int ( z '04A6' ), & ! CYRILLIC SMALL LETTER PE WITH MIDDLE HOOK (ABKHASIAN) => CYRILLIC CAPITAL LETTER PE WITH MIDDLE HOOK (ABKHASIAN) int ( z '04A9' ), int ( z '04A8' ), & ! CYRILLIC SMALL LETTER ABKHASIAN HA => CYRILLIC CAPITAL LETTER ABKHASIAN HA int ( z '04AB' ), int ( z '04AA' ), & ! CYRILLIC SMALL LETTER ES WITH DESCENDER => CYRILLIC CAPITAL LETTER ES WITH DESCENDER int ( z '04AD' ), int ( z '04AC' ), & ! CYRILLIC SMALL LETTER TE WITH DESCENDER => CYRILLIC CAPITAL LETTER TE WITH DESCENDER int ( z '04AF' ), int ( z '04AE' ), & ! CYRILLIC SMALL LETTER STRAIGHT U => CYRILLIC CAPITAL LETTER STRAIGHT U int ( z '04B1' ), int ( z '04B0' ), & ! CYRILLIC SMALL LETTER STRAIGHT U WITH STROKE => CYRILLIC CAPITAL LETTER STRAIGHT U WITH STROKE int ( z '04B3' ), int ( z '04B2' ), & ! CYRILLIC SMALL LETTER HA WITH DESCENDER => CYRILLIC CAPITAL LETTER HA WITH DESCENDER int ( z '04B5' ), int ( z '04B4' ), & ! CYRILLIC SMALL LIGATURE TE TSE (ABKHASIAN) => CYRILLIC CAPITAL LIGATURE TE TSE (ABKHASIAN) int ( z '04B7' ), int ( z '04B6' ), & ! CYRILLIC SMALL LETTER CHE WITH DESCENDER => CYRILLIC CAPITAL LETTER CHE WITH DESCENDER int ( z '04B9' ), int ( z '04B8' ), & ! CYRILLIC SMALL LETTER CHE WITH VERTICAL STROKE => CYRILLIC CAPITAL LETTER CHE WITH VERTICAL STROKE int ( z '04BB' ), int ( z '04BA' ), & ! CYRILLIC SMALL LETTER SHHA => CYRILLIC CAPITAL LETTER SHHA int ( z '04BD' ), int ( z '04BC' ), & ! CYRILLIC SMALL LETTER ABKHASIAN CHE => CYRILLIC CAPITAL LETTER ABKHASIAN CHE int ( z '04BF' ), int ( z '04BE' ), & ! CYRILLIC SMALL LETTER ABKHASIAN CHE WITH DESCENDER => CYRILLIC CAPITAL LETTER ABKHASIAN CHE WITH DESCENDER int ( z '04C2' ), int ( z '04C1' ), & ! CYRILLIC SMALL LETTER ZHE WITH BREVE => CYRILLIC CAPITAL LETTER ZHE WITH BREVE int ( z '04C4' ), int ( z '04C3' ), & ! CYRILLIC SMALL LETTER KA WITH HOOK => CYRILLIC CAPITAL LETTER KA WITH HOOK int ( z '04C8' ), int ( z '04C7' ), & ! CYRILLIC SMALL LETTER EN WITH HOOK => CYRILLIC CAPITAL LETTER EN WITH HOOK int ( z '04CC' ), int ( z '04CB' ), & ! CYRILLIC SMALL LETTER KHAKASSIAN CHE => CYRILLIC CAPITAL LETTER KHAKASSIAN CHE int ( z '04D1' ), int ( z '04D0' ), & ! CYRILLIC SMALL LETTER A WITH BREVE => CYRILLIC CAPITAL LETTER A WITH BREVE int ( z '04D3' ), int ( z '04D2' ), & ! CYRILLIC SMALL LETTER A WITH DIAERESIS => CYRILLIC CAPITAL LETTER A WITH DIAERESIS int ( z '04D5' ), int ( z '04D4' ), & ! CYRILLIC SMALL LIGATURE A IE => CYRILLIC CAPITAL LIGATURE A IE int ( z '04D7' ), int ( z '04D6' ), & ! CYRILLIC SMALL LETTER IE WITH BREVE => CYRILLIC CAPITAL LETTER IE WITH BREVE int ( z '04D9' ), int ( z '04D8' ), & ! CYRILLIC SMALL LETTER SCHWA => CYRILLIC CAPITAL LETTER SCHWA int ( z '04DB' ), int ( z '04DA' ), & ! CYRILLIC SMALL LETTER SCHWA WITH DIAERESIS => CYRILLIC CAPITAL LETTER SCHWA WITH DIAERESIS int ( z '04DD' ), int ( z '04DC' ), & ! CYRILLIC SMALL LETTER ZHE WITH DIAERESIS => CYRILLIC CAPITAL LETTER ZHE WITH DIAERESIS int ( z '04DF' ), int ( z '04DE' ), & ! CYRILLIC SMALL LETTER ZE WITH DIAERESIS => CYRILLIC CAPITAL LETTER ZE WITH DIAERESIS int ( z '04E1' ), int ( z '04E0' ), & ! CYRILLIC SMALL LETTER ABKHASIAN DZE => CYRILLIC CAPITAL LETTER ABKHASIAN DZE int ( z '04E3' ), int ( z '04E2' ), & ! CYRILLIC SMALL LETTER I WITH MACRON => CYRILLIC CAPITAL LETTER I WITH MACRON int ( z '04E5' ), int ( z '04E4' ), & ! CYRILLIC SMALL LETTER I WITH DIAERESIS => CYRILLIC CAPITAL LETTER I WITH DIAERESIS int ( z '04E7' ), int ( z '04E6' ), & ! CYRILLIC SMALL LETTER O WITH DIAERESIS => CYRILLIC CAPITAL LETTER O WITH DIAERESIS int ( z '04E9' ), int ( z '04E8' ), & ! CYRILLIC SMALL LETTER BARRED O => CYRILLIC CAPITAL LETTER BARRED O int ( z '04EB' ), int ( z '04EA' ), & ! CYRILLIC SMALL LETTER BARRED O WITH DIAERESIS => CYRILLIC CAPITAL LETTER BARRED O WITH DIAERESIS int ( z '04EF' ), int ( z '04EE' ), & ! CYRILLIC SMALL LETTER U WITH MACRON => CYRILLIC CAPITAL LETTER U WITH MACRON int ( z '04F1' ), int ( z '04F0' ), & ! CYRILLIC SMALL LETTER U WITH DIAERESIS => CYRILLIC CAPITAL LETTER U WITH DIAERESIS int ( z '04F3' ), int ( z '04F2' ), & ! CYRILLIC SMALL LETTER U WITH DOUBLE ACUTE => CYRILLIC CAPITAL LETTER U WITH DOUBLE ACUTE int ( z '04F5' ), int ( z '04F4' ), & ! CYRILLIC SMALL LETTER CHE AITH DIAERESIS => CYRILLIC CAPITAL LETTER CHE WITH DIAERESIS int ( z '04F9' ), int ( z '04F8' ), & ! CYRILLIC SMALL LETTER YERU WITH DIAERESIS => CYRILLIC CAPITAL LETTER YERU WITH DIAERESIS int ( z '0561' ), int ( z '0531' ), & ! ARMENIAN SMALL LETTER AYB => ARMENIAN CAPITAL LETTER AYB int ( z '0562' ), int ( z '0532' ), & ! ARMENIAN SMALL LETTER BEN => ARMENIAN CAPITAL LETTER BEN int ( z '0563' ), int ( z '0533' ), & ! ARMENIAN SMALL LETTER GIM => ARMENIAN CAPITAL LETTER GIM int ( z '0564' ), int ( z '0534' ), & ! ARMENIAN SMALL LETTER DA => ARMENIAN CAPITAL LETTER DA int ( z '0565' ), int ( z '0535' ), & ! ARMENIAN SMALL LETTER ECH => ARMENIAN CAPITAL LETTER ECH int ( z '0566' ), int ( z '0536' ), & ! ARMENIAN SMALL LETTER ZA => ARMENIAN CAPITAL LETTER ZA int ( z '0567' ), int ( z '0537' ), & ! ARMENIAN SMALL LETTER EH => ARMENIAN CAPITAL LETTER EH int ( z '0568' ), int ( z '0538' ), & ! ARMENIAN SMALL LETTER ET => ARMENIAN CAPITAL LETTER ET int ( z '0569' ), int ( z '0539' ), & ! ARMENIAN SMALL LETTER TO => ARMENIAN CAPITAL LETTER TO int ( z '056A' ), int ( z '053A' ), & ! ARMENIAN SMALL LETTER ZHE => ARMENIAN CAPITAL LETTER ZHE int ( z '056B' ), int ( z '053B' ), & ! ARMENIAN SMALL LETTER INI => ARMENIAN CAPITAL LETTER INI int ( z '056C' ), int ( z '053C' ), & ! ARMENIAN SMALL LETTER LIWN => ARMENIAN CAPITAL LETTER LIWN int ( z '056D' ), int ( z '053D' ), & ! ARMENIAN SMALL LETTER XEH => ARMENIAN CAPITAL LETTER XEH int ( z '056E' ), int ( z '053E' ), & ! ARMENIAN SMALL LETTER CA => ARMENIAN CAPITAL LETTER CA int ( z '056F' ), int ( z '053F' ), & ! ARMENIAN SMALL LETTER KEN => ARMENIAN CAPITAL LETTER KEN int ( z '0570' ), int ( z '0540' ), & ! ARMENIAN SMALL LETTER HO => ARMENIAN CAPITAL LETTER HO int ( z '0571' ), int ( z '0541' ), & ! ARMENIAN SMALL LETTER JA => ARMENIAN CAPITAL LETTER JA int ( z '0572' ), int ( z '0542' ), & ! ARMENIAN SMALL LETTER GHAD => ARMENIAN CAPITAL LETTER GHAD int ( z '0573' ), int ( z '0543' ), & ! ARMENIAN SMALL LETTER CHEH => ARMENIAN CAPITAL LETTER CHEH int ( z '0574' ), int ( z '0544' ), & ! ARMENIAN SMALL LETTER MEN => ARMENIAN CAPITAL LETTER MEN int ( z '0575' ), int ( z '0545' ), & ! ARMENIAN SMALL LETTER YI => ARMENIAN CAPITAL LETTER YI int ( z '0576' ), int ( z '0546' ), & ! ARMENIAN SMALL LETTER NOW => ARMENIAN CAPITAL LETTER NOW int ( z '0577' ), int ( z '0547' ), & ! ARMENIAN SMALL LETTER SNA => ARMENIAN CAPITAL LETTER SHA int ( z '0578' ), int ( z '0548' ), & ! ARMENIAN SMALL LETTER VO => ARMENIAN CAPITAL LETTER VO int ( z '0579' ), int ( z '0549' ), & ! ARMENIAN SMALL LETTER CHA => ARMENIAN CAPITAL LETTER CHA int ( z '057A' ), int ( z '054A' ), & ! ARMENIAN SMALL LETTER PEH => ARMENIAN CAPITAL LETTER PEH int ( z '057B' ), int ( z '054B' ), & ! ARMENIAN SMALL LETTER JHEH => ARMENIAN CAPITAL LETTER JHEH int ( z '057C' ), int ( z '054C' ), & ! ARMENIAN SMALL LETTER RA => ARMENIAN CAPITAL LETTER RA int ( z '057D' ), int ( z '054D' ), & ! ARMENIAN SMALL LETTER SEH => ARMENIAN CAPITAL LETTER SEH int ( z '057E' ), int ( z '054E' ), & ! ARMENIAN SMALL LETTER VEW => ARMENIAN CAPITAL LETTER VEW int ( z '057F' ), int ( z '054F' ), & ! ARMENIAN SMALL LETTER TIWN => ARMENIAN CAPITAL LETTER TIWN int ( z '0580' ), int ( z '0550' ), & ! ARMENIAN SMALL LETTER REH => ARMENIAN CAPITAL LETTER REH int ( z '0581' ), int ( z '0551' ), & ! ARMENIAN SMALL LETTER CO => ARMENIAN CAPITAL LETTER CO int ( z '0582' ), int ( z '0552' ), & ! ARMENIAN SMALL LETTER YIWN => ARMENIAN CAPITAL LETTER YIWN int ( z '0583' ), int ( z '0553' ), & ! ARMENIAN SMALL LETTER PIWP => ARMENIAN CAPITAL LETTER PIWR int ( z '0584' ), int ( z '0554' ), & ! ARMENIAN SMALL LETTER KEH => ARMENIAN CAPITAL LETTER KEH int ( z '0585' ), int ( z '0555' ), & ! ARMENIAN SMALL LETTER OH => ARMENIAN CAPITAL LETTER OH int ( z '0586' ), int ( z '0556' ), & ! ARMENIAN SMALL LETTER FEH => ARMENIAN CAPITAL LETTER FEH int ( z '10D0' ), int ( z '10A0' ), & ! GEORGIAN LETTER AN => GEORGIAN CAPITAL LETTER AN (KHUTSURI) int ( z '10D1' ), int ( z '10A1' ), & ! GEORGIAN LETTER BAN => GEORGIAN CAPITAL LETTER BAN (KHUTSURI) int ( z '10D2' ), int ( z '10A2' ), & ! GEORGIAN LETTER GAN => GEORGIAN CAPITAL LETTER GAN (KHUTSURI) int ( z '10D3' ), int ( z '10A3' ), & ! GEORGIAN LETTER DON => GEORGIAN CAPITAL LETTER DON (KHUTSURI) int ( z '10D4' ), int ( z '10A4' ), & ! GEORGIAN LETTER EN => GEORGIAN CAPITAL LETTER EN (KHUTSURI) int ( z '10D5' ), int ( z '10A5' ), & ! GEORGIAN LETTER VIN => GEORGIAN CAPITAL LETTER VIN (KHUTSURI) int ( z '10D6' ), int ( z '10A6' ), & ! GEORGIAN LETTER ZEN => GEORGIAN CAPITAL LETTER ZEN (KHUTSURI) int ( z '10D7' ), int ( z '10A7' ), & ! GEORGIAN LETTER TAN => GEORGIAN CAPITAL LETTER TAN (KHUTSURI) int ( z '10D8' ), int ( z '10A8' ), & ! GEORGIAN LETTER IN => GEORGIAN CAPITAL LETTER IN (KHUTSURI) int ( z '10D9' ), int ( z '10A9' ), & ! GEORGIAN LETTER KAN => GEORGIAN CAPITAL LETTER KAN (KHUTSURI) int ( z '10DA' ), int ( z '10AA' ), & ! GEORGIAN LETTER LAS => GEORGIAN CAPITAL LETTER LAS (KHUTSURI) int ( z '10DB' ), int ( z '10AB' ), & ! GEORGIAN LETTER MAN => GEORGIAN CAPITAL LETTER MAN (KHUTSURI) int ( z '10DC' ), int ( z '10AC' ), & ! GEORGIAN LETTER NAR => GEORGIAN CAPITAL LETTER NAR (KHUTSURI) int ( z '10DD' ), int ( z '10AD' ), & ! GEORGIAN LETTER ON => GEORGIAN CAPITAL LETTER ON (KHUTSURI) int ( z '10DE' ), int ( z '10AE' ), & ! GEORGIAN LETTER PAR => GEORGIAN CAPITAL LETTER PAR (KHUTSURI) int ( z '10DF' ), int ( z '10AF' ), & ! GEORGIAN LETTER ZHAR => GEORGIAN CAPITAL LETTER ZHAR (KHUTSURI) int ( z '10E0' ), int ( z '10B0' ), & ! GEORGIAN LETTER RAE => GEORGIAN CAPITAL LETTER RAE (KHUTSURI) int ( z '10E1' ), int ( z '10B1' ), & ! GEORGIAN LETTER SAN => GEORGIAN CAPITAL LETTER SAN (KHUTSURI) int ( z '10E2' ), int ( z '10B2' ), & ! GEORGIAN LETTER TAR => GEORGIAN CAPITAL LETTER TAR (KHUTSURI) int ( z '10E3' ), int ( z '10B3' ), & ! GEORGIAN LETTER UN => GEORGIAN CAPITAL LETTER UN (KHUTSURI) int ( z '10E4' ), int ( z '10B4' ), & ! GEORGIAN LETTER PHAR => GEORGIAN CAPITAL LETTER PHAR (KHUTSURI) int ( z '10E5' ), int ( z '10B5' ), & ! GEORGIAN LETTER KHAR => GEORGIAN CAPITAL LETTER KHAR (KHUTSURI) int ( z '10E6' ), int ( z '10B6' ), & ! GEORGIAN LETTER GHAN => GEORGIAN CAPITAL LETTER GHAN (KHUTSURI) int ( z '10E7' ), int ( z '10B7' ), & ! GEORGIAN LETTER QAR => GEORGIAN CAPITAL LETTER QAR (KHUTSURI) int ( z '10E8' ), int ( z '10B8' ), & ! GEORGIAN LETTER SHIN => GEORGIAN CAPITAL LETTER SHIN (KHUTSURI) int ( z '10E9' ), int ( z '10B9' ), & ! GEORGIAN LETTER CHIN => GEORGIAN CAPITAL LETTER CHIN (KHUTSURI) int ( z '10EA' ), int ( z '10BA' ), & ! GEORGIAN LETTER CAN => GEORGIAN CAPITAL LETTER CAN (KHUTSURI) int ( z '10EB' ), int ( z '10BB' ), & ! GEORGIAN LETTER JIL => GEORGIAN CAPITAL LETTER JIL (KHUTSURI) int ( z '10EC' ), int ( z '10BC' ), & ! GEORGIAN LETTER CIL => GEORGIAN CAPITAL LETTER CIL (KHUTSURI) int ( z '10ED' ), int ( z '10BD' ), & ! GEORGIAN LETTER CHAR => GEORGIAN CAPITAL LETTER CHAR (KHUTSURI) int ( z '10EE' ), int ( z '10BE' ), & ! GEORGIAN LETTER XAN => GEORGIAN CAPITAL LETTER XAN (KHUTSURI) int ( z '10EF' ), int ( z '10BF' ), & ! GEORGIAN LETTER JHAN => GEORGIAN CAPITAL LETTER JHAN (KHUTSURI) int ( z '10F0' ), int ( z '10C0' ), & ! GEORGIAN LETTER HAE => GEORGIAN CAPITAL LETTER HAE (KHUTSURI) int ( z '10F1' ), int ( z '10C1' ), & ! GEORGIAN LETTER HE => GEORGIAN CAPITAL LETTER HE (KHUTSURI) int ( z '10F2' ), int ( z '10C2' ), & ! GEORGIAN LETTER HIE => GEORGIAN CAPITAL LETTER HIE (KHUTSURI) int ( z '10F3' ), int ( z '10C3' ), & ! GEORGIAN LETTER WE => GEORGIAN CAPITAL LETTER WE (KHUTSURI) int ( z '10F4' ), int ( z '10C4' ), & ! GEORGIAN LETTER HAR => GEORGIAN CAPITAL LETTER HAR (KHUTSURI) int ( z '10F5' ), int ( z '10C5' ), & ! GEORGIAN LETTER HOE => GEORGIAN CAPITAL LETTER HOE (KHUTSURI) int ( z '1E01' ), int ( z '1E00' ), & ! LATIN SMALL LETTER A WITH RING BELOW => LATIN CAPITAL LETTER A WITH RING BELOW int ( z '1E03' ), int ( z '1E02' ), & ! LATIN SMALL LETTER B WITH DOT ABOVE => LATIN CAPITAL LETTER B WITH DOT ABOVE int ( z '1E05' ), int ( z '1E04' ), & ! LATIN SMALL LETTER B WITH DOT BELOW => LATIN CAPITAL LETTER B WITH DOT BELOW int ( z '1E07' ), int ( z '1E06' ), & ! LATIN SMALL LETTER B WITH LINE BELOW => LATIN CAPITAL LETTER B WITH LINE BELOW int ( z '1E09' ), int ( z '1E08' ), & ! LATIN SMALL LETTER C WITH CEDILLA AND ACUTE => LATIN CAPITAL LETTER C WITH CEDILLA AND ACUTE int ( z '1E0B' ), int ( z '1E0A' ), & ! LATIN SMALL LETTER D WITH DOT ABOVE => LATIN CAPITAL LETTER D WITH DOT ABOVE int ( z '1E0D' ), int ( z '1E0C' ), & ! LATIN SMALL LETTER D WITH DOT BELOW => LATIN CAPITAL LETTER D WITH DOT BELOW int ( z '1E0F' ), int ( z '1E0E' ), & ! LATIN SMALL LETTER D WITH LINE BELOW => LATIN CAPITAL LETTER D WITH LINE BELOW int ( z '1E11' ), int ( z '1E10' ), & ! LATIN SMALL LETTER D WITH CEDILLA => LATIN CAPITAL LETTER D WITH CEDILLA int ( z '1E13' ), int ( z '1E12' ), & ! LATIN SMALL LETTER D WITH CIRCUMFLEX BELOW => LATIN CAPITAL LETTER D WITH CIRCUMFLEX BELOW int ( z '1E15' ), int ( z '1E14' ), & ! LATIN SMALL LETTER E WITH MACRON AND GRAVE => LATIN CAPITAL LETTER E WITH MACRON AND GRAVE int ( z '1E17' ), int ( z '1E16' ), & ! LATIN SMALL LETTER E WITH MACRON AND ACUTE => LATIN CAPITAL LETTER E WITH MACRON AND ACUTE int ( z '1E19' ), int ( z '1E18' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX BELOW => LATIN CAPITAL LETTER E WITH CIRCUMFLEX BELOW int ( z '1E1B' ), int ( z '1E1A' ), & ! LATIN SMALL LETTER E WITH TILDE BELOW => LATIN CAPITAL LETTER E WITH TILDE BELOW int ( z '1E1D' ), int ( z '1E1C' ), & ! LATIN SMALL LETTER E WITH CEDILLA AND BREVE => LATIN CAPITAL LETTER E WITH CEDILLA AND BREVE int ( z '1E1F' ), int ( z '1E1E' ), & ! LATIN SMALL LETTER F WITH DOT ABOVE => LATIN CAPITAL LETTER F WITH DOT ABOVE int ( z '1E21' ), int ( z '1E20' ), & ! LATIN SMALL LETTER G WITH MACRON => LATIN CAPITAL LETTER G WITH MACRON int ( z '1E23' ), int ( z '1E22' ), & ! LATIN SMALL LETTER H WITH DOT ABOVE => LATIN CAPITAL LETTER H WITH DOT ABOVE int ( z '1E25' ), int ( z '1E24' ), & ! LATIN SMALL LETTER H WITH DOT BELOW => LATIN CAPITAL LETTER H WITH DOT BELOW int ( z '1E27' ), int ( z '1E26' ), & ! LATIN SMALL LETTER H WITH DIAERESIS => LATIN CAPITAL LETTER H WITH DIAERESIS int ( z '1E29' ), int ( z '1E28' ), & ! LATIN SMALL LETTER H WITH CEDILLA => LATIN CAPITAL LETTER H WITH CEDILLA int ( z '1E2B' ), int ( z '1E2A' ), & ! LATIN SMALL LETTER H WITH BREVE BELOW => LATIN CAPITAL LETTER H WITH BREVE BELOW int ( z '1E2D' ), int ( z '1E2C' ), & ! LATIN SMALL LETTER I WITH TILDE BELOW => LATIN CAPITAL LETTER I WITH TILDE BELOW int ( z '1E2F' ), int ( z '1E2E' ), & ! LATIN SMALL LETTER I WITH DIAERESIS AND ACUTE => LATIN CAPITAL LETTER I WITH DIAERESIS AND ACUTE int ( z '1E31' ), int ( z '1E30' ), & ! LATIN SMALL LETTER K WITH ACUTE => LATIN CAPITAL LETTER K WITH ACUTE int ( z '1E33' ), int ( z '1E32' ), & ! LATIN SMALL LETTER K WITH DOT BELOW => LATIN CAPITAL LETTER K WITH DOT BELOW int ( z '1E35' ), int ( z '1E34' ), & ! LATIN SMALL LETTER K WITH LINE BELOW => LATIN CAPITAL LETTER K WITH LINE BELOW int ( z '1E37' ), int ( z '1E36' ), & ! LATIN SMALL LETTER L WITH DOT BELOW => LATIN CAPITAL LETTER L WITH DOT BELOW int ( z '1E39' ), int ( z '1E38' ), & ! LATIN SMALL LETTER L WITH DOT BELOW AND MACRON => LATIN CAPITAL LETTER L WITH DOT BELOW AND MACRON int ( z '1E3B' ), int ( z '1E3A' ), & ! LATIN SMALL LETTER L WITH LINE BELOW => LATIN CAPITAL LETTER L WITH LINE BELOW int ( z '1E3D' ), int ( z '1E3C' ), & ! LATIN SMALL LETTER L WITH CIRCUMFLEX BELOW => LATIN CAPITAL LETTER L WITH CIRCUMFLEX BELOW int ( z '1E3F' ), int ( z '1E3E' ), & ! LATIN SMALL LETTER M WITH ACUTE => LATIN CAPITAL LETTER M WITH ACUTE int ( z '1E41' ), int ( z '1E40' ), & ! LATIN SMALL LETTER M WITH DOT ABOVE => LATIN CAPITAL LETTER M WITH DOT ABOVE int ( z '1E43' ), int ( z '1E42' ), & ! LATIN SMALL LETTER M WITH DOT BELOW => LATIN CAPITAL LETTER M WITH DOT BELOW int ( z '1E45' ), int ( z '1E44' ), & ! LATIN SMALL LETTER N WITH DOT ABOVE => LATIN CAPITAL LETTER N WITH DOT ABOVE int ( z '1E47' ), int ( z '1E46' ), & ! LATIN SMALL LETTER N WITH DOT BELOW => LATIN CAPITAL LETTER N WITH DOT BELOW int ( z '1E49' ), int ( z '1E48' ), & ! LATIN SMALL LETTER N WITH LINE BELOW => LATIN CAPITAL LETTER N WITH LINE BELOW int ( z '1E4B' ), int ( z '1E4A' ), & ! LATIN SMALL LETTER N WITH CIRCUMFLEX BELOW => LATIN CAPITAL LETTER N WITH CIRCUMFLEX BELOW int ( z '1E4D' ), int ( z '1E4C' ), & ! LATIN SMALL LETTER O WITH TILDE AND ACUTE => LATIN CAPITAL LETTER O WITH TILDE AND ACUTE int ( z '1E4F' ), int ( z '1E4E' ), & ! LATIN SMALL LETTER O WITH TlLDE AND DIAERESIS => LATIN CAPITAL LETTER O WITH TILDE AND DIAERESIS int ( z '1E51' ), int ( z '1E50' ), & ! LATIN SMALL LETTER O WITH MACRON AND GRAVE => LATIN CAPITAL LETTER O WITH MACRON AND GRAVE int ( z '1E53' ), int ( z '1E52' ), & ! LATIN SMALL LETTER O WITH MACRON AND ACUTE => LATIN CAPITAL LETTER O WITH MACRON AND ACUTE int ( z '1E55' ), int ( z '1E54' ), & ! LATIN SMALL LETTER P WITH ACUTE => LATIN CAPITAL LETTER P WITH ACUTE int ( z '1E57' ), int ( z '1E56' ), & ! LATIN SMALL LETTER P WITH DOT ABOVE => LATIN CAPITAL LETTER P WITH DOT ABOVE int ( z '1E59' ), int ( z '1E58' ), & ! LATIN SMALL LETTER R WITH DOT ABOVE => LATIN CAPITAL LETTER R WITH DOT ABOVE int ( z '1E5B' ), int ( z '1E5A' ), & ! LATIN SMALL LETTER R WITH DOT BELOW => LATIN CAPITAL LETTER R WITH DOT BELOW int ( z '1E5D' ), int ( z '1E5C' ), & ! LATIN SMALL LETTER R WITH DOT BELOW AND MACRON => LATIN CAPITAL LETTER R WITH DOT BELOW AND MACRON int ( z '1E5F' ), int ( z '1E5E' ), & ! LATIN SMALL LETTER R WITH LINE BELOW => LATIN CAPITAL LETTER R WITH LINE BELOW int ( z '1E61' ), int ( z '1E60' ), & ! LATIN SMALL LETTER S WITH DOT ABOVE => LATIN CAPITAL LETTER S WITH DOT ABOVE int ( z '1E63' ), int ( z '1E62' ), & ! LATIN SMALL LETTER S WITH DOT BELOW => LATIN CAPITAL LETTER S WITH DOT BELOW int ( z '1E65' ), int ( z '1E64' ), & ! LATIN SMALL LETTER S WITH ACUTE AND DOT ABOVE => LATIN CAPITAL LETTER S WITH ACUTE AND DOT ABOVE int ( z '1E67' ), int ( z '1E66' ), & ! LATIN SMALL LETTER S WITH CARON AND DOT ABOVE => LATIN CAPITAL LETTER S WITH CARON AND DOT ABOVE int ( z '1E69' ), int ( z '1E68' ), & ! LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE => LATIN CAPITAL LETTER S WITH DOT BELOW AND DOT ABOVE int ( z '1E6B' ), int ( z '1E6A' ), & ! LATIN SMALL LETTER T WITH DOT ABOVE => LATIN CAPITAL LETTER T WITH DOT ABOVE int ( z '1E6D' ), int ( z '1E6C' ), & ! LATIN SMALL LETTER T WITH DOT BELOW => LATIN CAPITAL LETTER T WITH DOT BELOW int ( z '1E6F' ), int ( z '1E6E' ), & ! LATIN SMALL LETTER T WITH LINE BELOW => LATIN CAPITAL LETTER T WITH LINE BELOW int ( z '1E71' ), int ( z '1E70' ), & ! LATIN SMALL LETTER T WITH CIRCUMFLEX BELOW => LATIN CAPITAL LETTER T WITH CIRCUMFLEX BELOW int ( z '1E73' ), int ( z '1E72' ), & ! LATIN SMALL LETTER U WITH DIAERESIS BELOW => LATIN CAPITAL LETTER U WITH DIAERESIS BELOW int ( z '1E75' ), int ( z '1E74' ), & ! LATIN SMALL LETTER U WITH TILDE BELOW => LATIN CAPITAL LETTER U WITH TILDE BELOW int ( z '1E77' ), int ( z '1E76' ), & ! LATIN SMALL LETTER U WITH CIRCUMFLEX BELOW => LATIN CAPITAL LETTER U WITH CIRCUMFLEX BELOW int ( z '1E79' ), int ( z '1E78' ), & ! LATIN SMALL LETTER U WITH TILDE AND ACUTE => LATIN CAPITAL LETTER U WITH TILDE AND ACUTE int ( z '1E7B' ), int ( z '1E7A' ), & ! LATIN SMALL LETTER U WITH MACRON AND DIAERESIS => LATIN CAPITAL LETTER U WITH MACRON AND DIAERESIS int ( z '1E7D' ), int ( z '1E7C' ), & ! LATIN SMALL LETTER V WITH TILDE => LATIN CAPITAL LETTER V WITH TILDE int ( z '1E7F' ), int ( z '1E7E' ), & ! LATIN SMALL LETTER V WITH DOT BELOW => LATIN CAPITAL LETTER V WITH DOT BELOW int ( z '1E81' ), int ( z '1E80' ), & ! LATIN SMALL LETTER W WITH GRAVE => LATIN CAPITAL LETTER W WITH GRAVE int ( z '1E83' ), int ( z '1E82' ), & ! LATIN SMALL LETTER W WITH ACUTE => LATIN CAPITAL LETTER W WITH ACUTE int ( z '1E85' ), int ( z '1E84' ), & ! LATIN SMALL LETTER W WITH DIAERESIS => LATIN CAPITAL LETTER W WITH DIAERESIS int ( z '1E87' ), int ( z '1E86' ), & ! LATIN SMALL LETTER W WITH DOT ABOVE => LATIN CAPITAL LETTER W WITH DOT ABOVE int ( z '1E89' ), int ( z '1E88' ), & ! LATIN SMALL LETTER W WITH DOT BELOW => LATIN CAPITAL LETTER W WITH DOT BELOW int ( z '1E8B' ), int ( z '1E8A' ), & ! LATIN SMALL LETTER X WITH DOT ABOVE => LATIN CAPITAL LETTER X WITH DOT ABOVE int ( z '1E8D' ), int ( z '1E8C' ), & ! LATIN SMALL LETTER X WITH DIAERESIS => LATIN CAPITAL LETTER X5 WITH DIAERESIS int ( z '1E8F' ), int ( z '1E8E' ), & ! LATIN SMALL LETTER Y WITH DOT ABOVE => LATIN CAPITAL LETTER Y WITH DOT ABOVE int ( z '1E91' ), int ( z '1E90' ), & ! LATIN SMALL LETTER Z WITH CIRCUMFLEX => LATIN CAPITAL LETTER Z WITH CIRCUMFLEX int ( z '1E93' ), int ( z '1E92' ), & ! LATIN SMALL LETTER Z WITH DOT BELOW => LATIN CAPITAL LETTER Z WITH DOT BELOW int ( z '1E95' ), int ( z '1E94' ), & ! LATIN SMALL LETTER Z WITH LINE BELOW => LATIN CAPITAL LETTER Z WITH LINE BELOW int ( z '1EA1' ), int ( z '1EA0' ), & ! LATIN SMALL LETTER A WITH DOT BELOW => LATIN CAPITAL LETTER A WITH DOT BELOW int ( z '1EA3' ), int ( z '1EA2' ), & ! LATIN SMALL LETTER A WITH HOOK ABOVE => LATIN CAPITAL LETTER A WITH HOOK ABOVE int ( z '1EA5' ), int ( z '1EA4' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE => LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE int ( z '1EA7' ), int ( z '1EA6' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND GRAVE => LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND GRAVE int ( z '1EA9' ), int ( z '1EA8' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE => LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE int ( z '1EAB' ), int ( z '1EAA' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND TILDE => LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND TILDE int ( z '1EAD' ), int ( z '1EAC' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND DOT BELOW => LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND DOT BELOW int ( z '1EAF' ), int ( z '1EAE' ), & ! LATIN SMALL LETTER A WITH BREVE AND ACUTE => LATIN CAPITAL LETTER A WITH BREVE AND ACUTE int ( z '1EB1' ), int ( z '1EB0' ), & ! LATIN SMALL LETTER A WITH BREVE AND GRAVE => LATIN CAPITAL LETTER A WITH BREVE AND GRAVE int ( z '1EB3' ), int ( z '1EB2' ), & ! LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE => LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE int ( z '1EB5' ), int ( z '1EB4' ), & ! LATIN SMALL LETTER A WITH BREVE AND TILDE => LATIN CAPITAL LETTER A WITH BREVE AND TILDE int ( z '1EB7' ), int ( z '1EB6' ), & ! LATIN SMALL LETTER A WITH BREVE AND DOT BELOW => LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW int ( z '1EB9' ), int ( z '1EB8' ), & ! LATIN SMALL LETTER E WITH DOT BELOW => LATIN CAPITAL LETTER E WITH DOT BELOW int ( z '1EBB' ), int ( z '1EBA' ), & ! LATIN SMALL LETTER E WITH HOOK ABOVE => LATIN CAPITAL LETTER E WITH HOOK ABOVE int ( z '1EBD' ), int ( z '1EBC' ), & ! LATIN SMALL LETTER E WITH TILDE => LATIN CAPITAL LETTER E WITH TILDE int ( z '1EBF' ), int ( z '1EBE' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE => LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE int ( z '1EC1' ), int ( z '1EC0' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND GRAVE => LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE int ( z '1EC3' ), int ( z '1EC2' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE => LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE int ( z '1EC5' ), int ( z '1EC4' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND TILDE => LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND TILDE int ( z '1EC7' ), int ( z '1EC6' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW => LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND DOT BELOW int ( z '1EC9' ), int ( z '1EC8' ), & ! LATIN SMALL LETTER I WITH HOOK ABOVE => LATIN CAPITAL LETTER I WITH HOOK ABOVE int ( z '1ECB' ), int ( z '1ECA' ), & ! LATIN SMALL LETTER I WITH DOT BELOW => LATIN CAPITAL LETTER I WITH DOT BELOW int ( z '1ECD' ), int ( z '1ECC' ), & ! LATIN SMALL LETTER O WITH DOT BELOW => LATIN CAPITAL LETTER O WITH DOT BELOW int ( z '1ECF' ), int ( z '1ECE' ), & ! LATIN SMALL LETTER O WITH HOOK ABOVE => LATIN CAPITAL LETTER O WITH HOOK ABOVE int ( z '1ED1' ), int ( z '1ED0' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE => LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE int ( z '1ED3' ), int ( z '1ED2' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND GRAVE => LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND GRAVE int ( z '1ED5' ), int ( z '1ED4' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE => LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE int ( z '1ED7' ), int ( z '1ED6' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND TILDE => LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND TILDE int ( z '1ED9' ), int ( z '1ED8' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW => LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND DOT BELOW int ( z '1EDB' ), int ( z '1EDA' ), & ! LATIN SMALL LETTER O WITH HORN AND ACUTE => LATIN CAPITAL LETTER O WITH HORN AND ACUTE int ( z '1EDD' ), int ( z '1EDC' ), & ! LATIN SMALL LETTER O WITH HORN AND GRAVE => LATIN CAPITAL LETTER O WITH HORN AND GRAVE int ( z '1EDF' ), int ( z '1EDE' ), & ! LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE => LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE int ( z '1EE1' ), int ( z '1EE0' ), & ! LATIN SMALL LETTER O WITH HORN AND TILDE => LATIN CAPITAL LETTER O WITH HORN AND TILDE int ( z '1EE3' ), int ( z '1EE2' ), & ! LATIN SMALL LETTER O WITH HORN AND DOT BELOW => LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW int ( z '1EE5' ), int ( z '1EE4' ), & ! LATIN SMALL LETTER U WITH DOT BELOW => LATIN CAPITAL LETTER U WITH DOT BELOW int ( z '1EE7' ), int ( z '1EE6' ), & ! LATIN SMALL LETTER U WITH HOOK ABOVE => LATIN CAPITAL LETTER U WITH HOOK ABOVE int ( z '1EE9' ), int ( z '1EE8' ), & ! LATIN SMALL LETTER U WITH HORN AND ACUTE => LATIN CAPITAL LETTER U WITH HORN AND ACUTE int ( z '1EEB' ), int ( z '1EEA' ), & ! LATIN SMALL LETTER U WITH HORN AND GRAVE => LATIN CAPITAL LETTER U WITH HORN AND GRAVE int ( z '1EED' ), int ( z '1EEC' ), & ! LATIN SMALL LETTER U WITH HORN AND HOCK ABOVE => LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE int ( z '1EEF' ), int ( z '1EEE' ), & ! LATIN SMALL LETTER U WITH HORN AND TILDE => LATIN CAPITAL LETTER U WITH HORN AND TILDE int ( z '1EF1' ), int ( z '1EF0' ), & ! LATIN SMALL LETTER U WITH HORN AND DOT BELOW => LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW int ( z '1EF3' ), int ( z '1EF2' ), & ! LATIN SMALL LETTER Y WITH GRAVE => LATIN CAPITAL LETTER Y WITH GRAVE int ( z '1EF5' ), int ( z '1EF4' ), & ! LATIN SMALL LETTER Y WITH DOT BELOW => LATIN CAPITAL LETTER Y WITH DOT BELOW int ( z '1EF7' ), int ( z '1EF6' ), & ! LATIN SMALL LETTER Y WITH HOOK ABOVE => LATIN CAPITAL LETTER Y WITH HOOK ABOVE int ( z '1EF9' ), int ( z '1EF8' ), & ! LATIN SMALL LETTER Y WITH TILDE => LATIN CAPITAL LETTER Y WITH TILDE int ( z '1F00' ), int ( z '1F08' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI => GREEK CAPITAL LETTER ALPHA WITH PSILI int ( z '1F01' ), int ( z '1F09' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA => GREEK CAPITAL LETTER ALPHA WITH DASIA int ( z '1F02' ), int ( z '1F0A' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA => GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA int ( z '1F03' ), int ( z '1F0B' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA => GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA int ( z '1F04' ), int ( z '1F0C' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA => GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA int ( z '1F05' ), int ( z '1F0D' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA => GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA int ( z '1F06' ), int ( z '1F0E' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI => GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI int ( z '1F07' ), int ( z '1F0F' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI => GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI int ( z '1F10' ), int ( z '1F18' ), & ! GREEK SMALL LETTER EPSILON WITH PSILI => GREEK CAPITAL LETTER EPSILON WITH PSILI int ( z '1F11' ), int ( z '1F19' ), & ! GREEK SMALL LETTER EPSILON WITH DASIA => GREEK CAPITAL LETTER EPSILON WITH DASIA int ( z '1F12' ), int ( z '1F1A' ), & ! GREEK SMALL LETTER EPSILON WITH PSILI AND VARIA => GREEK CAPITAL LETTER EPSILON WITH PSILI AND VARIA int ( z '1F13' ), int ( z '1F1B' ), & ! GREEK SMALL LETTER EPSILON WITH DASIA AND VARIA => GREEK CAPITAL LETTER EPSILON WITH DASIA AND VARIA int ( z '1F14' ), int ( z '1F1C' ), & ! GREEK SMALL LETTER EPSILON WITH PSILI AND OXIA => GREEK CAPITAL LETTER EPSILON WITH PSILI AND OXIA int ( z '1F15' ), int ( z '1F1D' ), & ! GREEK SMALL LETTER EPSILON WITH DASIA AND OXIA => GREEK CAPITAL LETTER EPSILON WITH DASIA AND OXIA int ( z '1F20' ), int ( z '1F28' ), & ! GREEK SMALL LETTER ETA WITH PSILI => GREEK CAPITAL LETTER ETA WITH PSILI int ( z '1F21' ), int ( z '1F29' ), & ! GREEK SMALL LETTER ETA WITH DASIA => GREEK CAPITAL LETTER ETA WITH DASIA int ( z '1F22' ), int ( z '1F2A' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND VARIA => GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA int ( z '1F23' ), int ( z '1F2B' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND VARIA => GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA int ( z '1F24' ), int ( z '1F2C' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND OXIA => GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA int ( z '1F25' ), int ( z '1F2D' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND OXIA => GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA int ( z '1F26' ), int ( z '1F2E' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI => GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI int ( z '1F27' ), int ( z '1F2F' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI => GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI int ( z '1F30' ), int ( z '1F38' ), & ! GREEK SMALL LETTER IOTA WITH PSILI => GREEK CAPITAL LETTER IOTA WITH PSILI int ( z '1F31' ), int ( z '1F39' ), & ! GREEK SMALL LETTER IOTA WITH DASIA => GREEK CAPITAL LETTER IOTA WITH DASIA int ( z '1F32' ), int ( z '1F3A' ), & ! GREEK SMALL LETTER IOTA WITH PSILI AND VARIA => GREEK CAPITAL LETTER IOTA WITH PSILI AND VARIA int ( z '1F33' ), int ( z '1F3B' ), & ! GREEK SMALL LETTER IOTA WITH DASIA AND VARIA => GREEK CAPITAL LETTER IOTA WITH DASIA AND VARIA int ( z '1F34' ), int ( z '1F3C' ), & ! GREEK SMALL LETTER IOTA WITH PSILI AND OXIA => GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA int ( z '1F35' ), int ( z '1F3D' ), & ! GREEK SMALL LETTER IOTA WITH DASIA AND OXIA => GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA int ( z '1F36' ), int ( z '1F3E' ), & ! GREEK SMALL LETTER IOTA WITH PSILI AND PERISPOMENI => GREEK CAPITAL LETTER IOTA WITH PSILI AND PERISPOMENI int ( z '1F37' ), int ( z '1F3F' ), & ! GREEK SMALL LETTER IOTA WITH DASIA AND PERISPOMENI => GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI int ( z '1F40' ), int ( z '1F48' ), & ! GREEK SMALL LETTER OMICRON WITH PSILI => GREEK CAPITAL LETTER OMICRON WITH PSILI int ( z '1F41' ), int ( z '1F49' ), & ! GREEK SMALL LETTER OMICRON WITH DASIA => GREEK CAPITAL LETTER OMICRON WITH DASIA int ( z '1F42' ), int ( z '1F4A' ), & ! GREEK SMALL LETTER OMICRON WITH PSILI AND VARIA => GREEK CAPITAL LETTER OMICRON WITH PSILI AND VARIA int ( z '1F43' ), int ( z '1F4B' ), & ! GREEK SMALL LETTER OMICRON WITH DASIA AND VARIA => GREEK CAPITAL LETTER OMICRON WITH DASIA AND VARIA int ( z '1F44' ), int ( z '1F4C' ), & ! GREEK SMALL LETTER OMICRON WITH PSILI AND OXIA => GREEK CAPITAL LETTER OMICRON WITH PSILI AND OXIA int ( z '1F45' ), int ( z '1F4D' ), & ! GREEK SMALL LETTER OMICRON WITH DASIA AND OXIA => GREEK CAPITAL LETTER OMICRON WITH DASIA AND OXIA int ( z '1F51' ), int ( z '1F59' ), & ! GREEK SMALL LETTER UPSILON WITH DASIA => GREEK CAPITAL LETTER UPSILON WITH OASIS int ( z '1F53' ), int ( z '1F5B' ), & ! GREEK SMALL LETTER UPSILON WITH DASIA AND VARIA => GREEK CAPITAL LETTER UPSILON WITH DASIA AND VARIA int ( z '1F55' ), int ( z '1F5D' ), & ! GREEK SMALL LETTER UPSILON WITH DASIA AND OXIA => GREEK CAPITAL LETTER UPSILON WITH DASIA AND OXIA int ( z '1F57' ), int ( z '1F5F' ), & ! GREEK SMALL LETTER UPSILON WITH DASIA AND PERISPOMENI => GREEK CAPITAL LETTER UPSILON WITH DASIA AND PERISPOMENI int ( z '1F60' ), int ( z '1F68' ), & ! GREEK SMALL LETTER OMEGA WITh PSILI => GREEK CAPITAL LETTER OMEGA WITH PSILI int ( z '1F61' ), int ( z '1F69' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA => GREEK CAPITAL LETTER OMEGA WITH DASIA int ( z '1F62' ), int ( z '1F6A' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA => GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA int ( z '1F63' ), int ( z '1F6B' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA => GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA int ( z '1F64' ), int ( z '1F6C' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA => GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA int ( z '1F65' ), int ( z '1F6D' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA => GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA int ( z '1F66' ), int ( z '1F6E' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI => GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI int ( z '1F67' ), int ( z '1F6F' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI => GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI int ( z '1F80' ), int ( z '1F88' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITh PSILI AND PROSGEGRAMMENI int ( z '1F81' ), int ( z '1F89' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH DASIA AND PROSGEGRAMMENI int ( z '1F82' ), int ( z '1F8A' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI int ( z '1F83' ), int ( z '1F8B' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI int ( z '1F84' ), int ( z '1F8C' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMEN int ( z '1F85' ), int ( z '1F8D' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMEN int ( z '1F86' ), int ( z '1F8E' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1F87' ), int ( z '1F8F' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1F90' ), int ( z '1F98' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH PSILI AND PROSGEGRAMMENI int ( z '1F91' ), int ( z '1F99' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH DASIA AND PROSGEGRAMMENI int ( z '1F92' ), int ( z '1F9A' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI int ( z '1F93' ), int ( z '1F9B' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI int ( z '1F94' ), int ( z '1F9C' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI int ( z '1F95' ), int ( z '1F9D' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI int ( z '1F96' ), int ( z '1F9E' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1F97' ), int ( z '1F9F' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1FA0' ), int ( z '1FA8' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH PSILI AND PROSGEGRAMMENI int ( z '1FA1' ), int ( z '1FA9' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH DASIA AND PROSGEGRAMMENI int ( z '1FA2' ), int ( z '1FAA' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI int ( z '1FA3' ), int ( z '1FAB' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI int ( z '1FA4' ), int ( z '1FAC' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI int ( z '1FA5' ), int ( z '1FAD' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI int ( z '1FA6' ), int ( z '1FAE' ), & ! GREEK SMALL LETTER OMEGA WITh PSILI AND PERISPOMENI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1FA7' ), int ( z '1FAF' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND PEPISPOMENI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMECA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1FB0' ), int ( z '1FB8' ), & ! GREEK SMALL LETTER ALPHA WITH VRACHY => GREEK CAPITAL LETTER ALPHA WITH VRACHY int ( z '1FB1' ), int ( z '1FB9' ), & ! GREEK SMALL LETTER ALPHA WITH MACRON => GREEK CAPITAL LETTER ALPHA WITH MACRON int ( z '1FD0' ), int ( z '1FD8' ), & ! GREEK SMALL LETTER IOTA WITH VRACHY => GREEK CAPITAL LETTER IOTA WITH VRACHY int ( z '1FD1' ), int ( z '1FD9' ), & ! GREEK SMALL LETTER IOTA WITH MACRON => GREEK CAPITAL LETTER IOTA WITH MACRON int ( z '1FE0' ), int ( z '1FE8' ), & ! GREEK SMALL LETTER UPSILON WITH VRACHY => GREEK CAPITAL LETTER UPSILON WITH VRACHY int ( z '1FE1' ), int ( z '1FE9' ), & ! GREEK SMALL LETTER UPSILON WITH MACRON => GREEK CAPITAL LETTER UPSILON WITH MACRON int ( z '24D0' ), int ( z '24B6' ), & ! CIRCLED LATIN SMALL LETTER A => CIRCLED LATIN CAPITAL LETTER A int ( z '24D1' ), int ( z '24B7' ), & ! CIRCLED LATIN SMALL LETTER B => CIRCLED LATIN CAPITAL LETTER B int ( z '24D2' ), int ( z '24B8' ), & ! CIRCLED LATIN SMALL LETTER C => CIRCLED LATIN CAPITAL LETTER C int ( z '24D3' ), int ( z '24B9' ), & ! CIRCLED LATIN SMALL LETTER D => CIRCLED LATIN CAPITAL LETTER D int ( z '24D4' ), int ( z '24BA' ), & ! CIRCLED LATIN SMALL LETTER E => CIRCLED LATIN CAPITAL LETTER E int ( z '24D5' ), int ( z '24BB' ), & ! CIRCLED LATIN SMALL LETTER F => CIRCLED LATIN CAPITAL LETTER F int ( z '24D6' ), int ( z '24BC' ), & ! CIRCLED LATIN SMALL LETTER G => CIRCLED LATIN CAPITAL LETTER G int ( z '24D7' ), int ( z '24BD' ), & ! CIRCLED LATIN SMALL LETTER H => CIRCLED LATIN CAPITAL LETTER H int ( z '24D8' ), int ( z '24BE' ), & ! CIRCLED LATIN SMALL LETTER I => CIRCLED LATIN CAPITAL LETTER I int ( z '24D9' ), int ( z '24BF' ), & ! CIRCLED LATIN SMALL LETTER J => CIRCLED LATIN CAPITAL LETTER J int ( z '24DA' ), int ( z '24C0' ), & ! CIRCLED LATIN SMALL LETTER K => CIRCLED LATIN CAPITAL LETTER K int ( z '24DB' ), int ( z '24C1' ), & ! CIRCLED LATIN SMALL LETTER L => CIRCLED LATIN CAPITAL LETTER L int ( z '24DC' ), int ( z '24C2' ), & ! CIRCLED LATIN SMALL LETTER M => CIRCLED LATIN CAPITAL LETTER M int ( z '24DD' ), int ( z '24C3' ), & ! CIRCLED LATIN SMALL LETTER N => CIRCLED LATIN CAPITAL LETTER N int ( z '24DE' ), int ( z '24C4' ), & ! CIRCLED LATIN SMALL LETTER O => CIRCLED LATIN CAPITAL LETTER O int ( z '24DF' ), int ( z '24C5' ), & ! CIRCLED LATIN SMALL LETTER P => CIRCLED LATIN CAPITAL LETTER P int ( z '24E0' ), int ( z '24C6' ), & ! CIRCLED LATIN SMALL LETTER Q => CIRCLED LATIN CAPITAL LETTER Q int ( z '24E1' ), int ( z '24C7' ), & ! CIRCLED LATIN SMALL LETTER R => CIRCLED LATIN CAPITAL LETTER R int ( z '24E2' ), int ( z '24C8' ), & ! CIRCLED LATIN SMALL LETTER S => CIRCLED LATIN CAPITAL LETTER S int ( z '24E3' ), int ( z '24C9' ), & ! CIRCLED LATIN SMALL LETTER T => CIRCLED LATIN CAPITAL LETTER T int ( z '24E4' ), int ( z '24CA' ), & ! CIRCLED LATIN SMALL LETTER U => CIRCLED LATIN CAPITAL LETTER U int ( z '24E5' ), int ( z '24CB' ), & ! CIRCLED LATIN SMALL LETTER V => CIRCLED LATIN CAPITAL LETTER V int ( z '24E6' ), int ( z '24CC' ), & ! CIRCLED LATIN SMALL LETTER W => CIRCLED LATIN CAPITAL LETTER W int ( z '24E7' ), int ( z '24CD' ), & ! CIRCLED LATIN SMALL LETTER X => CIRCLED LATIN CAPITAL LETTER X int ( z '24E8' ), int ( z '24CE' ), & ! CIRCLED LATIN SMALL LETTER Y => CIRCLED LATIN CAPITAL LETTER Y int ( z '24E9' ), int ( z '24CF' ), & ! CIRCLED LATIN SMALL LETTER Z => CIRCLED LATIN CAPITAL LETTER Z int ( z 'FF41' ), int ( z 'FF21' ), & ! FULLWIDTH LATIN SMALL LETTER A => FULLWIDTH LATIN CAPITAL LETTER A int ( z 'FF42' ), int ( z 'FF22' ), & ! FULLWIDTH LATIN SMALL LETTER B => FULLWIDTH LATIN CAPITAL LETTER B int ( z 'FF43' ), int ( z 'FF23' ), & ! FULLWIDTH LATIN SMALL LETTER C => FULLWIDTH LATIN CAPITAL LETTER C int ( z 'FF44' ), int ( z 'FF24' ), & ! FULLWIDTH LATIN SMALL LETTER D => FULLWIDTH LATIN CAPITAL LETTER D int ( z 'FF45' ), int ( z 'FF25' ), & ! FULLWIDTH LATIN SMALL LETTER E => FULLWIDTH LATIN CAPITAL LETTER E int ( z 'FF46' ), int ( z 'FF26' ), & ! FULLWIDTH LATIN SMALL LETTER F => FULLWIDTH LATIN CAPITAL LETTER F int ( z 'FF47' ), int ( z 'FF27' ), & ! FULLWIDTH LATIN SMALL LETTER G => FULLWIDTH LATIN CAPITAL LETTER G int ( z 'FF48' ), int ( z 'FF28' ), & ! FULLWIDTH LATIN SMALL LETTER H => FULLWIDTH LATIN CAPITAL LETTER H int ( z 'FF49' ), int ( z 'FF29' ), & ! FULLWIDTH LATIN SMALL LETTER I => FULLWIDTH LATIN CAPITAL LETTER I int ( z 'FF4A' ), int ( z 'FF2A' ), & ! FULLWIDTH LATIN SMALL LETTER J => FULLWIDTH LATIN CAPITAL LETTER J int ( z 'FF4B' ), int ( z 'FF2B' ), & ! FULLWIDTH LATIN SMALL LETTER K => FULLWIDTH LATIN CAPITAL LETTER K int ( z 'FF4C' ), int ( z 'FF2C' ), & ! FULLWIDTH LATIN SMALL LETTER L => FULLWIDTH LATIN CAPITAL LETTER L int ( z 'FF4D' ), int ( z 'FF2D' ), & ! FULLWIDTH LATIN SMALL LETTER M => FULLWIDTH LATIN CAPITAL LETTER M int ( z 'FF4E' ), int ( z 'FF2E' ), & ! FULLWIDTH LATIN SMALL LETTER N => FULLWIDTH LATIN CAPITAL LETTER N int ( z 'FF4F' ), int ( z 'FF2F' ), & ! FULLWIDTH LATIN SMALL LETTER O => FULLWIDTH LATIN CAPITAL LETTER O int ( z 'FF50' ), int ( z 'FF30' ), & ! FULLWIDTH LATIN SMALL LETTER P => FULLWIDTH LATIN CAPITAL LETTER P int ( z 'FF51' ), int ( z 'FF31' ), & ! FULLWIDTH LATIN SMALL LETTER Q => FULLWIDTH LATIN CAPITAL LETTER Q int ( z 'FF52' ), int ( z 'FF32' ), & ! FULLWIDTH LATIN SMALL LETTER R => FULLWIDTH LATIN CAPITAL LETTER R int ( z 'FF53' ), int ( z 'FF33' ), & ! FULLWIDTH LATIN SMALL LETTER S => FULLWIDTH LATIN CAPITAL LETTER S int ( z 'FF54' ), int ( z 'FF34' ), & ! FULLWIDTH LATIN SMALL LETTER T => FULLWIDTH LATIN CAPITAL LETTER T int ( z 'FF55' ), int ( z 'FF35' ), & ! FULLWIDTH LATIN SMALL LETTER U => FULLWIDTH LATIN CAPITAL LETTER U int ( z 'FF56' ), int ( z 'FF36' ), & ! FULLWIDTH LATIN SMALL LETTER V => FULLWIDTH LATIN CAPITAL LETTER V int ( z 'FF57' ), int ( z 'FF37' ), & ! FULLWIDTH LATIN SMALL LETTER W => FULLWIDTH LATIN CAPITAL LETTER W int ( z 'FF58' ), int ( z 'FF38' ), & ! FULLWIDTH LATIN SMALL LETTER X => FULLWIDTH LATIN CAPITAL LETTER X int ( z 'FF59' ), int ( z 'FF39' ), & ! FULLWIDTH LATIN SMALL LETTER Y => FULLWIDTH LATIN CAPITAL LETTER Y int ( z 'FF5A' ), int ( z 'FF3A' )] & ! FULLWIDTH LATIN SMALL LETTER Z => FULLWIDTH LATIN CAPITAL LETTER Z , shape ( low_to_up ), order = [ 2 , 1 ]) integer , parameter :: highlow = 666 integer , parameter :: up_to_low ( highlow , 2 ) = reshape ([ & int ( z '0041' ), int ( z '0061' ), & ! LATIN SMALL LETTER A <= LATIN CAPITAL LETTER A int ( z '0042' ), int ( z '0062' ), & ! LATIN SMALL LETTER B <= LATIN CAPITAL LETTER B int ( z '0043' ), int ( z '0063' ), & ! LATIN SMALL LETTER C <= LATIN CAPITAL LETTER C int ( z '0044' ), int ( z '0064' ), & ! LATIN SMALL LETTER D <= LATIN CAPITAL LETTER D int ( z '0045' ), int ( z '0065' ), & ! LATIN SMALL LETTER E <= LATIN CAPITAL LETTER E int ( z '0046' ), int ( z '0066' ), & ! LATIN SMALL LETTER F <= LATIN CAPITAL LETTER F int ( z '0047' ), int ( z '0067' ), & ! LATIN SMALL LETTER G <= LATIN CAPITAL LETTER G int ( z '0048' ), int ( z '0068' ), & ! LATIN SMALL LETTER H <= LATIN CAPITAL LETTER H int ( z '0049' ), int ( z '0131' ), & ! LATIN SMALL LETTER DOTLESS I <= LATIN CAPITAL LETTER I int ( z '004A' ), int ( z '006A' ), & ! LATIN SMALL LETTER J <= LATIN CAPITAL LETTER J int ( z '004B' ), int ( z '006B' ), & ! LATIN SMALL LETTER K <= LATIN CAPITAL LETTER K int ( z '004C' ), int ( z '006C' ), & ! LATIN SMALL LETTER L <= LATIN CAPITAL LETTER L int ( z '004D' ), int ( z '006D' ), & ! LATIN SMALL LETTER M <= LATIN CAPITAL LETTER M int ( z '004E' ), int ( z '006E' ), & ! LATIN SMALL LETTER N <= LATIN CAPITAL LETTER N int ( z '004F' ), int ( z '006F' ), & ! LATIN SMALL LETTER O <= LATIN CAPITAL LETTER O int ( z '0050' ), int ( z '0070' ), & ! LATIN SMALL LETTER P <= LATIN CAPITAL LETTER P int ( z '0051' ), int ( z '0071' ), & ! LATIN SMALL LETTER Q <= LATIN CAPITAL LETTER Q int ( z '0052' ), int ( z '0072' ), & ! LATIN SMALL LETTER R <= LATIN CAPITAL LETTER R int ( z '0053' ), int ( z '0073' ), & ! LATIN SMALL LETTER S <= LATIN CAPITAL LETTER S int ( z '0054' ), int ( z '0074' ), & ! LATIN SMALL LETTER T <= LATIN CAPITAL LETTER T int ( z '0055' ), int ( z '0075' ), & ! LATIN SMALL LETTER U <= LATIN CAPITAL LETTER U int ( z '0056' ), int ( z '0076' ), & ! LATIN SMALL LETTER V <= LATIN CAPITAL LETTER V int ( z '0057' ), int ( z '0077' ), & ! LATIN SMALL LETTER W <= LATIN CAPITAL LETTER W int ( z '0058' ), int ( z '0078' ), & ! LATIN SMALL LETTER X <= LATIN CAPITAL LETTER X int ( z '0059' ), int ( z '0079' ), & ! LATIN SMALL LETTER Y <= LATIN CAPITAL LETTER Y int ( z '005A' ), int ( z '007A' ), & ! LATIN SMALL LETTER Z <= LATIN CAPITAL LETTER Z int ( z '00C0' ), int ( z '00E0' ), & ! LATIN SMALL LETTER A GRAVE <= LATIN CAPITAL LETTER A GRAVE int ( z '00C1' ), int ( z '00E1' ), & ! LATIN SMALL LETTER A GRAVE <= LATIN CAPITAL LETTER A ACUTE int ( z '00C2' ), int ( z '00E2' ), & ! LATIN SMALL LETTER A GRAVE <= LATIN CAPITAL LETTER A CIRCUMFLEX int ( z '00C3' ), int ( z '00E3' ), & ! LATIN SMALL LETTER A GRAVE <= LATIN CAPITAL LETTER A TILDE int ( z '00C4' ), int ( z '00E4' ), & ! LATIN SMALL LETTER A GRAVE <= LATIN CAPITAL LETTER A DIAERESIS int ( z '00C5' ), int ( z '00E5' ), & ! LATIN SMALL LETTER A GRAVE <= LATIN CAPITAL LETTER A RING int ( z '00C6' ), int ( z '00E6' ), & ! LATIN SMALL LETTER A GRAVE <= LATIN CAPITAL LETTER A E int ( z '00C7' ), int ( z '00E7' ), & ! LATIN SMALL LETTER A GRAVE <= LATIN CAPITAL LETTER C CEDILLA int ( z '00C8' ), int ( z '00E8' ), & ! LATIN SMALL LETTER A GRAVE <= LATIN CAPITAL LETTER E GRAVE int ( z '00C9' ), int ( z '00E9' ), & ! LATIN SMALL LETTER A GRAVE <= LATIN CAPITAL LETTER E ACUTE int ( z '00CA' ), int ( z '00EA' ), & ! LATIN SMALL LETTER E CIRCUMFLEX <= LATIN CAPITAL LETTER E CIRCUMFLEX int ( z '00CB' ), int ( z '00EB' ), & ! LATIN SMALL LETTER E DIAERESIS <= LATIN CAPITAL LETTER E DIAERESIS int ( z '00CC' ), int ( z '00EC' ), & ! LATIN SMALL LETTER I GRAVE <= LATIN CAPITAL LETTER I GRAVE int ( z '00CD' ), int ( z '00ED' ), & ! LATIN SMALL LETTER I ACUTE <= LATIN CAPITAL LETTER I ACUTE int ( z '00CE' ), int ( z '00EE' ), & ! LATIN SMALL LETTER I CIRCUMFLEX <= LATIN CAPITAL LETTER I CIRCUMFLEX int ( z '00CF' ), int ( z '00EF' ), & ! LATIN SMALL LETTER I DIAERESIS <= LATIN CAPITAL LETTER I DIAERESIS int ( z '00D0' ), int ( z '00F0' ), & ! LATIN SMALL LETTER ETH <= LATIN CAPITAL LETTER ETH int ( z '00D1' ), int ( z '00F1' ), & ! LATIN SMALL LETTER N TILDE <= LATIN CAPITAL LETTER N TILDE int ( z '00D2' ), int ( z '00F2' ), & ! LATIN SMALL LETTER O GRAVE <= LATIN CAPITAL LETTER O GRAVE int ( z '00D3' ), int ( z '00F3' ), & ! LATIN SMALL LETTER O ACUTE <= LATIN CAPITAL LETTER O ACUTE int ( z '00D4' ), int ( z '00F4' ), & ! LATIN SMALL LETTER O CIRCUMFLEX <= LATIN CAPITAL LETTER O CIRCUMFLEX int ( z '00D5' ), int ( z '00F5' ), & ! LATIN SMALL LETTER O TILDE <= LATIN CAPITAL LETTER O TILDE int ( z '00D6' ), int ( z '00F6' ), & ! LATIN SMALL LETTER O DIAERESIS <= LATIN CAPITAL LETTER O DIAERESIS int ( z '00D8' ), int ( z '00F8' ), & ! LATIN SMALL LETTER O SLASH <= LATIN CAPITAL LETTER O SLASH int ( z '00D9' ), int ( z '00F9' ), & ! LATIN SMALL LETTER U GRAVE <= LATIN CAPITAL LETTER U GRAVE int ( z '00DA' ), int ( z '00FA' ), & ! LATIN SMALL LETTER U ACUTE <= LATIN CAPITAL LETTER U ACUTE int ( z '00DB' ), int ( z '00FB' ), & ! LATIN SMALL LETTER U CIRCUMFLEX <= LATIN CAPITAL LETTER U CIRCUMFLEX int ( z '00DC' ), int ( z '00FC' ), & ! LATIN SMALL LETTER U DIAERESIS <= LATIN CAPITAL LETTER U DIAERESIS int ( z '00DD' ), int ( z '00FD' ), & ! LATIN SMALL LETTER Y ACUTE <= LATIN CAPITAL LETTER Y ACUTE int ( z '00DE' ), int ( z '00FE' ), & ! LATIN SMALL LETTER THORN <= LATIN CAPITAL LETTER THORN int ( z '0100' ), int ( z '0101' ), & ! LATIN SMALL LETTER A WITH MACRON <= LATIN CAPITAL LETTER A WITH MACRON int ( z '0102' ), int ( z '0103' ), & ! LATIN SMALL LETTER A WITH BREVE <= LATIN CAPITAL LETTER A WITH BREVE int ( z '0104' ), int ( z '0105' ), & ! LATIN SMALL LETTER A WITH OGONEK <= LATIN CAPITAL LETTER A WITH OGONEK int ( z '0106' ), int ( z '0107' ), & ! LATIN SMALL LETTER C WITH ACUTE <= LATIN CAPITAL LETTER C WITH ACUTE int ( z '0108' ), int ( z '0109' ), & ! LATIN SMALL LETTER C WITH CIRCUMFLEX <= LATIN CAPITAL LETTER C WITH CIRCUMFLEX int ( z '010A' ), int ( z '010B' ), & ! LATIN SMALL LETTER C WITH DOT ABOVE <= LATIN CAPITAL LETTER C WITH DOT ABOVE int ( z '010C' ), int ( z '010D' ), & ! LATIN SMALL LETTER C WITH CARON <= LATIN CAPITAL LETTER C WITH CARON int ( z '010E' ), int ( z '010F' ), & ! LATIN SMALL LETTER D WITH CARON <= LATIN CAPITAL LETTER D WITH CARON int ( z '0110' ), int ( z '0111' ), & ! LATIN SMALL LETTER D WITH STROKE <= LATIN CAPITAL LETTER D WITH STROKE int ( z '0112' ), int ( z '0113' ), & ! LATIN SMALL LETTER E WITH MACRON <= LATIN CAPITAL LETTER E WITH MACRON int ( z '0114' ), int ( z '0115' ), & ! LATIN SMALL LETTER E WITH BREVE <= LATIN CAPITAL LETTER E WITH BREVE int ( z '0116' ), int ( z '0117' ), & ! LATIN SMALL LETTER E WITH DOT ABOVE <= LATIN CAPITAL LETTER E WITH DOT ABOVE int ( z '0118' ), int ( z '0119' ), & ! LATIN SMALL LETTER E WITH OGONEK <= LATIN CAPITAL LETTER E WITH OGONEK int ( z '011A' ), int ( z '011B' ), & ! LATIN SMALL LETTER E WITH CARON <= LATIN CAPITAL LETTER E WITH CARON int ( z '011C' ), int ( z '011D' ), & ! LATIN SMALL LETTER G WITH CIRCUMFLEX <= LATIN CAPITAL LETTER G WITH CIRCUMFLEX int ( z '011E' ), int ( z '011F' ), & ! LATIN SMALL LETTER G WITH BREVE <= LATIN CAPITAL LETTER G WITH BREVE int ( z '0120' ), int ( z '0121' ), & ! LATIN SMALL LETTER G WITH DOT ABOVE <= LATIN CAPITAL LETTER G WITH DOT ABOVE int ( z '0122' ), int ( z '0123' ), & ! LATIN SMALL LETTER G WITH CEDILLA <= LATIN CAPITAL LETTER G WITH CEDILLA int ( z '0124' ), int ( z '0125' ), & ! LATIN SMALL LETTER H WITH CIRCUMFLEX <= LATIN CAPITAL LETTER H WITH CIRCUMFLEX int ( z '0126' ), int ( z '0127' ), & ! LATIN SMALL LETTER H WITH STROKE <= LATIN CAPITAL LETTER H WITH STROKE int ( z '0128' ), int ( z '0129' ), & ! LATIN SMALL LETTER I WITH TILDE <= LATIN CAPITAL LETTER I WITH TILDE int ( z '012A' ), int ( z '012B' ), & ! LATIN SMALL LETTER I WITH MACRON <= LATIN CAPITAL LETTER I WITH MACRON int ( z '012C' ), int ( z '012D' ), & ! LATIN SMALL LETTER I WITH BREVE <= LATIN CAPITAL LETTER I WITH BREVE int ( z '012E' ), int ( z '012F' ), & ! LATIN SMALL LETTER I WITH OGONEK <= LATIN CAPITAL LETTER I WITH OGONEK int ( z '0130' ), int ( z '0069' ), & ! LATIN sMALL LETTER I <= LATIN CAPITAL LETTER I WITH DOT ABOVE int ( z '0132' ), int ( z '0133' ), & ! LATIN SMALL LIGATURE IJ <= LATIN CAPITAL LIGATURE IJ int ( z '0134' ), int ( z '0135' ), & ! LATIN SMALL LETTER J WITH CIRCUMFLEX <= LATIN CAPITAL LETTER J WITH CIRCUMFLEX int ( z '0136' ), int ( z '0137' ), & ! LATIN SMALL LETTER K WITH CEDILLA <= LATIN CAPITAL LETTER K WITH CEDILLA int ( z '0139' ), int ( z '013A' ), & ! LATIN SMALL LETTER L WITH ACUTE <= LATIN CAPITAL LETTER L WITH ACUTE int ( z '013B' ), int ( z '013C' ), & ! LATIN SMALL LETTER L WITH CEDILLA <= LATIN CAPITAL LETTER L WITH CEDILLA int ( z '013D' ), int ( z '013E' ), & ! LATIN SMALL LETTER L WITH CARON <= LATIN CAPITAL LETTER L WITH CARON int ( z '013F' ), int ( z '0140' ), & ! LATIN SMALL LETTER L WITH MIDDLE DOT <= LATIN CAPITAL LETTER L WITH MIDDLE DOT int ( z '0141' ), int ( z '0142' ), & ! LATIN SMALL LETTER L WITH STROKE <= LATIN CAPITAL LETTER L WITH STROKE int ( z '0143' ), int ( z '0144' ), & ! LATIN SMALL LETTER N WITH ACUTE <= LATIN CAPITAL LETTER N WITH ACUTE int ( z '0145' ), int ( z '0146' ), & ! LATIN SMALL LETTER N WITH CEDILLA <= LATIN CAPITAL LETTER N WITH CEDILLA int ( z '0147' ), int ( z '0148' ), & ! LATIN SMALL LETTER N WITH CARON <= LATIN CAPITAL LETTER N WITH CARON int ( z '014A' ), int ( z '014B' ), & ! LATIN SMALL LETTER ENG (SAMI) <= LATIN CAPITAL LETTER ENG (SAMI) int ( z '014C' ), int ( z '014D' ), & ! LATIN SMALL LETTER O WITH MACRON <= LATIN CAPITAL LETTER O WITH MACRON int ( z '014E' ), int ( z '014F' ), & ! LATIN SMALL LETTER O WITH BREVE <= LATIN CAPITAL LETTER O WITH BREVE int ( z '0150' ), int ( z '0151' ), & ! LATIN SMALL LETTER O WITH DOUBLE ACUTE <= LATIN CAPITAL LETTER O WITH DOUBLE ACUTE int ( z '0152' ), int ( z '0153' ), & ! LATIN SMALL LIGATURE OE <= LATIN CAPITAL LIGATURE OE int ( z '0154' ), int ( z '0155' ), & ! LATIN SMALL LETTER R WITH ACUTE <= LATIN CAPITAL LETTER R WITH ACUTE int ( z '0156' ), int ( z '0157' ), & ! LATIN SMALL LETTER R WITH CEDILLA <= LATIN CAPITAL LETTER R WITH CEDILLA int ( z '0158' ), int ( z '0159' ), & ! LATIN SMALL LETTER R WITH CARON <= LATIN CAPITAL LETTER R WITH CARON int ( z '015A' ), int ( z '015B' ), & ! LATIN SMALL LETTER S WITH ACUTE <= LATIN CAPITAL LETTER S WITH ACUTE int ( z '015C' ), int ( z '015D' ), & ! LATIN SMALL LETTER S WITH CIRCUMFLEX <= LATIN CAPITAL LETTER S WITH CIRCUMFLEX int ( z '015E' ), int ( z '015F' ), & ! LATIN SMALL LETTER S WITH CEDILLA <= LATIN CAPITAL LETTER S WITH CEDILLA int ( z '0160' ), int ( z '0161' ), & ! LATIN SMALL LETTER S WITH CARON <= LATIN CAPITAL LETTER S WITH CARON int ( z '0162' ), int ( z '0163' ), & ! LATIN SMALL LETTER T WITH CEDILLA <= LATIN CAPITAL LETTER T WITH CEDILLA int ( z '0164' ), int ( z '0165' ), & ! LATIN SMALL LETTER T WITH CARON <= LATIN CAPITAL LETTER T WITH CARON int ( z '0166' ), int ( z '0167' ), & ! LATIN SMALL LETTER T WITH STROKE <= LATIN CAPITAL LETTER T WITH STROKE int ( z '0168' ), int ( z '0169' ), & ! LATIN SMALL LETTER U WITH TILDE <= LATIN CAPITAL LETTER U WITH TILDE int ( z '016A' ), int ( z '016B' ), & ! LATIN SMALL LETTER U WITH MACRON <= LATIN CAPITAL LETTER U WITH MACRON int ( z '016C' ), int ( z '016D' ), & ! LATIN SMALL LETTER U WITH BREVE <= LATIN CAPITAL LETTER U WITH BREVE int ( z '016E' ), int ( z '016F' ), & ! LATIN SMALL LETTER U WITH RING ABOVE <= LATIN CAPITAL LETTER U WITH RING ABOVE int ( z '0170' ), int ( z '0171' ), & ! LATIN SMALL LETTER U WITH DOUBLE ACUTE <= LATIN CAPITAL LETTER U WITH DOUBLE ACUTE int ( z '0172' ), int ( z '0173' ), & ! LATIN SMALL LETTER U WITH OGONEK <= LATIN CAPITAL LETTER U WITH OGONEK int ( z '0174' ), int ( z '0175' ), & ! LATIN SMALL LETTER W WITH CIRCUMFLEX <= LATIN CAPITAL LETTER W WITH CIRCUMFLEX int ( z '0176' ), int ( z '0177' ), & ! LATIN SMALL LETTER Y WITH CIRCUMFLEX <= LATIN CAPITAL LETTER Y WITH CIRCUMFLEX int ( z '0178' ), int ( z '00FF' ), & ! LATIN SMALL LETTER Y DIAERESIS <= LATIN CAPITAL LETTER Y WITH DIAERESIS int ( z '0179' ), int ( z '017A' ), & ! LATIN SMALL LETTER Z WITH ACUTE <= LATIN CAPITAL LETTER Z WITH ACUTE int ( z '017B' ), int ( z '017C' ), & ! LATIN SMALL LETTER Z WITH DOT ABOVE <= LATIN CAPITAL LETTER Z WITH DOT ABOVE int ( z '017D' ), int ( z '017E' ), & ! LATIN SMALL LETTER Z WITH CARON <= LATIN CAPITAL LETTER Z WITH CARON int ( z '0181' ), int ( z '0253' ), & ! LATIN SMALL LETTER B WITH HOOK <= LATIN CAPITAL LETTER B WITH HOOK int ( z '0182' ), int ( z '0183' ), & ! LATIN SMALL LETTER B WITH TOPBAR <= LATIN CAPITAL LETTER B WITH TOPBAR int ( z '0184' ), int ( z '0185' ), & ! LATIN SMALL LETTER TONE SIX <= LATIN CAPITAL LETTER TONE SIX int ( z '0186' ), int ( z '0254' ), & ! LATIN SMALL LETTER OPEN O <= LATIN CAPITAL LETTER OPEN O int ( z '0187' ), int ( z '0188' ), & ! LATIN SMALL LETTER C WITH HOOK <= LATIN CAPITAL LETTER C WITH HOOK int ( z '018A' ), int ( z '0257' ), & ! LATIN SMALL LETTER D WITH HOOK <= LATIN CAPITAL LETTER D WITH HOOK int ( z '018B' ), int ( z '018C' ), & ! LATIN SMALL LETTER D WITH TOPBAR <= LATIN CAPITAL LETTER D WITH TOPBAR int ( z '018E' ), int ( z '0258' ), & ! LATIN SMALL LETTER REVERSED E <= LATIN CAPITAL LETTER REVERSED E int ( z '018F' ), int ( z '0259' ), & ! LATIN SMALL LETTER SCHWA <= LATIN CAPITAL LETTER SCHWA int ( z '0190' ), int ( z '025B' ), & ! LATIN SMALL LETTER OPEN E <= LATIN CAPITAL LETTER OPEN E int ( z '0191' ), int ( z '0192' ), & ! LATIN SMALL LETTER F WITH HOOK <= LATIN CAPITAL LETTER F WITH HOOK int ( z '0193' ), int ( z '0260' ), & ! LATIN SMALL LETTER G WITH HOOK <= LATIN CAPITAL LETTER G WITH HOOK int ( z '0194' ), int ( z '0263' ), & ! LATIN SMALL LETTER GAMMA <= LATIN CAPITAL LETTER GAMMA int ( z '0196' ), int ( z '0269' ), & ! LATIN SMALL LETTER IOTA <= LATIN CAPITAL LETTER IOTA int ( z '0197' ), int ( z '0268' ), & ! LATIN SMALL LETTER I WITH STROKE <= LATIN CAPITAL LETTER I WITH STROKE int ( z '0198' ), int ( z '0199' ), & ! LATIN SMALL LETTER K WITH HOOK <= LATIN CAPITAL LETTER K WITH HOOK int ( z '019C' ), int ( z '026F' ), & ! LATIN SMALL LETTER TURNED M <= LATIN CAPITAL LETTER TURNED M int ( z '019D' ), int ( z '0272' ), & ! LATIN SMALL LETTER N WITH LEFT HOOK <= LATIN CAPITAL LETTER N WITH LEFT HOOK int ( z '019F' ), int ( z '0275' ), & ! LATIN SMALL LETTER BARRED O <= LATIN CAPITAL LETTER O WITH MIDDLE TILDE int ( z '01A0' ), int ( z '01A1' ), & ! LATIN SMALL LETTER O WITH HORN <= LATIN CAPITAL LETTER O WITH HORN int ( z '01A2' ), int ( z '01A3' ), & ! LATIN SMALL LETTER OI <= LATIN CAPITAL LETTER OI int ( z '01A4' ), int ( z '01A5' ), & ! LATIN SMALL LETTER P WITH HOOK <= LATIN CAPITAL LETTER P WITH HOOK int ( z '01A7' ), int ( z '01A8' ), & ! LATIN SMALL LETTER TONE TWO <= LATIN CAPITAL LETTER TONE TWO int ( z '01A9' ), int ( z '0283' ), & ! LATIN SMALL LETTER ESH <= LATIN CAPITAL LETTER ESH int ( z '01AC' ), int ( z '01AD' ), & ! LATIN SMALL LETTER T WITH HOOK <= LATIN CAPITAL LETTER T WITH HOOK int ( z '01AE' ), int ( z '0288' ), & ! LATIN SMALL LETTER T WITH RETROFLEX HOOK <= LATIN CAPITAL LETTER T WITH RETROFLEX HOOK int ( z '01AF' ), int ( z '01B0' ), & ! LATIN SMALL LETTER U WITH HORN <= LATIN CAPITAL LETTER U WITH HORN int ( z '01B1' ), int ( z '028A' ), & ! LATIN SMALL LETTER UPSILON <= LATIN CAPITAL LETTER UPSILON int ( z '01B2' ), int ( z '028B' ), & ! LATIN SMALL LETTER V WITH HOOK <= LATIN CAPITAL LETTER V WITH HOOK int ( z '01B3' ), int ( z '01B4' ), & ! LATIN SMALL LETTER Y WITH HOOK <= LATIN CAPITAL LETTER Y WITH HOOK int ( z '01B5' ), int ( z '01B6' ), & ! LATIN SMALL LETTER Z WITH STROKE <= LATIN CAPITAL LETTER Z WITH STROKE int ( z '01B7' ), int ( z '0292' ), & ! LATIN SMALL LETTER EZH <= LATIN CAPITAL LETTER EZH int ( z '01B8' ), int ( z '01B9' ), & ! LATIN SMALL LETTER EZH REVERSED <= LATIN CAPITAL LETTER EZH REVERSED int ( z '01BC' ), int ( z '01BD' ), & ! LATIN SMALL LETTER TONE FIVE <= LATIN CAPITAL LETTER TONE FIVE int ( z '01C4' ), int ( z '01C6' ), & ! LATIN SMALL LETTER DZ WITH CARON <= LATIN CAPITAL LETTER DZ WITH CARON int ( z '01C7' ), int ( z '01C9' ), & ! LATIN SMALL LETTER LJ <= LATIN CAPITAL LETTER LJ int ( z '01CA' ), int ( z '01CC' ), & ! LATIN SMALL LETTER NJ <= LATIN CAPITAL LETTER NJ int ( z '01CD' ), int ( z '01CE' ), & ! LATIN SMALL LETTER A WITH CARON <= LATIN CAPITAL LETTER A WITH CARON int ( z '01CF' ), int ( z '01D0' ), & ! LATIN SMALL LETTER I WITH CARON <= LATIN CAPITAL LETTER I WITH CARON int ( z '01D1' ), int ( z '01D2' ), & ! LATIN SMALL LETTER O WITH CARON <= LATIN CAPITAL LETTER O WITH CARON int ( z '01D3' ), int ( z '01D4' ), & ! LATIN SMALL LETTER U WITH CARON <= LATIN CAPITAL LETTER U WITH CARON int ( z '01D5' ), int ( z '01D6' ), & ! LATIN SMALL LETTER U WITH DIAERESIS AND MACRON <= LATIN CAPITAL LETTER U WITH DIAERESIS AND MACRON int ( z '01D7' ), int ( z '01D8' ), & ! LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE <= LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE int ( z '01D9' ), int ( z '01DA' ), & ! LATIN SMALL LETTER U WITH DIAERESIS AND CARON <= LATIN CAPITAL LETTER U WITH DIAERESIS AND CARON int ( z '01DB' ), int ( z '01DC' ), & ! LATIN SMALL LETTER U WITH DIAERESIS AND GRAVE <= LATIN CAPITAL LETTER U WITH DIAERESIS AND GRAVE int ( z '01DE' ), int ( z '01DF' ), & ! LATIN SMALL LETTER A WITH DIAERESIS AND MACRON <= LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON int ( z '01E0' ), int ( z '01E1' ), & ! LATIN SMALL LETTER A WITH DOT ABOVE AND MACRON <= LATIN CAPITAL LETTER A WITH DOT ABOVE AND MACRON int ( z '01E2' ), int ( z '01E3' ), & ! LATIN SMALL LIGATURE AE WITH MACRON <= LATIN CAPITAL LIGATURE AE MTH MACRON int ( z '01E4' ), int ( z '01E5' ), & ! LATIN SMALL LETTER G WITH STROKE <= LATIN CAPITAL LETTER G WITH STROKE int ( z '01E6' ), int ( z '01E7' ), & ! LATIN SMALL LETTER G WITH CARON <= LATIN CAPITAL LETTER G WITH CARON int ( z '01E8' ), int ( z '01E9' ), & ! LATIN SMALL LETTER K WITH CARON <= LATIN CAPITAL LETTER K WITH CARON int ( z '01EA' ), int ( z '01EB' ), & ! LATIN SMALL LETTER O WITH OGONEK <= LATIN CAPITAL LETTER O WITH OGONEK int ( z '01EC' ), int ( z '01ED' ), & ! LATIN SMALL LETTER O WITH OGONEK AND MACRON <= LATIN CAPITAL LETTER O WITH OGONEK AND MACRON int ( z '01EE' ), int ( z '01EF' ), & ! LATIN SMALL LETTER EZH WITH CARON <= LATIN CAPITAL LETTER EZH WITH CARON int ( z '01F1' ), int ( z '01F3' ), & ! LATIN SMALL LETTER DZ <= LATIN CAPITAL LETTER DZ int ( z '01F4' ), int ( z '01F5' ), & ! LATIN SMALL LETTER G WITH ACUTE <= LATIN CAPITAL LETTER G WITH ACUTE int ( z '01FA' ), int ( z '01FB' ), & ! LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE <= LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE int ( z '01FC' ), int ( z '01FD' ), & ! LATIN SMALL LIGATURE AE WITH ACUTE <= LATIN CAPITAL LIGATURE AE WITH ACUTE int ( z '01FE' ), int ( z '01FF' ), & ! LATIN SMALL LETTER O WITH STROKE AND ACUTE <= LATIN CAPITAL LETTER O WITH STROKE AND ACUTE int ( z '0200' ), int ( z '0201' ), & ! LATIN SMALL LETTER A WITH DOUBLE GRAVE <= LATIN CAPITAL LETTER A WITH DOUBLE GRAVE int ( z '0202' ), int ( z '0203' ), & ! LATIN SMALL LETTER A WITH INVERTED BREVE <= LATIN CAPITAL LETTER A WITH INVERTED BREVE int ( z '0204' ), int ( z '0205' ), & ! LATIN SMALL LETTER E WITH DOUBLE GRAVE <= LATIN CAPITAL LETTER E WITH DOUBLE GRAVE int ( z '0206' ), int ( z '0207' ), & ! LATIN SMALL LETTER E WITH INVERTED BREVE <= LATIN CAPITAL LETTER E WITH INVERTED BREVE int ( z '0208' ), int ( z '0209' ), & ! LATIN SMALL LETTER I WITH DOUBLE GRAVE <= LATIN CAPITAL LETTER I WITH DOUBLE GRAVE int ( z '020A' ), int ( z '020B' ), & ! LATIN SMALL LETTER I WITH INVERTED BREVE <= LATIN CAPITAL LETTER I WITH INVERTED BREVE int ( z '020C' ), int ( z '020D' ), & ! LATIN SMALL LETTER O WITH DOUBLE GRAVE <= LATIN CAPITAL LETTER O WITH DOUBLE GRAVE int ( z '020E' ), int ( z '020F' ), & ! LATIN SMALL LETTER O WITH INVERTED BREVE <= LATIN CAPITAL LETTER O WITH INVERTED BREVE int ( z '0210' ), int ( z '0211' ), & ! LATIN SMALL LETTER R WITH DOUBLE GRAVE <= LATIN CAPITAL LETTER R WITH DOUBLE GRAVE int ( z '0212' ), int ( z '0213' ), & ! LATIN SMALL LETTER R WITH INVERTED BREVE <= LATIN CAPITAL LETTER R WITH INVERTED BREVE int ( z '0214' ), int ( z '0215' ), & ! LATIN SMALL LETTER U WITH DOUBLE GRAVE <= LATIN CAPITAL LETTER U WITH DOUBLE GRAVE int ( z '0216' ), int ( z '0217' ), & ! LATIN SMALL LETTER U WITH INVERTED BREVE <= LATIN CAPITAL LETTER U WITH INVERTED BREVE int ( z '0386' ), int ( z '03AC' ), & ! GREEK SMALL LETTER ALPHA WITH TONOS <= GREEK CAPITAL LETTER ALPHA WITH TONOS int ( z '0388' ), int ( z '03AD' ), & ! GREEK SMALL LETTER EPSILON WITH TONOS <= GREEK CAPITAL LETTER EPSILON WITH TONOS int ( z '0389' ), int ( z '03AE' ), & ! GREEK SMALL LETTER ETA WITH TONOS <= GREEK CAPITAL LETTER ETA WITH TONOS int ( z '038A' ), int ( z '03AF' ), & ! GREEK SMALL LETTER IOTA WITH TONOS <= GREEK CAPITAL LETTER IOTA WITH TONOS int ( z '038C' ), int ( z '03CC' ), & ! GREEK SMALL LETTER OMICRON WITH TONOS <= GREEK CAPITAL LETTER OMICRON WITH TONOS int ( z '038E' ), int ( z '03CD' ), & ! GREEK SMALL LETTER UPSILON WITH TONOS <= GREEK CAPITAL LETTER UPSILON WITH TONOS int ( z '038F' ), int ( z '03CE' ), & ! GREEK SMALL LETTER OMEGA WITH TONOS <= GREEK CAPITAL LETTER OMEGA WITH TONOS int ( z '0391' ), int ( z '03B1' ), & ! GREEK SMALL LETTER ALPHA <= GREEK CAPITAL LETTER ALPHA int ( z '0392' ), int ( z '03B2' ), & ! GREEK SMALL LETTER BETA <= GREEK CAPITAL LETTER BETA int ( z '0393' ), int ( z '03B3' ), & ! GREEK SMALL LETTER GAMMA <= GREEK CAPITAL LETTER GAMMA int ( z '0394' ), int ( z '03B4' ), & ! GREEK SMALL LETTER DELTA <= GREEK CAPITAL LETTER DELTA int ( z '0395' ), int ( z '03B5' ), & ! GREEK SMALL LETTER EPSILON <= GREEK CAPITAL LETTER EPSILON int ( z '0396' ), int ( z '03B6' ), & ! GREEK SMALL LETTER ZETA <= GREEK CAPITAL LETTER ZETA int ( z '0397' ), int ( z '03B7' ), & ! GREEK SMALL LETTER ETA <= GREEK CAPITAL LETTER ETA int ( z '0398' ), int ( z '03B8' ), & ! GREEK SMALL LETTER THETA <= GREEK CAPITAL LETTER THETA int ( z '0399' ), int ( z '03B9' ), & ! GREEK SMALL LETTER IOTA <= GREEK CAPITAL LETTER IOTA int ( z '039A' ), int ( z '03BA' ), & ! GREEK SMALL LETTER KAPPA <= GREEK CAPITAL LETTER KAPPA int ( z '039B' ), int ( z '03BB' ), & ! GREEK SMALL LETTER LAMDA <= GREEK CAPITAL LETTER LAMDA int ( z '039C' ), int ( z '03BC' ), & ! GREEK SMALL LETTER MU <= GREEK CAPITAL LETTER MU int ( z '039D' ), int ( z '03BD' ), & ! GREEK SMALL LETTER NU <= GREEK CAPITAL LETTER NU int ( z '039E' ), int ( z '03BE' ), & ! GREEK SMALL LETTER XI <= GREEK CAPITAL LETTER XI int ( z '039F' ), int ( z '03BF' ), & ! GREEK SMALL LETTER OMICRON <= GREEK CAPITAL LETTER OMICRON int ( z '03A0' ), int ( z '03C0' ), & ! GREEK SMALL LETTER PI <= GREEK CAPITAL LETTER PI int ( z '03A1' ), int ( z '03C1' ), & ! GREEK SMALL LETTER RHO <= GREEK CAPITAL LETTER RHO int ( z '03A3' ), int ( z '03C3' ), & ! GREEK SMALL LETTER SIGMA <= GREEK CAPITAL LETTER SIGMA int ( z '03A4' ), int ( z '03C4' ), & ! GREEK SMALL LETTER TAU <= GREEK CAPITAL LETTER TAU int ( z '03A5' ), int ( z '03C5' ), & ! GREEK SMALL LETTER UPSILON <= GREEK CAPITAL LETTER UPSILON int ( z '03A6' ), int ( z '03C6' ), & ! GREEK SMALL LETTER PHI <= GREEK CAPITAL LETTER PHI int ( z '03A7' ), int ( z '03C7' ), & ! GREEK SMALL LETTER CHI <= GREEK CAPITAL LETTER CHI int ( z '03A8' ), int ( z '03C8' ), & ! GREEK SMALL LETTER PSI <= GREEK CAPITAL LETTER PSI int ( z '03A9' ), int ( z '03C9' ), & ! GREEK SMALL LETTER OMEGA <= GREEK CAPITAL LETTER OMEGA int ( z '03AA' ), int ( z '03CA' ), & ! GREEK SMALL LETTER IOTA WITH DIALYTIKA <= GREEK CAPITAL LETTER IOTA WITH DIALYTIKA int ( z '03AB' ), int ( z '03CB' ), & ! GREEK SMALL LETTER UPSILON WITH DIALYTIKA <= GREEK CAPITAL LETTER UPSILON WITH DIALYTIKA int ( z '03E2' ), int ( z '03E3' ), & ! COPTIC SMALL LETTER SHEI <= COPTIC CAPITAL LETTER SHEI int ( z '03E4' ), int ( z '03E5' ), & ! COPTIC SMALL LETTER FEI <= COPTIC CAPITAL LETTER FEI int ( z '03E6' ), int ( z '03E7' ), & ! COPTIC SMALL LETTER KHEI <= COPTIC CAPITAL LETTER KHEI int ( z '03E8' ), int ( z '03E9' ), & ! COPTIC SMALL LETTER HORI <= COPTIC CAPITAL LETTER HORI int ( z '03EA' ), int ( z '03EB' ), & ! COPTIC SMALL LETTER GANGIA <= COPTIC CAPITAL LETTER GANGIA int ( z '03EC' ), int ( z '03ED' ), & ! COPTIC SMALL LETTER SHIMA <= COPTIC CAPITAL LETTER SHIMA int ( z '03EE' ), int ( z '03EF' ), & ! COPTIC SMALL LETTER DEI <= COPTIC CAPITAL LETTER DEI int ( z '0401' ), int ( z '0451' ), & ! CYRILLIC SMALL LETTER IO <= CYRILLIC CAPITAL LETTER IO int ( z '0402' ), int ( z '0452' ), & ! CYRILLIC SMALL LETTER DJE (SERBOCROATIAN) <= CYRILLIC CAPITAL LETTER DJE (SERBOCROATIAN) int ( z '0403' ), int ( z '0453' ), & ! CYRILLIC SMALL LETTER GJE <= CYRILLIC CAPITAL LETTER GJE int ( z '0404' ), int ( z '0454' ), & ! CYRILLIC SMALL LETTER UKRAINIAN IE <= CYRILLIC CAPITAL LETTER UKRAINIAN IE int ( z '0405' ), int ( z '0455' ), & ! CYRILLIC SMALL LETTER DZE <= CYRILLIC CAPITAL LETTER DZE int ( z '0406' ), int ( z '0456' ), & ! CYRILLIC SMALL LETTER BYELORUSSIAN-UKRAINIAN I <= CYRILLIC CAPITAL LETTER BYELORUSSIAN_UKRAINIAN I int ( z '0407' ), int ( z '0457' ), & ! CYRILLIC SMALL LETTER YI (UKRAINIAN) <= CYRILLIC CAPITAL LETTER YI (UKRAINIAN) int ( z '0408' ), int ( z '0458' ), & ! CYRILLIC SMALL LETTER JE <= CYRILLIC CAPITAL LETTER JE int ( z '0409' ), int ( z '0459' ), & ! CYRILLIC SMALL LETTER LJE <= CYRILLIC CAPITAL LETTER LJE int ( z '040A' ), int ( z '045A' ), & ! CYRILLIC SMALL LETTER NJE <= CYRILLIC CAPITAL LETTER NJE int ( z '040B' ), int ( z '045B' ), & ! CYRILLIC SMALL LETTER TSHE (SERBOCROATIAN) <= CYRILLIC CAPITAL LETTER TSHE (SERBOCROATIAN) int ( z '040C' ), int ( z '045C' ), & ! CYRILLIC SMALL LETTER KJE <= CYRILLIC CAPITAL LETTER KJE int ( z '040E' ), int ( z '045E' ), & ! CYRILLIC SMALL LETTER SHORT U (BYELORUSSIAN) <= CYRILLIC CAPITAL LETTER SHORT U (BYELORUSSIAN) int ( z '040F' ), int ( z '045F' ), & ! CYRILLIC SMALL LETTER DZHE <= CYRILLIC CAPITAL LETTER DZHE int ( z '0410' ), int ( z '0430' ), & ! CYRILLIC SMALL LETTER A <= CYRILLIC CAPITAL LETTER A int ( z '0411' ), int ( z '0431' ), & ! CYRILLIC SMALL LETTER BE <= CYRILLIC CAPITAL LETTER BE int ( z '0412' ), int ( z '0432' ), & ! CYRILLIC SMALL LETTER VE <= CYRILLIC CAPITAL LETTER VE int ( z '0413' ), int ( z '0433' ), & ! CYRILLIC SMALL LETTER GHE <= CYRILLIC CAPITAL LETTER GHE int ( z '0414' ), int ( z '0434' ), & ! CYRILLIC SMALL LETTER DE <= CYRILLIC CAPITAL LETTER DE int ( z '0415' ), int ( z '0435' ), & ! CYRILLIC SMALL LETTER IE <= CYRILLIC CAPITAL LETTER IE int ( z '0416' ), int ( z '0436' ), & ! CYRILLIC SMALL LETTER ZHE <= CYRILLIC CAPITAL LETTER ZHE int ( z '0417' ), int ( z '0437' ), & ! CYRILLIC SMALL LETTER ZE <= CYRILLIC CAPITAL LETTER ZE int ( z '0418' ), int ( z '0438' ), & ! CYRILLIC SMALL LETTER I <= CYRILLIC CAPITAL LETTER I int ( z '0419' ), int ( z '0439' ), & ! CYRILLIC SMALL LETTER SHORT I <= CYRILLIC CAPITAL LETTER SHORT I int ( z '041A' ), int ( z '043A' ), & ! CYRILLIC SMALL LETTER KA <= CYRILLIC CAPITAL LETTER KA int ( z '041B' ), int ( z '043B' ), & ! CYRILLIC SMALL LETTER EL <= CYRILLIC CAPITAL LETTER EL int ( z '041C' ), int ( z '043C' ), & ! CYRILLIC SMALL LETTER EM <= CYRILLIC CAPITAL LETTER EM int ( z '041D' ), int ( z '043D' ), & ! CYRILLIC SMALL LETTER EN <= CYRILLIC CAPITAL LETTER EN int ( z '041E' ), int ( z '043E' ), & ! CYRILLIC SMALL LETTER O <= CYRILLIC CAPITAL LETTER O int ( z '041F' ), int ( z '043F' ), & ! CYRILLIC SMALL LETTER PE <= CYRILLIC CAPITAL LETTER PE int ( z '0420' ), int ( z '0440' ), & ! CYRILLIC SMALL LETTER ER <= CYRILLIC CAPITAL LETTER ER int ( z '0421' ), int ( z '0441' ), & ! CYRILLIC SMALL LETTER ES <= CYRILLIC CAPITAL LETTER ES int ( z '0422' ), int ( z '0442' ), & ! CYRILLIC SMALL LETTER TE <= CYRILLIC CAPITAL LETTER TE int ( z '0423' ), int ( z '0443' ), & ! CYRILLIC SMALL LETTER U <= CYRILLIC CAPITAL LETTER U int ( z '0424' ), int ( z '0444' ), & ! CYRILLIC SMALL LETTER EF <= CYRILLIC CAPITAL LETTER EF int ( z '0425' ), int ( z '0445' ), & ! CYRILLIC SMALL LETTER HA <= CYRILLIC CAPITAL LETTER HA int ( z '0426' ), int ( z '0446' ), & ! CYRILLIC SMALL LETTER TSE <= CYRILLIC CAPITAL LETTER TSE int ( z '0427' ), int ( z '0447' ), & ! CYRILLIC SMALL LETTER CHE <= CYRILLIC CAPITAL LETTER CHE int ( z '0428' ), int ( z '0448' ), & ! CYRILLIC SMALL LETTER SHA <= CYRILLIC CAPITAL LETTER SHA int ( z '0429' ), int ( z '0449' ), & ! CYRILLIC SMALL LETTER SHCHA <= CYRILLIC CAPITAL LETTER SHCHA int ( z '042A' ), int ( z '044A' ), & ! CYRILLIC SMALL LETTER HARD SIGN <= CYRILLIC CAPITAL LETTER HARD SIGN int ( z '042B' ), int ( z '044B' ), & ! CYRILLIC SMALL LETTER YERU <= CYRILLIC CAPITAL LETTER YERU int ( z '042C' ), int ( z '044C' ), & ! CYRILLIC SMALL LETTER SOFT SIGN <= CYRILLIC CAPITAL LETTER SOFT SIGN int ( z '042D' ), int ( z '044D' ), & ! CYRILLIC SMALL LETTER E <= CYRILLIC CAPITAL LETTER E int ( z '042E' ), int ( z '044E' ), & ! CYRILLIC SMALL LETTER YU <= CYRILLIC CAPITAL LETTER YU int ( z '042F' ), int ( z '044F' ), & ! CYRILLIC SMALL LETTER YA <= CYRILLIC CAPITAL LETTER YA int ( z '0460' ), int ( z '0461' ), & ! CYRILLIC SMALL LETTER OMEGA <= CYRILLIC CAPITAL LETTER OMEGA int ( z '0462' ), int ( z '0463' ), & ! CYRILLIC SMALL LETTER YAT <= CYRILLIC CAPITAL LETTER YAT int ( z '0464' ), int ( z '0465' ), & ! CYRILLIC SMALL LETTER IOTIFIED E <= CYRILLIC CAPITAL LETTER IOTIFIED E int ( z '0466' ), int ( z '0467' ), & ! CYRILLIC SMALL LETTER LITTLE YUS <= CYRILLIC CAPITAL LETTER LITTLE YUS int ( z '0468' ), int ( z '0469' ), & ! CYRILLIC SMALL LETTER IOTIFIED LITTLE YUS <= CYRILLIC CAPITAL LETTER IOTIFIED LITTLE YUS int ( z '046A' ), int ( z '046B' ), & ! CYRILLIC SMALL LETTER BIG YUS <= CYRILLIC CAPITAL LETTER BIG YUS int ( z '046C' ), int ( z '046D' ), & ! CYRILLIC SMALL LETTER IOTIFIED BIG YUS <= CYRILLIC CAPITAL LETTER IOTIFIED BIG YUS int ( z '046E' ), int ( z '046F' ), & ! CYRILLIC SMALL LETTER KSI <= CYRILLIC CAPITAL LETTER KSI int ( z '0470' ), int ( z '0471' ), & ! CYRILLIC SMALL LETTER PSI <= CYRILLIC CAPITAL LETTER PSI int ( z '0472' ), int ( z '0473' ), & ! CYRILLIC SMALL LETTER FITA <= CYRILLIC CAPITAL LETTER FITA int ( z '0474' ), int ( z '0475' ), & ! CYRILLIC SMALL LETTER IZHITSA <= CYRILLIC CAPITAL LETTER IZHITSA int ( z '0476' ), int ( z '0477' ), & ! CYRILLIC SMALL LETTER IZHITSA WITH DOUBLE GRAVE ACCENT <= CYRILLIC CAPITAL LETTER IZHITSA WITH DOUBLE GRAVE ACCENT int ( z '0478' ), int ( z '0479' ), & ! CYRILLIC SMALL LETTER UK <= CYRILLIC CAPITAL LETTER UK int ( z '047A' ), int ( z '047B' ), & ! CYRILLIC SMALL LETTER ROUND OMEGA <= CYRILLIC CAPITAL LETTER ROUND OMEGA int ( z '047C' ), int ( z '047D' ), & ! CYRILLIC SMALL LETTER OMEGA WITH TITLO <= CYRILLIC CAPITAL LETTER OMEGA WITH TITLO int ( z '047E' ), int ( z '047F' ), & ! CYRILLIC SMALL LETTER OT <= CYRILLIC CAPITAL LETTER OT int ( z '0480' ), int ( z '0481' ), & ! CYRILLIC SMALL LETTER KOPPA <= CYRILLIC CAPITAL LETTER KOPPA int ( z '0490' ), int ( z '0491' ), & ! CYRILLIC SMALL LETTER GHE WITH UPTURN <= CYRILLIC CAPITAL LETTER GHE WITH UPTURN int ( z '0492' ), int ( z '0493' ), & ! CYRILLIC SMALL LETTER GHE WITH STROKE <= CYRILLIC CAPITAL LETTER GHE WITH STROKE int ( z '0494' ), int ( z '0495' ), & ! CYRILLIC SMALL LETTER GHE WITH MIDDLE HOOK <= CYRILLIC CAPITAL LETTER GHE WITH MIDDLE HOOK int ( z '0496' ), int ( z '0497' ), & ! CYRILLIC SMALL LETTER ZHE WITH DESCENDER <= CYRILLIC CAPITAL LETTER ZHE WITH DESCENDER int ( z '0498' ), int ( z '0499' ), & ! CYRILLIC SMALL LETTER ZE WITH DESCENDER <= CYRILLIC CAPITAL LETTER ZE WITH DESCENDER int ( z '049A' ), int ( z '049B' ), & ! CYRILLIC SMALL LETTER KA WITH DESCENDER <= CYRILLIC CAPITAL LETTER KA WITH DESCENDER int ( z '049C' ), int ( z '049D' ), & ! CYRILLIC SMALL LETTER KA WITH VERTICAL STROKE <= CYRILLIC CAPITAL LETTER KA WITH VERTICAL STROKE int ( z '049E' ), int ( z '049F' ), & ! CYRILLIC SMALL LETTER KA WITH STROKE <= CYRILLIC CAPITAL LETTER KA WITH STROKE int ( z '04A0' ), int ( z '04A1' ), & ! CYRILLIC SMALL LETTER EASHKIR KA <= CYRILLIC CAPITAL LETTER BASHKIR KA int ( z '04A2' ), int ( z '04A3' ), & ! CYRILLIC SMALL LETTER EN WITH DESCENOER <= CYRILLIC CAPITAL LETTER EN WITH DESCENDER int ( z '04A4' ), int ( z '04A5' ), & ! CYRILLIC SMALL LIGATURE EN GHE <= CYRILLIC CAPITAL LIGATURE EN GHF int ( z '04A6' ), int ( z '04A7' ), & ! CYRILLIC SMALL LETTER PE WITH MIDDLE HOOK (ABKHASIAN) <= CYRILLIC CAPITAL LETTER PE WITH MIDDLE HOOK (ABKHASIAN) int ( z '04A8' ), int ( z '04A9' ), & ! CYRILLIC SMALL LETTER ABKHASIAN HA <= CYRILLIC CAPITAL LETTER ABKHASIAN HA int ( z '04AA' ), int ( z '04AB' ), & ! CYRILLIC SMALL LETTER ES WITH DESCENDER <= CYRILLIC CAPITAL LETTER ES WITH DESCENDER int ( z '04AC' ), int ( z '04AD' ), & ! CYRILLIC SMALL LETTER TE WITH DESCENDER <= CYRILLIC CAPITAL LETTER TE WITH DESCENDER int ( z '04AE' ), int ( z '04AF' ), & ! CYRILLIC SMALL LETTER STRAIGHT U <= CYRILLIC CAPITAL LETTER STRAIGHT U int ( z '04B0' ), int ( z '04B1' ), & ! CYRILLIC SMALL LETTER STRAIGHT U WITH STROKE <= CYRILLIC CAPITAL LETTER STRAIGHT U WITH STROKE int ( z '04B2' ), int ( z '04B3' ), & ! CYRILLIC SMALL LETTER HA WITH DESCENDER <= CYRILLIC CAPITAL LETTER HA WITH DESCENDER int ( z '04B4' ), int ( z '04B5' ), & ! CYRILLIC SMALL LIGATURE TE TSE (ABKHASIAN) <= CYRILLIC CAPITAL LIGATURE TE TSE (ABKHASIAN) int ( z '04B6' ), int ( z '04B7' ), & ! CYRILLIC SMALL LETTER CHE WITH DESCENDER <= CYRILLIC CAPITAL LETTER CHE WITH DESCENDER int ( z '04B8' ), int ( z '04B9' ), & ! CYRILLIC SMALL LETTER CHE WITH VERTICAL STROKE <= CYRILLIC CAPITAL LETTER CHE WITH VERTICAL STROKE int ( z '04BA' ), int ( z '04BB' ), & ! CYRILLIC SMALL LETTER SHHA <= CYRILLIC CAPITAL LETTER SHHA int ( z '04BC' ), int ( z '04BD' ), & ! CYRILLIC SMALL LETTER ABKHASIAN CHE <= CYRILLIC CAPITAL LETTER ABKHASIAN CHE int ( z '04BE' ), int ( z '04BF' ), & ! CYRILLIC SMALL LETTER ABKHASIAN CHE WITH DESCENDER <= CYRILLIC CAPITAL LETTER ABKHASIAN CHE WITH DESCENDER int ( z '04C1' ), int ( z '04C2' ), & ! CYRILLIC SMALL LETTER ZHE WITH BREVE <= CYRILLIC CAPITAL LETTER ZHE WITH BREVE int ( z '04C3' ), int ( z '04C4' ), & ! CYRILLIC SMALL LETTER KA WITH HOOK <= CYRILLIC CAPITAL LETTER KA WITH HOOK int ( z '04C7' ), int ( z '04C8' ), & ! CYRILLIC SMALL LETTER EN WITH HOOK <= CYRILLIC CAPITAL LETTER EN WITH HOOK int ( z '04CB' ), int ( z '04CC' ), & ! CYRILLIC SMALL LETTER KHAKASSIAN CHE <= CYRILLIC CAPITAL LETTER KHAKASSIAN CHE int ( z '04D0' ), int ( z '04D1' ), & ! CYRILLIC SMALL LETTER A WITH BREVE <= CYRILLIC CAPITAL LETTER A WITH BREVE int ( z '04D2' ), int ( z '04D3' ), & ! CYRILLIC SMALL LETTER A WITH DIAERESIS <= CYRILLIC CAPITAL LETTER A WITH DIAERESIS int ( z '04D4' ), int ( z '04D5' ), & ! CYRILLIC SMALL LIGATURE A IE <= CYRILLIC CAPITAL LIGATURE A IE int ( z '04D6' ), int ( z '04D7' ), & ! CYRILLIC SMALL LETTER IE WITH BREVE <= CYRILLIC CAPITAL LETTER IE WITH BREVE int ( z '04D8' ), int ( z '04D9' ), & ! CYRILLIC SMALL LETTER SCHWA <= CYRILLIC CAPITAL LETTER SCHWA int ( z '04DA' ), int ( z '04DB' ), & ! CYRILLIC SMALL LETTER SCHWA WITH DIAERESIS <= CYRILLIC CAPITAL LETTER SCHWA WITH DIAERESIS int ( z '04DC' ), int ( z '04DD' ), & ! CYRILLIC SMALL LETTER ZHE WITH DIAERESIS <= CYRILLIC CAPITAL LETTER ZHE WITH DIAERESIS int ( z '04DE' ), int ( z '04DF' ), & ! CYRILLIC SMALL LETTER ZE WITH DIAERESIS <= CYRILLIC CAPITAL LETTER ZE WITH DIAERESIS int ( z '04E0' ), int ( z '04E1' ), & ! CYRILLIC SMALL LETTER ABKHASIAN DZE <= CYRILLIC CAPITAL LETTER ABKHASIAN DZE int ( z '04E2' ), int ( z '04E3' ), & ! CYRILLIC SMALL LETTER I WITH MACRON <= CYRILLIC CAPITAL LETTER I WITH MACRON int ( z '04E4' ), int ( z '04E5' ), & ! CYRILLIC SMALL LETTER I WITH DIAERESIS <= CYRILLIC CAPITAL LETTER I WITH DIAERESIS int ( z '04E6' ), int ( z '04E7' ), & ! CYRILLIC SMALL LETTER O WITH DIAERESIS <= CYRILLIC CAPITAL LETTER O WITH DIAERESIS int ( z '04E8' ), int ( z '04E9' ), & ! CYRILLIC SMALL LETTER BARRED O <= CYRILLIC CAPITAL LETTER BARRED O int ( z '04EA' ), int ( z '04EB' ), & ! CYRILLIC SMALL LETTER BARRED O WITH DIAERESIS <= CYRILLIC CAPITAL LETTER BARRED O WITH DIAERESIS int ( z '04EE' ), int ( z '04EF' ), & ! CYRILLIC SMALL LETTER U WITH MACRON <= CYRILLIC CAPITAL LETTER U WITH MACRON int ( z '04F0' ), int ( z '04F1' ), & ! CYRILLIC SMALL LETTER U WITH DIAERESIS <= CYRILLIC CAPITAL LETTER U WITH DIAERESIS int ( z '04F2' ), int ( z '04F3' ), & ! CYRILLIC SMALL LETTER U WITH DOUBLE ACUTE <= CYRILLIC CAPITAL LETTER U WITH DOUBLE ACUTE int ( z '04F4' ), int ( z '04F5' ), & ! CYRILLIC SMALL LETTER CHE AITH DIAERESIS <= CYRILLIC CAPITAL LETTER CHE WITH DIAERESIS int ( z '04F8' ), int ( z '04F9' ), & ! CYRILLIC SMALL LETTER YERU WITH DIAERESIS <= CYRILLIC CAPITAL LETTER YERU WITH DIAERESIS int ( z '0531' ), int ( z '0561' ), & ! ARMENIAN SMALL LETTER AYB <= ARMENIAN CAPITAL LETTER AYB int ( z '0532' ), int ( z '0562' ), & ! ARMENIAN SMALL LETTER BEN <= ARMENIAN CAPITAL LETTER BEN int ( z '0533' ), int ( z '0563' ), & ! ARMENIAN SMALL LETTER GIM <= ARMENIAN CAPITAL LETTER GIM int ( z '0534' ), int ( z '0564' ), & ! ARMENIAN SMALL LETTER DA <= ARMENIAN CAPITAL LETTER DA int ( z '0535' ), int ( z '0565' ), & ! ARMENIAN SMALL LETTER ECH <= ARMENIAN CAPITAL LETTER ECH int ( z '0536' ), int ( z '0566' ), & ! ARMENIAN SMALL LETTER ZA <= ARMENIAN CAPITAL LETTER ZA int ( z '0537' ), int ( z '0567' ), & ! ARMENIAN SMALL LETTER EH <= ARMENIAN CAPITAL LETTER EH int ( z '0538' ), int ( z '0568' ), & ! ARMENIAN SMALL LETTER ET <= ARMENIAN CAPITAL LETTER ET int ( z '0539' ), int ( z '0569' ), & ! ARMENIAN SMALL LETTER TO <= ARMENIAN CAPITAL LETTER TO int ( z '053A' ), int ( z '056A' ), & ! ARMENIAN SMALL LETTER ZHE <= ARMENIAN CAPITAL LETTER ZHE int ( z '053B' ), int ( z '056B' ), & ! ARMENIAN SMALL LETTER INI <= ARMENIAN CAPITAL LETTER INI int ( z '053C' ), int ( z '056C' ), & ! ARMENIAN SMALL LETTER LIWN <= ARMENIAN CAPITAL LETTER LIWN int ( z '053D' ), int ( z '056D' ), & ! ARMENIAN SMALL LETTER XEH <= ARMENIAN CAPITAL LETTER XEH int ( z '053E' ), int ( z '056E' ), & ! ARMENIAN SMALL LETTER CA <= ARMENIAN CAPITAL LETTER CA int ( z '053F' ), int ( z '056F' ), & ! ARMENIAN SMALL LETTER KEN <= ARMENIAN CAPITAL LETTER KEN int ( z '0540' ), int ( z '0570' ), & ! ARMENIAN SMALL LETTER HO <= ARMENIAN CAPITAL LETTER HO int ( z '0541' ), int ( z '0571' ), & ! ARMENIAN SMALL LETTER JA <= ARMENIAN CAPITAL LETTER JA int ( z '0542' ), int ( z '0572' ), & ! ARMENIAN SMALL LETTER GHAD <= ARMENIAN CAPITAL LETTER GHAD int ( z '0543' ), int ( z '0573' ), & ! ARMENIAN SMALL LETTER CHEH <= ARMENIAN CAPITAL LETTER CHEH int ( z '0544' ), int ( z '0574' ), & ! ARMENIAN SMALL LETTER MEN <= ARMENIAN CAPITAL LETTER MEN int ( z '0545' ), int ( z '0575' ), & ! ARMENIAN SMALL LETTER YI <= ARMENIAN CAPITAL LETTER YI int ( z '0546' ), int ( z '0576' ), & ! ARMENIAN SMALL LETTER NOW <= ARMENIAN CAPITAL LETTER NOW int ( z '0547' ), int ( z '0577' ), & ! ARMENIAN SMALL LETTER SNA <= ARMENIAN CAPITAL LETTER SHA int ( z '0548' ), int ( z '0578' ), & ! ARMENIAN SMALL LETTER VO <= ARMENIAN CAPITAL LETTER VO int ( z '0549' ), int ( z '0579' ), & ! ARMENIAN SMALL LETTER CHA <= ARMENIAN CAPITAL LETTER CHA int ( z '054A' ), int ( z '057A' ), & ! ARMENIAN SMALL LETTER PEH <= ARMENIAN CAPITAL LETTER PEH int ( z '054B' ), int ( z '057B' ), & ! ARMENIAN SMALL LETTER JHEH <= ARMENIAN CAPITAL LETTER JHEH int ( z '054C' ), int ( z '057C' ), & ! ARMENIAN SMALL LETTER RA <= ARMENIAN CAPITAL LETTER RA int ( z '054D' ), int ( z '057D' ), & ! ARMENIAN SMALL LETTER SEH <= ARMENIAN CAPITAL LETTER SEH int ( z '054E' ), int ( z '057E' ), & ! ARMENIAN SMALL LETTER VEW <= ARMENIAN CAPITAL LETTER VEW int ( z '054F' ), int ( z '057F' ), & ! ARMENIAN SMALL LETTER TIWN <= ARMENIAN CAPITAL LETTER TIWN int ( z '0550' ), int ( z '0580' ), & ! ARMENIAN SMALL LETTER REH <= ARMENIAN CAPITAL LETTER REH int ( z '0551' ), int ( z '0581' ), & ! ARMENIAN SMALL LETTER CO <= ARMENIAN CAPITAL LETTER CO int ( z '0552' ), int ( z '0582' ), & ! ARMENIAN SMALL LETTER YIWN <= ARMENIAN CAPITAL LETTER YIWN int ( z '0553' ), int ( z '0583' ), & ! ARMENIAN SMALL LETTER PIWP <= ARMENIAN CAPITAL LETTER PIWR int ( z '0554' ), int ( z '0584' ), & ! ARMENIAN SMALL LETTER KEH <= ARMENIAN CAPITAL LETTER KEH int ( z '0555' ), int ( z '0585' ), & ! ARMENIAN SMALL LETTER OH <= ARMENIAN CAPITAL LETTER OH int ( z '0556' ), int ( z '0586' ), & ! ARMENIAN SMALL LETTER FEH <= ARMENIAN CAPITAL LETTER FEH int ( z '10A0' ), int ( z '10D0' ), & ! GEORGIAN LETTER AN <= GEORGIAN CAPITAL LETTER AN (KHUTSURI) int ( z '10A1' ), int ( z '10D1' ), & ! GEORGIAN LETTER BAN <= GEORGIAN CAPITAL LETTER BAN (KHUTSURI) int ( z '10A2' ), int ( z '10D2' ), & ! GEORGIAN LETTER GAN <= GEORGIAN CAPITAL LETTER GAN (KHUTSURI) int ( z '10A3' ), int ( z '10D3' ), & ! GEORGIAN LETTER DON <= GEORGIAN CAPITAL LETTER DON (KHUTSURI) int ( z '10A4' ), int ( z '10D4' ), & ! GEORGIAN LETTER EN <= GEORGIAN CAPITAL LETTER EN (KHUTSURI) int ( z '10A5' ), int ( z '10D5' ), & ! GEORGIAN LETTER VIN <= GEORGIAN CAPITAL LETTER VIN (KHUTSURI) int ( z '10A6' ), int ( z '10D6' ), & ! GEORGIAN LETTER ZEN <= GEORGIAN CAPITAL LETTER ZEN (KHUTSURI) int ( z '10A7' ), int ( z '10D7' ), & ! GEORGIAN LETTER TAN <= GEORGIAN CAPITAL LETTER TAN (KHUTSURI) int ( z '10A8' ), int ( z '10D8' ), & ! GEORGIAN LETTER IN <= GEORGIAN CAPITAL LETTER IN (KHUTSURI) int ( z '10A9' ), int ( z '10D9' ), & ! GEORGIAN LETTER KAN <= GEORGIAN CAPITAL LETTER KAN (KHUTSURI) int ( z '10AA' ), int ( z '10DA' ), & ! GEORGIAN LETTER LAS <= GEORGIAN CAPITAL LETTER LAS (KHUTSURI) int ( z '10AB' ), int ( z '10DB' ), & ! GEORGIAN LETTER MAN <= GEORGIAN CAPITAL LETTER MAN (KHUTSURI) int ( z '10AC' ), int ( z '10DC' ), & ! GEORGIAN LETTER NAR <= GEORGIAN CAPITAL LETTER NAR (KHUTSURI) int ( z '10AD' ), int ( z '10DD' ), & ! GEORGIAN LETTER ON <= GEORGIAN CAPITAL LETTER ON (KHUTSURI) int ( z '10AE' ), int ( z '10DE' ), & ! GEORGIAN LETTER PAR <= GEORGIAN CAPITAL LETTER PAR (KHUTSURI) int ( z '10AF' ), int ( z '10DF' ), & ! GEORGIAN LETTER ZHAR <= GEORGIAN CAPITAL LETTER ZHAR (KHUTSURI) int ( z '10B0' ), int ( z '10E0' ), & ! GEORGIAN LETTER RAE <= GEORGIAN CAPITAL LETTER RAE (KHUTSURI) int ( z '10B1' ), int ( z '10E1' ), & ! GEORGIAN LETTER SAN <= GEORGIAN CAPITAL LETTER SAN (KHUTSURI) int ( z '10B2' ), int ( z '10E2' ), & ! GEORGIAN LETTER TAR <= GEORGIAN CAPITAL LETTER TAR (KHUTSURI) int ( z '10B3' ), int ( z '10E3' ), & ! GEORGIAN LETTER UN <= GEORGIAN CAPITAL LETTER UN (KHUTSURI) int ( z '10B4' ), int ( z '10E4' ), & ! GEORGIAN LETTER PHAR <= GEORGIAN CAPITAL LETTER PHAR (KHUTSURI) int ( z '10B5' ), int ( z '10E5' ), & ! GEORGIAN LETTER KHAR <= GEORGIAN CAPITAL LETTER KHAR (KHUTSURI) int ( z '10B6' ), int ( z '10E6' ), & ! GEORGIAN LETTER GHAN <= GEORGIAN CAPITAL LETTER GHAN (KHUTSURI) int ( z '10B7' ), int ( z '10E7' ), & ! GEORGIAN LETTER QAR <= GEORGIAN CAPITAL LETTER QAR (KHUTSURI) int ( z '10B8' ), int ( z '10E8' ), & ! GEORGIAN LETTER SHIN <= GEORGIAN CAPITAL LETTER SHIN (KHUTSURI) int ( z '10B9' ), int ( z '10E9' ), & ! GEORGIAN LETTER CHIN <= GEORGIAN CAPITAL LETTER CHIN (KHUTSURI) int ( z '10BA' ), int ( z '10EA' ), & ! GEORGIAN LETTER CAN <= GEORGIAN CAPITAL LETTER CAN (KHUTSURI) int ( z '10BB' ), int ( z '10EB' ), & ! GEORGIAN LETTER JIL <= GEORGIAN CAPITAL LETTER JIL (KHUTSURI) int ( z '10BC' ), int ( z '10EC' ), & ! GEORGIAN LETTER CIL <= GEORGIAN CAPITAL LETTER CIL (KHUTSURI) int ( z '10BD' ), int ( z '10ED' ), & ! GEORGIAN LETTER CHAR <= GEORGIAN CAPITAL LETTER CHAR (KHUTSURI) int ( z '10BE' ), int ( z '10EE' ), & ! GEORGIAN LETTER XAN <= GEORGIAN CAPITAL LETTER XAN (KHUTSURI) int ( z '10BF' ), int ( z '10EF' ), & ! GEORGIAN LETTER JHAN <= GEORGIAN CAPITAL LETTER JHAN (KHUTSURI) int ( z '10C0' ), int ( z '10F0' ), & ! GEORGIAN LETTER HAE <= GEORGIAN CAPITAL LETTER HAE (KHUTSURI) int ( z '10C1' ), int ( z '10F1' ), & ! GEORGIAN LETTER HE <= GEORGIAN CAPITAL LETTER HE (KHUTSURI) int ( z '10C2' ), int ( z '10F2' ), & ! GEORGIAN LETTER HIE <= GEORGIAN CAPITAL LETTER HIE (KHUTSURI) int ( z '10C3' ), int ( z '10F3' ), & ! GEORGIAN LETTER WE <= GEORGIAN CAPITAL LETTER WE (KHUTSURI) int ( z '10C4' ), int ( z '10F4' ), & ! GEORGIAN LETTER HAR <= GEORGIAN CAPITAL LETTER HAR (KHUTSURI) int ( z '10C5' ), int ( z '10F5' ), & ! GEORGIAN LETTER HOE <= GEORGIAN CAPITAL LETTER HOE (KHUTSURI) int ( z '1E00' ), int ( z '1E01' ), & ! LATIN SMALL LETTER A WITH RING BELOW <= LATIN CAPITAL LETTER A WITH RING BELOW int ( z '1E02' ), int ( z '1E03' ), & ! LATIN SMALL LETTER B WITH DOT ABOVE <= LATIN CAPITAL LETTER B WITH DOT ABOVE int ( z '1E04' ), int ( z '1E05' ), & ! LATIN SMALL LETTER B WITH DOT BELOW <= LATIN CAPITAL LETTER B WITH DOT BELOW int ( z '1E06' ), int ( z '1E07' ), & ! LATIN SMALL LETTER B WITH LINE BELOW <= LATIN CAPITAL LETTER B WITH LINE BELOW int ( z '1E08' ), int ( z '1E09' ), & ! LATIN SMALL LETTER C WITH CEDILLA AND ACUTE <= LATIN CAPITAL LETTER C WITH CEDILLA AND ACUTE int ( z '1E0A' ), int ( z '1E0B' ), & ! LATIN SMALL LETTER D WITH DOT ABOVE <= LATIN CAPITAL LETTER D WITH DOT ABOVE int ( z '1E0C' ), int ( z '1E0D' ), & ! LATIN SMALL LETTER D WITH DOT BELOW <= LATIN CAPITAL LETTER D WITH DOT BELOW int ( z '1E0E' ), int ( z '1E0F' ), & ! LATIN SMALL LETTER D WITH LINE BELOW <= LATIN CAPITAL LETTER D WITH LINE BELOW int ( z '1E10' ), int ( z '1E11' ), & ! LATIN SMALL LETTER D WITH CEDILLA <= LATIN CAPITAL LETTER D WITH CEDILLA int ( z '1E12' ), int ( z '1E13' ), & ! LATIN SMALL LETTER D WITH CIRCUMFLEX BELOW <= LATIN CAPITAL LETTER D WITH CIRCUMFLEX BELOW int ( z '1E14' ), int ( z '1E15' ), & ! LATIN SMALL LETTER E WITH MACRON AND GRAVE <= LATIN CAPITAL LETTER E WITH MACRON AND GRAVE int ( z '1E16' ), int ( z '1E17' ), & ! LATIN SMALL LETTER E WITH MACRON AND ACUTE <= LATIN CAPITAL LETTER E WITH MACRON AND ACUTE int ( z '1E18' ), int ( z '1E19' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX BELOW <= LATIN CAPITAL LETTER E WITH CIRCUMFLEX BELOW int ( z '1E1A' ), int ( z '1E1B' ), & ! LATIN SMALL LETTER E WITH TILDE BELOW <= LATIN CAPITAL LETTER E WITH TILDE BELOW int ( z '1E1C' ), int ( z '1E1D' ), & ! LATIN SMALL LETTER E WITH CEDILLA AND BREVE <= LATIN CAPITAL LETTER E WITH CEDILLA AND BREVE int ( z '1E1E' ), int ( z '1E1F' ), & ! LATIN SMALL LETTER F WITH DOT ABOVE <= LATIN CAPITAL LETTER F WITH DOT ABOVE int ( z '1E20' ), int ( z '1E21' ), & ! LATIN SMALL LETTER G WITH MACRON <= LATIN CAPITAL LETTER G WITH MACRON int ( z '1E22' ), int ( z '1E23' ), & ! LATIN SMALL LETTER H WITH DOT ABOVE <= LATIN CAPITAL LETTER H WITH DOT ABOVE int ( z '1E24' ), int ( z '1E25' ), & ! LATIN SMALL LETTER H WITH DOT BELOW <= LATIN CAPITAL LETTER H WITH DOT BELOW int ( z '1E26' ), int ( z '1E27' ), & ! LATIN SMALL LETTER H WITH DIAERESIS <= LATIN CAPITAL LETTER H WITH DIAERESIS int ( z '1E28' ), int ( z '1E29' ), & ! LATIN SMALL LETTER H WITH CEDILLA <= LATIN CAPITAL LETTER H WITH CEDILLA int ( z '1E2A' ), int ( z '1E2B' ), & ! LATIN SMALL LETTER H WITH BREVE BELOW <= LATIN CAPITAL LETTER H WITH BREVE BELOW int ( z '1E2C' ), int ( z '1E2D' ), & ! LATIN SMALL LETTER I WITH TILDE BELOW <= LATIN CAPITAL LETTER I WITH TILDE BELOW int ( z '1E2E' ), int ( z '1E2F' ), & ! LATIN SMALL LETTER I WITH DIAERESIS AND ACUTE <= LATIN CAPITAL LETTER I WITH DIAERESIS AND ACUTE int ( z '1E30' ), int ( z '1E31' ), & ! LATIN SMALL LETTER K WITH ACUTE <= LATIN CAPITAL LETTER K WITH ACUTE int ( z '1E32' ), int ( z '1E33' ), & ! LATIN SMALL LETTER K WITH DOT BELOW <= LATIN CAPITAL LETTER K WITH DOT BELOW int ( z '1E34' ), int ( z '1E35' ), & ! LATIN SMALL LETTER K WITH LINE BELOW <= LATIN CAPITAL LETTER K WITH LINE BELOW int ( z '1E36' ), int ( z '1E37' ), & ! LATIN SMALL LETTER L WITH DOT BELOW <= LATIN CAPITAL LETTER L WITH DOT BELOW int ( z '1E38' ), int ( z '1E39' ), & ! LATIN SMALL LETTER L WITH DOT BELOW AND MACRON <= LATIN CAPITAL LETTER L WITH DOT BELOW AND MACRON int ( z '1E3A' ), int ( z '1E3B' ), & ! LATIN SMALL LETTER L WITH LINE BELOW <= LATIN CAPITAL LETTER L WITH LINE BELOW int ( z '1E3C' ), int ( z '1E3D' ), & ! LATIN SMALL LETTER L WITH CIRCUMFLEX BELOW <= LATIN CAPITAL LETTER L WITH CIRCUMFLEX BELOW int ( z '1E3E' ), int ( z '1E3F' ), & ! LATIN SMALL LETTER M WITH ACUTE <= LATIN CAPITAL LETTER M WITH ACUTE int ( z '1E40' ), int ( z '1E41' ), & ! LATIN SMALL LETTER M WITH DOT ABOVE <= LATIN CAPITAL LETTER M WITH DOT ABOVE int ( z '1E42' ), int ( z '1E43' ), & ! LATIN SMALL LETTER M WITH DOT BELOW <= LATIN CAPITAL LETTER M WITH DOT BELOW int ( z '1E44' ), int ( z '1E45' ), & ! LATIN SMALL LETTER N WITH DOT ABOVE <= LATIN CAPITAL LETTER N WITH DOT ABOVE int ( z '1E46' ), int ( z '1E47' ), & ! LATIN SMALL LETTER N WITH DOT BELOW <= LATIN CAPITAL LETTER N WITH DOT BELOW int ( z '1E48' ), int ( z '1E49' ), & ! LATIN SMALL LETTER N WITH LINE BELOW <= LATIN CAPITAL LETTER N WITH LINE BELOW int ( z '1E4A' ), int ( z '1E4B' ), & ! LATIN SMALL LETTER N WITH CIRCUMFLEX BELOW <= LATIN CAPITAL LETTER N WITH CIRCUMFLEX BELOW int ( z '1E4C' ), int ( z '1E4D' ), & ! LATIN SMALL LETTER O WITH TILDE AND ACUTE <= LATIN CAPITAL LETTER O WITH TILDE AND ACUTE int ( z '1E4E' ), int ( z '1E4F' ), & ! LATIN SMALL LETTER O WITH TlLDE AND DIAERESIS <= LATIN CAPITAL LETTER O WITH TILDE AND DIAERESIS int ( z '1E50' ), int ( z '1E51' ), & ! LATIN SMALL LETTER O WITH MACRON AND GRAVE <= LATIN CAPITAL LETTER O WITH MACRON AND GRAVE int ( z '1E52' ), int ( z '1E53' ), & ! LATIN SMALL LETTER O WITH MACRON AND ACUTE <= LATIN CAPITAL LETTER O WITH MACRON AND ACUTE int ( z '1E54' ), int ( z '1E55' ), & ! LATIN SMALL LETTER P WITH ACUTE <= LATIN CAPITAL LETTER P WITH ACUTE int ( z '1E56' ), int ( z '1E57' ), & ! LATIN SMALL LETTER P WITH DOT ABOVE <= LATIN CAPITAL LETTER P WITH DOT ABOVE int ( z '1E58' ), int ( z '1E59' ), & ! LATIN SMALL LETTER R WITH DOT ABOVE <= LATIN CAPITAL LETTER R WITH DOT ABOVE int ( z '1E5A' ), int ( z '1E5B' ), & ! LATIN SMALL LETTER R WITH DOT BELOW <= LATIN CAPITAL LETTER R WITH DOT BELOW int ( z '1E5C' ), int ( z '1E5D' ), & ! LATIN SMALL LETTER R WITH DOT BELOW AND MACRON <= LATIN CAPITAL LETTER R WITH DOT BELOW AND MACRON int ( z '1E5E' ), int ( z '1E5F' ), & ! LATIN SMALL LETTER R WITH LINE BELOW <= LATIN CAPITAL LETTER R WITH LINE BELOW int ( z '1E60' ), int ( z '1E61' ), & ! LATIN SMALL LETTER S WITH DOT ABOVE <= LATIN CAPITAL LETTER S WITH DOT ABOVE int ( z '1E62' ), int ( z '1E63' ), & ! LATIN SMALL LETTER S WITH DOT BELOW <= LATIN CAPITAL LETTER S WITH DOT BELOW int ( z '1E64' ), int ( z '1E65' ), & ! LATIN SMALL LETTER S WITH ACUTE AND DOT ABOVE <= LATIN CAPITAL LETTER S WITH ACUTE AND DOT ABOVE int ( z '1E66' ), int ( z '1E67' ), & ! LATIN SMALL LETTER S WITH CARON AND DOT ABOVE <= LATIN CAPITAL LETTER S WITH CARON AND DOT ABOVE int ( z '1E68' ), int ( z '1E69' ), & ! LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE <= LATIN CAPITAL LETTER S WITH DOT BELOW AND DOT ABOVE int ( z '1E6A' ), int ( z '1E6B' ), & ! LATIN SMALL LETTER T WITH DOT ABOVE <= LATIN CAPITAL LETTER T WITH DOT ABOVE int ( z '1E6C' ), int ( z '1E6D' ), & ! LATIN SMALL LETTER T WITH DOT BELOW <= LATIN CAPITAL LETTER T WITH DOT BELOW int ( z '1E6E' ), int ( z '1E6F' ), & ! LATIN SMALL LETTER T WITH LINE BELOW <= LATIN CAPITAL LETTER T WITH LINE BELOW int ( z '1E70' ), int ( z '1E71' ), & ! LATIN SMALL LETTER T WITH CIRCUMFLEX BELOW <= LATIN CAPITAL LETTER T WITH CIRCUMFLEX BELOW int ( z '1E72' ), int ( z '1E73' ), & ! LATIN SMALL LETTER U WITH DIAERESIS BELOW <= LATIN CAPITAL LETTER U WITH DIAERESIS BELOW int ( z '1E74' ), int ( z '1E75' ), & ! LATIN SMALL LETTER U WITH TILDE BELOW <= LATIN CAPITAL LETTER U WITH TILDE BELOW int ( z '1E76' ), int ( z '1E77' ), & ! LATIN SMALL LETTER U WITH CIRCUMFLEX BELOW <= LATIN CAPITAL LETTER U WITH CIRCUMFLEX BELOW int ( z '1E78' ), int ( z '1E79' ), & ! LATIN SMALL LETTER U WITH TILDE AND ACUTE <= LATIN CAPITAL LETTER U WITH TILDE AND ACUTE int ( z '1E7A' ), int ( z '1E7B' ), & ! LATIN SMALL LETTER U WITH MACRON AND DIAERESIS <= LATIN CAPITAL LETTER U WITH MACRON AND DIAERESIS int ( z '1E7C' ), int ( z '1E7D' ), & ! LATIN SMALL LETTER V WITH TILDE <= LATIN CAPITAL LETTER V WITH TILDE int ( z '1E7E' ), int ( z '1E7F' ), & ! LATIN SMALL LETTER V WITH DOT BELOW <= LATIN CAPITAL LETTER V WITH DOT BELOW int ( z '1E80' ), int ( z '1E81' ), & ! LATIN SMALL LETTER W WITH GRAVE <= LATIN CAPITAL LETTER W WITH GRAVE int ( z '1E82' ), int ( z '1E83' ), & ! LATIN SMALL LETTER W WITH ACUTE <= LATIN CAPITAL LETTER W WITH ACUTE int ( z '1E84' ), int ( z '1E85' ), & ! LATIN SMALL LETTER W WITH DIAERESIS <= LATIN CAPITAL LETTER W WITH DIAERESIS int ( z '1E86' ), int ( z '1E87' ), & ! LATIN SMALL LETTER W WITH DOT ABOVE <= LATIN CAPITAL LETTER W WITH DOT ABOVE int ( z '1E88' ), int ( z '1E89' ), & ! LATIN SMALL LETTER W WITH DOT BELOW <= LATIN CAPITAL LETTER W WITH DOT BELOW int ( z '1E8A' ), int ( z '1E8B' ), & ! LATIN SMALL LETTER X WITH DOT ABOVE <= LATIN CAPITAL LETTER X WITH DOT ABOVE int ( z '1E8C' ), int ( z '1E8D' ), & ! LATIN SMALL LETTER X WITH DIAERESIS <= LATIN CAPITAL LETTER X5 WITH DIAERESIS int ( z '1E8E' ), int ( z '1E8F' ), & ! LATIN SMALL LETTER Y WITH DOT ABOVE <= LATIN CAPITAL LETTER Y WITH DOT ABOVE int ( z '1E90' ), int ( z '1E91' ), & ! LATIN SMALL LETTER Z WITH CIRCUMFLEX <= LATIN CAPITAL LETTER Z WITH CIRCUMFLEX int ( z '1E92' ), int ( z '1E93' ), & ! LATIN SMALL LETTER Z WITH DOT BELOW <= LATIN CAPITAL LETTER Z WITH DOT BELOW int ( z '1E94' ), int ( z '1E95' ), & ! LATIN SMALL LETTER Z WITH LINE BELOW <= LATIN CAPITAL LETTER Z WITH LINE BELOW int ( z '1EA0' ), int ( z '1EA1' ), & ! LATIN SMALL LETTER A WITH DOT BELOW <= LATIN CAPITAL LETTER A WITH DOT BELOW int ( z '1EA2' ), int ( z '1EA3' ), & ! LATIN SMALL LETTER A WITH HOOK ABOVE <= LATIN CAPITAL LETTER A WITH HOOK ABOVE int ( z '1EA4' ), int ( z '1EA5' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE <= LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE int ( z '1EA6' ), int ( z '1EA7' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND GRAVE <= LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND GRAVE int ( z '1EA8' ), int ( z '1EA9' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE <= LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE int ( z '1EAA' ), int ( z '1EAB' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND TILDE <= LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND TILDE int ( z '1EAC' ), int ( z '1EAD' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND DOT BELOW <= LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND DOT BELOW int ( z '1EAE' ), int ( z '1EAF' ), & ! LATIN SMALL LETTER A WITH BREVE AND ACUTE <= LATIN CAPITAL LETTER A WITH BREVE AND ACUTE int ( z '1EB0' ), int ( z '1EB1' ), & ! LATIN SMALL LETTER A WITH BREVE AND GRAVE <= LATIN CAPITAL LETTER A WITH BREVE AND GRAVE int ( z '1EB2' ), int ( z '1EB3' ), & ! LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE <= LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE int ( z '1EB4' ), int ( z '1EB5' ), & ! LATIN SMALL LETTER A WITH BREVE AND TILDE <= LATIN CAPITAL LETTER A WITH BREVE AND TILDE int ( z '1EB6' ), int ( z '1EB7' ), & ! LATIN SMALL LETTER A WITH BREVE AND DOT BELOW <= LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW int ( z '1EB8' ), int ( z '1EB9' ), & ! LATIN SMALL LETTER E WITH DOT BELOW <= LATIN CAPITAL LETTER E WITH DOT BELOW int ( z '1EBA' ), int ( z '1EBB' ), & ! LATIN SMALL LETTER E WITH HOOK ABOVE <= LATIN CAPITAL LETTER E WITH HOOK ABOVE int ( z '1EBC' ), int ( z '1EBD' ), & ! LATIN SMALL LETTER E WITH TILDE <= LATIN CAPITAL LETTER E WITH TILDE int ( z '1EBE' ), int ( z '1EBF' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE <= LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE int ( z '1EC0' ), int ( z '1EC1' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND GRAVE <= LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE int ( z '1EC2' ), int ( z '1EC3' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE <= LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE int ( z '1EC4' ), int ( z '1EC5' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND TILDE <= LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND TILDE int ( z '1EC6' ), int ( z '1EC7' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW <= LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND DOT BELOW int ( z '1EC8' ), int ( z '1EC9' ), & ! LATIN SMALL LETTER I WITH HOOK ABOVE <= LATIN CAPITAL LETTER I WITH HOOK ABOVE int ( z '1ECA' ), int ( z '1ECB' ), & ! LATIN SMALL LETTER I WITH DOT BELOW <= LATIN CAPITAL LETTER I WITH DOT BELOW int ( z '1ECC' ), int ( z '1ECD' ), & ! LATIN SMALL LETTER O WITH DOT BELOW <= LATIN CAPITAL LETTER O WITH DOT BELOW int ( z '1ECE' ), int ( z '1ECF' ), & ! LATIN SMALL LETTER O WITH HOOK ABOVE <= LATIN CAPITAL LETTER O WITH HOOK ABOVE int ( z '1ED0' ), int ( z '1ED1' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE <= LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE int ( z '1ED2' ), int ( z '1ED3' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND GRAVE <= LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND GRAVE int ( z '1ED4' ), int ( z '1ED5' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE <= LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE int ( z '1ED6' ), int ( z '1ED7' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND TILDE <= LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND TILDE int ( z '1ED8' ), int ( z '1ED9' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW <= LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND DOT BELOW int ( z '1EDA' ), int ( z '1EDB' ), & ! LATIN SMALL LETTER O WITH HORN AND ACUTE <= LATIN CAPITAL LETTER O WITH HORN AND ACUTE int ( z '1EDC' ), int ( z '1EDD' ), & ! LATIN SMALL LETTER O WITH HORN AND GRAVE <= LATIN CAPITAL LETTER O WITH HORN AND GRAVE int ( z '1EDE' ), int ( z '1EDF' ), & ! LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE <= LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE int ( z '1EE0' ), int ( z '1EE1' ), & ! LATIN SMALL LETTER O WITH HORN AND TILDE <= LATIN CAPITAL LETTER O WITH HORN AND TILDE int ( z '1EE2' ), int ( z '1EE3' ), & ! LATIN SMALL LETTER O WITH HORN AND DOT BELOW <= LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW int ( z '1EE4' ), int ( z '1EE5' ), & ! LATIN SMALL LETTER U WITH DOT BELOW <= LATIN CAPITAL LETTER U WITH DOT BELOW int ( z '1EE6' ), int ( z '1EE7' ), & ! LATIN SMALL LETTER U WITH HOOK ABOVE <= LATIN CAPITAL LETTER U WITH HOOK ABOVE int ( z '1EE8' ), int ( z '1EE9' ), & ! LATIN SMALL LETTER U WITH HORN AND ACUTE <= LATIN CAPITAL LETTER U WITH HORN AND ACUTE int ( z '1EEA' ), int ( z '1EEB' ), & ! LATIN SMALL LETTER U WITH HORN AND GRAVE <= LATIN CAPITAL LETTER U WITH HORN AND GRAVE int ( z '1EEC' ), int ( z '1EED' ), & ! LATIN SMALL LETTER U WITH HORN AND HOCK ABOVE <= LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE int ( z '1EEE' ), int ( z '1EEF' ), & ! LATIN SMALL LETTER U WITH HORN AND TILDE <= LATIN CAPITAL LETTER U WITH HORN AND TILDE int ( z '1EF0' ), int ( z '1EF1' ), & ! LATIN SMALL LETTER U WITH HORN AND DOT BELOW <= LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW int ( z '1EF2' ), int ( z '1EF3' ), & ! LATIN SMALL LETTER Y WITH GRAVE <= LATIN CAPITAL LETTER Y WITH GRAVE int ( z '1EF4' ), int ( z '1EF5' ), & ! LATIN SMALL LETTER Y WITH DOT BELOW <= LATIN CAPITAL LETTER Y WITH DOT BELOW int ( z '1EF6' ), int ( z '1EF7' ), & ! LATIN SMALL LETTER Y WITH HOOK ABOVE <= LATIN CAPITAL LETTER Y WITH HOOK ABOVE int ( z '1EF8' ), int ( z '1EF9' ), & ! LATIN SMALL LETTER Y WITH TILDE <= LATIN CAPITAL LETTER Y WITH TILDE int ( z '1F08' ), int ( z '1F00' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI <= GREEK CAPITAL LETTER ALPHA WITH PSILI int ( z '1F09' ), int ( z '1F01' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA <= GREEK CAPITAL LETTER ALPHA WITH DASIA int ( z '1F0A' ), int ( z '1F02' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA <= GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA int ( z '1F0B' ), int ( z '1F03' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA <= GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA int ( z '1F0C' ), int ( z '1F04' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA <= GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA int ( z '1F0D' ), int ( z '1F05' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA <= GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA int ( z '1F0E' ), int ( z '1F06' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI <= GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI int ( z '1F0F' ), int ( z '1F07' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI <= GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI int ( z '1F18' ), int ( z '1F10' ), & ! GREEK SMALL LETTER EPSILON WITH PSILI <= GREEK CAPITAL LETTER EPSILON WITH PSILI int ( z '1F19' ), int ( z '1F11' ), & ! GREEK SMALL LETTER EPSILON WITH DASIA <= GREEK CAPITAL LETTER EPSILON WITH DASIA int ( z '1F1A' ), int ( z '1F12' ), & ! GREEK SMALL LETTER EPSILON WITH PSILI AND VARIA <= GREEK CAPITAL LETTER EPSILON WITH PSILI AND VARIA int ( z '1F1B' ), int ( z '1F13' ), & ! GREEK SMALL LETTER EPSILON WITH DASIA AND VARIA <= GREEK CAPITAL LETTER EPSILON WITH DASIA AND VARIA int ( z '1F1C' ), int ( z '1F14' ), & ! GREEK SMALL LETTER EPSILON WITH PSILI AND OXIA <= GREEK CAPITAL LETTER EPSILON WITH PSILI AND OXIA int ( z '1F1D' ), int ( z '1F15' ), & ! GREEK SMALL LETTER EPSILON WITH DASIA AND OXIA <= GREEK CAPITAL LETTER EPSILON WITH DASIA AND OXIA int ( z '1F28' ), int ( z '1F20' ), & ! GREEK SMALL LETTER ETA WITH PSILI <= GREEK CAPITAL LETTER ETA WITH PSILI int ( z '1F29' ), int ( z '1F21' ), & ! GREEK SMALL LETTER ETA WITH DASIA <= GREEK CAPITAL LETTER ETA WITH DASIA int ( z '1F2A' ), int ( z '1F22' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND VARIA <= GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA int ( z '1F2B' ), int ( z '1F23' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND VARIA <= GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA int ( z '1F2C' ), int ( z '1F24' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND OXIA <= GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA int ( z '1F2D' ), int ( z '1F25' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND OXIA <= GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA int ( z '1F2E' ), int ( z '1F26' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI <= GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI int ( z '1F2F' ), int ( z '1F27' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI <= GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI int ( z '1F38' ), int ( z '1F30' ), & ! GREEK SMALL LETTER IOTA WITH PSILI <= GREEK CAPITAL LETTER IOTA WITH PSILI int ( z '1F39' ), int ( z '1F31' ), & ! GREEK SMALL LETTER IOTA WITH DASIA <= GREEK CAPITAL LETTER IOTA WITH DASIA int ( z '1F3A' ), int ( z '1F32' ), & ! GREEK SMALL LETTER IOTA WITH PSILI AND VARIA <= GREEK CAPITAL LETTER IOTA WITH PSILI AND VARIA int ( z '1F3B' ), int ( z '1F33' ), & ! GREEK SMALL LETTER IOTA WITH DASIA AND VARIA <= GREEK CAPITAL LETTER IOTA WITH DASIA AND VARIA int ( z '1F3C' ), int ( z '1F34' ), & ! GREEK SMALL LETTER IOTA WITH PSILI AND OXIA <= GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA int ( z '1F3D' ), int ( z '1F35' ), & ! GREEK SMALL LETTER IOTA WITH DASIA AND OXIA <= GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA int ( z '1F3E' ), int ( z '1F36' ), & ! GREEK SMALL LETTER IOTA WITH PSILI AND PERISPOMENI <= GREEK CAPITAL LETTER IOTA WITH PSILI AND PERISPOMENI int ( z '1F3F' ), int ( z '1F37' ), & ! GREEK SMALL LETTER IOTA WITH DASIA AND PERISPOMENI <= GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI int ( z '1F48' ), int ( z '1F40' ), & ! GREEK SMALL LETTER OMICRON WITH PSILI <= GREEK CAPITAL LETTER OMICRON WITH PSILI int ( z '1F49' ), int ( z '1F41' ), & ! GREEK SMALL LETTER OMICRON WITH DASIA <= GREEK CAPITAL LETTER OMICRON WITH DASIA int ( z '1F4A' ), int ( z '1F42' ), & ! GREEK SMALL LETTER OMICRON WITH PSILI AND VARIA <= GREEK CAPITAL LETTER OMICRON WITH PSILI AND VARIA int ( z '1F4B' ), int ( z '1F43' ), & ! GREEK SMALL LETTER OMICRON WITH DASIA AND VARIA <= GREEK CAPITAL LETTER OMICRON WITH DASIA AND VARIA int ( z '1F4C' ), int ( z '1F44' ), & ! GREEK SMALL LETTER OMICRON WITH PSILI AND OXIA <= GREEK CAPITAL LETTER OMICRON WITH PSILI AND OXIA int ( z '1F4D' ), int ( z '1F45' ), & ! GREEK SMALL LETTER OMICRON WITH DASIA AND OXIA <= GREEK CAPITAL LETTER OMICRON WITH DASIA AND OXIA int ( z '1F59' ), int ( z '1F51' ), & ! GREEK SMALL LETTER UPSILON WITH DASIA <= GREEK CAPITAL LETTER UPSILON WITH OASIS int ( z '1F5B' ), int ( z '1F53' ), & ! GREEK SMALL LETTER UPSILON WITH DASIA AND VARIA <= GREEK CAPITAL LETTER UPSILON WITH DASIA AND VARIA int ( z '1F5D' ), int ( z '1F55' ), & ! GREEK SMALL LETTER UPSILON WITH DASIA AND OXIA <= GREEK CAPITAL LETTER UPSILON WITH DASIA AND OXIA int ( z '1F5F' ), int ( z '1F57' ), & ! GREEK SMALL LETTER UPSILON WITH DASIA AND PERISPOMENI <= GREEK CAPITAL LETTER UPSILON WITH DASIA AND PERISPOMENI int ( z '1F68' ), int ( z '1F60' ), & ! GREEK SMALL LETTER OMEGA WITh PSILI <= GREEK CAPITAL LETTER OMEGA WITH PSILI int ( z '1F69' ), int ( z '1F61' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA <= GREEK CAPITAL LETTER OMEGA WITH DASIA int ( z '1F6A' ), int ( z '1F62' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA <= GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA int ( z '1F6B' ), int ( z '1F63' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA <= GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA int ( z '1F6C' ), int ( z '1F64' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA <= GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA int ( z '1F6D' ), int ( z '1F65' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA <= GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA int ( z '1F6E' ), int ( z '1F66' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI <= GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI int ( z '1F6F' ), int ( z '1F67' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI <= GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI int ( z '1F88' ), int ( z '1F80' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ALPHA WITh PSILI AND PROSGEGRAMMENI int ( z '1F89' ), int ( z '1F81' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ALPHA WITH DASIA AND PROSGEGRAMMENI int ( z '1F8A' ), int ( z '1F82' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI int ( z '1F8B' ), int ( z '1F83' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI int ( z '1F8C' ), int ( z '1F84' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMEN int ( z '1F8D' ), int ( z '1F85' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMEN int ( z '1F8E' ), int ( z '1F86' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1F8F' ), int ( z '1F87' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1F98' ), int ( z '1F90' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ETA WITH PSILI AND PROSGEGRAMMENI int ( z '1F99' ), int ( z '1F91' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ETA WITH DASIA AND PROSGEGRAMMENI int ( z '1F9A' ), int ( z '1F92' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI int ( z '1F9B' ), int ( z '1F93' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI int ( z '1F9C' ), int ( z '1F94' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI int ( z '1F9D' ), int ( z '1F95' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI int ( z '1F9E' ), int ( z '1F96' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1F9F' ), int ( z '1F97' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1FA8' ), int ( z '1FA0' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER OMEGA WITH PSILI AND PROSGEGRAMMENI int ( z '1FA9' ), int ( z '1FA1' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER OMEGA WITH DASIA AND PROSGEGRAMMENI int ( z '1FAA' ), int ( z '1FA2' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI int ( z '1FAB' ), int ( z '1FA3' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI int ( z '1FAC' ), int ( z '1FA4' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI int ( z '1FAD' ), int ( z '1FA5' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI int ( z '1FAE' ), int ( z '1FA6' ), & ! GREEK SMALL LETTER OMEGA WITh PSILI AND PERISPOMENI AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1FAF' ), int ( z '1FA7' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND PEPISPOMENI AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER OMECA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1FB8' ), int ( z '1FB0' ), & ! GREEK SMALL LETTER ALPHA WITH VRACHY <= GREEK CAPITAL LETTER ALPHA WITH VRACHY int ( z '1FB9' ), int ( z '1FB1' ), & ! GREEK SMALL LETTER ALPHA WITH MACRON <= GREEK CAPITAL LETTER ALPHA WITH MACRON int ( z '1FD8' ), int ( z '1FD0' ), & ! GREEK SMALL LETTER IOTA WITH VRACHY <= GREEK CAPITAL LETTER IOTA WITH VRACHY int ( z '1FD9' ), int ( z '1FD1' ), & ! GREEK SMALL LETTER IOTA WITH MACRON <= GREEK CAPITAL LETTER IOTA WITH MACRON int ( z '1FE8' ), int ( z '1FE0' ), & ! GREEK SMALL LETTER UPSILON WITH VRACHY <= GREEK CAPITAL LETTER UPSILON WITH VRACHY int ( z '1FE9' ), int ( z '1FE1' ), & ! GREEK SMALL LETTER UPSILON WITH MACRON <= GREEK CAPITAL LETTER UPSILON WITH MACRON int ( z '24B6' ), int ( z '24D0' ), & ! CIRCLED LATIN SMALL LETTER A <= CIRCLED LATIN CAPITAL LETTER A int ( z '24B7' ), int ( z '24D1' ), & ! CIRCLED LATIN SMALL LETTER B <= CIRCLED LATIN CAPITAL LETTER B int ( z '24B8' ), int ( z '24D2' ), & ! CIRCLED LATIN SMALL LETTER C <= CIRCLED LATIN CAPITAL LETTER C int ( z '24B9' ), int ( z '24D3' ), & ! CIRCLED LATIN SMALL LETTER D <= CIRCLED LATIN CAPITAL LETTER D int ( z '24BA' ), int ( z '24D4' ), & ! CIRCLED LATIN SMALL LETTER E <= CIRCLED LATIN CAPITAL LETTER E int ( z '24BB' ), int ( z '24D5' ), & ! CIRCLED LATIN SMALL LETTER F <= CIRCLED LATIN CAPITAL LETTER F int ( z '24BC' ), int ( z '24D6' ), & ! CIRCLED LATIN SMALL LETTER G <= CIRCLED LATIN CAPITAL LETTER G int ( z '24BD' ), int ( z '24D7' ), & ! CIRCLED LATIN SMALL LETTER H <= CIRCLED LATIN CAPITAL LETTER H int ( z '24BE' ), int ( z '24D8' ), & ! CIRCLED LATIN SMALL LETTER I <= CIRCLED LATIN CAPITAL LETTER I int ( z '24BF' ), int ( z '24D9' ), & ! CIRCLED LATIN SMALL LETTER J <= CIRCLED LATIN CAPITAL LETTER J int ( z '24C0' ), int ( z '24DA' ), & ! CIRCLED LATIN SMALL LETTER K <= CIRCLED LATIN CAPITAL LETTER K int ( z '24C1' ), int ( z '24DB' ), & ! CIRCLED LATIN SMALL LETTER L <= CIRCLED LATIN CAPITAL LETTER L int ( z '24C2' ), int ( z '24DC' ), & ! CIRCLED LATIN SMALL LETTER M <= CIRCLED LATIN CAPITAL LETTER M int ( z '24C3' ), int ( z '24DD' ), & ! CIRCLED LATIN SMALL LETTER N <= CIRCLED LATIN CAPITAL LETTER N int ( z '24C4' ), int ( z '24DE' ), & ! CIRCLED LATIN SMALL LETTER O <= CIRCLED LATIN CAPITAL LETTER O int ( z '24C5' ), int ( z '24DF' ), & ! CIRCLED LATIN SMALL LETTER P <= CIRCLED LATIN CAPITAL LETTER P int ( z '24C6' ), int ( z '24E0' ), & ! CIRCLED LATIN SMALL LETTER Q <= CIRCLED LATIN CAPITAL LETTER Q int ( z '24C7' ), int ( z '24E1' ), & ! CIRCLED LATIN SMALL LETTER R <= CIRCLED LATIN CAPITAL LETTER R int ( z '24C8' ), int ( z '24E2' ), & ! CIRCLED LATIN SMALL LETTER S <= CIRCLED LATIN CAPITAL LETTER S int ( z '24C9' ), int ( z '24E3' ), & ! CIRCLED LATIN SMALL LETTER T <= CIRCLED LATIN CAPITAL LETTER T int ( z '24CA' ), int ( z '24E4' ), & ! CIRCLED LATIN SMALL LETTER U <= CIRCLED LATIN CAPITAL LETTER U int ( z '24CB' ), int ( z '24E5' ), & ! CIRCLED LATIN SMALL LETTER V <= CIRCLED LATIN CAPITAL LETTER V int ( z '24CC' ), int ( z '24E6' ), & ! CIRCLED LATIN SMALL LETTER W <= CIRCLED LATIN CAPITAL LETTER W int ( z '24CD' ), int ( z '24E7' ), & ! CIRCLED LATIN SMALL LETTER X <= CIRCLED LATIN CAPITAL LETTER X int ( z '24CE' ), int ( z '24E8' ), & ! CIRCLED LATIN SMALL LETTER Y <= CIRCLED LATIN CAPITAL LETTER Y int ( z '24CF' ), int ( z '24E9' ), & ! CIRCLED LATIN SMALL LETTER Z <= CIRCLED LATIN CAPITAL LETTER Z int ( z 'FF21' ), int ( z 'FF41' ), & ! FULLWIDTH LATIN SMALL LETTER A <= FULLWIDTH LATIN CAPITAL LETTER A int ( z 'FF22' ), int ( z 'FF42' ), & ! FULLWIDTH LATIN SMALL LETTER B <= FULLWIDTH LATIN CAPITAL LETTER B int ( z 'FF23' ), int ( z 'FF43' ), & ! FULLWIDTH LATIN SMALL LETTER C <= FULLWIDTH LATIN CAPITAL LETTER C int ( z 'FF24' ), int ( z 'FF44' ), & ! FULLWIDTH LATIN SMALL LETTER D <= FULLWIDTH LATIN CAPITAL LETTER D int ( z 'FF25' ), int ( z 'FF45' ), & ! FULLWIDTH LATIN SMALL LETTER E <= FULLWIDTH LATIN CAPITAL LETTER E int ( z 'FF26' ), int ( z 'FF46' ), & ! FULLWIDTH LATIN SMALL LETTER F <= FULLWIDTH LATIN CAPITAL LETTER F int ( z 'FF27' ), int ( z 'FF47' ), & ! FULLWIDTH LATIN SMALL LETTER G <= FULLWIDTH LATIN CAPITAL LETTER G int ( z 'FF28' ), int ( z 'FF48' ), & ! FULLWIDTH LATIN SMALL LETTER H <= FULLWIDTH LATIN CAPITAL LETTER H int ( z 'FF29' ), int ( z 'FF49' ), & ! FULLWIDTH LATIN SMALL LETTER I <= FULLWIDTH LATIN CAPITAL LETTER I int ( z 'FF2A' ), int ( z 'FF4A' ), & ! FULLWIDTH LATIN SMALL LETTER J <= FULLWIDTH LATIN CAPITAL LETTER J int ( z 'FF2B' ), int ( z 'FF4B' ), & ! FULLWIDTH LATIN SMALL LETTER K <= FULLWIDTH LATIN CAPITAL LETTER K int ( z 'FF2C' ), int ( z 'FF4C' ), & ! FULLWIDTH LATIN SMALL LETTER L <= FULLWIDTH LATIN CAPITAL LETTER L int ( z 'FF2D' ), int ( z 'FF4D' ), & ! FULLWIDTH LATIN SMALL LETTER M <= FULLWIDTH LATIN CAPITAL LETTER M int ( z 'FF2E' ), int ( z 'FF4E' ), & ! FULLWIDTH LATIN SMALL LETTER N <= FULLWIDTH LATIN CAPITAL LETTER N int ( z 'FF2F' ), int ( z 'FF4F' ), & ! FULLWIDTH LATIN SMALL LETTER O <= FULLWIDTH LATIN CAPITAL LETTER O int ( z 'FF30' ), int ( z 'FF50' ), & ! FULLWIDTH LATIN SMALL LETTER P <= FULLWIDTH LATIN CAPITAL LETTER P int ( z 'FF31' ), int ( z 'FF51' ), & ! FULLWIDTH LATIN SMALL LETTER Q <= FULLWIDTH LATIN CAPITAL LETTER Q int ( z 'FF32' ), int ( z 'FF52' ), & ! FULLWIDTH LATIN SMALL LETTER R <= FULLWIDTH LATIN CAPITAL LETTER R int ( z 'FF33' ), int ( z 'FF53' ), & ! FULLWIDTH LATIN SMALL LETTER S <= FULLWIDTH LATIN CAPITAL LETTER S int ( z 'FF34' ), int ( z 'FF54' ), & ! FULLWIDTH LATIN SMALL LETTER T <= FULLWIDTH LATIN CAPITAL LETTER T int ( z 'FF35' ), int ( z 'FF55' ), & ! FULLWIDTH LATIN SMALL LETTER U <= FULLWIDTH LATIN CAPITAL LETTER U int ( z 'FF36' ), int ( z 'FF56' ), & ! FULLWIDTH LATIN SMALL LETTER V <= FULLWIDTH LATIN CAPITAL LETTER V int ( z 'FF37' ), int ( z 'FF57' ), & ! FULLWIDTH LATIN SMALL LETTER W <= FULLWIDTH LATIN CAPITAL LETTER W int ( z 'FF38' ), int ( z 'FF58' ), & ! FULLWIDTH LATIN SMALL LETTER X <= FULLWIDTH LATIN CAPITAL LETTER X int ( z 'FF39' ), int ( z 'FF59' ), & ! FULLWIDTH LATIN SMALL LETTER Y <= FULLWIDTH LATIN CAPITAL LETTER Y int ( z 'FF3A' ), int ( z 'FF5A' )] & ! FULLWIDTH LATIN SMALL LETTER Z <= FULLWIDTH LATIN CAPITAL LETTER Z , shape ( up_to_low ), order = [ 2 , 1 ]) ! hits but in alpha lfortran !integer,parameter :: hexchars(*) = iachar(['a','b','c','d','e','f', & !                                         & '0','1','2','3','4','5','6','7','8','9', & !                                         & 'A','B','C','D','E','F' ]) integer , parameter :: hexchars ( * ) = [ 97 , 98 , 99 , 100 , 101 , 102 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 65 , 66 , 67 , 68 , 69 , 70 ] type unicode_codepoints integer :: SPACES ( size ( spacescodes )) integer :: LOWER ( size ( low_to_up , dim = 1 )) integer :: UPPER ( size ( up_to_low , dim = 1 )) integer :: hexadecimal ( size ( hexchars )) integer :: bom ( 1 ) = [ int ( z 'FEFF' )] end type unicode_codepoints type ( unicode_codepoints ), parameter , public :: unicode = unicode_codepoints ( & upper = up_to_low (:, 2 ), & lower = low_to_up (:, 2 ), & hexadecimal = [ hexchars ], & bom = [ int ( z 'FEFF' )], & spaces = spacescodes ) type :: force_keywords ! force keywords, using @awvwgk method end type force_keywords ! so then any argument that comes after \"force_kwargs\" is a compile time error ! if not done with a keyword unless someone \"breaks\" it by passing something ! of this type: !    type(force_keywords), optional, intent(in) :: force_kwargs !> Write string to connected formatted unit. interface write ( formatted ); module procedure :: write_formatted ; end interface contains !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!   CODEPOINTS_TO_UTF8(3f) - [M_unicode:CONVERSION] convert codepoints !!   to CHARACTER !!   (LICENSE:MIT) !! !!##SYNOPSIS !! !! !!    pure subroutine codepoints_to_utf8(codepoints,utf8,nerr) !! !!     integer,allocatable,intent(in) :: codepoints(:) !!     ! !!     character(len=1),intent(out)   :: utf8(:) !!     !  or !!     character(len=*),intent(out)   :: utf8 !!     ! !!     integer,intent(out)            :: nerr !! !!##CHARACTERISTICS !!   + UTF8 is a scalar or array CHARACTER variable !!   + CODEPOINTS is of default INTEGER kind !!   + NERR is of default INTEGER kind !! !!##DESCRIPTION !!   CODEPOINTS_TO_UTF8(3f) takes an integer array of Unicode codepoint !!   values and generates either a scalar CHARACTER variable or an array !!   of bytes (AKA. CHARACTER(LEN=1)) which are assumed to contain a stream !!   of bytes representing UTF-8-encoded data. !! !!##OPTIONS !! !!    + CODEPOINTS :  An INTEGER array of Unicode codepoint values representing !!                    the glyphs to be encoded at UTF-8 data !! !!    + UTF8 :  Scalar or single-character array CHARACTER variables !!              to contain a stream of bytes containing data encoded at !!              UTF-8 text. !! !!    + NERR :  Zero if no error occurred. If not zero the stream of bytes !!              could not be completely converted to UTF-8 characters. !! !!##EXAMPLES !! !!   Sample program !! !!    program demo_codepoints_to_utf8 !!    use m_unicode, only : codepoints_to_utf8 !!    implicit none !!    !'Noho me ka hau‚Äôoli' !(Be happy) !!    integer,parameter :: codepoints(*)=[ & !!       & 78,111,104,111,& !!       & 32,109,101, & !!       & 32,107,97, & !!       & 32,104,97,117,8217,111,108,105] !!    character(len=:),allocatable :: string !!    character(len=1),allocatable :: bytes(:) !!    character(len=*),parameter   :: solid='(*(g0))' !!    character(len=*),parameter   :: space='(*(g0,1x))' !!    character(len=*),parameter   :: z='(a,*(z0,1x))' !!    integer                      :: nerr !!    ! BASIC USAGE: SCALAR CHARACTER VARIABLE !!      write(*,space)'CODEPOINTS:', codepoints !!      write(*,z)'HEXADECIMAL CODEPOINTS:', codepoints !!      call codepoints_to_utf8(codepoints,string,nerr) !!      write(*,solid)'STRING:',string !!    ! !!      write(*,space)'How long is this string in glyphs? ' !!      write(*,space)size(codepoints) !!      write(*,space)'How long is this string in bytes? ' !!      write(*,space)len(string) !!    ! !!    ! BASIC USAGE: ARRAY OF BYTES !!      call codepoints_to_utf8(codepoints,bytes,nerr) !!      write(*,solid)'STRING:',bytes !!    ! !!      write(*,space)'How long is this string in glyphs? ' !!      write(*,space)size(codepoints) !!      write(*,space)'How long is this string in bytes? ' !!      write(*,space)size(bytes) !!    ! !!    end program demo_codepoints_to_utf8 !! !!  Results: !! !!     > CODEPOINTS: 78 111 104 111 32 109 101 32 107 97 32 104 97 117 ... !!     > 8217 111 108 105 !!     > 48 4E 6F 68 6F 20 6D 65 20 6B 61 20 68 61 75 2019 6F 6C 69 !!     > STRING:Noho me ka hau‚Äôoli !!     > How long is this string in glyphs? !!     > 18 !!     > How long is this string in bytes? !!     > 20 !!     > STRING:Noho me ka hau‚Äôoli !!     > How long is this string in glyphs? !!     > 18 !!     > How long is this string in bytes? !!     > 20 !! !!##SEE ALSO !!   functions that perform operations on character strings: !! !!   + elemental: adjustl(3), adjustr(3), index(3), scan(3), verify(3) !!   + non-elemental: len_trim(3), repeat(3), trim(3), !!                    codepoints_to_utf8(3), utf8_to_codepoints(3) !! !!##AUTHOR !!   + John S. Urban !!   + Francois Jacq - enhancements and Latin support from Francois Jacq, 2025-08 !! !!##LICENSE !!     MIT !=================================================================================================================================== pure subroutine codepoints_to_utf8_chars ( codepoints , utf8 , nerr ) intrinsic char integer , intent ( in ) :: codepoints (:) character , allocatable , intent ( out ) :: utf8 (:) integer , intent ( out ) :: nerr integer :: i , n_unicode , n_utf8 , cp character , allocatable :: temp_utf8 (:) n_unicode = size ( codepoints ) if ( allocated ( temp_utf8 )) deallocate ( temp_utf8 ) allocate ( temp_utf8 ( 4 * n_unicode )) n_utf8 = 0 nerr = 0 do i = 1 , n_unicode cp = codepoints ( i ) select case ( cp ) case ( 0 : 127 ) ! 1 byte : 0xxxxxxx n_utf8 = n_utf8 + 1 temp_utf8 ( n_utf8 ) = char ( cp ) case ( 128 : 2047 ) ! 2 bytes : 110xxxxx 10xxxxxx n_utf8 = n_utf8 + 2 temp_utf8 ( n_utf8 - 1 ) = char ( ior ( 192 , ishft ( cp , - 6 ))) temp_utf8 ( n_utf8 ) = char ( ior ( 128 , iand ( cp , 63 ))) case ( 2048 : 65535 ) ! 3 bytes : 1110xxxx 10xxxxxx 10xxxxxx if ( cp >= 55296 . and . cp <= 57343 ) then nerr = nerr + 1 n_utf8 = n_utf8 + 1 temp_utf8 ( n_utf8 ) = '?' cycle endif n_utf8 = n_utf8 + 3 temp_utf8 ( n_utf8 - 2 ) = char ( ior ( 224 , ishft ( cp , - 12 ))) temp_utf8 ( n_utf8 - 1 ) = char ( ior ( 128 , iand ( ishft ( cp , - 6 ), 63 ))) temp_utf8 ( n_utf8 ) = char ( ior ( 128 , iand ( cp , 63 ))) case ( 65536 : 1114111 ) ! 4 bytes : 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx n_utf8 = n_utf8 + 4 temp_utf8 ( n_utf8 - 3 ) = char ( ior ( 240 , ishft ( cp , - 18 ))) temp_utf8 ( n_utf8 - 2 ) = char ( ior ( 128 , iand ( ishft ( cp , - 12 ), 63 ))) temp_utf8 ( n_utf8 - 1 ) = char ( ior ( 128 , iand ( ishft ( cp , - 6 ), 63 ))) temp_utf8 ( n_utf8 ) = char ( ior ( 128 , iand ( cp , 63 ))) case default nerr = nerr + 1 n_utf8 = n_utf8 + 1 temp_utf8 ( n_utf8 ) = '?' end select enddo if ( allocated ( utf8 )) deallocate ( utf8 ) allocate ( utf8 ( n_utf8 )) utf8 = temp_utf8 ( 1 : n_utf8 ) end subroutine codepoints_to_utf8_chars !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!   UTF8_TO_CODEPOINTS(3f) - [M_unicode:CONVERSION] Convert UTF-8-encoded !!   data to Unicode codepoints !!   (LICENSE:MIT) !! !!##SYNOPSIS !! !! !!    pure subroutine utf8_to_codepoints(utf8,codepoints,nerr) !! !!     character(len=1),intent(in)     :: utf8(:) !!     !  or !!     character(len=*),intent(in)     :: utf8 !!     ! !!     integer,allocatable,intent(out) :: codepoints(:) !!     integer,intent(out)             :: nerr !! !!##CHARACTERISTICS !!   + UTF8 is a scalar CHARACTER variable or array of single-byte !!     CHARACTER values !!   + the returned values in CODEPOINTS are of default INTEGER kind !!   + the error flag NERR is default integer kind !! !!##DESCRIPTION !!   UTF8_TO_CODEPOINTS(3f) takes either a scalar CHARACTER variable or !!   an array of CHARACTER(LEN=1) bytes which are treated as a stream of !!   bytes representing UTF-8-encoded data and converted to an INTEGER !!   array containing Unicode codepoint values for each glyph. !! !!   In fact, this routine is also able to decode an ISOLATIN string !! !!##OPTIONS !!   + UTF8 :  Scalar CHARACTER string or single-character array of CHARACTER !!             variables assumed to represent a stream of bytes containing !!             data encoded at UTF-8 text. !! !!   + CODEPOINTS :  An INTEGER array of Unicode codepoint values !!                   representing the glyphs found in STRING !!   + NERR :  Zero if no error occurred. If not zero the stream of bytes !!             could not be completely converted to UTF-8 characters. !! !!##EXAMPLES !! !!   Sample program !! !!    program demo_utf8_to_codepoints !!    use m_unicode, only : utf8_to_codepoints !!    implicit none !!    character(len=*),parameter   :: string ='Noho me ka hau‚Äôoli' !(Be happy) !!    character(len=1),allocatable :: bytes(:) !!    character(len=*),parameter   :: solid='(*(g0))' !!    character(len=*),parameter   :: space='(*(g0,1x))' !!    character(len=*),parameter   :: z='(a,*(z0,1x))' !!    integer,allocatable          :: codepoints(:) !!    integer                      :: nerr !!    integer                      :: i !!    ! BASIC USAGE: SCALAR CHARACTER VARIABLE !!      write(*,solid)'STRING:',string !!      call utf8_to_codepoints(string,codepoints,nerr) !!      write(*,space)'CODEPOINTS:', codepoints !!      write(*,z)'HEXADECIMAL CODEPOINTS:', codepoints !!    ! !!      write(*,space)'How long is this string in glyphs? ' !!      write(*,space)size(codepoints) !!      write(*,space)'How long is this string in bytes? ' !!      write(*,space)len(string) !!    ! !!    ! BASIC USAGE: ARRAY OF BYTES !!      bytes=[(string(i:i),i=1,len(string))] !!      write(*,solid)'STRING:',bytes !!      call utf8_to_codepoints(bytes,codepoints,nerr) !!      write(*,space)'CODEPOINTS:', codepoints !!      write(*,z)'HEXADECIMAL CODEPOINTS:', codepoints !!    ! !!      write(*,space)'How long is this string in glyphs? ' !!      write(*,space)size(codepoints) !!      write(*,space)'How long is this string in bytes? ' !!      write(*,space)size(bytes) !!    ! !!    end program demo_utf8_to_codepoints !! !!  Results: !! !!     > STRING:Noho me ka hau‚Äôoli !!     > CODEPOINTS: 78 111 104 111 32 109 101 32 107 97 32 104 97 117 ... !!     > 8217 111 108 105 !!     > 48 4E 6F 68 6F 20 6D 65 20 6B 61 20 68 61 75 2019 6F 6C 69 !!     > How long is this string in glyphs? !!     > 18 !!     > How long is this string in bytes? !!     > 20 !!     > STRING:Noho me ka hau‚Äôoli !!     > CODEPOINTS: 78 111 104 111 32 109 101 32 107 97 32 104 97 117 ... !!     > 8217 111 108 105 !!     > 48 4E 6F 68 6F 20 6D 65 20 6B 61 20 68 61 75 2019 6F 6C 69 !!     > How long is this string in glyphs? !!     > 18 !!     > How long is this string in bytes? !!     > 20 !! !!##SEE ALSO !!   functions that perform operations on character strings: !! !!   + elemental: adjustl(3), adjustr(3), index(3), scan(3), verify(3) !!   + non-elemental: len_trim(3), repeat(3), trim(3), codepoints_to_utf8(3) !! !!##AUTHOR !!   + John S. Urban !!   + Francois Jacq - enhancements and Latin support from Francois Jacq, 2025-08 !! !!##LICENSE !!     MIT !=================================================================================================================================== pure subroutine utf8_to_codepoints_chars ( utf8 , codepoints , nerr ) ! in fact, this routine is also able to decode an ISOLATIN string character ( len = 1 ), intent ( in ) :: utf8 (:) integer , allocatable , intent ( out ) :: codepoints (:) integer , intent ( out ) :: nerr integer :: n_out integer :: i , len8 , b1 , b2 , b3 , b4 integer :: cp , nbytes , nerr0 integer , allocatable :: temp (:) nerr = 0 len8 = size ( utf8 ) i = 1 n_out = 0 if ( allocated ( temp )) deallocate ( temp ) allocate ( temp ( len8 )) ! big enough to store all Unicode codepoint values do while ( i <= len8 ) nerr0 = nerr b1 = ichar ( utf8 ( i )) if ( b1 < 0 ) b1 = b1 + 256 nbytes = 1 select case ( b1 ) case ( 0 : 127 ) cp = b1 case ( 192 : 223 ) if ( i + 1 > len8 ) then nbytes = len8 - i + 1 nerr = nerr + 1 cp = ICHAR ( '?' ) else nbytes = 2 b2 = ichar ( utf8 ( i + 1 )); if ( b2 < 0 ) b2 = b2 + 256 if ( iand ( b2 , 192 ) /= 128 ) then nerr = nerr + 1 cp = ICHAR ( '?' ) else cp = iand ( b1 , 31 ) cp = ishft ( cp , 6 ) + iand ( b2 , 63 ) endif endif case ( 224 : 239 ) if ( i + 2 > len8 ) then nbytes = len8 - i + 1 nerr = nerr + 1 cp = ICHAR ( '?' ) else nbytes = 3 b2 = ichar ( utf8 ( i + 1 )); if ( b2 < 0 ) b2 = b2 + 256 b3 = ichar ( utf8 ( i + 2 )); if ( b3 < 0 ) b3 = b3 + 256 if ( iand ( b2 , 192 ) /= 128 . or . iand ( b3 , 192 ) /= 128 ) then nerr = nerr + 1 cp = ICHAR ( '?' ) else cp = iand ( b1 , 15 ) cp = ishft ( cp , 6 ) + iand ( b2 , 63 ) cp = ishft ( cp , 6 ) + iand ( b3 , 63 ) endif endif case ( 240 : 247 ) if ( i + 3 > len8 ) then nbytes = len8 - i + 1 nerr = nerr + 1 cp = ICHAR ( '?' ) else nbytes = 4 b2 = ichar ( utf8 ( i + 1 )); if ( b2 < 0 ) b2 = b2 + 256 b3 = ichar ( utf8 ( i + 2 )); if ( b3 < 0 ) b3 = b3 + 256 b4 = ichar ( utf8 ( i + 3 )); if ( b4 < 0 ) b4 = b4 + 256 if ( iand ( b2 , 192 ) /= 128 . or . iand ( b3 , 192 ) /= 128 . or . iand ( b4 , 192 ) /= 128 ) then nerr = nerr + 1 cp = ICHAR ( '?' ) else cp = iand ( b1 , 7 ) cp = ishft ( cp , 6 ) + iand ( b2 , 63 ) cp = ishft ( cp , 6 ) + iand ( b3 , 63 ) cp = ishft ( cp , 6 ) + iand ( b4 , 63 ) endif endif case default nerr = nerr + 1 cp = ICHAR ( '?' ) end select if ( nerr0 /= nerr ) then ! This is an invalid UTF-8 start byte. We apply the heuristic ! and interpret it as an ISO-8859-15 character. select case ( b1 ) case ( 164 ); cp = 8364 ! Euro case ( 166 ); cp = 352 ! S caron case ( 168 ); cp = 353 ! s caron case ( 180 ); cp = 381 ! Z caron case ( 184 ); cp = 382 ! z caron case ( 188 ); cp = 338 ! OE case ( 189 ); cp = 339 ! oe case ( 190 ); cp = 376 ! Y trema case default cp = b1 ! For all other chars, the codepoint is the byte value end select nbytes = 1 endif n_out = n_out + 1 temp ( n_out ) = cp i = i + nbytes enddo if ( allocated ( codepoints )) deallocate ( codepoints ) allocate ( codepoints ( n_out )) codepoints = temp ( 1 : n_out ) end subroutine utf8_to_codepoints_chars !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure function a2s ( array ) result ( string ) ! ident_1=\"@(#) M_unicode a2s(3fp) function to copy char array to string\" character ( len = 1 ), intent ( in ) :: array (:) character ( len = SIZE ( array )) :: string integer :: i forall ( i = 1 : size ( array )) string ( i : i ) = array ( i ) !  string=transfer(array,string) end function a2s !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure function s2a ( string ) result ( array ) ! ident_2=\"@(#) M_unicode s2a(3fp) function to copy string(1 Clen(string)) to char array\" character ( len =* ), intent ( in ) :: string character ( len = 1 ) :: array ( len ( string )) integer :: i forall ( i = 1 : len ( string )) array ( i ) = string ( i : i ) !  array=transfer(string,array) end function s2a !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure function binary_search ( arr , target ) result ( index ) implicit none integer , intent ( in ) :: arr (:) ! The sorted array to search integer , intent ( in ) :: target ! The value to find integer :: index ! The returned index of the target, or -1 if not found integer :: low , high , mid low = 1 high = size ( arr ) index = - 1 ! Initialize to -1 (not found) do while ( low <= high ) mid = low + ( high - low ) / 2 ! Calculate middle index to prevent overflow if ( arr ( mid ) == target ) then index = mid exit elseif ( arr ( mid ) < target ) then low = mid + 1 else high = mid - 1 endif enddo end function binary_search !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure subroutine codepoints_to_utf8_str ( codepoints , utf8 , nerr ) integer , intent ( in ) :: codepoints (:) character ( len = :), allocatable , intent ( out ) :: utf8 integer , intent ( out ) :: nerr character , allocatable :: utf8_chars (:) nerr = 0 call codepoints_to_utf8_chars ( codepoints , utf8_chars , nerr ) utf8 = a2s ( utf8_chars ) end subroutine codepoints_to_utf8_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure subroutine utf8_to_codepoints_str ( utf8 , codepoints , nerr ) ! in fact, this routine is also able to decode an ISOLATIN string character ( len =* ), intent ( in ) :: utf8 integer , allocatable , intent ( out ) :: codepoints (:) integer , intent ( out ) :: nerr character , allocatable :: temp (:) temp = s2a ( utf8 ) call utf8_to_codepoints_chars ( temp , codepoints , nerr ) end subroutine utf8_to_codepoints_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Constructor for new string instances from a scalar character value. elemental module function new_str ( string ) result ( new ) character ( len =* ), intent ( in ), optional :: string type ( unicode_type ) :: new integer :: nerr if ( present ( string )) then call utf8_to_codepoints_str ( string , new % codes , nerr ) endif end function new_str ! Constructor for new string instances from a vector character value. module function new_strs ( strings ) result ( new ) character ( len =* ), intent ( in ) :: strings (:) type ( unicode_type ) :: new ( size ( strings )) integer :: nerr integer :: i do i = 1 , size ( strings ) call utf8_to_codepoints_str ( strings ( i ), new ( i )% codes , nerr ) enddo end function new_strs ! Constructor for new string instance from a vector integer value. module function new_codes ( codes ) result ( new ) integer , intent ( in ) :: codes (:) type ( unicode_type ) :: new new % codes = codes end function new_codes !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> Assign a string to a character sequence subroutine assign_ints_str ( lhs , rhs ) integer , allocatable , intent ( inout ) :: lhs (:) type ( unicode_type ), intent ( in ) :: rhs lhs = rhs % codes end subroutine assign_ints_str !> Assign a string to a character sequence subroutine assign_char_str ( lhs , rhs ) character ( len = :), allocatable , intent ( inout ) :: lhs type ( unicode_type ), intent ( in ) :: rhs integer :: nerr call codepoints_to_utf8_str ( rhs % codes , lhs , nerr ) end subroutine assign_char_str !> Assign a character sequence to a string. elemental subroutine assign_str_char ( lhs , rhs ) type ( unicode_type ), intent ( inout ) :: lhs character ( len =* ), intent ( in ) :: rhs integer :: nerr call utf8_to_codepoints_str ( rhs , lhs % codes , nerr ) end subroutine assign_str_char subroutine assign_strs_char ( lhs , rhs ) type ( unicode_type ), intent ( inout ) :: lhs character ( len =* ), intent ( in ) :: rhs (:) integer :: nerr integer :: i integer , allocatable :: temp (:) if ( allocated ( lhs % codes )) deallocate ( lhs % codes ) allocate ( lhs % codes ( 0 )) do i = 1 , size ( rhs ) call utf8_to_codepoints_str ( rhs ( i ), temp , nerr ) lhs % codes = [ lhs % codes , temp ] enddo end subroutine assign_strs_char ! Assign a sequence of codepoints to a string. subroutine assign_str_codes ( lhs , rhs ) type ( unicode_type ), intent ( inout ) :: lhs integer , intent ( in ) :: rhs (:) lhs % codes = rhs end subroutine assign_str_codes elemental subroutine assign_str_code ( lhs , rhs ) type ( unicode_type ), intent ( inout ) :: lhs integer , intent ( in ) :: rhs lhs % codes = [ rhs ] end subroutine assign_str_code !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!   LEN(3f) - [M_unicode:WHITESPACE] Length of a string !!     (LICENSE:MIT) !! !!##SYNOPSIS !! !!   result = len(string) !! !!    elemental integer function len(string) !! !!     type(unicode_type),intent(in) :: string !! !!##CHARACTERISTICS !!   + STRING is a scalar or array string variable !!   + the returned value is of default INTEGER kind !! !!##DESCRIPTION !!   LEN(3) returns the length of a type(unicode_type) string. !! !!   Note that unlike the intrinsic of the same name STRING needs to be !!   defined; as the length of each element is not defined until allocated; !!   and the KIND parameter is not available for specifying the kind of the !!   integer returned. !! !!##OPTIONS !!   + STRING : A scalar or array string to return the length(s) of in glyph !!     counts. If it is an unallocated allocatable variable or a pointer that !!     is not associated, its length type parameter shall not be deferred. !! !!##RESULT !!   The result has a value equal to the number of glyphs in STRING if !!   it is scalar or the elements of STRING if it is an array. !! !!##EXAMPLES !! !!   Sample program !! !!    program demo_len !!    use M_unicode, only : assignment(=), ut=>unicode_type, len !!    use M_unicode, only : write(formatted) !!    implicit none !!    type(ut)             :: string !!    type(ut),allocatable :: many_strings(:) !!    integer                        :: ii !!    ! BASIC USAGE !!      string='Noho me ka hau‚Äôoli' ! (Be happy.) !!      ii=len(string) !!      write(*,'(DT,*(g0))')string, ' LEN=', ii !!    ! !!      string=' How long is this allocatable string? ' !!      write(*,'(DT,*(g0))')string, ' LEN=', len(string) !!    ! !!    ! STRINGS IN AN ARRAY MAY BE OF DIFFERENT LENGTHS !!      many_strings = [ ut('Tom'), ut('Dick'), ut('Harry') ] !!      write(*,'(*(g0,1x))')'length of elements of array=',len(many_strings) !!    ! !!      write(*,'(*(g0))')'length from type parameter inquiry=',string%len() !!    ! !!    ! LOOK AT HOW A PASSED STRING CAN BE USED ... !!      call passed(ut(' how long? ')) !!    ! !!    contains !!    ! !!    subroutine passed(str) !!    type(ut),intent(in) :: str !!       ! you can query the length of the passed variable !!       ! when an interface is present !!       write(*,'(*(g0))')'length of passed value is ', len(str) !!    end subroutine passed !!    ! !!    end program demo_len !! !!   Results: !! !!    > Noho me ka hau‚Äôoli LEN=18 !!    >  How long is this allocatable string?  LEN=38 !!    > length of elements of array= 3 4 5 !!    > length from type parameter inquiry=38 !!    > length of passed value is 11 !! !!##SEE ALSO !!   functions that perform operations on character strings: !! !!   + elemental: adjustl(3), adjustr(3), index(3), scan(3), verify(3) !!   + non-elemental: len_trim(3), len(3), repeat(3), trim(3) !! !!##AUTHOR !!     John S. Urban !! !!##LICENSE !!     MIT ! Returns the length of the character sequence represented by the string. elemental function len_str ( string ) result ( length ) type ( unicode_type ), intent ( in ) :: string integer :: length if ( allocated ( string % codes )) then length = size ( string % codes ) else length = 0 endif end function len_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    CHARACTER(3f) - [M_unicode:WHITESPACE] convert type(unicode_type) !!    string  to a CHARACTER variable !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !!     result = character(STRING,start,end,inc) !!      or !!     result = STRING%character(start,end,inc) !! !!      elemental function character(string,start,end,inc) !! !!       type(unicode_type),intent(in) :: string !!       integer,intent(in)            :: start !!       integer,intent(in)            :: end !!       integer,intent(in)            :: inc !! !!##CHARACTERISTICS !!   + STRING is a scalar or array string variable !!   + the returned value is a CHARACTER scalar or array !! !!##DESCRIPTION !!   CHARACTER(3f) returns a CHARACTER variable given a string variable !!   of type type(unicode_type). !! !!##OPTIONS !!   + STRING : A scalar or array string to convert to intrinsic CHARACTER !!              type. !!##RESULT !!   The result converts each string to bytes stored in CHARACTER variables. !!   All elements will be padded to the same length of the longest element; !!   as all elements of a CHARACTER array are required to be of the same length. !! !!   Commonly used to pass data to procedures requiring CHARACTER variables !!   or for printing when the DT format is not used.. !! !!##EXAMPLES !! !!   Sample program !! !!    program demo_character !!    use M_unicode, only : ut=>unicode_type, ch=>character, trim, len, pad !!    use M_unicode, only : write(formatted), assignment(=) !!    type(ut)             :: ustr !!    type(ut),allocatable :: array(:) !!    integer              :: i !!    character(len=*),parameter :: all='(*(g0))' !! !!       ustr=[949, 8021, 961, 951, 954, 945, 33] ! eureka in codepoints !!       ! when doing I/O using DT might be the most intuitive !!       ! but sometimes converting to intrinsic character variables !!       ! is preferred !!       write (*,all)  ch(ustr)      ! convert to CHARACTER variable !!       write (*,all)  ustr%character()      ! convert to CHARACTER variable !!       ! you can select a range of glyphs !!       write (*,all)  ustr%character(3,4) ! similar to LINE(3:4) for !!                                          ! CHARACTER variables !!       ! and even reverse a string !!       write (*,all)  ustr%character(len(ustr),1,-1) ! reverse string !!       ! note that OOP syntax provides a few other options !!       write (*,all)  ustr%byte() ! convert to CHARACTER(LEN=1) type !! !!       ! arrays !!       ! !!       ! using this syntax make sure to make the LEN value large enough !!       ! that glyphs can take up to four bytes !!       array= ut([ character(len=60) :: & !!       'Confucius never claimed to be a prophet, '       ,& !!       'but I think he foresaw AI! He said '             ,& !!       ''                                                ,& !!       ' \"Â≠¶ËÄå‰∏çÊÄùÂàôÁΩîÔºåÊÄùËÄå‰∏çÂ≠¶ÂàôÊÆÜ\"'                   ,& !!       'or'                                              ,& !!       ' (xu√© √©r b√π sƒ´ z√© w«éng, sƒ´ √©r b√π xu√© z√© d√†i),'   ,& !!       'which is also'                                   ,& !!       ' \"To learn without thinking is to be lost, '     ,& !!       ' to think without learning is to be in danger\".']) !!       ! !!       write(*,'(*(:,\"[\",g0,\"]\",/))')ch(array) !!       ! all elements will be the same length in bytes but not necessarily !!       !in glyphs !!       write(*,'(a,*(i0,1x))')'all elements the same length in BYTES:', & !!               & len(ch(array)) !!       write(*,'(a,*(i0,1x))')'lengths (in glyphs):',len(array) !!       array=trim(array) !!       write(*,'(a,*(i0,1x))')'lengths after trimming (in glyphs):', & !!               & len(array) !!       write(*,'(:*(:,\"[\",g0,\"]\",/))')ch(array) !!       write(*,*) !!       ! !!       ! using this syntax the elements will be of different lengths !!       array= [ & !!       ut('Confucius never claimed to be a prophet,')      ,& !!       ut('but I think he foresaw AI! He said')            ,& !!       ut('')                                              ,& !!       ut(' \"Â≠¶ËÄå‰∏çÊÄùÂàôÁΩîÔºåÊÄùËÄå‰∏çÂ≠¶ÂàôÊÆÜ\"')                    ,& !!       ut('or')                                            ,& !!       ut(' (xu√© √©r b√π sƒ´ z√© w«éng, sƒ´ √©r b√π xu√© z√© d√†i),') ,& !!       ut('which is also')                                 ,& !!       ut(' \"To learn without thinking is to be lost,')    ,& !!       ut(' to think without learning is to be in danger\".')] !!       ! but using the CHARACTER function will still make them the same !!       ! length in bytes so you might want to print them individually !!       ! for certain effects, subject to font properties such as varying !!       ! glyph widths. !!       write(*,'(*(\"[\",g0,\"]\",/))')(ch(array(i)),i=1,size(array)) !!       write(*,'(*(\"[\",g0,\"]\",/))')(ch(pad(array(i),60)),i=1,size(array)) !!       ! !!    end program demo_character !! !!  Results: !! !!     > Œµ·ΩïœÅŒ∑Œ∫Œ±! !!     > Œµ·ΩïœÅŒ∑Œ∫Œ±! !!     > œÅŒ∑ !!     > !Œ±Œ∫Œ∑œÅ·ΩïŒµ !!     > Œµ·ΩïœÅŒ∑Œ∫Œ±! !!     > [Confucius never claimed to be a prophet,                    ] !!     > [but I think he foresaw AI! He said                          ] !!     > [                                                            ] !!     > [ \"Â≠¶ËÄå‰∏çÊÄùÂàôÁΩîÔºåÊÄùËÄå‰∏çÂ≠¶ÂàôÊÆÜ\"                  ] !!     > [or                                                          ] !!     > [ (xu√© √©r b√π sƒ´ z√© w«éng, sƒ´ √©r b√π xu√© z√© d√†i),   ] !!     > [which is also                                               ] !!     > [ \"To learn without thinking is to be lost,                  ] !!     > [ to think without learning is to be in danger\".             ] !!     > !!     > all elements the same length in BYTES:60 !!     > lengths (in glyphs):60 60 60 34 60 48 60 60 60 !!     > lengths after trimming (in glyphs):40 34 0 16 2 45 13 42 47 !!     > [Confucius never claimed to be a prophet,                 ] !!     > [but I think he foresaw AI! He said                       ] !!     > [                                                         ] !!     > [ \"Â≠¶ËÄå‰∏çÊÄùÂàôÁΩîÔºåÊÄùËÄå‰∏çÂ≠¶ÂàôÊÆÜ\"               ] !!     > [or                                                       ] !!     > [ (xu√© √©r b√π sƒ´ z√© w«éng, sƒ´ √©r b√π xu√© z√© d√†i),] !!     > [which is also                                            ] !!     > [ \"To learn without thinking is to be lost,               ] !!     > [ to think without learning is to be in danger\".          ] !!     > !!     > !!     > [Confucius never claimed to be a prophet,] !!     > [but I think he foresaw AI! He said] !!     > [] !!     > [ \"Â≠¶ËÄå‰∏çÊÄùÂàôÁΩîÔºåÊÄùËÄå‰∏çÂ≠¶ÂàôÊÆÜ\"] !!     > [or] !!     > [ (xu√© √©r b√π sƒ´ z√© w«éng, sƒ´ √©r b√π xu√© z√© d√†i),] !!     > [which is also] !!     > [ \"To learn without thinking is to be lost,] !!     > [ to think without learning is to be in danger\".] !!     > [ !!     > [Confucius never claimed to be a prophet,                    ] !!     > [but I think he foresaw AI! He said                          ] !!     > [                                                            ] !!     > [\"Â≠¶ËÄå‰∏çÊÄùÂàôÁΩîÔºåÊÄùËÄå‰∏çÂ≠¶ÂàôÊÆÜ\"                                      ] !!     > [or                                                          ] !!     > [(xu√© √©r b√π sƒ´ z√© w«éng, sƒ´ √©r b√π xu√© z√© d√†i),                ] !!     > [which is also                                               ] !!     > [\"To learn without thinking is to be lost,                   ] !!     > [to think without learning is to be in danger\".              ] !!     > [ !! !!##SEE ALSO !!   functions that perform operations on character strings: !! !!   + elemental: adjustl(3), adjustr(3), index(3), scan(3), verify(3) !!   + non-elemental: len_trim(3), len(3), repeat(3), trim(3) !! !!##AUTHOR !!     John S. Urban !! !!##LICENSE !!     MIT ! Return the character sequence represented by the string. pure function str_to_char ( string ) result ( aline ) type ( unicode_type ), intent ( in ) :: string character ( len = :), allocatable :: aline integer :: nerr call codepoints_to_utf8_str ( string % codes , aline , nerr ) end function str_to_char pure function strs_to_chars ( string ) result ( lines ) type ( unicode_type ), intent ( in ) :: string (:) character ( len = :), allocatable :: lines (:) character ( len = :), allocatable :: aline integer :: i integer :: mx integer :: nerr mx = 0 do i = 1 , size ( string ) call codepoints_to_utf8_str ( string ( i )% codes , aline , nerr ) mx = max ( mx , len ( aline )) enddo if ( allocated ( lines )) deallocate ( lines ) allocate ( character ( len = mx ) :: lines ( size ( string )) ) do i = 1 , size ( string ) call codepoints_to_utf8_str ( string ( i )% codes , aline , nerr ) lines ( i )(:) = aline enddo end function strs_to_chars pure function str_to_char_pos ( string , pos ) result ( aline ) type ( unicode_type ), intent ( in ) :: string integer , intent ( in ) :: pos character ( len = :), allocatable :: aline integer :: nerr call codepoints_to_utf8_str ( string % codes ( pos : pos ), aline , nerr ) end function str_to_char_pos pure function strs_to_chars_pos ( string , pos ) result ( aline ) type ( unicode_type ), intent ( in ) :: string (:) integer , intent ( in ) :: pos character ( len = 1 ), allocatable :: aline (:) character ( len = :), allocatable :: line integer :: nerr integer :: i if ( allocated ( aline )) deallocate ( aline ) allocate ( character ( len = 1 ) :: aline ( size ( string )) ) do i = 1 , size ( string ) call codepoints_to_utf8_str ( string ( i )% codes ( pos : pos ), line , nerr ) aline ( i ) = line enddo end function strs_to_chars_pos pure function str_to_char_range ( string , first , last ) result ( aline ) type ( unicode_type ), intent ( in ) :: string integer , intent ( in ) :: first integer , intent ( in ) :: last character ( len = :), allocatable :: aline integer :: nerr integer :: last_local last_local = last if ( last_local . le . 0 ) last_local = len ( string ) call codepoints_to_utf8_str ( string % codes ( first : last_local ), aline , nerr ) end function str_to_char_range pure function strs_to_chars_range ( string , first , last ) result ( lines ) type ( unicode_type ), intent ( in ) :: string (:) integer , intent ( in ) :: first integer , intent ( in ) :: last character ( len = :), allocatable :: lines (:) character ( len = :), allocatable :: aline integer :: i integer :: mx integer :: last_local integer :: nerr mx = 0 do i = 1 , size ( string ) last_local = last if ( last_local . le . 0 ) last_local = len ( string ( i )) call codepoints_to_utf8_str ( string ( i )% codes ( first : last_local ), aline , nerr ) mx = max ( mx , len ( aline )) enddo if ( allocated ( lines )) deallocate ( lines ) allocate ( character ( len = mx ) :: lines ( size ( string )) ) do i = 1 , size ( string ) call codepoints_to_utf8_str ( string ( i )% codes ( first : last_local ), aline , nerr ) lines ( i )(:) = aline enddo end function strs_to_chars_range pure function str_to_char_range_step ( string , first , last , step ) result ( aline ) type ( unicode_type ), intent ( in ) :: string integer , intent ( in ) :: first integer , intent ( in ) :: last integer , intent ( in ) :: step character ( len = :), allocatable :: aline integer :: nerr integer :: last_local last_local = last if ( last_local . le . 0 ) last_local = len ( string ) call codepoints_to_utf8_str ( string % codes ( first : last_local : step ), aline , nerr ) end function str_to_char_range_step pure function strs_to_chars_range_step ( string , first , last , step ) result ( lines ) type ( unicode_type ), intent ( in ) :: string (:) integer , intent ( in ) :: first integer , intent ( in ) :: last integer , intent ( in ) :: step character ( len = :), allocatable :: lines (:) character ( len = :), allocatable :: aline integer :: i integer :: mx integer :: nerr integer :: last_local mx = 0 do i = 1 , size ( string ) last_local = last if ( last_local . le . 0 ) last_local = len ( string ( i )) call codepoints_to_utf8_str ( string ( i )% codes ( first : last_local : step ), aline , nerr ) mx = max ( mx , len ( aline )) enddo if ( allocated ( lines )) deallocate ( lines ) allocate ( character ( len = mx ) :: lines ( size ( string )) ) do i = 1 , size ( string ) last_local = last if ( last_local . le . 0 ) last_local = len ( string ( i )) call codepoints_to_utf8_str ( string ( i )% codes ( first : last_local : step ), aline , nerr ) lines ( i )(:) = aline enddo end function strs_to_chars_range_step !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!   REPEAT(3) - [M_unicode:CHARACTER] Repeated string concatenation !! !!##SYNOPSIS !! !!   result = repeat(string, ncopies) !! !!    type(unicode_type) function repeat(string, ncopies) !! !!     type(unicode_type),intent(in)   :: string !!     integer(kind=**),intent(in)   :: ncopies !! !!##CHARACTERISTICS !! !!   + STRING is a scalar string of type(unicode_type). !!   + NCOPIES is a scalar integer. !!   + the result is a new scalar string of type type(unicode_type) !! !!##DESCRIPTION !!   REPEAT(3) concatenates copies of a string. !! !!##OPTIONS !!   +  STRING : The input string to repeat !!   +  NCOPIES : Number of copies to make of STRING, greater than or equal to !!      zero (0). !! !!##RESULT !!   A new string built up from NCOPIES copies of STRING. !! !!##EXAMPLES !! !!   Sample program: !! !!     program demo_repeat !!     use M_unicode, only : ut=>unicode_type,repeat,escape,write(formatted) !!     implicit none !!        write(*,'(DT)') repeat(escape(\"\\u2025*\"), 35) !!        write(*,'(DT)') repeat(ut(\"_\"), 70)          ! line break !!        write(*,'(DT)') repeat(ut(\"1234567890\"), 7)  ! number line !!        write(*,'(DT)') repeat(ut(\"         |\"), 7)  ! !!     end program demo_repeat !! !!##STANDARD !!   Fortran 95 !! !!##SEE ALSO !!   Functions that perform operations on character strings: !! !!   + ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), SCAN(3), VERIFY(3) !!   + NON-ELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3) !! !!   Fortran descriptions (license: MIT) @urbanjost ! Repeats the character sequence held by the string by the number of specified copies. ! This method is elemental and returns a scalar character value. elemental function repeat_str ( string , ncopies ) result ( repeated_str ) type ( unicode_type ), intent ( in ) :: string integer , intent ( in ) :: ncopies type ( unicode_type ) :: repeated_str integer :: i repeated_str % codes = [( string % codes , i = 1 , ncopies )] end function repeat_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!   LEN_TRIM(3f) - [M_unicode:WHITESPACE] string length without trailing blank !!   characters !!   (LICENSE:MIT) !! !!##SYNOPSIS !! !!   result = len_trim(string) !! !!          elemental integer(kind=kind) function len_trim(string) !! !!           character(len=*),intent(in) :: string !! !!##CHARACTERISTICS !!   + string is of type type(unicode_type) !!   + the return value is of type default integer. !! !!##DESCRIPTION !!   len_trim(3) returns the length of a string, ignoring any trailing !!   blanks. !! !!##OPTIONS !!   + string : the input string whose length is to be measured. !! !!##RESULT !!   the result equals the number of glyphs remaining after any trailing !!   blanks in string are removed. !! !!   if the input argument is of zero length or all blanks the result is zero. !! !!##EXAMPLES !! !!   sample program !! !!    program demo_len_trim !!    use M_unicode, only : ut=>unicode_type, assignment(=) !!    use M_unicode, only : len,len_trim !!    use M_unicode, only : write(formatted) !!    implicit none !!    type(ut) :: string !!    integer  :: i !!    ! basic usage !!       string=\" how long is this string?     \" !!       print '(DT)',  string !!       print *, 'untrimmed length=',len(string) !!       print *, 'trimmed length=',len_trim(string) !!       ! !!       ! print string, then print substring of string !!       string='xxxxx   ' !!       write(*,'(*(DT))')string,string,string !!       i=len_trim(string) !!       print '(*(DT))',string%sub(1,i),string%sub(1,i),string%sub(1,i) !!       ! !!       ! elemental example !!       ele:block !!       ! an array of strings may be used !!       type(ut),allocatable :: tablet(:) !!       tablet=[ & !!       & ut(' how long is this string?     '),& !!       & ut('and this one?')] !!          write(*,*)'untrimmed length=  ',len(tablet) !!          write(*,*)'trimmed length=    ',len_trim(tablet) !!          write(*,*)'sum trimmed length=',sum(len_trim(tablet)) !!       endblock ele !!       ! !!    end program demo_len_trim !! !!   results: !! !!    >  how long is this string? !!    >  untrimmed length=          30 !!    >  trimmed length=          25 !!    > xxxxx   xxxxx   xxxxx !!    > xxxxxxxxxxxxxxx !!    >  untrimmed length=            30          13 !!    >  trimmed length=              25          13 !!    >  sum trimmed length=          38 !! !!##SEE ALSO !!   functions that perform operations on character strings, return lengths of !!   arguments, and search for certain arguments: !! !!   + elemental: adjustl(3), adjustr(3), index(3), scan(3), verify(3) !! !!   + nonelemental: repeat(3), len(3), trim(3) !! !!##AUTHOR !!     John S. Urban !! !!##LICENSE !!     MIT ! Returns length of character sequence without trailing spaces represented by the string. ! elemental function len_trim_str ( string ) result ( length ) type ( unicode_type ), intent ( in ) :: string integer :: length if ( allocated ( string % codes )) then do length = size ( string % codes ), 1 , - 1 if ( any ( string % codes ( length ). eq . unicode % SPACES )) cycle exit enddo else length = 0 endif end function len_trim_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!   ICHAR(3f) - [M_unicode:CONVERSION] character-to-integer code conversion !!   function !!   (LICENSE:MIT) !! !!##SYNOPSIS !! !!   result = ichar(c) !! !!     elemental integer function ichar(c,kind) !! !!      type(unicode_type),intent(in) :: c !! !!##CHARACTERISTICS !!   ‚Ä¢  c is a scalar character !! !!   ‚Ä¢  the return value is of default integer kind. !! !!##DESCRIPTION !!   ichar(3) returns the code for the character in the system's native !!   character set. the correspondence between characters and their codes is !!   not necessarily the same across different Fortran implementations. For !!   example, a platform using EBCDIC would return different values than !!   an ASCII platform. !! !!   See IACHAR(3) for specifically working with the ASCII character set. !! !!##OPTIONS !!   +  C : The input character to determine the decimal code of. !! !!##RESULT !!    The codepoint in the Unicode character set for the character being !!    queried is returned. !! !!    The result is the position of C in the Unicode collating sequence, !!    which is generally not the dictionary order in a particular language. !! !!    It is nonnegative and less than n, where n is the number of characters !!    in the collating sequence. !! !!    For any characters C and D capable of representation in the processor, !!    C <= D is true if and only if ICHAR(C) <= ICHAR(D) is true and C == !!    D is true if and only if ICHAR(C) == ICHAR(D) is true. !! !!##EXAMPLES !! !!   sample program: !! !!    program demo_ichar !!    use M_unicode, only : assignment(=),ch=>character !!    use M_unicode, only : ut=>unicode_type, write(formatted) !!    use M_unicode, only : ichar, escape, len !!    implicit none !!    type(ut)             :: string !!    type(ut),allocatable :: lets(:) !!    integer,allocatable  :: ilets(:) !!    integer              :: i !!       ! !!       ! create a string containing multibyte characters !!       string=[949, 8021, 961, 951, 954, 945, 33] ! eureka !!       write(*,'(*(DT,1x,\"(AKA. eureka!)\"))')string !!       ! !!       ! call ichar(3) on each glyph of the string to convert !!       ! the string to an array of integer codepoints !!       ilets=[(ichar(string%sub(i,i)),i=1,len(string))] !!       write(*,'(*(z0,1x))')ilets !!       ! !!       ! note that the %codepoint method is commonly used to !!       ! convert a string to an integer array of codepoints !!       write(*,'(*(z0,1x))')string%codepoint() !! !!       ! elemental !!       write(*,'(\"WRITING ISSUES:\")') !!       ! !!       ! define an array LETS with escape codes with one glyph per element !!       lets=[ut('\\U03B5'),ut('\\U1F55'),ut('\\U03C1'),ut('\\U03B7'), & !!           & ut('\\U03BA'),ut('\\U03B1'),ut('\\U0021')] !!       lets=escape(lets) ! convert escape codes to glyphs !!       ! !!       ! look at issues with converting to CHARACTER for simple printing !!       ! !!       write(*,'(\"each element is a single glyph \",*(g0,1x))')len(lets) !!       ! !!       ! notice if you convert to an array of intrinsic CHARACTER type the !!       ! strings are all the same length in bytes; but unicode characters !!       ! can take various numbers of bytes !!       write(*,'(*(g0,\":\"))')'CHARACTER array elements have same length',& !!          & len(ch(lets)) !!       ! this will not appear correctly because all elements are padded to !!       ! the same length in bytes !!       write(*,'(*(a,\":\"))')ch(lets) !!       ! one element at a time will retain the size of each element !!       write(*,'(*(a,\":\"))')(ch(lets(i:i)),i=1,size(lets)) !!       ! !!       ! the FIRST LETTER of each element is converted to a codepoint so !!       ! for the special case where each string element is a single glyph !!       ! an elemental approach works !!       write(*,'(\"ELEMENTAL:\",*(z0,1x))')ichar(lets) !! !!       ! OOPS !!       write(*,'(\"OOPS:\",*(z0,1x))')lets%ichar() !!    end program demo_ichar !! !!   results: !! !!    > Project is up to date !!    > Œµ·ΩïœÅŒ∑Œ∫Œ±! (AKA. eureka!) !!    > 3B5 1F55 3C1 3B7 3BA 3B1 21 !!    > 3B5 1F55 3C1 3B7 3BA 3B1 21 !!    > WRITING ISSUES: !!    > each element is a single glyph 1 1 1 1 1 1 1 !!    > CHARACTER array elements have same length:3: !!    > Œµ :·Ωï:œÅ :Œ∑ :Œ∫ :Œ± :!  : !!    > Œµ:·Ωï:œÅ:Œ∑:Œ∫:Œ±:!: !!    > ELEMENTAL:3B5 1F55 3C1 3B7 3BA 3B1 21 !!    > OOPS:3B5 1F55 3C1 3B7 3BA 3B1 21 !! !!##SEE ALSO !!   achar(3), char(3), iachar(3) !! !!   functions that perform operations on character strings, return !!   lengths of arguments, and search for certain arguments: !! !!   +  elemental: adjustl(3), adjustr(3), index(3), !!      scan(3), verify(3) !! !!   +  nonelemental: len_trim(3), len(3), repeat(3), trim(3) !! !!##AUTHOR !!     John S. Urban !! !!##LICENSE !!     MIT ! ! Return code value of first character of string like intrinsic ichar() ! elemental function ichar_str ( string ) result ( code ) type ( unicode_type ), intent ( in ) :: string integer :: code if ( size ( string % codes ) == 0 ) then code = 0 else code = string % codes ( 1 ) endif end function ichar_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!   TRIM(3f) - [M_unicode:WHITESPACE] remove trailing blank characters from !!              a string !!              (LICENSE:MIT) !! !!##SYNOPSIS !! !!   result = trim(string) !! !!    type(unicode_type) function trim(string) !! !!     type(unicode_type),intent(in) :: string !! !!##CHARACTERISTICS !! !!   + the result is a string. !! !!##DESCRIPTION !!   trim(3) removes trailing blank characters from a string. !! !!##OPTIONS !!   + string : a string to trim !! !!##RESULT !!   the result is the same as string except trailing blanks are removed. !! !!   if string is composed entirely of blanks or has zero length, the !!   result has zero length. !! !!##EXAMPLES !! !!   sample program: !! !!    program demo_trim !!    use M_unicode, only : ut=>unicode_type, assignment(=) !!    use M_unicode, only : trim, len !!    use M_unicode, only : write(formatted) !!    implicit none !!    type(ut)                   :: str !!    type(ut), allocatable      :: strs(:) !!    character(len=*),parameter :: brackets='( *(\"[\",DT,\"]\":,1x) )' !!    integer                    :: i !!       ! !!       str='   trailing    ' !!       print brackets, str,trim(str) ! trims it !!       ! !!       str='   leading' !!       print brackets, str,trim(str) ! no effect !!       ! !!       str='            ' !!       print brackets, str,trim(str) ! becomes zero length !!       print *,  len(str), len(trim('               ')) !!       ! !!       strs=[ut(\"Z \"),ut(\" a b c\"),ut(\"ABC   \"),ut(\"\")] !!       ! !!       write(*,*)'untrimmed:' !!       print brackets, (strs(i), i=1,size(strs)) !!       print brackets, strs !!       ! !!       write(*,*)'trimmed:' !!       ! everything prints trimmed !!       print brackets, (trim(strs(i)), i=1,size(strs)) !!       print brackets, trim(strs) !!       ! !!    end program demo_trim !! !!   results: !! !!    > [   trailing    ] [   trailing] !!    > [   leading] [   leading] !!    > [            ] [] !!    >           12           0 !!    >  untrimmed: !!    > [Z ] [ a b c] [ABC   ] [] !!    > [Z ] [ a b c] [ABC   ] [] !!    >  trimmed: !!    > [Z] [ a b c] [ABC] [] !!    > [Z] [ a b c] [ABC] [] !! !!##SEE ALSO !!   Functions that perform operations on character strings, return !!   lengths of arguments, and search for certain arguments: !! !!   + elemental: adjustl(3), adjustr(3), index(3), scan(3), verify(3) !! !!   + nonelemental: len_trim(3), len(3), repeat(3), trim(3) !! !!##AUTHOR !!     John S. Urban !! !!##LICENSE !!     MIT ! This method is elemental and returns a scalar character value. elemental function trim_str ( string ) result ( trimmed_str ) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ) :: trimmed_str integer :: last last = len_trim_str ( string ) trimmed_str % codes = string % codes (: last ) end function trim_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!   ADJUSTR(3f) - [M_unicode:WHITESPACE] right-justify a string !!                 (LICENSE:MIT) !! !!##SYNOPSIS !! !!   result = adjustr(string,glyphs) !! !!    elemental function adjustr(string) !! !!     type(unicode_type)            :: adjustr !!     type(unicode_type),intent(in) :: string !!     integer,intent(in),optional   :: glyphs !! !!##CHARACTERISTICS !!   + STRING is a string variable !!   + GLYPHS is a default integer !!   + the return value is a string variable !! !!##DESCRIPTION !!   ADJUSTR(3) right-justifies a string by removing trailing spaces. Spaces !!   are inserted at the start of the string as needed to retain the !!   original length unless an explicit return length is specified by the !!   GLYPHS parameter. !! !!##OPTIONS !!   + STRING : the string to right-justify !!   + GLYPHS : length in glyphs to extend to or truncate to !! !!##RESULT !!   trailing spaces are removed and the same number of spaces are then !!   inserted at the start of string. !! !!##EXAMPLES !! !! !!  sample program: !! !!   program demo_adjustr !!   use M_unicode, only : ut=>unicode_type !!   use M_unicode, only : adjustr, len !!   use M_unicode, only : write(formatted) !!   use M_unicode, only : assignment(=) !!   implicit none !!   type(ut)                   :: str !!   type(ut),allocatable       :: array(:) !!   integer                    :: i !!   character(len=*),parameter :: bracket='(\"[\",DT,\"]\")' !!       ! !!       call numberline(2) !!       ! !!       ! basic usage !!       str = '  sample string     ' !!       write(*,bracket) str !!       str = adjustr(str) !!       write(*,bracket) str !!       ! !!       call numberline(5) !!       ! !!       ! elemental !!       array=ut([character(len=50) :: & !!       '    ‡§è‡§ï (ek) ', & !!       '       ‡§¶‡•ã (do) ', & !!       '          ‡§§‡•Ä‡§®(teen) ' ]) !!       ! !!       ! print array unadjusted !!       write(*,bracket)array !!       !do i=1,size(array) !!       !   write(*,'(*(g0,1x))')array(i)%codepoint() !!       !enddo !!       ! note 50 bytes is not necessarily 50 glyphs !!       write(*,'(*(g0,1x))')'length in glyphs=',len(array) !!       write(*,'(*(g0,1x))')'length in bytes=',(len(array(i)%character()),i=1,size(array)) !!       ! !!       call numberline(5) !!       ! !!       ! print array right-justified !!       write(*,bracket)adjustr(array) !!       ! !!       call numberline(5) !!       ! !!       ! print array right-justified specifying number of glyphs !!       write(*,*)'set to 50' !!       write(*,bracket)adjustr(array,50) !!       ! !!       write(*,*)'set to 60' !!       call numberline(6) !!       write(*,bracket)adjustr(array,60) !!       write(*,*)'set to 40' !!       call numberline(4) !!       write(*,bracket)adjustr(array,40) !!       write(*,*)'set to 10' !!       call numberline(1) !!       write(*,bracket)adjustr(array,10) !!       write(*,*)'set to 5' !!       write(*,bracket)adjustr(array,5) !!       write(*,*)'set to 4' !!       write(*,bracket)adjustr(array,4) !!       write(*,*)'set to 1' !!       write(*,bracket)adjustr(array,1) !!    contains !!       ! !!       subroutine numberline(ireps) !!       integer,intent(in) :: ireps !!          write(*,'(1x,a)')repeat('1234567890',ireps) !!       end subroutine numberline !!    end program demo_adjustr !! !!   Results: !! !!    >  12345678901234567890 !!    > [  sample string     ] !!    > [       sample string] !!    >  12345678901234567890123456789012345678901234567890 !!    > [    ‡§è‡§ï (ek)                                   ] !!    > [       ‡§¶‡•ã (do)                                ] !!    > [          ‡§§‡•Ä‡§®(teen)                         ] !!    > length in glyphs= 46 46 44 !!    > length in bytes= 50 50 50 !!    >  12345678901234567890123456789012345678901234567890 !!    > [                                       ‡§è‡§ï (ek)] !!    > [                                       ‡§¶‡•ã (do)] !!    > [                                   ‡§§‡•Ä‡§®(teen)] !!    >  12345678901234567890123456789012345678901234567890 !!    >  set to 50 !!    > [                                           ‡§è‡§ï (ek)] !!    > [                                           ‡§¶‡•ã (do)] !!    > [                                         ‡§§‡•Ä‡§®(teen)] !!    >  set to 60 !!    >  123456789012345678901234567890123456789012345678901234567890 !!    > [                                                     ‡§è‡§ï (ek)] !!    > [                                                     ‡§¶‡•ã (do)] !!    > [                                                   ‡§§‡•Ä‡§®(teen)] !!    >  set to 40 !!    >  1234567890123456789012345678901234567890 !!    > [                                 ‡§è‡§ï (ek)] !!    > [                                 ‡§¶‡•ã (do)] !!    > [                               ‡§§‡•Ä‡§®(teen)] !!    >  set to 10 !!    >  1234567890 !!    > [   ‡§è‡§ï (ek)] !!    > [   ‡§¶‡•ã (do)] !!    > [ ‡§§‡•Ä‡§®(teen)] !!    >  set to 5 !!    > [ (ek)] !!    > [ (do)] !!    > [teen)] !!    >  set to 4 !!    > [(ek)] !!    > [(do)] !!    > [een)] !!    >  set to 1 !!    > [)] !!    > [)] !!    > [)] !! !!##SEE ALSO !!   ADJUSTL(3), TRIM(3) !! !!##AUTHOR !!     John S. Urban !! !!##LICENSE !!     MIT impure elemental function adjustr_str ( string , glyphs ) result ( adjusted ) ! ident_3=\"@(#) M_unicode adjustr(3f) adjust string to right\" ! right-justify string by moving trailing spaces to beginning of string so length is retained even if spaces are of varied width type ( unicode_type ), intent ( in ) :: string integer , intent ( in ), optional :: glyphs type ( unicode_type ) :: adjusted integer :: last integer :: i if ( present ( glyphs )) then if ( glyphs . le . 0 ) then if ( allocated ( adjusted % codes )) deallocate ( adjusted % codes ) allocate ( adjusted % codes ( 0 )) elseif ( glyphs . lt . size ( string % codes )) then ! shorter adjusted % codes = adjustl ( string ) adjusted = trim_str ( adjusted ) if ( size ( adjusted % codes ). lt . glyphs ) then adjusted % codes = [( 32 , i = 1 , glyphs - size ( adjusted % codes )), adjusted % codes ] else adjusted % codes = adjusted % codes ( size ( adjusted % codes ) - glyphs + 1 :) endif elseif ( glyphs . eq . size ( string % codes )) then last = len_trim_str ( string ) adjusted % codes = cshift ( string % codes , - ( size ( string % codes ) - last )) else ! longer than string length adjusted % codes = [( 32 , i = 1 , glyphs - size ( string % codes )), string % codes ] last = len_trim_str ( adjusted ) adjusted % codes = cshift ( adjusted % codes , - ( size ( adjusted % codes ) - last )) endif else last = len_trim_str ( string ) adjusted % codes = cshift ( string % codes , - ( size ( string % codes ) - last )) endif end function adjustr_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!   ADJUSTL(3f) - [M_unicode:WHITESPACE] Left-justified a string !!                 (LICENSE:MIT) !! !!##SYNOPSIS !! !!   result = adjustl(string,glyphs) !! !!    function adjustl(string,glyphs) result(out) !! !!     type(unicode_type),intent(in) :: string !!     integer,intent(in),optional   :: glyphs !!     type(unicode_type)            :: out !! !!##CHARACTERISTICS !!   + STRING is a string variable of type(unicode_type) !!   + GLYPHS is a default integer !!   + The return value is a string variable of type(unicode_type) !! !!##DESCRIPTION !!   adjustl(3) will left-justify a string by removing leading spaces. Spaces !!   are inserted at the end of the string as needed to keep the number of !!   glyphs on output the same as the number on input unless overridden by !!   the GLYPHS parameter. !! !!##OPTIONS !!   +  STRING : the string to left-justify !!   +  GLYPHS : the length of the output in glyphs !! !!##RESULT !!   A copy of STRING where leading spaces are removed and the same !!   number of spaces are inserted on the end of STRING unless GLYPHS is !!   specified. Note using GLYPHS can cause in string truncation. !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_adjustl !!    use M_unicode, only : ut=>unicode_type !!    use M_unicode, only : ch=>character !!    use M_unicode, only : adjustl, trim, len_trim, verify !!    use M_unicode, only : write(formatted) !!    use M_unicode, only : assignment(=) !!    implicit none !!    type(ut)                   :: usample, uout !!    integer                    :: istart, iend !!    character(len=*),parameter :: adt = '(a,\"[\",DT,\"]\")' !!     ! !!     ! basic use !!       usample='   sample string   ' !!       write(*,adt) 'original: ',usample !!     ! !!     ! note a string stays the same length !!     ! and is not trimmed by just an adjustl(3) call. !!       write(*,adt) 'adjusted: ',adjustl(usample) !!     ! !!     ! a fixed‚Äêlength string can be trimmed using trim(3) !!       uout=trim(adjustl(usample)) !!       write(*,adt) 'trimmed:  ',uout !!     ! !!     ! or alternatively you can select a substring without adjusting !!       istart= max(1,verify(usample, ' ')) ! first non‚Äêblank character !!       iend = len_trim(usample) !!       write(*,adt) 'substring:',usample%sub(istart,iend) !!     ! !!       write(*,adt) 'substring:',adjustl(usample,30) !!       write(*,adt) 'substring:',adjustl(usample,20) !!       write(*,adt) 'substring:',adjustl(usample,10) !!       write(*,adt) 'substring:',adjustl(usample,0) !!    end program demo_adjustl !! !!   Results: !! !!    > original: [   sample string   ] !!    > adjusted: [sample string      ] !!    > trimmed:  [sample string] !!    > substring:[sample string] !! !!##SEE ALSO !!   ADJUSTR(3), TRIM(3) !! !!##AUTHOR !!     John S. Urban !! !!##LICENSE !!     MIT !left-justify string by  moving leading spaces to end of string so length is retained even if spaces are of varied width elemental function adjustl_str ( string , glyphs ) result ( adjusted ) type ( unicode_type ), intent ( in ) :: string integer , intent ( in ), optional :: glyphs type ( unicode_type ) :: adjusted integer :: first integer :: i do first = 1 , size ( string % codes ), 1 if ( any ( string % codes ( first ). eq . unicode % SPACES )) cycle exit enddo adjusted % codes = cshift ( string % codes , first - 1 ) if ( present ( glyphs )) then if ( glyphs . le . 0 ) then deallocate ( adjusted % codes ) allocate ( adjusted % codes ( 0 )) elseif ( glyphs . le . size ( adjusted % codes )) then adjusted % codes = adjusted % codes ( 1 : glyphs ) else adjusted % codes = [ adjusted % codes ,( 32 , i = 1 , glyphs - size ( adjusted % codes ) + 1 )] endif endif end function adjustl_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Compare two character sequences for non-equality; LHS, RHS or both sequences can be a unicode string or character variable. ! elemental function lne_str_str ( lhs , rhs ) result ( is_equal ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_equal integer :: icount if ( lhs % len_trim (). eq . rhs % len_trim ()) then icount = lhs % len_trim () is_equal = . not . all ( lhs % codes (: icount ) . eq . rhs % codes (: icount ) ) else is_equal = . true . endif end function lne_str_str elemental function lne_str_char ( lhs , rhs ) result ( is_equal ) type ( unicode_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_equal is_equal = lne_str_str ( lhs , unicode_type ( rhs )) end function lne_str_char elemental function lne_char_str ( lhs , rhs ) result ( is_equal ) character ( len =* ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_equal is_equal = lne_str_str ( unicode_type ( lhs ), rhs ) end function lne_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Compare two character sequences for equality; LHS, RHS or both sequences can be a unicode string or character variable. ! elemental function leq_str_str ( lhs , rhs ) result ( is_equal ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_equal integer :: icount if ( lhs % len_trim (). eq . rhs % len_trim ()) then icount = lhs % len_trim () is_equal = all ( lhs % codes (: icount ) . eq . rhs % codes (: icount ) ) else is_equal = . false . endif end function leq_str_str elemental function leq_str_char ( lhs , rhs ) result ( is_equal ) type ( unicode_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_equal is_equal = leq_str_str ( lhs , unicode_type ( rhs )) end function leq_str_char elemental function leq_char_str ( lhs , rhs ) result ( is_equal ) character ( len =* ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_equal is_equal = leq_str_str ( unicode_type ( lhs ), rhs ) end function leq_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Lexically compare two character sequences for being greater or equal elemental function lge_str_str ( lhs , rhs ) result ( is_lge ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_lge integer :: i integer :: llen integer :: rlen llen = len_trim ( lhs ) rlen = len_trim ( rhs ) FOUND : block do i = 1 , min ( llen , rlen ) select case ( lhs % codes ( i ) - rhs % codes ( i )) case ( 0 ); cycle case ( 1 :); is_lge = . true .; exit FOUND case (: - 1 ); is_lge = . false .; exit FOUND end select enddo ! all equal, decide based on difference in length select case ( llen - rlen ) case ( 0 ); is_lge = . true . case ( 1 :); is_lge = . true . case (: - 1 ); is_lge = . false . end select endblock FOUND end function lge_str_str elemental function lge_str_char ( lhs , rhs ) result ( is_lge ) type ( unicode_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lge is_lge = lge_str_str ( lhs , unicode_type ( rhs )) end function lge_str_char elemental function lge_char_str ( lhs , rhs ) result ( is_lge ) character ( len =* ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_lge is_lge = lge_str_str ( unicode_type ( lhs ), rhs ) end function lge_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Lexically compare two character sequences for being less than or equal elemental function lle_str_str ( lhs , rhs ) result ( is_lle ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_lle integer :: i integer :: llen integer :: rlen llen = len_trim ( lhs ) rlen = len_trim ( rhs ) FOUND : block do i = 1 , min ( llen , rlen ) select case ( lhs % codes ( i ) - rhs % codes ( i ) ) case ( 0 ); cycle case ( 1 :); is_lle = . false .; exit FOUND case (: - 1 ); is_lle = . true .; exit FOUND end select enddo ! all equal, decide based on difference in length select case ( llen - rlen ) case (: - 1 ); is_lle = . true . case ( 0 ); is_lle = . true . case ( 1 :); is_lle = . false . end select endblock FOUND end function lle_str_str elemental function lle_str_char ( lhs , rhs ) result ( is_lle ) type ( unicode_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lle is_lle = lle_str_str ( lhs , unicode_type ( rhs )) end function lle_str_char elemental function lle_char_str ( lhs , rhs ) result ( is_lle ) character ( len =* ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_lle is_lle = lle_str_str ( unicode_type ( lhs ), rhs ) end function lle_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Lexically compare two character sequences for being less than elemental function llt_str_str ( lhs , rhs ) result ( is_llt ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_llt integer :: i integer :: llen integer :: rlen llen = len_trim ( lhs ) rlen = len_trim ( rhs ) FOUND : block do i = 1 , min ( llen , rlen ) select case ( lhs % codes ( i ) - rhs % codes ( i )) case ( 0 ); cycle ; case ( 1 :); is_llt = . false .; exit FOUND case (: - 1 ); is_llt = . true .; exit FOUND end select enddo ! all equal, decide based on difference in length select case ( llen - rlen ) case ( 0 ); is_llt = . false . case ( 1 :); is_llt = . false . case (: - 1 ); is_llt = . true . end select endblock FOUND end function llt_str_str elemental function llt_str_char ( lhs , rhs ) result ( is_llt ) type ( unicode_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_llt is_llt = llt_str_str ( lhs , unicode_type ( rhs )) end function llt_str_char elemental function llt_char_str ( lhs , rhs ) result ( is_llt ) character ( len =* ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_llt is_llt = llt_str_str ( unicode_type ( lhs ), rhs ) end function llt_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Lexically compare two character sequences for being greater than elemental function lgt_str_str ( lhs , rhs ) result ( is_lgt ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_lgt integer :: i integer :: llen integer :: rlen llen = len_trim ( lhs ) rlen = len_trim ( rhs ) FOUND : block do i = 1 , min ( llen , rlen ) select case ( lhs % codes ( i ) - rhs % codes ( i )) case ( 0 ); cycle ; case ( 1 :); is_lgt = . true .; exit FOUND case (: - 1 ); is_lgt = . false .; exit FOUND end select enddo ! all equal, decide based on difference in length select case ( llen - rlen ) case ( 0 ); is_lgt = . false . case ( 1 :); is_lgt = . true . case (: - 1 ); is_lgt = . false . end select endblock FOUND end function lgt_str_str elemental function lgt_str_char ( lhs , rhs ) result ( is_lgt ) type ( unicode_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lgt is_lgt = lgt_str_str ( lhs , unicode_type ( rhs )) end function lgt_str_char elemental function lgt_char_str ( lhs , rhs ) result ( is_lgt ) character ( len =* ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_lgt is_lgt = lgt_str_str ( unicode_type ( lhs ), rhs ) end function lgt_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!   INDEX(3f) - [M_unicode:SEARCH] Position of a substring within a string !!               (LICENSE:MIT) !! !!##SYNOPSIS !! !!   result = index( string, substring [,back] [,kind] ) !! !!    elemental integer(kind=KIND) function index(string,substring,back,kind) !! !!     character(len=*,kind=KIND),intent(in) :: string !!     character(len=*,kind=KIND),intent(in) :: substring !!     logical(kind=**),intent(in),optional :: back !!     integer(kind=**),intent(in),optional :: kind !! !!##CHARACTERISTICS !!   + STRING     is a character variable of any kind !! !!   + SUBSTRING  is a character variable of the same kind as STRING !! !!   + BACK       is a logical variable of any supported kind !! !!   + KIND       is a scalar integer constant expression. !! !!##DESCRIPTION !!   INDEX(3) returns the position of the start of the leftmost or !!   rightmost occurrence of string SUBSTRING in STRING, counting from !!   one. If SUBSTRING is not present in STRING, zero is returned. !! !!##OPTIONS !!   + STRING : string to be searched for a match !! !!   + SUBSTRING : string to attempt to locate in STRING !! !!   + BACK : If the BACK argument is present and true, the return value !!     is the start of the rightmost occurrence rather than the !!     leftmost. !! !!   + KIND : if KIND is present, the kind type parameter is that specified !!     by the value of KIND; otherwise the kind type parameter is !!     that of default integer type. !! !!##RESULT !!   The result is the starting position of the first substring SUBSTRING !!   found in STRING. !! !!   If the length of SUBSTRING is longer than STRING the result is zero. !! !!   If the substring is not found the result is zero. !! !!   If BACK is .true. the greatest starting position is returned (that is, !!   the position of the right‚Äêmost match). Otherwise, the smallest !!   position starting a match (ie. the left‚Äêmost match) is returned. !! !!   The position returned is measured from the left with the first character !!   of STRING being position one. !! !!   Otherwise, if no match is found zero is returned. !! !!##EXAMPLES !! !!   Example program !! !!    program demo_index !!    use M_unicode, only : ut=>unicode_type !!    use M_unicode, only : assignment(=) !!    use M_unicode, only : index !!    implicit none !!    type(ut)                   :: str !!    character(len=*),parameter :: all='(*(g0))' !!    integer                    :: ii !!       ! !!       str='Huli i kƒìia kaula no kƒìia  ª≈çlelo' !!       !bug!print all, index(str,'kƒìia').eq.8 !!       ii=index(str,'kƒìia'); print all, ii.eq.8 !!       ! !!       ! return value is counted from the left end even if BACK=.TRUE. !!       !bug!print all, index(str,'kƒìia',back=.true.).eq.22 !!       ii=index(str,'kƒìia',back=.true.); print all, ii.eq.22 !!       ! !!       ! INDEX is case-sensitive !!       !bug!print all, index(str,'Kƒìia').eq.0 !!       ii=index(str,'Kƒìia'); print all, ii.eq.0 !!       !<<<<<<<<<< !!       !ifx bug: ifx (IFX) 2024.1.0 20240308 !!       ! !!       !example/demo_index.f90(17): error #6766: A binary defined OPERATOR !!       !definition is missing or incorrect.   [EQ] !!       !        print all, index(str,'k  ia',back=.true.).eq.22 !!       !--------------------------------------------------&#94; !!       !Original works with gfortran and flang_new and this works with ifx !!       !        ii=ndex(str,'k  ia',back=.true.) !!       !    print all, ii.eq.22 !!       !>>>>>>>>>> !!    end program demo_index !! !!   Expected Results: !! !!    > T !!    > T !!    > T !!    > T !!    > T !!    > T !! !!##SEE ALSO !!   Functions that perform operations on character strings, return lengths !!   of arguments, and search for certain arguments: !! !!   +  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), SCAN(3), VERIFY(3) !! !!   +  NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3) !! !!##AUTHOR !!     John S. Urban !! !!##LICENSE !!     MIT ! find location of substring within string elemental function index_str_str ( string , substring , back ) result ( foundat ) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: substring logical , intent ( in ), optional :: back integer :: foundat integer :: i integer :: strlen integer :: sublen logical :: back_local back_local = . false . if ( present ( back )) back_local = back strlen = string % len () sublen = substring % len () foundat = 0 if ( back_local ) then do i = strlen - sublen + 1 , 1 , - 1 if ( all ( string % codes ( i : i + sublen - 1 ) . eq . substring % codes ) ) then foundat = i exit endif enddo else do i = 1 , strlen - sublen + 1 if ( all ( string % codes ( i : i + sublen - 1 ) . eq . substring % codes ) ) then foundat = i exit endif enddo endif end function index_str_str elemental function index_str_char ( string , substring , back ) result ( foundat ) type ( unicode_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring logical , intent ( in ), optional :: back integer :: foundat foundat = index_str_str ( string , unicode_type ( substring ), back ) end function index_str_char elemental function index_char_str ( string , substring , back ) result ( foundat ) character ( len =* ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: substring logical , intent ( in ), optional :: back integer :: foundat foundat = index_str_str ( unicode_type ( string ), substring , back ) end function index_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !! !! In computing, Unicode characters are typically sorted using one of two methods: !! !! a simple binary code point sort or a more sophisticated, !! language-sensitive collation. The correct approach depends on whether a !! linguistically accurate \"alphabetical\" order is needed or if a simple, !! fixed order is sufficient. !! !! Binary code point sort !! !! This is the simplest and fastest method, often used as a default by !! programming languages and databases. !! !!     How it works: Strings are sorted based on the numeric value of their !!     underlying Unicode code points. For example, a character with a code !!     point of U+0061 (lowercase \"a\") will always be placed before U+0062 !!     (lowercase \"b\") because 97 is less than 98. !! !!     Limitations: While this works for the basic English alphabet, it !!     produces non-intuitive results for other characters because the code !!     point value does not correlate with linguistic sorting rules. For !!     instance, it may place: !! !!         Uppercase letters before all lowercase letters (Z comes before a). !! !!         Accented letters in an order that is not linguistically correct !!         for a given language (e.g., in German, an umlauted character !!         like √∂ might be sorted differently than a plain o). !! !!         Characters from different scripts (like Latin, Greek, and !!         Cyrillic) in an order determined solely by their assigned code !!         point blocks. !! !! Unicode Collation Algorithm (UCA) !! !! This is the standard, more robust method for sorting that produces !! correct, language-sensitive results. It is described in Unicode Technical !! Standard #10. !! !!     How it works: Instead of sorting by a single numeric value, the !!     UCA uses a multi-level approach to determine a sort key for each !!     string. The algorithm takes into account the specific rules (or !!     \"tailorings\") of a given language or locale, which are defined in !!     the Common Locale Data Repository (CLDR). !! !!     Multi-level sorting: The UCA uses a hierarchy of weights for each !!     character: !! !!         Primary: Compares the base letter, ignoring case and accents. This !!         groups all versions of \"a\" (a, √°, A, √Å) together. !! !!         Secondary: Compares accents and diacritics. This establishes the !!         order for different versions of the same base letter (e.g., o, !!         √≥, √¥). !! !!         Tertiary: Compares case differences (uppercase vs. lowercase). !! !!         Quaternary: Deals with other special features, such as handling !!         punctuation. !! !!     Locale-specific rules: The UCA can apply different rules based on !!     a user's location. For example: !! !!         In German phonebooks, umlauted letters (√§) are often sorted as !!         if they were ae. In other contexts, they are sorted with their !!         base letter (a). !! !!         The correct sorting order for Chinese characters can be based !!         on pronunciation (Pinyin) or stroke count, depending on the !!         dictionary or region. !! !! How to choose a sorting method !! !!     Use binary sorting for performance when linguistic order doesn't !!     matter. This is fine for internal data processing where you just !!     need a consistent, quick sort. !! !!     Use the UCA for user-facing applications where culturally appropriate !!     sorting is critical. If your application supports multiple languages, !!     you must use a language-sensitive collator to provide the sorting !!     users will expect. Most modern programming languages and databases !!     have built-in libraries that implement the Unicode Collation !!     Algorithm. !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !> !!##NAME !!     SORT(3f) - [M_unicode:SORT] indexed hybrid quicksort of !!     an array !!     (LICENSE:MIT) !! !!##SYNOPSIS !! !! !!       subroutine sort(data,index) !! !!           type(unicode_type),intent(in) :: data(:) !!           integer,intent(out)           :: indx(size(data)) !! !!##DESCRIPTION !!    A rank hybrid quicksort. The data is not moved. An integer array is !!    generated instead with values that are indices to the sorted order !!    of the data. This requires a second array the size of the input !!    array, which for large arrays would require a significant amount of !!    memory. One major advantage of this method is that the indices can !!    be used to access an entire user-defined type in sorted order. This !!    makes this seemingly simple sort procedure usable with the vast !!    majority of user-defined types. or other correlated data. !! !!##BACKGROUND !!     From Leonard J. Moss of SLAC: !! !!     Here's a hybrid QuickSort I wrote a number of years ago. It's based !!     on suggestions in Knuth, Volume 3, and performs much better than a !!     pure QuickSort on short or partially ordered input arrays. !! !!     This routine performs an in-memory sort of the first N elements of !!     array DATA, returning into array INDEX the indices of elements of !!     DATA arranged in ascending order. Thus, !! !!        DATA(INDX(1)) will be the smallest number in array DATA; !!        DATA(INDX(N)) will be the largest number in DATA. !! !!     The original data is not physically rearranged. The original order !!     of equal input values is not necessarily preserved. !! !!     sort(3f) uses a hybrid QuickSort algorithm, based on several !!     suggestions in Knuth, Volume 3, Section 5.2.2. In particular, the !!     \"pivot key\" [my term] for dividing each subsequence is chosen to be !!     the median of the first, last, and middle values of the subsequence; !!     and the QuickSort is cut off when a subsequence has 9 or fewer !!     elements, and a straight insertion sort of the entire array is done !!     at the end. The result is comparable to a pure insertion sort for !!     very short arrays, and very fast for very large arrays (of order 12 !!     micro-sec/element on the 3081K for arrays of 10K elements). It is !!     also not subject to the poor performance of the pure QuickSort on !!     partially ordered data. !! !!     Complex values are sorted by the magnitude of sqrt(r**2+i**2). !! !!     o Created: sortrx(3f): 15 Jul 1986, Len Moss !!     o saved from url=(0044)http://www.fortran.com/fortran/quick_sort2.f !!     o changed to update syntax from F77 style; John S. Urban 20161021 !!     o generalized from only real values to include other intrinsic types; !!       John S. Urban 20210110 !!     o type(unicode_type) version JSU 2025-09-20. See M_sort for other types. !! !!##EXAMPLES !! !! !!   Sample usage: !! !!    program demo_sort !!    use iso_fortran_env, only : stdout => output_unit !!    use M_unicode,       only : sort, unicode_type, assignment(=) !!    use M_unicode,       only : ut=>unicode_type, write(formatted) !!    use M_unicode,       only : ch=>character !!    implicit none !!    character(len=*),parameter :: g='(*(g0,1x))' !!    integer,parameter          :: isz=4 !!    type(unicode_type)         :: rr(isz) !!    integer                    :: ii(isz) !!    integer                    :: i !!       ! !!       write(stdout,g)'sort array with sort(3f)' !!       rr=[ & !!        ut(\"the\"),   & !!        ut(\"quick\"), & !!        ut(\"brown\"), & !!        ut(\"fox\") ] !!       ! !!       write(stdout,g)'original order' !!       write(stdout,g)ch(rr) !!       ! !!       call sort(rr,ii) !!       ! !!       write(stdout,g)'sorted order' !!       ! convert to character !!       do i=1,size(rr) !!          write(stdout,'(i3.3,1x,a)')i,rr(ii(i))%character() !!       enddo !!       ! !!       write(stdout,g)'reorder original' !!       rr=rr(ii) !!       write(stdout,g)ch(rr) !!    end program demo_sort !! !!   Results: !! !!    > sort array with sort(3f) !!    > original order !!    > the quick brown fox !!    > sorted order !!    > 001 brown !!    > 002 fox !!    > 003 quick !!    > 004 the !!    > reorder original !!    > brown fox quick the !!##AUTHOR !!     John S. Urban !! !!##LICENSE !!     MIT subroutine sort_quick_rx ( data , indx ) ! ident_4=\"@(#) M_unicode sort_quick_rx(3f) indexed hybrid quicksort of a type(unicode_type) array\" type ( unicode_type ), intent ( in ) :: data (:) integer ( kind = int32 ), intent ( out ) :: indx (:) type ( unicode_type ) :: datap integer ( kind = int32 ) :: n integer ( kind = int32 ) :: lstk ( 31 ), rstk ( 31 ), istk integer ( kind = int32 ) :: l , r , i , j , p , indexp , indext !  QuickSort Cutoff ! !  Quit QuickSort-ing when a subsequence contains M or fewer elements and finish off at end with straight insertion sort. !  According to Knuth, V.3, the optimum value of M is around 9. integer , parameter :: M = 9 !=================================================================================================================================== n = size ( data ) if ( size ( indx ). lt . n ) then ! if index is not big enough, only sort part of the data write ( * , * ) '*sort_quick_rx* ERROR: insufficient space to store index data' n = size ( indx ) endif !=================================================================================================================================== !  Make initial guess for INDEX do i = 1 , n indx ( i ) = i enddo !  If array is short go directly to the straight insertion sort, else execute a QuickSort if ( N . gt . M ) then !============================================================================================================================= !  QuickSort ! !  The \"Qn:\"s correspond roughly to steps in Algorithm Q, Knuth, V.3, PP.116-117, modified to select the median !  of the first, last, and middle elements as the \"pivot key\" (in Knuth's notation, \"K\"). Also modified to leave !  data in place and produce an INDEX array. To simplify comments, let DATA[I]=DATA(INDX(I)). ! Q1: Initialize istk = 0 l = 1 r = n !============================================================================================================================= TOP : do ! Q2: Sort the subsequence DATA[L]..DATA[R]. ! !  At this point, DATA[l] <= DATA[m] <= DATA[r] for all l < L, r > R, and L <= m <= R. !  (First time through, there is no DATA for l < L or r > R.) i = l j = r ! Q2.5: Select pivot key ! !  Let the pivot, P, be the midpoint of this subsequence, P=(L+R)/2; then rearrange INDX(L), INDX(P), and INDX(R) !  so the corresponding DATA values are in increasing order. The pivot key, DATAP, is then DATA[P]. p = ( l + r ) / 2 indexp = indx ( p ) datap = data ( indexp ) if ( data ( indx ( l )) . gt . datap ) then indx ( p ) = indx ( l ) indx ( l ) = indexp indexp = indx ( p ) datap = data ( indexp ) endif if ( datap . gt . data ( indx ( r ))) then if ( data ( indx ( l )) . gt . data ( indx ( r ))) then indx ( p ) = indx ( l ) indx ( l ) = indx ( r ) else indx ( p ) = indx ( r ) endif indx ( r ) = indexp indexp = indx ( p ) datap = data ( indexp ) endif !  Now we swap values between the right and left sides and/or move DATAP until all smaller values are on the left and all !  larger values are on the right. Neither the left or right side will be internally ordered yet; however, DATAP will be !  in its final position. Q3 : do ! Q3: Search for datum on left >= DATAP !   At this point, DATA[L] <= DATAP. We can therefore start scanning up from L, looking for a value >= DATAP !   (this scan is guaranteed to terminate since we initially placed DATAP near the middle of the subsequence). I = I + 1 if ( data ( indx ( i )). lt . datap ) then cycle Q3 endif !----------------------------------------------------------------------------------------------------------------------- ! Q4: Search for datum on right <= DATAP ! !   At this point, DATA[R] >= DATAP. We can therefore start scanning down from R, looking for a value <= DATAP !   (this scan is guaranteed to terminate since we initially placed DATAP near the middle of the subsequence). Q4 : do j = j - 1 if ( data ( indx ( j )). le . datap ) then exit Q4 endif enddo Q4 !----------------------------------------------------------------------------------------------------------------------- ! Q5: Have the two scans collided? if ( i . lt . j ) then ! Q6: No, interchange DATA[I] <--> DATA[J] and continue indext = indx ( i ) indx ( i ) = indx ( j ) indx ( j ) = indext cycle Q3 else ! Q7: Yes, select next subsequence to sort !   At this point, I >= J and DATA[l] <= DATA[I] == DATAP <= DATA[r], for all L <= l < I and J < r <= R. !   If both subsequences are more than M elements long, push the longer one on the stack !   and go back to QuickSort the shorter; if only one is more than M elements long, go back and QuickSort it; !   otherwise, pop a subsequence off the stack and QuickSort it. if ( r - j . ge . i - l . and . i - l . gt . m ) then istk = istk + 1 lstk ( istk ) = j + 1 rstk ( istk ) = r r = i - 1 elseif ( i - l . gt . r - j . and . r - j . gt . m ) then istk = istk + 1 lstk ( istk ) = l rstk ( istk ) = i - 1 l = j + 1 elseif ( r - j . gt . m ) then l = j + 1 elseif ( i - l . gt . m ) then r = i - 1 else ! Q8: Pop the stack, or terminate QuickSort if empty if ( istk . lt . 1 ) then exit TOP endif l = lstk ( istk ) r = rstk ( istk ) istk = istk - 1 endif cycle TOP endif ! never get here, as cycle Q3 or cycle TOP enddo Q3 exit TOP enddo TOP endif !=================================================================================================================================== ! Q9: Straight Insertion sort do i = 2 , n if ( data ( indx ( i - 1 )) . gt . data ( indx ( i ))) then indexp = indx ( i ) datap = data ( indexp ) p = i - 1 INNER : do indx ( p + 1 ) = indx ( p ) p = p - 1 if ( p . le . 0 ) then exit INNER endif if ( data ( indx ( p )). le . datap ) then exit INNER endif enddo INNER indx ( p + 1 ) = indexp endif enddo !=================================================================================================================================== !     All done end subroutine sort_quick_rx !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== impure elemental function reverse ( string ) result ( rev ) ! ident_5=\"@(#) M_unicode reverse(3f) Return a string reversed\" type ( unicode_type ), intent ( in ) :: string ! string to reverse type ( unicode_type ) :: rev ! return value (reversed string) rev = string % sub ( len ( string ), 1 , - 1 ) end function reverse !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!     REPLACE(3f) - [M_unicode:EDITING] function replaces one !!     substring for another in string !!     (LICENSE:MIT) !! !!##SYNOPSIS !! !! !!  syntax: !! !!       function replace(target,old,new, & !!        & occurrence, & !!        & repeat, & !!        & ignorecase, & !!        & ierr,back) result (newline) !!          or !!       function replace(target,start,end,new) result newline !! !!       type(unicode_type)|character(len=*),intent(in) :: target !! !!       type(unicode_type)|character(len=*),intent(in) :: old !!       type(unicode_type)|character(len=*),intent(in) :: new !!           or !!       type(unicode_type)|character(len=*),intent(in) :: new !!       integer, intent(in) :: start !!       integer, intent(in) :: end !! !!       integer,intent(in),optional            :: occurrence !!       integer,intent(in),optional            :: repeat !!       logical,intent(in),optional            :: ignorecase !!       integer,intent(out),optional           :: changes !!       logical,intent(in),optional            :: back !!       character(len=:),allocatable           :: newline !! !!##CHARACTERISTICS !!   + TARGET,OLD and NEW may be a string or a character variable. !! !!##DESCRIPTION !!     Replace old substring with new value in string. Either a !!     old and new string is specified, or a new string and a !!     column range indicating the position of the text to replace !!     is specified. !! !!##OPTIONS !!      target      input line to be changed !!      old         old substring to replace !!      new         new substring !!      start       starting column of text to replace !!      end         ending column of text to replace !! !!     KEYWORD REQUIRED !!      occurrence  if present, start changing at the Nth occurrence of the !!                  OLD string. !!      repeat      number of replacements to perform. Defaults to a global !!                  replacement. !!      ignorecase  whether to ignore ASCII case or not. Defaults !!                  to .false. . !!      back        if true start replacing moving from the right end of the !!                  string moving left instead of from the left to the right. !!##RETURNS !!      newline     allocatable string returned !!      changes     count of changes made. !! !!##EXAMPLES !! !! !!   Sample Program: !! !!    program demo_replace !!    use M_unicode, only : ut=>unicode_type !!    use M_unicode, only : unicode_type !!    use M_unicode, only : character, replace !!    use M_unicode, only : write(formatted) !!    implicit none !!    type(unicode_type) :: line !!    ! !!    write(*,'(DT)') & !!    & replace(ut('Xis is Xe string'),ut('X'),ut('th') ) !!    write(*,'(DT)') & !!    & replace(ut('Xis is xe string'),ut('x'),ut('th'),ignorecase=.true.) !!    write(*,'(DT)') & !!    & replace(ut('Xis is xe string'),ut('X'),ut('th'),ignorecase=.false.) !!    ! !!    ! a null old substring means \"at beginning of line\" !!    write(*,'(DT)') & !!    & replace(ut('my line of text'),ut(''),ut('BEFORE:')) !!    ! !!    ! a null new string deletes occurrences of the old substring !!    write(*,'(DT)') replace(ut('I wonder i ii iii'),ut('i'),ut('')) !!    ! !!    ! Examples of the use of RANGE !!    ! !!    line=replace(ut('aaaaaaaaa'),ut('a'),ut('A'),occurrence=1,repeat=1) !!    write(*,*)'replace first a with A ['//line%character()//']' !!    ! !!    line=replace(ut('aaaaaaaaa'),ut('a'),ut('A'),occurrence=3,repeat=3) !!    write(*,*)'replace a with A for 3rd to 5th occurrence [' & !!    & //line%character()//']' !!    ! !!    line=replace(ut('ababababa'),ut('a'),ut(''),occurrence=3,repeat=3) !!    write(*,*)'replace a with null instances 3 to 5 ['// & !!    & line%character()//']' !!    ! !!    line=replace( & !!     & ut('a b ab baaa aaaa aa aa a a a aa aaaaaa'),& !!     & ut('aa'),ut('CCCC'),occurrence=-1,repeat=1) !!    write(*,*)'replace lastaa with CCCC ['//line%character()//']' !!    ! !!    write(*,'(DT)')replace(ut('myf90stuff.f90.f90'),& !!    & ut('f90'),ut('for'),occurrence=-1,repeat=1) !!    write(*,'(DT)')replace(ut('myf90stuff.f90.f90'),& !!    & ut('f90'),ut('for'),occurrence=-2,repeat=2) !!    ! !!    end program demo_replace !! !!   Results: !! !!    > this is the string !!    > this is the string !!    > this is xe string !!    > BEFORE:my line of text !!    > I wonder !!    >  replace first a with A [Aaaaaaaaa] !!    >  replace a with A for 3rd to 5th occurrence [aaAAAaaaa] !!    >  replace a with null instances 3 to 5 [ababbb] !!    >  replace lastaa with CCCC [a b ab baaa aaaa aa aa a a a aa aaaaCCCC] !!    > myf90stuff.f90.for !!    > myforstuff.for.f90 !! !!##AUTHOR !!     John S. Urban !!##LICENSE !!    MIT function replace_uuu ( target , old , new , force_ , occurrence , repeat , ignorecase , changes , back ) result ( newline ) ! ident_6=\"@(#) M_unicode replace(3f) replace one substring for another in string\" ! parameters type ( unicode_type ), intent ( in ) :: target ! input line to be changed type ( unicode_type ), intent ( in ) :: old ! old substring to replace type ( unicode_type ), intent ( in ) :: new ! new substring type ( force_keywords ), optional , intent ( in ) :: force_ integer , intent ( in ), optional :: occurrence ! Nth occurrence of OLD string to start replacement at integer , intent ( in ), optional :: repeat ! how many replacements logical , intent ( in ), optional :: ignorecase integer , intent ( out ), optional :: changes ! number of changes made logical , intent ( in ), optional :: back ! returns type ( unicode_type ) :: newline ! output string ! local type ( unicode_type ) :: new_local , old_local , old_local_for_comparison integer :: icount , ichange integer :: original_input_length integer :: len_old , len_new integer :: ladd integer :: left_margin , right_margin integer :: ind integer :: ic integer :: ichr integer :: range_local ( 2 ) integer :: ilen_temp type ( unicode_type ) :: target_for_comparison ! input line to be changed logical :: ignorecase_local logical :: flip type ( unicode_type ) :: target_local ! input line to be changed flip = . false . ignorecase_local = . false . original_input_length = len_trim ( target ) ! get non-blank length of input line old_local = old new_local = new if ( present ( ignorecase )) then ignorecase_local = ignorecase else ignorecase_local = . false . endif if ( present ( occurrence )) then range_local ( 1 ) = abs ( occurrence ) else range_local ( 1 ) = 1 endif if ( present ( repeat )) then range_local ( 2 ) = range_local ( 1 ) + repeat - 1 else range_local ( 2 ) = original_input_length endif if ( ignorecase_local ) then target_for_comparison = lower ( target ) old_local_for_comparison = lower ( old_local ) else target_for_comparison = target old_local_for_comparison = old_local endif if ( present ( back )) then flip = back endif if ( present ( occurrence )) then if ( occurrence < 0 ) then flip = . true . target_for_comparison = reverse ( target_for_comparison ) target_local = reverse ( target ) old_local_for_comparison = reverse ( old_local_for_comparison ) old_local = reverse ( old_local ) new_local = reverse ( new_local ) else target_local = target endif else target_local = target endif icount = 0 ! initialize error flag/change count ichange = 0 ! initialize error flag/change count len_old = len ( old_local ) ! length of old substring to be replaced len_new = len ( new_local ) ! length of new substring to replace old substring left_margin = 1 ! left_margin is left margin of window to change right_margin = len ( target ) ! right_margin is right margin of window to change newline = '' ! begin with a blank line as output string if ( len_old == 0 ) then ! c//new/ means insert new at beginning of line (or left margin) ichr = len_new + original_input_length if ( len_new > 0 ) then newline = new_local % sub ( 1 , len_new ). cat . target_local % sub ( left_margin , original_input_length ) else newline = target_local % sub ( left_margin , original_input_length ) endif ichange = 1 ! made one change. actually, c/// should maybe return 0 if ( present ( changes )) changes = ichange if ( flip ) newline = reverse ( newline ) return endif ichr = left_margin ! place to put characters into output string ic = left_margin ! place looking at in input string loop : do ! try finding start of OLD in remaining part of input in change window ilen_temp = len ( target_for_comparison ) ind = index ( target_for_comparison % sub ( ic , ilen_temp ), old_local_for_comparison % sub ( 1 , len_old )) + ic - 1 if ( ind == ic - 1. or . ind > right_margin ) then ! did not find old string or found old string past edit window exit loop ! no more changes left to make endif icount = icount + 1 ! found an old string to change, so increment count of change candidates if ( ind > ic ) then ! if found old string past at current position in input string copy unchanged ladd = ind - ic ! find length of character range to copy as-is from input to output newline = newline % sub ( 1 , ichr - 1 ). cat . target_local % sub ( ic , ind - 1 ) ichr = ichr + ladd endif if ( icount >= range_local ( 1 ). and . icount <= range_local ( 2 )) then ! check if this is an instance to change or keep ichange = ichange + 1 if ( len_new /= 0 ) then ! put in new string newline = newline % sub ( 1 , ichr - 1 ). cat . new_local % sub ( 1 , len_new ) ichr = ichr + len_new endif else if ( len_old /= 0 ) then ! put in copy of old string newline = newline % sub ( 1 , ichr - 1 ). cat . old_local % sub ( 1 , len_old ) ichr = ichr + len_old endif endif ic = ind + len_old enddo loop select case ( ichange ) case ( 0 ) ! there were no changes made to the window newline = target_local ! if no changes made output should be input case default if ( ic <= len ( target )) then ! if there is more after last change on original line add it newline = newline % sub ( 1 , ichr - 1 ). cat . target_local % sub ( ic , max ( ic , original_input_length )) endif end select if ( present ( changes )) changes = ichange if ( flip ) newline = reverse ( newline ) end function replace_uuu !=================================================================================================================================== function replace_uua ( target , old , new , force_ , occurrence , repeat , ignorecase , changes , back ) result ( newline ) type ( unicode_type ), intent ( in ) :: target type ( unicode_type ), intent ( in ) :: old character ( len =* ), intent ( in ) :: new type ( force_keywords ), optional , intent ( in ) :: force_ integer , intent ( in ), optional :: occurrence , repeat logical , intent ( in ), optional :: ignorecase integer , intent ( out ), optional :: changes logical , intent ( in ), optional :: back type ( unicode_type ) :: newline newline = replace_uuu ( target , old , unicode_type ( new ), force_ , occurrence , repeat , ignorecase , changes , back ) end function replace_uua !=================================================================================================================================== function replace_uau ( target , old , new , force_ , occurrence , repeat , ignorecase , changes , back ) result ( newline ) type ( unicode_type ), intent ( in ) :: target character ( len =* ), intent ( in ) :: old type ( unicode_type ), intent ( in ) :: new type ( force_keywords ), optional , intent ( in ) :: force_ integer , intent ( in ), optional :: occurrence , repeat logical , intent ( in ), optional :: ignorecase integer , intent ( out ), optional :: changes logical , intent ( in ), optional :: back type ( unicode_type ) :: newline newline = replace_uuu ( target , unicode_type ( old ), new , force_ , occurrence , repeat , ignorecase , changes , back ) end function replace_uau !=================================================================================================================================== function replace_uaa ( target , old , new , force_ , occurrence , repeat , ignorecase , changes , back ) result ( newline ) type ( unicode_type ), intent ( in ) :: target character ( len =* ), intent ( in ) :: old character ( len =* ), intent ( in ) :: new type ( force_keywords ), optional , intent ( in ) :: force_ integer , intent ( in ), optional :: occurrence , repeat logical , intent ( in ), optional :: ignorecase integer , intent ( out ), optional :: changes logical , intent ( in ), optional :: back type ( unicode_type ) :: newline newline = replace_uuu ( target , unicode_type ( old ), unicode_type ( new ), force_ , occurrence , repeat , ignorecase , changes , back ) end function replace_uaa !=================================================================================================================================== function replace_aaa ( target , old , new , force_ , occurrence , repeat , ignorecase , changes , back ) result ( newline ) character ( len =* ), intent ( in ) :: target character ( len =* ), intent ( in ) :: old character ( len =* ), intent ( in ) :: new type ( force_keywords ), optional , intent ( in ) :: force_ integer , intent ( in ), optional :: occurrence , repeat logical , intent ( in ), optional :: ignorecase integer , intent ( out ), optional :: changes logical , intent ( in ), optional :: back type ( unicode_type ) :: newline newline = replace_uuu ( unicode_type ( target ), unicode_type ( old ), unicode_type ( new ), force_ , occurrence , repeat , ignorecase , changes , back ) end function replace_aaa !=================================================================================================================================== function replace_aua ( target , old , new , force_ , occurrence , repeat , ignorecase , changes , back ) result ( newline ) character ( len =* ), intent ( in ) :: target type ( unicode_type ), intent ( in ) :: old character ( len =* ), intent ( in ) :: new type ( force_keywords ), optional , intent ( in ) :: force_ integer , intent ( in ), optional :: occurrence , repeat logical , intent ( in ), optional :: ignorecase integer , intent ( out ), optional :: changes logical , intent ( in ), optional :: back type ( unicode_type ) :: newline newline = replace_uuu ( unicode_type ( target ), old , unicode_type ( new ), force_ , occurrence , repeat , ignorecase , changes , back ) end function replace_aua !=================================================================================================================================== function replace_aau ( target , old , new , force_ , occurrence , repeat , ignorecase , changes , back ) result ( newline ) character ( len =* ), intent ( in ) :: target character ( len =* ), intent ( in ) :: old type ( unicode_type ), intent ( in ) :: new type ( force_keywords ), optional , intent ( in ) :: force_ integer , intent ( in ), optional :: occurrence , repeat logical , intent ( in ), optional :: ignorecase integer , intent ( out ), optional :: changes logical , intent ( in ), optional :: back type ( unicode_type ) :: newline newline = replace_uuu ( unicode_type ( target ), unicode_type ( old ), new , force_ , occurrence , repeat , ignorecase , changes , back ) end function replace_aau !=================================================================================================================================== function replace_auu ( target , old , new , force_ , occurrence , repeat , ignorecase , changes , back ) result ( newline ) character ( len =* ), intent ( in ) :: target type ( unicode_type ), intent ( in ) :: old type ( unicode_type ), intent ( in ) :: new type ( force_keywords ), optional , intent ( in ) :: force_ integer , intent ( in ), optional :: occurrence , repeat logical , intent ( in ), optional :: ignorecase integer , intent ( out ), optional :: changes logical , intent ( in ), optional :: back type ( unicode_type ) :: newline newline = replace_uuu ( unicode_type ( target ), old , new , force_ , occurrence , repeat , ignorecase , changes , back ) end function replace_auu !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!     JOIN(3f) - [M_unicode:EDITING] append CHARACTER variable array into !!     a single CHARACTER variable with specified separator !!     (LICENSE:MIT) !! !!##SYNOPSIS !! !! !!     impure function join(str,sep,clip) result (string) !! !!      type(unicode_type),intent(in)          :: str(:) !!      type(unicode_type),intent(in),optional :: sep !!      logical,intent(in),optional            :: clip !!      type(unicode_type),allocatable         :: string !! !!##DESCRIPTION !!    JOIN(3f) appends the elements of a CHARACTER array into a single !!    CHARACTER variable, with elements 1 to N joined from left to right. !!    By default each element is trimmed of trailing spaces and the !!    default separator is a null string. !! !!##OPTIONS !!       STR     array of variables to be joined !!       SEP     separator string to place between each variable. defaults !!               to a null string. !!       CLIP    option to trim each element of STR of trailing and leading !!               spaces. Defaults to .TRUE. !! !!##RETURNS !!       STRING  CHARACTER variable composed of all of the elements of STR() !!               appended together with the optional separator SEP placed !!               between the elements. !! !!##EXAMPLES !! !! !!   Sample program: !! !!    program demo_join !!    use M_unicode,  only : join, ut=>unicode_type, ch=>character, assignment(=) !!    !use M_unicode, only : write(formatted) !!    implicit none !!    character(len=*),parameter    :: w='((g0,/,g0))' !!    !character(len=*),parameter   :: v='((g0,/,DT))' !!    character(len=20),allocatable :: proverb(:) !!    type(ut),allocatable          :: s(:) !!    type(ut),allocatable          :: sep !!      ! !!      proverb=[ character(len=13) :: & !!        & ' United'       ,& !!        & '  we'          ,& !!        & '   stand,'     ,& !!        & '    divided'   ,& !!        & '     we fall.' ] !!      ! !!      if(allocated(s))deallocate(s) !!      allocate(s(size(proverb))) ! avoid GNU Fortran (GCC) 16.0.0 bug !!      s=proverb !!      write(*,w) 'SIMPLE JOIN:         ', ch( join(s)                ) !!      write(*,w) 'JOIN WITH SEPARATOR: ', ch( join(s,sep=ut(' '))    ) !!      write(*,w) 'CUSTOM SEPARATOR:    ', ch( join(s,sep=ut('<-->')) ) !!      write(*,w) 'NO TRIMMING:         ', ch( join(s,clip=.false.)   ) !!      ! !!      sep=ut() !!      write(*,w) 'SIMPLE JOIN:         ', ch(sep%join(s) ) !!      sep=' ' !!      write(*,w) 'JOIN WITH SEPARATOR: ', ch(sep%join(s) ) !!      sep='<-->' !!      write(*,w) 'CUSTOM SEPARATOR:    ', ch(sep%join(s) ) !!      sep='' !!      write(*,w) 'NO TRIMMING:         ', ch(sep%join(s,clip=.false.) ) !!    end program demo_join !! !!  Results: !! !!   > SIMPLE JOIN: !!   > Unitedwestand,dividedwe fall. !!   > JOIN WITH SEPARATOR: !!   > United we stand, divided we fall. !!   > CUSTOM SEPARATOR: !!   > United==>we==>stand,==>divided==>we fall. !!   > NO TRIMMING: !!   >  United         we             stand,         divided        we fall. !!   > SIMPLE JOIN: !!   > Unitedwestand,dividedwe fall. !!   > JOIN WITH SEPARATOR: !!   > United we stand, divided we fall. !!   > CUSTOM SEPARATOR: !!   > United==>we==>stand,==>divided==>we fall. !!   > NO TRIMMING: !!   >  United         we             stand,         divided        we fall. !! !!##AUTHOR !!     John S. Urban !! !!##LICENSE !!     MIT impure function join ( str , sep , clip ) result ( string ) ! ident_7=\"@(#) M_unicode join(3f) merge string array into a single string value adding specified separator\" type ( unicode_type ), intent ( in ) :: str (:) type ( unicode_type ), intent ( in ), optional :: sep logical , intent ( in ), optional :: clip type ( unicode_type ) :: temp type ( unicode_type ) :: sep_local type ( unicode_type ) :: string logical :: clip_local integer :: i if ( present ( sep )) then ; sep_local = sep ; else ; sep_local = '' ; endif if ( present ( clip )) then ; clip_local = clip ; else ; clip_local = . true . ; endif string = '' if ( size ( str ) /= 0 ) then do i = 1 , size ( str ) - 1 if ( clip_local ) then temp = adjustl ( str ( i )) ! avoid gfortran GNU Fortran (GCC) 16.0.0 20250727 (experimental) bug !gfortran!string=string//adjustl(trim(str))//sep_local ! produces no left adjust in gfortran as the moment !ifx!string=string//trim(temp)//sep_local temp = trim ( temp ) string = [ string % codes , temp % codes , sep_local % codes ] else !string=string//str(i)//sep_local string = [ string % codes , str ( i )% codes , sep_local % codes ] endif enddo if ( clip_local ) then temp = adjustl ( str ( i )) !string=[string//trim(temp) temp = trim ( temp ) string = [ string % codes , temp % codes ] else !string=string//str(i) string = [ string % codes , str ( i )% codes ] endif endif end function join !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!  UPPER(3f) - [M_unicode:CASE] changes a string to uppercase !!  (LICENSE:MIT) !! !!##SYNOPSIS !! !! !!     elemental pure function upper(str) result (string) !! !!      character(*), intent(in)    :: str !!      character(len(str))         :: string  ! output string !! !!##DESCRIPTION !!    upper(string) returns a copy of the input string with all characters !!    converted to uppercase, assuming Unicode character sets are being used. !! !!##OPTIONS !!     str    string to convert to uppercase !! !!##RETURNS !!     upper  copy of the input string with all characters converted to !!            uppercase. !! !!##TRIVIA !!     The terms \"uppercase\" and \"lowercase\" date back to the early days of !!     the mechanical printing press. Individual metal alloy casts of each !!     needed letter, or punctuation symbol, were meticulously added to a !!     press block, by hand, before rolling out copies of a page. These !!     metal casts were stored and organized in wooden cases. The more !!     often needed miniscule letters were placed closer to hand, in the !!     lower cases of the work bench. The less often needed, capitalized, !!     majuscule letters, ended up in the harder to reach upper cases. !! !!##EXAMPLES !! !! !!   Sample program: !! !!    program demo_upper !!    use iso_fortran_env, only : stdout => output_unit !!    use M_unicode,       only : upper, unicode_type, assignment(=) !!    use M_unicode,       only : ut => unicode_type, operator(==) !!    implicit none !!    character(len=*),parameter :: g='(*(g0))' !!    type(unicode_type)         :: pangram !!    type(unicode_type)         :: diacritics !!    type(unicode_type)         :: expected !!       ! !!       ! a sentence containing every letter of the English alphabet !!       ! often used to test telegraphs since the advent of the 19th century !!       ! and as an exercise repetitively generated in typing classes !!       pangram  = \"The quick brown fox jumps over the lazy dog.\" !!       expected = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG.\" !!       call test(pangram,expected) !!       ! !!       ! Slovak pangram !!       pangram    = 'Vyp√§t√° dc√©ra gr√≥fa Maxwella s IQ ni≈æ≈°√≠m ako & !!       &k√¥≈à n√∫ti ƒçeƒæaƒè hr√Ωz≈• h≈ïbu jabƒ∫k.' !!       expected   = 'VYP√ÑT√Å DC√âRA GR√ìFA MAXWELLA S IQ NI≈Ω≈†√çM AKO & !!       &K√î≈á N√öTI ƒåEƒΩAƒé HR√ùZ≈§ H≈îBU JABƒπK.' !!       call test(pangram,expected) !!       ! !!       ! contains each special Czech letter with diacritics exactly once !!       print g,'(\"A horse that was too yellow-ish moaned devilish odes\")' !!       diacritics = 'P≈ô√≠li≈° ≈ælu≈•ouƒçk√Ω k≈Ø≈à √∫pƒõl ƒè√°belsk√© √≥dy.' !!       expected   = 'P≈ò√çLI≈† ≈ΩLU≈§OUƒåK√ù K≈Æ≈á √öPƒöL ƒé√ÅBELSK√â √ìDY.' !!       call test(diacritics,expected) !!    contains !!    subroutine test(in,expected) !!    type(unicode_type),intent(in) :: in !!    type(unicode_type),intent(in) :: expected !!    type(unicode_type)            :: uppercase !!    character(len=*),parameter    :: nl=new_line('A') !!       write(stdout,g)in%character() !!       uppercase=upper(in) !!       write(stdout,g)uppercase%character() !!       write(stdout,g)merge('PASSED','FAILED',uppercase == expected ),nl !!    end subroutine test !!    end program demo_upper !! !!  Expected output !! !!   > The quick brown fox jumps over the lazy dog. !!   > THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG. !!   > PASSED !!   > !!   > Vyp√§t√° dc√©ra gr√≥fa Maxwella s IQ ni≈æ≈°√≠m ako k√¥≈à n√∫ti ... !!   > ƒçeƒæaƒè hr√Ωz≈• h≈ïbu jabƒ∫k. !!   > VYP√ÑT√Å DC√âRA GR√ìFA MAXWELLA S IQ NI≈Ω≈†√çM AKO K√î≈á N√öTI ... !!   > ƒåEƒΩAƒé HR√ùZ≈§ H≈îBU JABƒπK. !!   > PASSED !!   > !!   > (\"A horse that was too yellow-ish moaned devilish odes\") !!   > P≈ô√≠li≈° ≈ælu≈•ouƒçk√Ω k≈Ø≈à √∫pƒõl ƒè√°belsk√© √≥dy. !!   > P≈ò√çLI≈† ≈ΩLU≈§OUƒåK√ù K≈Æ≈á √öPƒöL ƒé√ÅBELSK√â √ìDY. !!   > PASSED !! !!##AUTHOR !!     John S. Urban !! !!##LICENSE !!     MIT elemental pure function upper ( str ) result ( string ) ! ident_8=\"@(#) M_unicode upper(3f) returns an uppercase string\" type ( unicode_type ), intent ( in ) :: str ! input string to convert to all uppercase type ( unicode_type ) :: string ! output string that contains no miniscule letters integer :: i ! loop counter integer :: pos integer , parameter :: ade_a = iachar ( 'a' ), ade_z = iachar ( 'z' ) integer , parameter :: diff = iachar ( 'A' ) - iachar ( 'a' ) string = str do i = 1 , len ( str ) ! step thru each letter in the string in specified range select case ( str % codes ( i )) case ( ade_a : ade_z ) string % codes ( i ) = str % codes ( i ) + diff case default pos = binary_search ( low_to_up (:, 1 ), str % codes ( i )) if ( pos > 0 ) then string % codes ( i ) = low_to_up ( pos , 2 ) endif end select enddo if ( len ( str ). eq . 0 ) string = str end function upper !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!     LOWER(3f) - [M_unicode:CASE] changes a string to lowercase over !!     specified range !!     (LICENSE:MIT) !! !!##SYNOPSIS !! !! !!     elemental pure function lower(str) result (string) !! !!      character(*), intent(in) :: str !!      character(len(str))      :: string  ! output string !! !!##DESCRIPTION !!       lower(str) returns a copy of the input string with all !!       characters converted to miniscule (ie. \"lowercase\"). !! !!##OPTIONS !!     str    string to convert to miniscule !! !!##RETURNS !!     lower  copy of the entire input string with all characters converted !!            to miniscule. !! !!##TRIVIA !!    The terms \"uppercase\" and \"lowercase\" date back to the early days !!    of the mechanical printing press. Individual metal alloy casts of !!    each needed letter or punctuation symbol were meticulously added to a !!    press block, by hand, before rolling out copies of a page. These metal !!    casts were stored and organized in wooden cases. The more-often-needed !!    miniscule letters were placed closer to hand, in the lower cases of !!    the work bench. The less often needed, capitalized, majuscule letters, !!    ended up in the harder to reach upper cases. !! !!##EXAMPLES !! !! !!  Sample program: !! !!    program demo_lower !!    use iso_fortran_env, only : stdout => output_unit !!    use M_unicode,       only : lower, unicode_type, assignment(=), trim !!    use M_unicode,       only : ut => unicode_type, operator(==) !!    implicit none !!    character(len=*),parameter :: g='(*(g0))' !!    type(unicode_type) :: pangram !!    type(unicode_type) :: diacritics !!    type(unicode_type) :: expected !!      ! !!      ! a sentence containing every letter of the English alphabet !!      pangram=\"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\" !!      expected=\"the quick brown fox jumps over the lazy dog\" !!      call test(pangram,expected) !!      ! !!      ! Slovak pangram !!      PANGRAM    = 'VYP√ÑT√Å DC√âRA GR√ìFA MAXWELLA S IQ NI≈Ω≈†√çM AKO & !!      &K√î≈á N√öTI ƒåEƒΩAƒé HR√ùZ≈§ H≈îBU JABƒπK.' !!      expected   = 'vyp√§t√° dc√©ra gr√≥fa maxwella s iq ni≈æ≈°√≠m ako & !!      &k√¥≈à n√∫ti ƒçeƒæaƒè hr√Ωz≈• h≈ïbu jabƒ∫k.' !!      call test(pangram,expected) !!      ! !!      ! contains each special Czech letter with diacritics exactly once !!      DIACRITICS='P≈ò√çLI≈† ≈ΩLU≈§OUƒåK√ù K≈Æ≈á √öPƒöL ƒé√ÅBELSK√â √ìDY.' !!      expected ='p≈ô√≠li≈° ≈ælu≈•ouƒçk√Ω k≈Ø≈à √∫pƒõl ƒè√°belsk√© √≥dy.' !!      print g,'(\"A horse that was too yellow-ish moaned devilish odes\")' !!      call test(diacritics,expected) !!    contains !!    subroutine test(in,expected) !!    type(unicode_type),intent(in) :: in !!    type(unicode_type),intent(in) :: expected !!    type(unicode_type)            :: lowercase !!    character(len=*),parameter    :: nl=new_line('A') !!        write(stdout,g)in%character() !!        lowercase=lower(in) !!        write(stdout,g)lowercase%character() !!        write(stdout,g)merge('PASSED','FAILED',lowercase == expected ),nl !!    end subroutine test !!    end program demo_lower !! !!   Expected output !! !!    > THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG !!    > the quick brown fox jumps over the lazy dog !!    > PASSED !!    > !!    > VYP√ÑT√Å DC√âRA GR√ìFA MAXWELLA S IQ NI≈Ω≈†√çM AKO K√î≈á N√öTI ... !!    > ƒåEƒΩAƒé HR√ùZ≈§ H≈îBU JABƒπK. !!    > vyp√§t√° dc√©ra gr√≥fa maxwella s iq ni≈æ≈°√≠m ako k√¥≈à n√∫ti ... !!    > ƒçeƒæaƒè hr√Ωz≈• h≈ïbu jabƒ∫k. !!    > PASSED !!    > !!    > (\"A horse that was too yellow-ish moaned devilish odes\") !!    > P≈ò√çLI≈† ≈ΩLU≈§OUƒåK√ù K≈Æ≈á √öPƒöL ƒé√ÅBELSK√â √ìDY. !!    > p≈ô√≠li≈° ≈ælu≈•ouƒçk√Ω k≈Ø≈à √∫pƒõl ƒè√°belsk√© √≥dy. !!    > PASSED !! !!##AUTHOR !!     John S. Urban !! !!##LICENSE !!     MIT elemental pure function lower ( str ) result ( string ) ! ident_9=\"@(#) M_unicode lower(3f) returns a lowercase string\" type ( unicode_type ), intent ( in ) :: str ! input string to convert to all lowercase type ( unicode_type ) :: string ! output string that contains no miniscule letters integer :: i ! loop counter integer :: pos integer , parameter :: ade_a = iachar ( 'A' ), ade_z = iachar ( 'Z' ) integer , parameter :: diff = iachar ( 'A' ) - iachar ( 'a' ) string = str do i = 1 , len ( str ) ! step thru each letter in the string in specified range select case ( str % codes ( i )) case ( ade_a : ade_z ) string % codes ( i ) = str % codes ( i ) - diff case default pos = binary_search ( up_to_low (:, 1 ), str % codes ( i )) if ( pos > 0 ) then string % codes ( i ) = up_to_low ( pos , 2 ) endif end select enddo if ( len ( str ). eq . 0 ) string = str end function lower !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!   SPLIT(3f) - [M_unicode:PARSE] parse a string into tokens, one at a time. !!   (LICENSE:MIT) !! !!##SYNOPSIS !! !!   call split (string, set, pos [, back]) !! !!    type(unicode_type),intent(in) :: string !!    type(unicode_type),intent(in) :: set !!    integer,intent(inout)         :: pos !!    logical,intent(in),optional   :: back !! !!##CHARACTERISTICS !!   + STRING is a scalar character variable !!   + SET is a scalar string variable !! !!##DESCRIPTION !!   Find the extent of consecutive tokens in a string. given a string and !!   a position to start looking for a token return the position of the !!   end of the token. a set of separator characters may be specified as !!   well as the direction of parsing. !! !!   typically consecutive calls are used to parse a string into a set of !!   tokens by stepping through the start and end positions of each token. !! !!##OPTIONS !!   + STRING : the string to search for tokens in. !! !!   + SET : Each character in set is a token delimiter. a sequence of !!     zero or more characters in string delimited by any token delimiter, !!     or the beginning or end of string, comprise a token. thus, two !!     consecutive token delimiters in STRING, or a token delimiter in the !!     first or last character of STRING, indicate a token with zero length. !! !!   + POS : on input, the position from which to start looking for the next !!     separator from. This is typically the first character or the last !!     returned value of POS if searching from left to right (ie. back is !!     absent or .true.) or the last character or the last returned value !!     of POS when searching from right to left (ie. when back is .FALSE.). !! !!     If BACK is present with the value .TRUE., the value of pos shall be !!     in the range 0 < POS <= len(STRING)+1; otherwise it shall be in the !!     range 0 <= POS <= len(STRING). !! !!     So POS on input is typically an end of the string or the position !!     of a separator, probably from a previous call to split but POS on !!     input can be any position in the range 1 <= POS <= len(STRING). if !!     POS points to a non-separator character in the string the call is !!     still valid but it will start searching from the specified position !!     and that will result (somewhat obviously) in the string from POS on !!     input to the returned POS being a partial token. !! !!   + BACK : If BACK is absent or is present with the value .FALSE., POS is !!     assigned the position of the leftmost token delimiter in string !!     whose position is greater than POS, or if there is no such character, !!     it is assigned a value one greater than the length of string. this !!     identifies a token with starting position one greater than the value !!     of POS on invocation, and ending position one less than the value !!     of POS on return. !! !!     If BACK is present with the value .TRUE., POS is assigned the !!     position of the rightmost token delimiter in string whose position !!     is less than POS, or if there is no such character, it is assigned !!     the value zero. This identifies a token with ending position one !!     less than the value of POS on invocation, and starting position one !!     greater than the value of POS  on return. !! !!##EXAMPLE !! !!   sample program: !! !!    program demo_split !!    use iso_fortran_env, only : stdout => output_unit !!    use M_unicode,       only : unicode_type, assignment(=) !!    use M_unicode,       only : split, len, character !!    use M_unicode,       only : ut=>unicode_type !!    implicit none !!    character(len=*),parameter :: g='(*(g0,1x))' !!    type(ut)                   :: proverb !!    type(ut)                   :: delims !!    type(ut),allocatable       :: array(:) !!    integer                    :: first !!    integer                    :: last !!    integer                    :: pos !!    integer                    :: i !!       ! !!       delims= '=|; ' !!       ! !!       proverb=\"M√°s vale p√°jaro en mano, que ciento volando.\" !!       call printwords(proverb) !! !!       ! there really are not spaces between these glyphs !!       array=[ & !!        ut(\"‰∏ÉËª¢„Å≥ÂÖ´Ëµ∑„Åç„ÄÇ\"), & !!        ut(\"Ëª¢„Çì„Åß„ÇÇ„Åæ„ÅüÁ´ã„Å°‰∏ä„Åå„Çã„ÄÇ\"), & !!        ut(\"„Åè„Åò„Åë„Åö„Å´Ââç„ÇíÂêë„ÅÑ„Å¶Ê≠©„ÅÑ„Å¶„ÅÑ„Åì„ÅÜ„ÄÇ\")] !!       call printwords(array) !!       ! !!       write(stdout,g)'OOP' !!       array=proverb%split(ut(' ')) !!       write(stdout,'(*(:\"[\",a,\"]\"))')(character(array(i)),i=1,size(array)) !!    contains !!    impure elemental subroutine printwords(line) !!    type(ut),intent(in) :: line !!       pos = 0 !!       write(stdout,g)line%character(),len(line) !!       do while (pos < len(line)) !!           first = pos + 1 !!           call split (line, delims, pos) !!           last = pos - 1 !!           print g, line%character(first,last),first,last,pos !!       end do !!    end subroutine printwords !!    end program demo_split !! !!   Results: !! !!    > Project is up to date !!    > M√°s vale p√°jaro en mano, que ciento volando. 44 !!    > M√°s 1 3 4 !!    > vale 5 8 9 !!    > p√°jaro 10 15 16 !!    > en 17 18 19 !!    > mano, 20 24 25 !!    > que 26 28 29 !!    > ciento 30 35 36 !!    > volando. 37 44 45 !!    > ‰∏ÉËª¢„Å≥ÂÖ´Ëµ∑„Åç„ÄÇ 7 !!    > ‰∏ÉËª¢„Å≥ÂÖ´Ëµ∑„Åç„ÄÇ 1 7 8 !!    > Ëª¢„Çì„Åß„ÇÇ„Åæ„ÅüÁ´ã„Å°‰∏ä„Åå„Çã„ÄÇ 12 !!    > Ëª¢„Çì„Åß„ÇÇ„Åæ„ÅüÁ´ã„Å°‰∏ä„Åå„Çã„ÄÇ 1 12 13 !!    > „Åè„Åò„Åë„Åö„Å´Ââç„ÇíÂêë„ÅÑ„Å¶Ê≠©„ÅÑ„Å¶„ÅÑ„Åì„ÅÜ„ÄÇ 17 !!    > „Åè„Åò„Åë„Åö„Å´Ââç„ÇíÂêë„ÅÑ„Å¶Ê≠©„ÅÑ„Å¶„ÅÑ„Åì„ÅÜ„ÄÇ 1 17 18 !!    > OOP !!    > [M√°s][vale][p√°jaro][en][mano,][que][ciento][volando.] !! !!##SEE ALSO !!   + tokenize(3) - parse a string into tokens !!   + index(3) - position of a substring within a string !!   + scan(3) - scan a string for the presence of a set of characters !!   + verify(3)  -  position  of a character in a string of characters that does !!     not appear in a given set of characters. !! !!##AUTHOR !!     Milan Curcic, \"milancurcic@hey.com\" !!     John S. Urban -- UTF-8 version !! !!##LICENSE !!     MIT !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!   TOKENIZE(3f) - [M_unicode:PARSE] Parse a string into tokens. !!   (LICENSE:MIT) !! !!##SYNOPSIS !! !!   TOKEN form (returns array of strings) !! !!    subroutine tokenize(string, set, tokens [, separator]) !! !!     type(unicode_type),intent(in) :: string !!     type(unicode_type),intent(in) :: set !!     type(unicode_type),allocatable,intent(out) :: tokens(:) !!     type(unicode_type),allocatable,intent(out),optional :: separator(:) !! !!   ARRAY BOUNDS form (returns arrays defining token positions) !! !!    subroutine tokenize (string, set, first, last) !! !!     type(unicode_type),intent(in) :: string !!     type(unicode_type),intent(in) :: set !!     integer,allocatable,intent(out) :: first(:) !!     integer,allocatable,intent(out) :: last(:) !! !!##CHARACTERISTICS !!   +  STRING ‚Äê a scalar of type string. It is an INTENT(IN) !!      argument. !! !!   +  SET ‚Äê a scalar of type string with the same kind type !!      parameter as STRING. It is an INTENT(IN) argument. !! !!   +  SEPARATOR ‚Äê (optional) shall be of type string. It is an !!      INTENT(OUT)argument. It shall not be a coarray or a coindexed object. !! !!   +  TOKENS ‚Äê of type string. It is an INTENT(OUT) argument. It shall !!      not be a coarray or a coindexed object. !! !!   +  FIRST,LAST ‚Äê an allocatable array of type integer and rank !!      one. It is an INTENT(OUT) argument. It shall not be a coarray or a !!      coindexed object. !! !!##DESCRIPTION !!   TOKENIZE(3) parses a string into tokens. There are two forms of the !!   subroutine TOKENIZE(3). !! !!   +  The token form returns an array with one token per element, !!      all of the same length as the longest token. !! !!   +  The array bounds form returns two integer arrays. One !!      contains the beginning position of the tokens and the other the end !!      positions. !! !!   Since the token form pads all the tokens to the same length the !!   original number of trailing spaces of each token accept for the !!   longest is lost. !! !!   The array bounds form retains information regarding the exact token !!   length even when padded by spaces. !! !!##OPTIONS !!   ‚Ä¢  STRING : The string to parse into tokens. !! !!   +  SET :  Each character in SET is a token delimiter. A !!      sequence of zero or more characters in STRING delimited by any token !!      delimiter, or the beginning or end of STRING, comprise a token. Thus, !!      two consecutive token delimiters in STRING, or a token delimiter !!      in the first or last character of STRING, indicate a token with !!      zero length. !! !!   +  TOKENS : It shall be an allocatable array of rank one with !!      deferred length. It is allocated with the lower bound equal to one !!      and the upper bound equal to the number of tokens in STRING, and !!      with character length equal to the length of the longest token. !! !!      The tokens in STRING are assigned in the order found, as if by !!      intrinsic assignment, to the elements of TOKENS, in array element !!      order. !! !!   +  FIRST : shall be an allocatable array of type integer and rank one. !!      It is an INTENT(OUT) argument. It shall not be a coarray or !!      a coindexed object. !! !!      It is allocated with the lower bound equal to one and the upper !!      bound equal to the number of tokens in STRING. Each element is !!      assigned, in array element order, the starting position of each !!      token in STRING, in the order found. !! !!      If a token has zero length, the starting position is equal to !!      one if the token is at the beginning of STRING, and one greater !!      than the position of the preceding delimiter otherwise. !! !!   +  LAST : It is allocated with the lower bound equal to one and the !!      upper bound equal to the number of tokens in STRING. Each !!      element is assigned, in array element order, the ending position !!      of each token in STRING, in the order found. !! !!      If a token has zero length, the ending position is one less than !!      the starting position. !! !!##EXAMPLES !! !! !!   Sample of uses !! !!    program demo_tokenize !!    use M_unicode, only : tokenize, ut=>unicode_type,ch=>character !!    use M_unicode, only : assignment(=),operator(/=) !!    implicit none !!    ! !!    ! some useful formats !!    character(len=*),parameter ::       & !!     & brackets='(*(\"[\",g0,\"]\":,\",\"))' ,& !!     & a_commas='(a,*(g0:,\",\"))'       ,& !!     & gen='(*(g0))' !!    ! !!    ! Execution of TOKEN form (return array of tokens) !!    ! !!       block !!       type(ut)             :: string !!       type(ut),allocatable :: tokens(:) !!       integer              :: i !!          string = '  first,second ,third       ' !!          call tokenize(string, set=';,', tokens=tokens ) !!          write(*,brackets)ch(tokens) !! !!          string = '  first , second ,third       ' !!          call tokenize(string, set=' ,', tokens=tokens ) !!          write(*,brackets)(tokens(i)%character(),i=1,size(tokens)) !!          ! remove blank tokens !!          tokens=pack(tokens, tokens /= '' ) !!          write(*,brackets)ch(tokens) !!    ! !!       endblock !!    ! !!    ! Execution of BOUNDS form (return position of tokens) !!    ! !!       block !!       type(ut)                   :: string !!       character(len=*),parameter :: set = \" ,\" !!       integer,allocatable        :: first(:), last(:) !!          write(*,gen)repeat('1234567890',6) !!          string = 'first,second,,fourth' !!          write(*,gen)ch(string) !!          call tokenize (string, set, first, last) !!          write(*,a_commas)'FIRST=',first !!          write(*,a_commas)'LAST=',last !!          write(*,a_commas)'HAS LENGTH=',last-first.gt.0 !!       endblock !!    ! !!    end program demo_tokenize !! !!   Results: !! !!    > [  first     ],[second      ],[third       ] !!    > [],[first],[],[],[second],[],[third],[],[],[],[],[] !!    > [first ],[second],[third ] !!    > 123456789012345678901234567890123456789012345678901234567890 !!    > first,second,,fourth !!    > FIRST=1,7,14,15 !!    > LAST=5,12,13,20 !!    > HAS LENGTH=T,T,F,T !! !!##SEE ALSO !!   +  SPLIT(3) ‚Äê return tokens from a string, one at a time !! !!   +  INDEX(3) ‚Äê Position of a substring within a string !! !!   +  SCAN(3) ‚Äê Scan a string for the presence of a set of characters !! !!   +  VERIFY(3) ‚Äê Position of a character in a string of characters !!                  that does not appear in a given set of characters. !! !!##AUTHOR !!     Milan Curcic, \"milancurcic@hey.com\" !!     John S. Urban -- UTF-8 version !! !!##LICENSE !!     MIT impure subroutine split_tokens ( string , set , tokens , separator ) ! Splits a string into tokens using characters in set as token delimiters. ! If present, separator contains the array of token delimiters. type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set type ( unicode_type ), allocatable , intent ( out ) :: tokens (:) type ( unicode_type ), allocatable , intent ( out ), optional :: separator (:) integer , allocatable :: first (:), last (:) integer :: n integer :: imax ! AUTHOR   : Milan Curcic, \"milancurcic@hey.com\" ! LICENSE  : MIT ! VERSION  : version 0.1.0, copyright 2020, Milan Curcic ! MODIFIED : 2025-10-15 UTF-8 version, urbanjost call split_first_last ( string , set , first , last ) ! maxval() of a zero-size array is set to a flag value not zero or length of character string if ( size ( first ). eq . 0 ) then imax = 0 else imax = maxval ( last - first ) + 1 endif if ( allocated ( tokens )) deallocate ( tokens ) allocate ( tokens ( size ( first ))) ! do n = 1 , size ( tokens ) tokens ( n ) = string % character ( first ( n ), last ( n ), 1 ) enddo ! if ( present ( separator )) then if ( allocated ( separator )) deallocate ( separator ) allocate ( separator ( size ( tokens ) - 1 )) do n = 1 , size ( tokens ) - 1 separator ( n ) = string % character ( first ( n + 1 ) - 1 , first ( n + 1 ) - 1 , 1 ) enddo endif end subroutine split_tokens !=================================================================================================================================== impure subroutine split_tokens_uauu ( string , set , tokens , separator ) ! Splits a string into tokens using characters in set as token delimiters. ! If present, separator contains the array of token delimiters. type ( unicode_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: set type ( unicode_type ), allocatable , intent ( out ) :: tokens (:) type ( unicode_type ), allocatable , intent ( out ), optional :: separator (:) call split_tokens ( string , unicode_type ( set ), tokens , separator ) end subroutine split_tokens_uauu !=================================================================================================================================== impure subroutine split_first_last ( string , set , first , last ) ! Computes the first and last indices of tokens in input string, delimited ! by the characters in set, and stores them into first and last output ! arrays. type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set integer , allocatable , intent ( out ) :: first (:) integer , allocatable , intent ( out ) :: last (:) type ( unicode_type ) :: set_array ( size ( set % codes )) logical , dimension ( size ( string % codes )) :: is_first , is_last , is_separator integer :: i integer :: n integer :: slen ! AUTHOR   : Milan Curcic, \"milancurcic@hey.com\" ! LICENSE  : MIT ! VERSION  : version 0.1.0, copyright 2020, Milan Curcic ! MODIFIED : 2025-09-21 JSU ! slen = len ( string ) ! do n = 1 , len ( set ) set_array ( n ) = set % character ( n , n ) enddo ! FINDIT : do n = 1 , slen do i = 1 , len ( set ) is_separator ( n ) = . false . if ( string % character ( n , n ) == set_array ( i )% character () ) then is_separator ( n ) = . true . exit endif enddo enddo FINDIT ! is_first = . false . is_last = . false . ! if (. not . is_separator ( 1 )) is_first ( 1 ) = . true . ! do concurrent ( n = 2 : slen - 1 ) if (. not . is_separator ( n )) then if ( is_separator ( n - 1 )) is_first ( n ) = . true . if ( is_separator ( n + 1 )) is_last ( n ) = . true . else if ( is_separator ( n - 1 )) then is_first ( n ) = . true . is_last ( n - 1 ) = . true . endif endif enddo ! if (. not . is_separator ( slen )) is_last ( slen ) = . true . ! first = pack ([( n , n = 1 , slen )], is_first ) last = pack ([( n , n = 1 , slen )], is_last ) ! end subroutine split_first_last !=================================================================================================================================== impure subroutine split_first_last_uaii ( string , set , first , last ) type ( unicode_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: set integer , allocatable , intent ( out ) :: first (:) integer , allocatable , intent ( out ), optional :: last (:) call split_first_last ( string , unicode_type ( set ), first , last ) end subroutine split_first_last_uaii !=================================================================================================================================== impure subroutine split_pos ( string , set , pos , back ) ! If back is absent, computes the leftmost token delimiter in string whose ! position is > pos. If back is present and true, computes the rightmost ! token delimiter in string whose position is < pos. The result is stored ! in pos. type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set integer , intent ( in out ) :: pos logical , intent ( in ), optional :: back logical :: backward type ( unicode_type ) :: set_array ( size ( set % codes )) integer :: i integer :: result_pos integer :: n ! AUTHOR   : Milan Curcic, \"milancurcic@hey.com\" ! LICENSE  : MIT ! VERSION  : version 0.1.0, copyright 2020, Milan Curcic ! MODIFIED : 2025-09-21 JSU backward = . false . if ( present ( back )) backward = back ! do n = 1 , len ( set ) set_array ( n ) = set % character ( n , n ) enddo ! if ( backward ) then result_pos = 0 FINDIT : do n = pos - 1 , 1 , - 1 do i = 1 , len ( set ) if ( string % character ( n , n ) == set_array ( i )% character () ) then result_pos = n exit FINDIT endif enddo enddo FINDIT else result_pos = len ( string ) + 1 GETPOS : do n = pos + 1 , len ( string ) do i = 1 , len ( set ) if ( string % character ( n , n ) == set_array ( i )% character () ) then result_pos = n exit GETPOS endif enddo enddo GETPOS endif ! pos = result_pos ! end subroutine split_pos !=================================================================================================================================== impure subroutine split_pos_uail ( string , set , pos , back ) type ( unicode_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: set integer , intent ( in out ) :: pos logical , intent ( in ), optional :: back call split_pos ( string , unicode_type ( set ), pos , back ) end subroutine split_pos_uail !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    PAD(3f) - [M_unicode:WHITESPACE] return string padded to at least !!    specified length !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !! !!    function pad(str,length,pattern,right,clip) result(out) !! !!     type(unicode_type)                         :: str !!     integer,intent(in)                         :: length !!     type(unicode_type)                         :: out !!     type(unicode_type),intent(in),optional     :: pattern !!     logical,intent(in),optional                :: right !!     logical,intent(in),optional                :: clip !! !!##DESCRIPTION !!    pad(3f) pads a string with a pattern to at least the specified !!    length. If the trimmed input string is longer than the requested !!    length the trimmed string is returned. !! !!##OPTIONS !!    str      the input string to return trimmed, but then padded to !!             the specified length if shorter than length !!    length   The minimum string length to return !!    pattern  optional string to use as padding. Defaults to a space. !!    right    if true pads string on the right, else on the left. Defaults !!             to true. !!    clip     trim spaces from input string ends. Defaults to .true. !! !!##RETURNS !!    out  The input string padded to the requested length or !!         the trimmed input string if the input string is !!         longer than the requested length. !! !!##EXAMPLES !! !! !!  Sample Program: !! !!   program demo_pad !!   use M_unicode, only  : pad, assignment(=) !!   !use M_unicode, only : write(formatted) !!   use M_unicode, only  : len !!   use M_unicode, only  : ch=> character !!   use M_unicode, only  : ut=> unicode_type !!   implicit none !!   type(ut)                   :: string !!   type(ut)                   :: answer !!   integer                    :: i !!   !character(len=*),parameter :: u='(*(DT))' !!   character(len=*),parameter :: u='(*(g0))' !!     ! !!     string='abcdefghij' !!     ! !!     write(*,*)'pad on right till 20 characters long' !!     answer=pad(string,20) !!     write(*,'(\"[\",g0,\"]\",/)') answer%character() !!     ! !!     write(*,*)'original is not trimmed for short length requests' !!     answer=pad(string,5) !!     write(*,'(\"[\",g0,\"]\",/)') answer%character() !!     ! !!     i=30 !!     write(*,*)'pad with specified string and left-justified integers' !!     write(*,'(1x,g0,1x,i0)') & !!      & ch(pad(ut('CHAPTER 1 : The beginning '),i,ut('.') )), 1   , & !!      & ch(pad(ut('CHAPTER 2 : The end '),i,ut('.') )),       1234, & !!      & ch(pad(ut('APPENDIX '),i,ut('.') )),                  1235 !!     ! !!     write(*,*)'pad with specified string and right-justified integers' !!     write(*,'(1x,g0,i7)') & !!      & ch(pad(ut('CHAPTER 1 : The beginning '),i,ut('.') )), 1   , & !!      & ch(pad(ut('CHAPTER 2 : The end '),i,ut('.') )),       1234, & !!      & ch(pad(ut('APPENDIX '),i,ut('.') )),                  1235 !!     ! !!     write(*,*)'pad on left with zeros' !!     write(*,u)ch(pad(ut('12'),5,ut('0'),right=.false.)) !!     ! !!     write(*,*)'various lengths with clip .true. and .false.' !!     write(*,u)ch(pad(ut('12345 '),30,ut('_'),right=.false.)) !!     write(*,u)ch(pad(ut('12345 '),30,ut('_'),right=.false.,clip=.true.)) !!     write(*,u)ch(pad(ut('12345 '), 7,ut('_'),right=.false.)) !!     write(*,u)ch(pad(ut('12345 '), 7,ut('_'),right=.false.,clip=.true.)) !!     write(*,u)ch(pad(ut('12345 '), 6,ut('_'),right=.false.)) !!     write(*,u)ch(pad(ut('12345 '), 6,ut('_'),right=.false.,clip=.true.)) !!     write(*,u)ch(pad(ut('12345 '), 5,ut('_'),right=.false.)) !!     write(*,u)ch(pad(ut('12345 '), 5,ut('_'),right=.false.,clip=.true.)) !!     write(*,u)ch(pad(ut('12345 '), 4,ut('_'),right=.false.)) !!     write(*,u)ch(pad(ut('12345 '), 4,ut('_'),right=.false.,clip=.true.)) !!  end program demo_pad !! !!   Results: !! !!    >  pad on right till 20 characters long !!    > [abcdefghij          ] !!    > !!    >  original is not trimmed for short length requests !!    > [abcdefghij] !!    > !!    >  pad with specified string and left-justified integers !!    >  CHAPTER 1 : The beginning .... 1 !!    >  CHAPTER 2 : The end .......... 1234 !!    >  APPENDIX ..................... 1235 !!    >  pad with specified string and right-justified integers !!    >  CHAPTER 1 : The beginning ....      1 !!    >  CHAPTER 2 : The end ..........   1234 !!    >  APPENDIX .....................   1235 !!    >  pad on left with zeros !!    > 00012 !!    >  various lengths with clip .true. and .false. !!    > ________________________12345 !!    > _________________________12345 !!    > _12345 !!    > __12345 !!    > 12345 !!    > _12345 !!    > 12345 !!    > 12345 !!    > 12345 !!    > 2345 !! !!##SEE ALSO !!      adjustl(3f), adjustr(3f), repeat(3f), trim(3f), len_trim(3f), len(3f) !! !!##AUTHOR !!     John S. Urban !! !!##LICENSE !!     MIT !=================================================================================================================================== impure elemental function pad ( line , length , pattern , right , clip ) result ( out ) ! ident_10=\"@(#) M_unicode pad(3f) return string padded to at least specified length\" type ( unicode_type ), intent ( in ) :: line integer , intent ( in ) :: length type ( unicode_type ), intent ( in ), optional :: pattern logical , optional , intent ( in ) :: right logical , optional , intent ( in ) :: clip type ( unicode_type ) :: out type ( unicode_type ) :: temp logical :: local_right logical :: local_clip type ( unicode_type ) :: local_pattern type ( unicode_type ) :: local_line integer :: newlen if ( present ( right ) ) then ; local_right = right ; else ; local_right = . true .; endif if ( present ( clip ) ) then ; local_clip = clip ; else ; local_clip = . true . ; endif if ( present ( pattern ) ) then ; local_pattern = pattern ; else ; local_pattern = ' ' ; endif if ( len ( local_pattern ) == 0 ) then out = line else if ( local_clip ) then local_line = trim ( adjustl ( line )) newlen = max ( length , len ( local_line )) else local_line = line newlen = max ( length , len ( line ) ) endif if ( local_right ) then !out=[local_line//repeat(local_pattern,newlen/len(local_pattern)+1) temp = repeat ( local_pattern , newlen / len ( local_pattern ) + 1 ) out = [ local_line % codes , temp % codes ] else ! make a line of pattern out = repeat ( local_pattern , ceiling ( real ( newlen ) / len ( local_pattern ))) !out=out%sub(1,newlen-len(local_line))//local_line out = out % sub ( 1 , newlen - len ( local_line )) out = [ out % codes , local_line % codes ] endif out = out % sub ( 1 , newlen ) endif end function pad !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!   SCAN(3f) - [M_unicode:SEARCH] Scan a string for the presence of a !!   set of characters !!   (LICENSE:MIT) !! !!##SYNOPSIS !! !!   result = scan( string, set, [,back] ) !! !!    elemental integer(kind=KIND) function scan(string,set,back) !! !!     type(unicode_type),intent(in) :: string !! !!     type(unicode_type),intent(in) :: set !!        or !!     character(len=*),intent(in)   :: set !! !!     logical,intent(in),optional   :: back !! !!##CHARACTERISTICS !!   +  STRING is a string of type unicode_type !! !!   +  SET must be a string of type unicode_type or character !! !!   +  BACK is a logical of default kind !! !!   +  the result is an integer of default kind. !! !!##DESCRIPTION !!   SCAN(3) scans a STRING for any of the characters in a SET of characters. !! !!   If BACK is either absent or equals .false., this function returns the !!   position of the leftmost character of STRING that is in SET. If BACK !!   equals .true., the rightmost position is returned. If no character of !!   SET is found in STRING, the result is zero. !! !!##OPTIONS !!   +  STRING : the string to be scanned !! !!   +  SET : the set of characters which will be matched !! !!   +  BACK : if .true. the position of the rightmost character matched !!      is returned, instead of the leftmost. !! !!##RESULT !!   If BACK is absent or is present with the value false and if STRING !!   contains at least one character that is in SET, the value of the result !!   is the position of the leftmost character of STRING that is in SET. !! !!   If BACK is present with the value true and if STRING contains at least !!   one character that is in SET, the value of the result is the position !!   of the rightmost character of STRING that is in SET. !! !!   The value of the result is zero if no character of STRING is in SET !!   or if the length of STRING or SET is zero. !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_scan !!    use iso_fortran_env, only : stdout => output_unit !!    use M_unicode,       only : scan, unicode_type, assignment(=) !!    use M_unicode,       only : ut=>unicode_type !!    implicit none !!    character(len=*),parameter :: g='(*(g0,1x))' !!    type(ut)                   :: line !!    type(ut)                   :: set !!       ! !!       write(*,*) scan(\"fortran\", \"ao\")          ! 2, found ‚Äôo‚Äô !!       write(*,*) scan(\"fortran\", \"ao\", .true.)  ! 6, found ‚Äôa‚Äô !!       write(*,*) scan(\"fortran\", \"c++\")         ! 0, found none !!       ! !!       line='parsleyüòÉsageüòÉrosemaryüòÉüòÉthyme' !!       set='üòÉ' !!       write(stdout,g) '12345678901234567890123456789012345678901234567890' !!       write(stdout,g) line%character() !!       write(stdout,g) scan(line, set) !!       write(stdout,g) scan(line, set, back=.true.) !!       write(stdout,g) scan(line, set, back=.false.) !!       write(stdout,g) scan(line, unicode_type(\"NOT\")) !!       write(stdout,g) 'OOP' !!       write(stdout,g) line%scan(set) !!       write(stdout,g) line%scan(ut(\"o\")) !!    end program demo_scan !! !!   Results: !! !!     >            2 !!     >            6 !!     >            0 !!     > 12345678901234567890123456789012345678901234567890 !!     > parsleyüòÉsageüòÉrosemaryüòÉüòÉthyme !!     > 8 !!     > 23 !!     > 8 !!     > 0 !!     > OOP !!     > 8 !!     > 15 !! !!##SEE ALSO !!   Functions that perform operations on character strings, return lengths !!   of arguments, and search for certain arguments: !! !!   +  ADJUSTL(3), ADJUSTR(3), INDEX(3), VERIFY(3) !! !!   +  LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3) !! !!##AUTHOR !!     John S. Urban !! !!##LICENSE !!     MIT elemental pure function scan_uu ( string , set , back ) result ( pos ) ! ident_11=\"@(#) M_unicode scan(3f) Scan a string for the presence of a set of characters\" type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set logical , intent ( in ), optional :: back logical :: back_local integer :: pos integer :: i back_local = . false . if ( present ( back )) back_local = back pos = 0 if ( back_local ) then pos = maxval ( [ ( findloc ( string % codes , set % codes ( i ), dim = 1 , back = back_local ) , i = 1 , size ( set % codes ) )]) else pos = minval ( [ ( findloc ( string % codes , set % codes ( i ), dim = 1 , back = back_local ), i = 1 , size ( set % codes ) )]) endif end function scan_uu !=================================================================================================================================== elemental pure function scan_ua ( string , set , back ) result ( pos ) ! allow SET to be CHARACTER and not just TYPE(UNICODE_TYPE) type ( unicode_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: set type ( unicode_type ) :: set_u logical , intent ( in ), optional :: back integer :: pos set_u = set pos = scan_uu ( string , set_u , back ) end function scan_ua !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !! !!##NAME !!   VERIFY(3f) - [M_unicode:SEARCH] Position of a character in a string of !!   characters that does not appear in a given set of characters. !!   (LICENSE:MIT) !! !!##SYNOPSIS !! !!   result = verify(string, set [,back] [,kind] ) !! !!            elemental integer function verify(string,set,back,KIND) !! !!             type(unicode_type),intent(in) :: string !! !!             type(unicode_type),intent(in) :: set !!                or !!             character(len=*),intent(in)   :: set !! !!             logical,intent(in),optional   :: back !! !!##CHARACTERISTICS !! !!   +  STRING  must be of type string !!   +  SET  must be of type string or character. !!   +  BACK shall be of type logical. !!   +  A default integer kind is returned. !! !!##DESCRIPTION !!   VERIFY(3) verifies that all the characters in STRING belong to the set of !!   characters in SET by identifying the position of the first character in the !!   string that is not in the set. !! !!   This makes it easy to verify strings are all uppercase or lowercase, follow a !!   basic syntax, only contain printable characters, and many of the conditions !!   tested for with the C routines ISALNUM(3c), ISALPHA(3c), ISASCII(3c), !!   ISBLANK(3c), ISCNTRL(3c), ISDIGIT(3c), ISGRAPH(3c), ISLOWER(3c), ISPRINT(3c), !!   ISPUNCT(3c), ISSPACE(3c), ISUPPER(3c), and ISXDIGIT(3c); but for a string as !!   well as an array of strings. !! !!##OPTIONS !!   +  STRING : The string to search in for an unmatched character. !! !!   +  SET : The set of characters that must be matched. !! !!   +  BACK : The direction to look for an unmatched character. The left‚Äêmost !!      unmatched character position isreturned unless BACK is present and !!      .false., which causes the position of the right‚Äêmost unmatched character !!      to be returned instead of the left‚Äêmost unmatched character. !! !!##RESULT !!   If all characters of STRING are found in SET, the result is zero. !! !!   If STRING is of zero length a zero (0) is always returned. !! !!   Otherwise, if an unmatched character is found The position of the first or !!   last (if BACK is .false.) unmatched character in STRING is returned, starting !!   with position one on the left end of the string. !! !!##EXAMPLES !! !!   Sample program I: !! !!    program demo_verify !!    ! general examples !!    use M_unicode, only : assignment(=) !!    use M_unicode, only : ut=>unicode_type, ch=>character !!    use M_unicode, only : write(formatted) !!    use M_unicode, only : operator(==) !!    use M_unicode, only : verify, replace !!    use M_unicode, only : operator(//) !!    implicit none !!    ! some useful character sets !!    character,parameter          :: & !!     & int*(*)   = \"1234567890\", & !!     & low*(*)   = \"abcdefghijklmnopqrstuvwxyz\", & !!     & upp*(*)   = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", & !!     & punc*(*)  = \"!\"\"#$%&'()*+,‚Äê./:;<=>?@['_‚Äò{|}Àú\", & !!     & blank*(*) = \" \", & !!     & tab       = char(11), & !!     & prnt*(*) = int//low//upp//blank//punc !!    ! !!    type(ut)                     :: stru !!    integer                      :: i !!        print *, \"basics:\" !!        print *, VERIFY (\"ABBA\", \"A\")                ! has the value 2. !!        print *, VERIFY (\"ABBA\", \"A\", BACK = .TRUE.) ! has the value 3. !!        print *, VERIFY (\"ABBA\", \"AB\")               ! has the value 0. !!       ! !!       print *,\"find first non‚Äêuppercase letter\" !!       ! will produce the location of \"d\", because there is no match in UPP !!       write(*,*) \"something unmatched\",verify(ut(\"ABCdEFG\"), upp) !!       ! !!       print *,\"if everything is matched return zero\" !!       ! will produce 0 as all letters have a match !!       write(*,*) & !!       & \"everything matched\",verify(ut(\"ffoorrttrraann\"), \"nartrof\") !!       ! !!       print *,\"easily categorize strings as uppercase, lowercase, ...\" !!       ! C-like functionality but does entire strings not just characters !!       write(*,*)\"isdigit 123?\",verify(ut(\"123\"), int) == 0 !!       write(*,*)\"islower abc?\",verify(ut(\"abc\"), low) == 0 !!       write(*,*)\"isalpha aBc?\",verify(ut(\"aBc\"), low//upp) == 0 !!       write(*,*)\"isblank aBc dEf?\",verify(ut(\"aBc dEf\"), blank//tab ) /= 0 !!       ! check if all printable characters !!       stru=\"aB;cde,fgHI!Jklmno PQRSTU vwxyz\" !!       write(*,*)\"isprint?\",verify(stru,prnt) == 0 !!       ! !!       ! this now has a nonprintable tab character in it !!       stru=replace(stru,10,10,ut(char(11))) !!       write(*,*)\"isprint?\",verify(stru,prnt) == 0 !!       ! !!       print *,\"VERIFY(3) is very powerful using expressions as masks\" !!       ! verify(3) is often used in a logical expression !!       stru=\" This is NOT all UPPERCASE \" !!       write(*,*)\"all uppercase/spaces?\",verify(stru, blank//upp) == 0 !!       stru=\" This IS all uppercase \" !!       write(*,*) \"stru=[\"//stru//\"]\" !!       write(*,*)\"all uppercase/spaces?\",verify(stru, blank//upp) == 0 !!       ! !!       ! set and show complex stru to be tested !!       stru=\"  Check this out. Let me know  \" !!       ! show the stru being examined !!       write(*,*) \"stru=[\"//stru//\"]\" !!       write(*,*) \"        \"//repeat(int,4) ! number line !!       ! !!       ! function returns a position just not a logical like C !!       print *, \"returning a position not just a logical is useful\" !!       ! which can be very useful for parsing strings !!       write(*,*)\"first non‚Äêblank character\",verify(stru, blank) !!       write(*,*)\"last non‚Äêblank character\",verify(stru, blank,back=.true.) !!       write(*,*)\"first non‚Äêletter non‚Äêblank\",verify(stru,low//upp//blank) !!       ! !!      !VERIFY(3) is elemental (can check an array of strings in one call) !!       print *, \"elemental\" !!       ! are strings all letters (or blanks)? !!       write(*,*) \"array of strings\",verify( & !!       ! strings must all be same length, so force to length 10 !!       & [character(len=10) :: \"YES\",\"ok\",\"000\",\"good one\",\"Nope!\"], & !!       & low//upp//blank) == 0 !!       ! !!       ! rarer, but the set can be an array, not just the strings to test !!       ! you could do ISPRINT() this (harder) way :> !!       write(*,*)\"isprint?\", & !!       & .not.all(verify(ut(\"aBc\"), [(char(i),i=32,126)])==1) !!       ! instead of this way !!       write(*,*)\"isprint?\",verify(ut(\"aBc\"),prnt) == 0 !!       ! !!    end program demo_verify !! !!   Results: !! !!        >  basics: !!        >            2 !!        >            3 !!        >            0 !!        >  find first non‚Äêuppercase letter !!        >  something unmatched           4 !!        >  if everything is matched return zero !!        >  everything matched           0 !!        >  easily categorize strings as uppercase, lowercase, ... !!        >  isdigit 123? T !!        >  islower abc? T !!        >  isalpha aBc? T !!        >  isblank aBc dEf? T !!        >  isprint? T !!        >  isprint? F !!        >  VERIFY(3) is very powerful using expressions as masks !!        >  all uppercase/spaces? F !!        >  string=[ This IS all uppercase ] !!        >  all uppercase/spaces? F !!        >  string=[  Check this out. Let me know  ] !!        >          1234567890123456789012345678901234567890 !!        >  returning a position not just a logical is useful !!        >  first non‚Äêblank character           3 !!        >  last non‚Äêblank character          29 !!        >  first non‚Äêletter non‚Äêblank          17 !!        >  elemental !!        >  array of strings T T F T F !!        >  isprint? T !!        >  isprint? T !! !!   Sample program II: !! !!   Determine if strings are valid integer representations !! !!    program fortran_ints !!    use M_unicode, only : ut=>unicode_type,assignment(=) !!    use M_unicode, only : adjustr, verify, trim, len !!    use M_unicode, only : write(formatted) !!    use M_unicode, only : operator(.cat.) !!    use M_unicode, only : operator(==) !!    implicit none !!    integer :: i !!    character(len=*),parameter :: asciiints(*)=[character(len=10) :: & !!     \"+1 \", & !!     \"3044848 \", & !!     \"30.40 \", & !!     \"September \", & !!     \"1 2 3\", & !!     \"  -3000 \", & !!     \" \"] !!     type(ut),allocatable :: ints(:) !!     if(allocated(ints))deallocate(ints) !!     allocate(ints(size(asciiints))) ! gfortran bug !!     ints=asciiints !!     ints=trim(ints) !!     ! show if strings pass or fail the test done by isint(3) !!     write(*,\"('is integer?')\") !!     do i=1,size(ints) !!       write(*,'(\"|\",DT,T14,\"|\",l1,\"|\")') ints(i), isint(ints(i)) !!     enddo !!     ! elemental !!     write(*,\"(*(g0,1x))\") isint(ints) !! !!    contains !! !!    impure elemental function isint(line) result (lout) !!    use M_unicode, only : adjustl, verify, trim !!    ! !!    ! determine if string is a valid integer representation !!    ! ignoring trailing spaces and leading spaces !!    ! !!    character(len=*),parameter :: digits=\"0123456789\" !!    type(ut),intent(in)        :: line !!    type(ut)                   :: name !!    logical                    :: lout !!       lout=.false. !!       ! make sure at least two characters long to simplify tests !!       name=adjustl(line).cat.'  ' !!       ! blank string !!       if( name == '' )return !!       ! allow one leading sign !!       if( verify(name%sub(1,1),ut('+‚Äê-')) == 0 ) name=name%sub(2,len(name)) !!       ! was just a sign !!       if( name == '' )return !!       lout=verify(trim(name), digits)  == 0 !!    end function isint !! !!    end program fortran_ints !! !!   Results: !! !!     > is integer? !!     > |+1          |T| !!     > |3044848     |T| !!     > |30.40       |F| !!     > |September   |F| !!     > |1 2 3       |F| !!     > |  ‚Äê3000     |T| !!     > |            |F| !!     > T T F F F T F !! !!   Sample program III: !! !!   Determine if strings represent valid Fortran symbol names !! !!    program fortran_symbol_name !!    use M_unicode, only : ut=>unicode_type, trim, verify, len !!    use M_unicode, only : ch=>character !!    use M_unicode, only : write(formatted) !!    implicit none !!    integer :: i !!    type(ut),allocatable :: symbols(:) !!       symbols=[ & !!        ut('A_'), ut('10'), ut('a10'), ut('September'), ut('A B'), & !!        ut('_A'), ut(' ')] !! !!       do i=1,size(symbols) !!          write(*,'(1x,DT,T11,\"|\",l2)')symbols(i),fortran_name(symbols(i)) !!       enddo !! !!    contains !! !!    impure elemental function fortran_name(line) result (lout) !!    ! !!    ! determine if a string is a valid Fortran name !!    ! ignoring trailing spaces (but not leading spaces) !!    ! !!    character(len=*),parameter :: int=\"0123456789\" !!    character(len=*),parameter :: lower=\"abcdefghijklmnopqrstuvwxyz\" !!    character(len=*),parameter :: upper=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" !!    character(len=*),parameter :: allowed=upper//lower//int//\"_\" !! !!    type(ut),intent(in)        :: line !!    type(ut)                   :: name !!    logical                    :: lout !!       name=trim(line) !!       if(len(name).ne.0)then !!          ! first character is alphameric !!          lout = verify(name%sub(1,1), lower//upper) == 0  & !!           ! other characters are allowed in a symbol name !!           & .and. verify(name,allowed) == 0           & !!           ! allowable length !!           & .and. len(name) <= 63 !!       else !!          lout = .false. !!       endif !!    end function fortran_name !! !!    end program fortran_symbol_name !! !!   Results: !! !!    >  A_       | T !!    >  10       | F !!    >  a10      | T !!    >  September| T !!    >  A B      | F !!    >  _A       | F !!    >           | F !! !!   Sample program IV: !! !!   check if string is of form NN‚ÄêHHHHH !! !!    program form !!    ! !!    ! check if string is of form NN‚ÄêHHHHH !!    ! !!    use iso_fortran_env, only : stdout => output_unit !!    use M_unicode,       only : verify, unicode_type, assignment(=) !!    use M_unicode,       only : ut=>unicode_type !!    implicit none !!    character(len=*),parameter :: g='(*(g0,1x))' !!    ! !!    character(len=*),parameter :: int='1234567890' !!    character(len=*),parameter :: hex='abcdefABCDEF0123456789' !!    logical                    :: lout !!    type(unicode_type)         :: chars !!    type(unicode_type)         :: str !!       ! !!       chars='32‚Äêaf43d' !!       lout=.true. !!       ! !!       ! are the first two characters integer characters? !!       str = chars%character(1,2) !!       lout = (verify( str, ut(int) ) == 0) .and.lout !!       ! !!       ! is the third character a dash? !!       str = chars%character(3,3) !!       lout = (verify( str, ut('‚Äê-') ) == 0) .and.lout !!       ! !!       ! is remaining string a valid representation of a hex value? !!       str = chars%character(4,8) !!       lout = (verify( str, ut(hex) ) == 0) .and.lout !!       ! !!       if(lout)then !!          write(stdout,g)trim(chars%character()),' passed' !!       else !!          write(stdout,g)trim(chars%character()),' failed' !!       endif !!    end program form !! !!   Results: !! !!           32‚Äêaf43d passed !! !!   Sample program V: !! !!   exploring uses of elemental functionality and dusty corners !! !!    program more_verify !!    use M_unicode, only : ut=>unicode_type, verify !!    use M_unicode, only : assignment(=) !!    use M_unicode, only : ch=>character !!    implicit none !!    character(len=*),parameter :: & !!      & low=\"abcdefghijklmnopqrstuvwxyz\", & !!      & upp=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", & !!      & blank=\" \" !!    ! note character variables in an array have to be of the same length !!    type(ut),allocatable :: strings(:) !!    type(ut),allocatable :: sets(:) !! !!       strings=[ut(\"Go\"),ut(\"right\"),ut(\"home!\")] !!       sets=[ut(\"do\"),ut(\"re\"),ut(\"me\")] !! !!      ! elemental ‚Äê‚Äê you can use arrays for both strings and for sets !! !!       ! check each string from right to left for non‚Äêletter/non‚Äêblank !!       write(*,*)\"last non‚Äêletter\",verify(strings,upp//low//blank,back=.true.) !! !!       ! even BACK can be an array !!       ! find last non‚Äêuppercase character in \"Go\" !!       ! and first non‚Äêlowercase in \"right\" !!       write(*,*) verify(strings(1:2),[upp,low],back=[.true.,.false.]) !! !!       ! using a null string for a set is not well defined. Avoid it !!       write(*,*) \"null\",verify(\"for tran \", \"\", .true.) ! 8,length of string? !!       ! probably what you expected !!       write(*,*) \"blank\",verify(\"for tran \", \" \", .true.) ! 7,found ‚Äôn‚Äô !! !!       ! first character in  \"Go    \" not in \"do\", !!       ! and first letter in \"right \" not in \"ri\" !!       ! and first letter in \"home! \" not in \"me\" !!       write(*,*) verify(strings,sets) !! !!    end program more_verify !! !!   Results: !! !!    >  last non‚Äêletter 0 0 5 !!    >  2 0 !!    >  null 9 !!    >  blank 8 !!    >  1 2 1 !! !!##SEE ALSO !!   Functions that perform operations on character strings, return !!   lengths of arguments, and search for certain arguments: !! !!   +  ELEMENTAL: ADJUSTL(3), ADJUSTR(3), INDEX(3), SCAN(3), !! !!   +  NONELEMENTAL: LEN_TRIM(3), LEN(3), REPEAT(3), TRIM(3) !! !!##AUTHOR !!     John S. Urban !! !!##LICENSE !!     MIT elemental impure function verify_uu ( string , set , back ) result ( result ) ! ident_12=\"@(#) M_unicode verify(3f) determine position of a character in a string that does not appear in a given set of characters.\" type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set type ( unicode_type ) :: str logical , intent ( in ), optional :: back integer :: result integer :: pos integer :: i result = 0 do i = 1 , len ( string ) str = string % sub ( i , i ) pos = index ( set , str , back ) if ( pos . eq . 0 ) then result = i exit endif enddo end function verify_uu !=================================================================================================================================== elemental impure function verify_ua ( string , set , back ) result ( result ) type ( unicode_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: set type ( unicode_type ) :: set_u logical , intent ( in ), optional :: back integer :: result set_u = set result = verify_uu ( string , set_u , back ) end function verify_ua !=================================================================================================================================== elemental impure function verify_au ( string , set , back ) result ( result ) character ( len =* ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set logical , intent ( in ), optional :: back type ( unicode_type ) :: ustring integer :: result ustring = string result = verify_uu ( ustring , set , back ) end function verify_au !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!     EXPANDTABS(3f) - [M_unicode:WHITESPACE] function to expand tab characters !!     (LICENSE:MIT) !! !!##SYNOPSIS !! !! !!     elemental function expandtabs(INSTR,TABSIZE) result(OUT) !! !!      type(unicode_type),intent=(in)  :: INSTR !!      integer,intent(in),optional     :: TAB_SIZE !!      type(unicode_type)              :: OUT !! !!##DESCRIPTION !!    EXPANDTABS(3) expands tabs in INSTR to spaces in OUT. It assumes a !!    tab is set every 8 characters by default. Trailing spaces are removed. !! !!##OPTIONS !!    instr     Input line to remove tabs from !!    tab_size  spacing between tab stops. !! !!##RETURNS !!    out       Output string with tabs expanded. !! !!##EXAMPLES !! !! !!  Sample program: !! !!     program demo_expandtabs !!     use M_unicode, only : expandtabs, ch=>character, replace !!     use M_unicode, only : assignment(=), ut=> unicode_type !!     implicit none !!     type(ut)                     :: in !!     type(ut)                     :: inexpanded !!     character(len=:),allocatable :: dat !!     integer                      :: i !!        dat='  this is my string  ' !!        ! change spaces to tabs to make a sample input !!        do i=1,len(dat) !!           if(dat(i:i) == ' ')dat(i:i)=char(9) !!        enddo !!        in=dat !!        ! !!        inexpanded=expandtabs(in) !!        write(*,'(\"[\",a,\"]\")')ch(inexpanded) !!        inexpanded=replace(inexpanded,ut(' '),ut('_')) !!        write(*,'(\"[\",a,\"]\")')ch(inexpanded) !!        ! !!        write(*,'(\"[\",a,\"]\")')ch(in%expandtabs()) !!        write(*,'(\"[\",a,\"]\")')ch(in%expandtabs(tab_size=8)) !!        write(*,'(\"[\",a,\"]\")')ch(in%expandtabs(tab_size=1)) !!        write(*,'(\"[\",a,\"]\")')ch(in%expandtabs(tab_size=0)) !!        ! !!     end program demo_expandtabs !! !!    Results: !! !!     > [                this    is      my      string] !!     > [________________this____is______my______string] !!     > [                this    is      my      string] !!     > [                this    is      my      string] !!     > [  this is my string] !!     > [thisismystring] !! !!##AUTHOR !!      John S. Urban !! !!##LICENSE !!     MIT elemental function expandtabs ( instr , tab_size ) result ( out ) ! ident_13=\"@(#) M_unicode expandtabs(3f) convert tabs to spaces and trim line removing CRLF chars\" type ( unicode_type ), intent ( in ) :: instr ! input line to scan for tab characters type ( unicode_type ) :: out ! tab-expanded version of INSTR produced integer , intent ( in ), optional :: tab_size integer :: ipos ! position in OUT to put next character of INSTR integer :: istep ! counter advances thru string INSTR integer :: icount ! number of tab characters in input integer :: i integer :: tab_size_local tab_size_local = 8 ! assume a tab stop is set every 8th column if ( present ( tab_size )) tab_size_local = tab_size ! count number of tab characters in input icount = 0 do i = 1 , size ( instr % codes ) if ( instr % codes ( i ) == 9 ) icount = icount + 1 enddo ! initially set length of output to the maxiumum length that might result if ( allocated ( out % codes )) deallocate ( out % codes ) allocate ( out % codes ( size ( instr % codes ) + 8 * icount ) ) out % codes = 32 ! blank-fill string ipos = 1 ! where to put next character in output string OUT SCAN_LINE : do istep = 1 , len_trim ( instr ) ! look through input string one character at a time EXPAND_TABS : select case ( instr % codes ( istep )) ! take actions based on character found case ( 9 ) ! character is a horizontal tab so move pointer out to appropriate column if ( tab_size_local . gt . 0 ) then ipos = ipos + ( tab_size_local - ( mod ( ipos - 1 , tab_size_local ))) endif case default ! character is anything else other than a tab out % codes ( ipos ) = instr % codes ( istep ) ipos = ipos + 1 end select EXPAND_TABS enddo SCAN_LINE out = trim ( out ) end function expandtabs !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!     ESCAPE(3f) - [M_unicode:CONVERSION] expand C-like escape sequences !!     (LICENSE:MIT) !! !!##SYNOPSIS !! !! !!    function escape(line,utf8) result(out) !! !!     type(unicode_type)                    :: line !!     character(len=1),intent(in),optional  :: protect !!     type(unicode_type)                    :: out !! !!##DESCRIPTION !!    ESCAPE(3) expands commonly used escape sequences that !!    represent glyphs or control characters. By default ... !! !!    Escape sequences !! !!     \\      backslash !!     a      alert (BEL) -- g is an alias for a !!     b      backspace !!     c      suppress further output !!     e      escape !!     f      form feed !!     n      new line !!     r      carriage return !!     t      horizontal tab !!     v      vertical tab !! !!     oNNN   byte with octal value NNN (3 digits) !!     0-9    digits will be assumed an octal value till a !!            non-octal value character is encountered !!     dNNN   byte with decimal value NNN (3 digits) !! !!     xHH        byte with hexadecimal value HH (2 digits); !!                h is an alias for x !!     uZZZZ      translate Unicode codepoint value to bytes !!     UZZZZZZZZ  translate Unicode codepoint value to bytes !! !!   The default escape character is the backslash, but this may be !!   changed using the optional parameter ESCAPE. !! !!##EXAMPLES !! !! !!   Sample Program: !! !!    program demo_escape !!    ! demonstrate filter to expand C-like escape sequences in input lines !!    use iso_fortran_env, only : stdout => output_unit !!    use M_unicode,       only : ut=>unicode_type,ch=>character,len,escape !!    use M_unicode,       only : assignment(=), trim !!    implicit none !!    type(ut),allocatable  :: poem(:) !!    type(ut)              :: test(5) !!    integer               :: i !!       ! !!       ! ‚ÄúThe Crow and the Fox‚Äù by Jean de la Fontaine !!       write(stdout,'(a,/)') & !!       'Le Corbeau et le Renard -- Jean de la Fontaine' !!       ! !!       poem=[& !!       ut( 'Le Corbeau et le Renard'                                   ),& !!       ut( ''                                                          ),& !!       ut( 'Ma\\u00EEtre Corbeau, sur un arbre perch\\u00E9,'            ),& !!       ut( 'Tenait en son bec un fromage.'                             ),& !!       ut( 'Ma\\u00EEtre Renard, par l\\u2019odeur all\\u00E9ch\\u00E9,'   ),& !!       ut( 'Lui tint \\U000000E0 peu pr\\U000000E8s ce langage :'        ),& !!       ut( '\\U000000ABH\\U000000E9 ! bonjour, Monsieur du Corbeau.'     ),& !!       ut( 'Que vous \\U000000EAtes joli ! que vous me semblez beau !'  ),& !!       ut( 'Sans mentir, si votre ramage'                              ),& !!       ut( 'Se rapporte \\U000000E0 votre plumage,'                     ),& !!       ut( 'Vous \\xEAtes le Ph\\xE9nix des h\\xF4tes de ces bois.\\xBB'   ),& !!       ut( 'A ces mots le Corbeau ne se sent pas de joie ;'            ),& !!       ut( 'Et pour montrer sa belle voix,'                            ),& !!       ut( 'Il ouvre un large bec, laisse tomber sa proie.'            ),& !!       ut( 'Le Renard s\\u2019en saisit, et dit : \\xABMon bon Monsieur,'),& !!       ut( 'Apprenez que tout flatteur'                                ),& !!       ut( 'Vit aux d\\xE9pens de celui qui l\\U00002019\\u00E9coute :'   ),& !!       ut( 'Cette le\\xE7on vaut bien un fromage, sans doute.\\xBB'      ),& !!       ut( 'Le Corbeau, honteux et confus,'                            ),& !!       ut( & !!       'Jura, mais un peu tard, qu\\u2019on ne l\\u2019y prendrait plus.'),& !!       ut( ' -- Jean de la Fontaine')] !!       ! !!       poem=escape(poem) !!       write(stdout,'(g0)')ch(poem) !!       ! !!       test=[ & !!        '\\e[H\\e[2J           ',& ! home cursor and clear screen !!                                 ! on ANSI terminals !!        '\\tABC\\tabc          ',& ! write some tabs in the output !!        '\\tA\\a               ',& ! ring bell at end if supported !!        '\\nONE\\nTWO\\nTHREE   ',& ! place one word per line !!        '\\\\                  '] !!       test=trim(escape(test)) !!       write(*,'(a)')(test(i)%character(),i=1,size(test)) !!       ! !!    end program demo_escape !! !!  Results (with nonprintable characters shown visible): !! !!      > &#94;[[H&#94;[[2J !!      > &#94;IABC&#94;Iabc !!      > &#94;IA&#94;G !!      > !!      > ONE !!      > TWO !!      > THREE !!      > \\ !! !!##AUTHOR !!     John S. Urban !! !!##LICENSE !!     MIT impure elemental function escape_uu ( line , protect ) result ( out ) ! ident_14=\"@(#) M_unicode escape(3f) return string with escape sequences expanded\" type ( unicode_type ), intent ( in ) :: line type ( unicode_type ), intent ( in ), optional :: protect ! default is backslash type ( unicode_type ) :: out character ( len = :), allocatable :: buffer character ( len = :), allocatable :: format character ( len = :), allocatable :: temp integer :: esc ! Default is backslash integer :: i integer :: lgth character ( len = 3 ) :: thr character ( len = 4 ) :: four character ( len = 8 ) :: eight integer :: nnn integer :: iostat integer :: icount integer , parameter :: alert = 7 integer , parameter :: backspace = 8 integer , parameter :: horizontal_tab = 9 integer , parameter :: newline = 10 integer , parameter :: vertical_tab = 11 integer , parameter :: form_feed = 12 integer , parameter :: carriage_return = 13 integer , parameter :: eskape = 27 integer , parameter :: a = ichar ( 'a' ), AA = ichar ( 'A' ), g = ichar ( 'g' ), GG = ichar ( 'G' ) integer , parameter :: b = ichar ( 'b' ), BB = ichar ( 'B' ) integer , parameter :: c = ichar ( 'c' ), CC = ichar ( 'C' ) integer , parameter :: d = ichar ( 'd' ), DD = ichar ( 'D' ) integer , parameter :: e = ichar ( 'e' ), EE = ichar ( 'E' ) integer , parameter :: f = ichar ( 'f' ), FF = ichar ( 'F' ) integer , parameter :: n = ichar ( 'n' ), NN = ichar ( 'N' ) integer , parameter :: o = ichar ( 'o' ), OO = ichar ( 'O' ) integer , parameter :: r = ichar ( 'r' ), RR = ichar ( 'R' ) integer , parameter :: t = ichar ( 't' ), TT = ichar ( 'T' ) integer , parameter :: u = ichar ( 'u' ), UU = ichar ( 'U' ) integer , parameter :: v = ichar ( 'v' ), VV = ichar ( 'V' ) integer , parameter :: x = ichar ( 'x' ), XX = ichar ( 'X' ), h = ichar ( 'h' ), HH = ichar ( 'H' ) i = 0 ! pointer into input lgth = len_trim ( line ) out = '' if ( lgth == 0 ) return if ( present ( protect ) ) then if ( size ( protect % codes ). lt . 1 ) then esc = 0 else esc = ichar ( protect % sub ( 1 , 1 )) endif else esc = 92 endif EXP : do i = i + 1 if ( i > lgth ) exit if ( line % codes ( i ) == esc ) then i = i + 1 if ( i > lgth ) then ! esc at end of line out % codes = [ out % codes , esc ] exit endif if ( line % codes ( i ) /= esc ) then BACKSLASH : select case ( line % codes ( i )) case ( a , AA , g , GG ); out % codes = [ out % codes , alert ] case ( b , BB ); out % codes = [ out % codes , backspace ] case ( c , CC ); exit EXP ! suppress further output case ( d , DD ) ! %d     Dnnn decimal value thr = character ( line % sub ( i + 1 , i + 3 )) read ( thr , '(i3)' , iostat = iostat ) nnn out = [ out % codes , nnn ] i = i + 3 case ( e , EE ); out % codes = [ out % codes , eskape ] case ( f , FF ); out % codes = [ out % codes , form_feed ] case ( n , NN ); out % codes = [ out % codes , newline ] case ( o , OO ) thr = character ( line % sub ( i + 1 , i + 3 )) read ( thr , '(o3)' , iostat = iostat ) nnn out % codes = [ out % codes , nnn ] i = i + 3 case ( r , RR ); out % codes = [ out % codes , carriage_return ] case ( t , TT ); out % codes = [ out % codes , horizontal_tab ] case ( v , VV ); out % codes = [ out % codes , vertical_tab ] case ( x , XX , h , HH ) ! %x xHH  byte with hexadecimal value HH (1 to 2 digits) thr = character ( line % sub ( i + 1 , i + 2 )) read ( thr , '(z2)' , iostat = iostat ) nnn out % codes = [ out % codes , nnn ] i = i + 2 case ( u ) ! %uZZZZ  translate Unicode codepoint to bytes four = character ( line % sub ( i + 1 , i + 4 )) read ( four , '(z4)' , iostat = iostat ) nnn out % codes = [ out % codes , nnn ] i = i + 4 case ( UU ) ! %UZZZZZZZZ  translate Unicode codepoint to bytes eight = character ( line % sub ( i + 1 , i + 8 )) read ( eight , '(z8)' , iostat = iostat ) nnn out % codes = [ out % codes , nnn ] i = i + 8 case ( ichar ( '0' ): ichar ( '7' )); buffer = line % sub ( i , step = 1 ) icount = verify ( buffer , '01234567' ) if ( icount . eq . 0 ) icount = len ( buffer ) + 1 icount = icount - 1 buffer = character ( line % sub ( i , i + icount - 1 )) temp = fmt ( icount ) format = '(o' // temp // ')' read ( buffer , format , iostat = iostat ) nnn out % codes = [ out % codes , nnn ] i = i + icount - 1 case default ! no match so just copy character, could produce warning out % codes = [ out % codes , line % codes ( i )] end select BACKSLASH else out % codes = [ out % codes , esc ] ! escape character, defaults to backslash endif else out % codes = [ out % codes , line % codes ( i )] endif if ( i >= lgth ) exit EXP enddo EXP end function escape_uu !=================================================================================================================================== impure elemental function escape_aa ( line , protect ) result ( out ) character ( len =* ), intent ( in ) :: line character ( len = 1 ), intent ( in ) :: protect type ( unicode_type ) :: uline type ( unicode_type ) :: uprotect type ( unicode_type ) :: out uline = line uprotect = protect out = escape ( uline , uprotect ) end function escape_aa !=================================================================================================================================== impure elemental function escape_au ( line , protect ) result ( out ) character ( len =* ), intent ( in ) :: line type ( unicode_type ), intent ( in ), optional :: protect type ( unicode_type ) :: uline type ( unicode_type ) :: out uline = line out = escape ( uline , protect ) end function escape_au !=================================================================================================================================== impure elemental function escape_ua ( line , protect ) result ( out ) type ( unicode_type ), intent ( in ) :: line character ( len = 1 ), intent ( in ) :: protect type ( unicode_type ) :: uprotect type ( unicode_type ) :: out uprotect = protect out = escape ( line , uprotect ) end function escape_ua !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    SUB(3f) - [M_unicode:EDITING] Return substring !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !! !!    function sub(str,left,right,step) result(section) !! !!     type(unicode_type)          :: str !!     integer,intent(in),optional :: left !!     integer,intent(in),optional :: right !!     integer,intent(in),optional :: step !! !!##DESCRIPTION !!    sub(3f) returns a substring from one column to another. !! !!##OPTIONS !!    str           the input string to return a section of !!    left          column number of str starting section of str to return. !!                  Defaults to 1 when STEP is positive, or right end of !!                  STR when STEP is negative. !!    right         column number of str ending section of str to return. !!                  Defaults to right end of STR when STEP is positive, or !!                  1 when STEP is negative. !!    step          step to take from left column to right column. !!                  Defaults to 1. !! !!##RETURNS !!    out  The specified subsection of the input string !! !!##EXAMPLES !! !! !!   Sample Program: !! !!     program demo_sub !!      use M_unicode, only : sub, assignment(=) !!      use M_unicode, only : len !!      use M_unicode, only : ut=> unicode_type !!      implicit none !!      type(ut)                   :: string !!      type(ut)                   :: piece !!         ! !!         string='abcdefghij' !!         ! !!         piece=sub(string,3,5) !!         call printme('selected range:') !!         piece=sub(string,6) !!         call printme('from character to end:') !!         piece=sub(string,5,5) !!         call printme('single character:') !!         piece=sub(string,step=-1) !!         call printme('reverse string:') !!      contains !!      subroutine printme(label) !!      character(len=*),intent(in) :: label !!         write(*,'(a,\"[\",g0,\"]\",/)') label, piece%character() !!      end subroutine printme !!      end program demo_sub !! !!   Results: !! !!##SEE ALSO !!      adjustl(3f), adjustr(3f), repeat(3f), trim(3f), len_trim(3f), len(3f) !! !!##AUTHOR !!     John S. Urban !! !!##LICENSE !!     MIT function sub ( str , start , end , step ) result ( section ) type ( unicode_type ), intent ( in ) :: str type ( unicode_type ) :: section integer , intent ( in ), optional :: start , end , step integer :: start_ , end_ , step_ integer :: which integer :: sgn sgn = 1 if ( present ( step )) sgn = sign ( 1 , step ) which = 4 * merge ( 1 , 0 , present ( start )) + 2 * merge ( 1 , 0 , present ( end )) + 1 * merge ( 1 , 0 , present ( step )) select case ( which * sgn ) case ( int ( b '000' )) ; start_ = 1 ; end_ = len ( str ) ; step_ = 1 case ( int ( b '001' )) ; start_ = 1 ; end_ = len ( str ) ; step_ = step case ( int ( b '010' )) ; start_ = 1 ; end_ = end ; step_ = 1 case ( int ( b '011' )) ; start_ = 1 ; end_ = end ; step_ = step case ( int ( b '100' )) ; start_ = start ; end_ = len ( str ) ; step_ = 1 case ( int ( b '101' )) ; start_ = start ; end_ = len ( str ) ; step_ = step case ( int ( b '110' )) ; start_ = start ; end_ = end ; step_ = 1 case ( int ( b '111' )) ; start_ = start ; end_ = end ; step_ = step case ( int ( b '001' ) * ( - 1 )) ; start_ = len ( str ) ; end_ = 1 ; step_ = step case ( int ( b '011' ) * ( - 1 )) ; start_ = 1 ; end_ = end ; step_ = step case ( int ( b '101' ) * ( - 1 )) ; start_ = start ; end_ = 1 ; step_ = step case ( int ( b '111' ) * ( - 1 )) ; start_ = start ; end_ = end ; step_ = step case default write ( 0 , * ) '*sub* unknown case ' , which , 'sign' , sgn stop 1 end select if ( step_ . gt . 0 ) then end_ = min ( size ( str % codes ), end_ ) start_ = max ( 1 , start_ ) else start_ = min ( size ( str % codes ), start_ ) end_ = max ( 1 , end_ ) endif section = str % codes ( start_ : end_ : step_ ) end function sub function section_uu ( str , first , last , new ) result ( out ) type ( unicode_type ), intent ( in ) :: str integer , intent ( in ), optional :: first , last type ( unicode_type ), intent ( in ) :: new type ( unicode_type ) :: out integer :: start , end integer :: which which = 2 * merge ( 1 , 0 , present ( first )) + 1 * merge ( 1 , 0 , present ( last )) select case ( which ) case ( int ( b '00' )) ; start = 1 ; end = len ( str ) case ( int ( b '01' )) ; start = 1 ; end = last case ( int ( b '10' )) ; start = first ; end = len ( str ) case ( int ( b '11' )) ; start = first ; end = last end select out = [ str % codes ( 1 : start - 1 ), new % codes , str % codes ( end + 1 : len ( str ))] end function section_uu !=================================================================================================================================== function section_ua ( str , first , last , new ) result ( out ) type ( unicode_type ), intent ( in ) :: str integer , intent ( in ) :: first , last character ( len =* ), intent ( in ) :: new type ( unicode_type ) :: out out = section_uu ( str , first , last , unicode_type ( new )) end function section_ua !=================================================================================================================================== function section_au ( str , first , last , new ) result ( out ) character ( len =* ), intent ( in ) :: str integer , intent ( in ) :: first , last type ( unicode_type ), intent ( in ) :: new type ( unicode_type ) :: out out = section_uu ( unicode_type ( str ), first , last , new ) end function section_au !=================================================================================================================================== function section_aa ( str , first , last , new ) result ( out ) character ( len =* ), intent ( in ) :: str integer , intent ( in ) :: first , last character ( len =* ), intent ( in ) :: new type ( unicode_type ) :: out out = section_uu ( unicode_type ( str ), first , last , unicode_type ( new )) end function section_aa !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!     transliterate(3f) - [M_unicode:EDITING] replace characters from old !!                         set with new set !!     (LICENSE:PD) !! !!##SYNOPSIS !! !! !!     impure function transliterate(instr,old_set,new_set) result(outstr) !! !!      type(unicode_type),intent(in)  :: instr !!      type(unicode_type),intent(in)  :: old_set !!      type(unicode_type),intent(in)  :: new_set !!      type(unicode_type)             :: outstr !! !!##CHARACTERISTICS !! !!    Although a conversion might occur on each call, the input values !!    may be CHARACTER as well as TYPE(UNICODE_TYPE). !! !!##DESCRIPTION !!    Translate or delete characters from an input string. !! !! !!##OPTIONS !!   instr    input string to change !!   old_set  list of glyphs to change in INSTR if found !! !!            Each glyph in the input string that matches a glyph !!            in the old set is replaced. !!   new_set  list of glyphs to replace glyphs in OLD_SET with. !! !!            If NEW_SET is the empty set glyphs in INSTR that !!            match any in OLD_SET are deleted. !! !!            If NEW_SET is shorter than OLD_SET the last glyph !!            in NEW_SET is used to replace the remaining glyphs !!            in NEW_SET. !! !!##RETURNS !!    outstr  INSTR with substitutions applied !! !!##EXAMPLES !! !! !!   Sample Program: !! !!    program demo_transliterate !! !!     use M_unicode, only : transliterate,ut=>unicode_type !!     use M_unicode, only : write(formatted),ch=>character !!     use M_unicode, only : assignment(=) !!     implicit none !!     character(len=*),parameter :: u='(DT)' !!     type(ut)  :: STRING, UPPER, LOWER !!     type(ut)  :: MIDDLE_DOT !! !!        STRING='aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ' !!        LOWER='abcdefghijklmnopqrstuvwxyz' !!        UPPER='ABCDEFGHIJKLMNOPQRSTUVWXYZ' !!        call callit() !! !!        print u !!        print u,ut('Greek') !!        ! !!        ! | Œë Œ± | Œí Œ≤ | Œì Œ≥ | Œî Œ¥ | Œï Œµ | Œñ Œ∂   | !!        ! | Œó Œ∑ | Œò Œ∏ | Œô Œπ | Œö Œ∫ | Œõ Œª | Œú Œº   | !!        ! | Œù ŒΩ | Œû Œæ | Œü Œø | Œ† œÄ | Œ° œÅ | Œ£ œÉ œÇ | !!        ! | Œ§ œÑ | Œ• œÖ | Œ¶ œÜ | Œß œá | Œ® œà | Œ© œâ   | !!        ! !!        STRING='ŒëŒ±ŒíŒ≤ŒìŒ≥ŒîŒ¥ŒïŒµŒñŒ∂ŒóŒ∑ŒòŒ∏ŒôŒπŒöŒ∫ŒõŒªŒúŒºŒùŒΩŒûŒæŒüŒøŒ†œÄŒ°œÅŒ£œÉœÇŒ§œÑŒ•œÖŒ¶œÜŒßœáŒ®œàŒ©œâ' !!        ! ignoring œÇ for simplicity !!        UPPER='ŒëŒíŒìŒîŒïŒñŒóŒòŒôŒöŒõŒúŒùŒûŒüŒ†Œ°Œ£Œ§Œ•Œ¶ŒßŒ®Œ©' !!        LOWER='Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÉœÑœÖœÜœáœàœâ' !!        call callit() !! !!        ! OOP !!        print u !!        print u,ut('OOP!') !!        print u,STRING%TRANSLITERATE(UPPER,'_') !! !!        ! U+00B7 Middle Dot Unicode Character !!        print u,STRING%TRANSLITERATE(LOWER,'¬∑') ! ASCII bytes !!        print u,STRING%TRANSLITERATE(LOWER,ut('¬∑')) ! cast !!        MIDDLE_DOT=int(z'00B7') !!        print u,STRING%TRANSLITERATE(LOWER,MIDDLE_DOT) ! hexadecimal !! !!     contains !!     subroutine callit() !!          print u, STRING !! !!          ! convert -7 string to uppercase: !!          print u, TRANSLITERATE(STRING , LOWER, UPPER ) !! !!          ! change all miniscule letters to a colon (\":\"): !!          print u, TRANSLITERATE(STRING, LOWER, ':') !! !!          ! delete all miniscule letters !!          print u, TRANSLITERATE(STRING, LOWER, '') !! !!          end subroutine callit !! !!     end program demo_transliterate !! !!   Results: !! !!    > aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ !!    > AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYYZZ !!    > :A:B:C:D:E:F:G:H:I:J:K:L:M:N:O:P:Q:R:S:T:U:V:W:X:Y:Z !!    > ABCDEFGHIJKLMNOPQRSTUVWXYZ !!    > !!    > Greek !!    > ŒëŒ±ŒíŒ≤ŒìŒ≥ŒîŒ¥ŒïŒµŒñŒ∂ŒóŒ∑ŒòŒ∏ŒôŒπŒöŒ∫ŒõŒªŒúŒºŒùŒΩŒûŒæŒüŒøŒ†œÄŒ°œÅŒ£œÉœÇŒ§œÑŒ•œÖŒ¶œÜŒßœáŒ®œàŒ©œâ !!    > ŒëŒëŒíŒíŒìŒìŒîŒîŒïŒïŒñŒñŒóŒóŒòŒòŒôŒôŒöŒöŒõŒõŒúŒúŒùŒùŒûŒûŒüŒüŒ†Œ†Œ°Œ°Œ£Œ£œÇŒ§Œ§Œ•Œ•Œ¶Œ¶ŒßŒßŒ®Œ®Œ©Œ© !!    > Œë:Œí:Œì:Œî:Œï:Œñ:Œó:Œò:Œô:Œö:Œõ:Œú:Œù:Œû:Œü:Œ†:Œ°:Œ£:œÇŒ§:Œ•:Œ¶:Œß:Œ®:Œ©: !!    > ŒëŒíŒìŒîŒïŒñŒóŒòŒôŒöŒõŒúŒùŒûŒüŒ†Œ°Œ£œÇŒ§Œ•Œ¶ŒßŒ®Œ© !!    > !!    > OOP! !!    > _Œ±_Œ≤_Œ≥_Œ¥_Œµ_Œ∂_Œ∑_Œ∏_Œπ_Œ∫_Œª_Œº_ŒΩ_Œæ_Œø_œÄ_œÅ_œÉœÇ_œÑ_œÖ_œÜ_œá_œà_œâ !!    > Œë¬∑Œí¬∑Œì¬∑Œî¬∑Œï¬∑Œñ¬∑Œó¬∑Œò¬∑Œô¬∑Œö¬∑Œõ¬∑Œú¬∑Œù¬∑Œû¬∑Œü¬∑Œ†¬∑Œ°¬∑Œ£¬∑œÇŒ§¬∑Œ•¬∑Œ¶¬∑Œß¬∑Œ®¬∑Œ©¬∑ !!    > Œë¬∑Œí¬∑Œì¬∑Œî¬∑Œï¬∑Œñ¬∑Œó¬∑Œò¬∑Œô¬∑Œö¬∑Œõ¬∑Œú¬∑Œù¬∑Œû¬∑Œü¬∑Œ†¬∑Œ°¬∑Œ£¬∑œÇŒ§¬∑Œ•¬∑Œ¶¬∑Œß¬∑Œ®¬∑Œ©¬∑ !!    > Œë¬∑Œí¬∑Œì¬∑Œî¬∑Œï¬∑Œñ¬∑Œó¬∑Œò¬∑Œô¬∑Œö¬∑Œõ¬∑Œú¬∑Œù¬∑Œû¬∑Œü¬∑Œ†¬∑Œ°¬∑Œ£¬∑œÇŒ§¬∑Œ•¬∑Œ¶¬∑Œß¬∑Œ®¬∑Œ©¬∑ !! !!##AUTHOR !!    John S. Urban !! !!##LICENSE !!     MIT impure function transliterate_uuu ( instr , old_set , new_set ) result ( outstr ) ! ident_15=\"@(#) M_unicode transliterate(3f) replace characters from old set with new set\" type ( unicode_type ), intent ( in ) :: instr ! input string to change type ( unicode_type ), intent ( in ) :: old_set ! set of characters to replace type ( unicode_type ), intent ( in ) :: new_set ! new characters to replace old characters type ( unicode_type ) :: outstr ! output string to generate integer :: i , ii , jj jj = size ( new_set % codes ) if ( jj /= 0 ) then outstr = instr ! initially assume output string equals input string stepthru : do i = 1 , size ( instr % codes ) ii = findloc ( old_set % codes , instr % codes ( i ), dim = 1 ) ! see if current character is in old_set if ( ii /= 0 ) then if ( ii <= jj ) then ! use corresponding character in new_set outstr % codes ( i ) = new_set % codes ( ii ) else outstr % codes ( i ) = new_set % codes ( jj ) ! new_set not as long as old_set; use last character in new_set endif endif enddo stepthru else ! new_set is null string so delete characters in old_set outstr % codes = [( 32 , i = 1 , size ( instr % codes ))] hopthru : do i = 1 , size ( instr % codes ) ii = findloc ( old_set % codes , instr % codes ( i ), dim = 1 ) ! see if current character is in old_set if ( ii == 0 ) then ! only keep characters not in old_set jj = jj + 1 outstr % codes ( jj ) = instr % codes ( i ) endif enddo hopthru endif end function transliterate_uuu !----------------------------------------------------------------------------------------------------------------------------------- function transliterate_uua ( instr , old_set , new_set ) result ( outstr ) type ( unicode_type ), intent ( in ) :: instr type ( unicode_type ), intent ( in ) :: old_set character ( len =* ), intent ( in ) :: new_set type ( unicode_type ) :: outstr outstr = transliterate_uuu ( instr , old_set , unicode_type ( new_set )) end function transliterate_uua !----------------------------------------------------------------------------------------------------------------------------------- function transliterate_uaa ( instr , old_set , new_set ) result ( outstr ) type ( unicode_type ), intent ( in ) :: instr character ( len =* ), intent ( in ) :: old_set character ( len =* ), intent ( in ) :: new_set type ( unicode_type ) :: outstr outstr = transliterate_uuu ( instr , unicode_type ( old_set ), unicode_type ( new_set )) end function transliterate_uaa !----------------------------------------------------------------------------------------------------------------------------------- function transliterate_aaa ( instr , old_set , new_set ) result ( outstr ) character ( len =* ), intent ( in ) :: instr character ( len =* ), intent ( in ) :: old_set character ( len =* ), intent ( in ) :: new_set type ( unicode_type ) :: outstr outstr = transliterate_uuu ( unicode_type ( instr ), unicode_type ( old_set ), unicode_type ( new_set )) end function transliterate_aaa !----------------------------------------------------------------------------------------------------------------------------------- function transliterate_uau ( instr , old_set , new_set ) result ( outstr ) type ( unicode_type ), intent ( in ) :: instr character ( len =* ), intent ( in ) :: old_set type ( unicode_type ), intent ( in ) :: new_set type ( unicode_type ) :: outstr outstr = transliterate_uuu ( instr , unicode_type ( old_set ), new_set ) end function transliterate_uau !----------------------------------------------------------------------------------------------------------------------------------- function transliterate_aau ( instr , old_set , new_set ) result ( outstr ) character ( len =* ), intent ( in ) :: instr character ( len =* ), intent ( in ) :: old_set type ( unicode_type ), intent ( in ) :: new_set type ( unicode_type ) :: outstr outstr = transliterate_uuu ( unicode_type ( instr ), unicode_type ( old_set ), new_set ) end function transliterate_aau !----------------------------------------------------------------------------------------------------------------------------------- function transliterate_aua ( instr , old_set , new_set ) result ( outstr ) character ( len =* ), intent ( in ) :: instr type ( unicode_type ), intent ( in ) :: old_set character ( len =* ), intent ( in ) :: new_set type ( unicode_type ) :: outstr outstr = transliterate_uuu ( unicode_type ( instr ), old_set , unicode_type ( new_set )) end function transliterate_aua !----------------------------------------------------------------------------------------------------------------------------------- function transliterate_auu ( instr , old_set , new_set ) result ( outstr ) character ( len =* ), intent ( in ) :: instr type ( unicode_type ), intent ( in ) :: old_set type ( unicode_type ), intent ( in ) :: new_set type ( unicode_type ) :: outstr outstr = transliterate_uuu ( unicode_type ( instr ), old_set , new_set ) end function transliterate_auu !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    get_env(3f) - [M_unicode:SYSTEM] return value of environment variable !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !! !!     impure elemental function get_env(name,default) result(out) !! !!      type(unicode_type),intent=(in) :: name !!      type(unicode_type),optional    :: default !!      type(unicode_type)             :: out !! !!##CHARACTERISTICS !!    NAME and DEFAULT may be default CHARACTER type as well. !! !!##DESCRIPTION !!    get_env(3) gets the value of the requested environment variable !!    as TYPE(UNICODE_TYPE) . !! !!##OPTIONS !!    name     name of environment variable to return the value of. !!             Typically the name may only contain the characters !!             A-Z,a-z,0-9 and underscore; but allowed values are !!             system-dependent. !!    default  value to return if environment variable NAME is not set !!             or set to a blank value !! !!##RETURNS !!    out      value assigned based on value of environment variable NAME !! !!##EXAMPLES !! !! !!  Sample program: !! !!     program demo_get_env !!     use M_unicode, only : get_env, ut=> unicode_type !!     use M_unicode, only : assignment(=), operator(//) !!     implicit none !!     type(ut) :: name !!     type(ut) :: default !!     type(ut) :: value !!     type(ut) :: smiley !!     integer  :: i !!     character(len=*),parameter :: bracket= '(1x,*(\"[\",a,\"]\",:))' !!        ! !!        smiley=128515 ! set with Unicode code point !!        name='UTF8'   ! set with ASCII !!        default='Have a nice day '//smiley//'!' ! set with unicode_type !!        ! !!        ! arguments can be type(unicode_type) or character !!        ! but type(unicode_type) is always returned !!        value=get_env(name,             default             ) !!        value=get_env(name%character(), default%character() ) !!        value=get_env(name,             default%character() ) !!        value=get_env(name%character(), default             ) !!        ! !!        write(*,*)value%character() !!        ! !!        ! print each glyph surrounded by brackets !!        write(*,bracket)(value%character(i,i),i=1,value%len()) !!        ! !!     end program demo_get_env !! !!   Results: !! !!     > Have a nice day üòÉ! !!     > [H][a][v][e][ ][a][ ][n][i][c][e][ ][d][a][y][ ][üòÉ][!] !! !!##AUTHOR !!      John S. Urban !! !!##LICENSE !!     MIT impure elemental function get_env_aa ( name , default ) result ( uvalue ) ! a function that makes calling get_environment_variable(3) simple use , intrinsic :: iso_fortran_env , only : stderr => ERROR_UNIT implicit none character ( len =* ), intent ( in ) :: name character ( len =* ), intent ( in ), optional :: default character ( len = :), allocatable :: value type ( unicode_type ) :: uvalue integer :: howbig integer :: stat integer :: length length = 0 value = \"\" if ( name . ne . \"\" ) then call get_environment_variable ( name , & & length = howbig , status = stat , trim_name = . true .) select case ( stat ) case ( 1 ) if (. not . present ( default )) then write ( stderr , * ) & & name , \" is not defined in the environment\" value = \"\" endif case ( 2 ) write ( stderr , * ) & & \"This processor does not support environment variables. Boooh!\" value = \"\" case default ! make string of sufficient size to hold value if ( allocated ( value )) deallocate ( value ) allocate ( character ( len = max ( howbig , 1 )) :: value ) ! get value call get_environment_variable ( & & name , value , status = stat , trim_name = . true .) if ( stat . ne . 0 ) value = \"\" end select endif if ( value . eq . \"\" . and . present ( default )) value = default uvalue = value end function get_env_aa impure elemental function get_env_uu ( name , default ) result ( value ) ! a function that makes calling get_environment_variable(3) simple type ( unicode_type ), intent ( in ) :: name type ( unicode_type ), intent ( in ), optional :: default type ( unicode_type ) :: value character ( len = :), allocatable :: temp1 character ( len = :), allocatable :: temp2 integer :: nerr call codepoints_to_utf8_str ( name % codes , temp1 , nerr ) if ( present ( default )) then call codepoints_to_utf8_str ( default % codes , temp2 , nerr ) value = get_env_aa ( temp1 , temp2 ) else value = get_env_aa ( temp1 ) endif end function get_env_uu impure elemental function get_env_au ( name , default ) result ( value ) ! a function that makes calling get_environment_variable(3) simple character ( len =* ), intent ( in ) :: name type ( unicode_type ), intent ( in ) :: default type ( unicode_type ) :: value character ( len = :), allocatable :: temp integer :: nerr call codepoints_to_utf8_str ( default % codes , temp , nerr ) value = get_env_aa ( name , temp ) end function get_env_au impure elemental function get_env_ua ( name , default ) result ( value ) ! a function that makes calling get_environment_variable(3) simple type ( unicode_type ), intent ( in ) :: name character ( len =* ), intent ( in ) :: default type ( unicode_type ) :: value character ( len = :), allocatable :: temp integer :: nerr call codepoints_to_utf8_str ( name % codes , temp , nerr ) value = get_env_aa ( temp , default ) end function get_env_ua !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!    get_arg(3f) - [M_unicode:SYSTEM] get command line argument !!    (LICENSE:MIT) !! !!##SYNOPSIS !! !! !!     impure elemental function get_arg(position,default) result(out) !! !!      integer,intent=(in)         :: position !!      type(unicode_type),optional :: default !!      type(unicode_type)          :: out !! !!##CHARACTERISTICS !!    DEFAULT may be default CHARACTER type as well. !! !!##DESCRIPTION !!    get_arg(3) gets the value of the requested command line argument !!    as TYPE(UNICODE_TYPE) . !! !!##OPTIONS !!    position  Position on command line of requested argument. Zero returns !!              the name of the command executed. Non-existent positions !!              default to returning a null string. !! !!    default  value to return if argument is not set or set to a blank value !! !!##RETURNS !!    out      value assigned based on value of environment variable NAME !! !!##EXAMPLES !! !! !!  Sample program: !! !!     program demo_get_arg !!     use M_unicode, only : get_arg, ut=> unicode_type, ch=>character !!     use M_unicode, only : assignment(=), operator(//), write(formatted) !!     implicit none !!     integer  :: position !!     type(ut) :: default !!     type(ut) :: value !!     type(ut) :: smiley !!     integer  :: i !!     character(len=*),parameter :: bracket= '(1x,*(\"[\",a,\"]\",:))' !!        ! !!        smiley=128515 ! set with Unicode code point !!        default='Wish I was first '//smiley//'!' ! set with unicode_type !!        ! !!        ! arguments can be type(unicode_type) or character !!        ! but type(unicode_type) is always returned !!        do position=0,command_argument_count() !!           value=get_arg(position, default             ) !!           value=get_arg(position, default%character() ) !!           ! !!           write(*,*)value%character() !!           write(*,'(DT)')default%get_arg(position) !!           ! !!           ! print each glyph surrounded by brackets !!           write(*,bracket)(value%character(i,i),i=1,value%len()) !!        enddo !!        ! !!     end program demo_get_arg !! !!   Results: !! !!    > demo_get_arg !!    > demo_get_arg !!    > [d][e][m][o][_][g][e][t][_][a][r][g] !! !!##AUTHOR !!      John S. Urban !! !!##LICENSE !!     MIT impure elemental function get_arg_ia ( position , default ) result ( value ) ! get nth argument from command line integer , intent ( in ) :: position character ( len =* ), intent ( in ), optional :: default character ( len = :), allocatable :: temp type ( unicode_type ) :: value integer :: argument_length , istat call get_command_argument ( number = position , length = argument_length ) if ( allocated ( temp )) deallocate ( temp ) allocate ( character ( len = argument_length ) :: temp ) temp (:) = '' call get_command_argument ( position , temp , status = istat ) if ( present ( default )) then if ( temp . eq . '' ) temp = default endif value = temp end function get_arg_ia impure elemental function get_arg_iu ( position , default ) result ( value ) integer , intent ( in ) :: position type ( unicode_type ), intent ( in ) :: default character ( len = :), allocatable :: temp type ( unicode_type ) :: value integer :: nerr call codepoints_to_utf8_str ( default % codes , temp , nerr ) value = get_arg_ia ( position , temp ) end function get_arg_iu !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_transliterate_uu ( self , old_set , new_set ) result ( outstr ) class ( unicode_type ), intent ( in ) :: self type ( unicode_type ), intent ( in ) :: old_set type ( unicode_type ), intent ( in ) :: new_set type ( unicode_type ) :: outstr outstr = transliterate_uuu ( self , old_set , new_set ) end function oop_transliterate_uu !=================================================================================================================================== function oop_transliterate_ua ( self , old_set , new_set ) result ( outstr ) class ( unicode_type ), intent ( in ) :: self type ( unicode_type ), intent ( in ) :: old_set character ( len =* ), intent ( in ) :: new_set type ( unicode_type ) :: outstr outstr = transliterate_uua ( self , old_set , new_set ) end function oop_transliterate_ua !=================================================================================================================================== function oop_transliterate_aa ( self , old_set , new_set ) result ( outstr ) class ( unicode_type ), intent ( in ) :: self character ( len =* ), intent ( in ) :: old_set character ( len =* ), intent ( in ) :: new_set type ( unicode_type ) :: outstr outstr = transliterate_uaa ( self , old_set , new_set ) end function oop_transliterate_aa !=================================================================================================================================== function oop_transliterate_au ( self , old_set , new_set ) result ( outstr ) class ( unicode_type ), intent ( in ) :: self character ( len =* ), intent ( in ) :: old_set type ( unicode_type ), intent ( in ) :: new_set type ( unicode_type ) :: outstr outstr = transliterate_uau ( self , old_set , new_set ) end function oop_transliterate_au !=================================================================================================================================== function oop_replace_uuu ( self , old , new , occurrence , repeat , ignorecase , changes , back ) result ( newline ) class ( unicode_type ), intent ( in ) :: self ! input line to be changed type ( unicode_type ), intent ( in ) :: old ! old substring to replace type ( unicode_type ), intent ( in ) :: new ! new substring integer , intent ( in ), optional :: occurrence ! Nth occurrence of OLD string to start replacement at integer , intent ( in ), optional :: repeat ! how many replacements logical , intent ( in ), optional :: ignorecase logical , intent ( in ), optional :: back integer , intent ( out ), optional :: changes ! number of changes made ! returns type ( unicode_type ) :: newline ! output string newline = replace ( self , old , new , occurrence = occurrence , repeat = repeat , ignorecase = ignorecase , changes = changes , back = back ) end function oop_replace_uuu !=================================================================================================================================== function oop_replace_uaa ( self , old , new , occurrence , repeat , ignorecase , changes , back ) result ( newline ) class ( unicode_type ), intent ( in ) :: self ! input line to be changed character ( len =* ), intent ( in ) :: old ! old substring to replace character ( len =* ), intent ( in ) :: new ! new substring integer , intent ( in ), optional :: occurrence ! Nth occurrence of OLD string to start replacement at integer , intent ( in ), optional :: repeat ! how many replacements logical , intent ( in ), optional :: ignorecase logical , intent ( in ), optional :: back integer , intent ( out ), optional :: changes ! number of changes made ! returns type ( unicode_type ) :: newline ! output string newline = replace ( self , unicode_type ( old ), unicode_type ( new ), & & occurrence = occurrence , repeat = repeat , ignorecase = ignorecase , changes = changes , back = back ) end function oop_replace_uaa !=================================================================================================================================== function oop_replace_uau ( self , old , new , occurrence , repeat , ignorecase , changes , back ) result ( newline ) class ( unicode_type ), intent ( in ) :: self ! input line to be changed character ( len =* ), intent ( in ) :: old ! old substring to replace type ( unicode_type ), intent ( in ) :: new ! new substring integer , intent ( in ), optional :: occurrence ! Nth occurrence of OLD string to start replacement at integer , intent ( in ), optional :: repeat ! how many replacements logical , intent ( in ), optional :: ignorecase logical , intent ( in ), optional :: back integer , intent ( out ), optional :: changes ! number of changes made ! returns type ( unicode_type ) :: newline ! output string newline = replace ( self , unicode_type ( old ), new , & & occurrence = occurrence , repeat = repeat , ignorecase = ignorecase , changes = changes , back = back ) end function oop_replace_uau !=================================================================================================================================== function oop_replace_uua ( self , old , new , occurrence , repeat , ignorecase , changes , back ) result ( newline ) class ( unicode_type ), intent ( in ) :: self ! input line to be changed type ( unicode_type ), intent ( in ) :: old ! old substring to replace character ( len =* ), intent ( in ) :: new ! new substring integer , intent ( in ), optional :: occurrence ! Nth occurrence of OLD string to start replacement at integer , intent ( in ), optional :: repeat ! how many replacements logical , intent ( in ), optional :: ignorecase logical , intent ( in ), optional :: back integer , intent ( out ), optional :: changes ! number of changes made ! returns type ( unicode_type ) :: newline ! output string newline = replace ( self , old , unicode_type ( new ), & & occurrence = occurrence , repeat = repeat , ignorecase = ignorecase , changes = changes , back = back ) end function oop_replace_uua !=================================================================================================================================== function oop_section_uu ( self , start , end , new ) result ( newline ) class ( unicode_type ), intent ( in ) :: self ! input line to be changed integer , intent ( in ) :: start integer , intent ( in ) :: end type ( unicode_type ), intent ( in ) :: new ! new substring type ( unicode_type ) :: newline ! output string newline = section_uu ( self , start , end , new ) end function oop_section_uu !=================================================================================================================================== function oop_section_ua ( self , start , end , new ) result ( newline ) class ( unicode_type ), intent ( in ) :: self ! input line to be changed integer , intent ( in ) :: start integer , intent ( in ) :: end character ( len =* ), intent ( in ) :: new ! new substring type ( unicode_type ) :: newline ! output string newline = section_ua ( self , start , end , new ) end function oop_section_ua !=================================================================================================================================== function oop_fmt ( self , format ) result ( string_out ) class ( unicode_type ), intent ( in ) :: self character ( len =* ), optional :: format type ( unicode_type ) :: string_out string_out = fmt ( self , format ) end function oop_fmt !=================================================================================================================================== function oop_expandtabs ( self , tab_size ) result ( string_out ) class ( unicode_type ), intent ( in ) :: self integer , intent ( in ), optional :: tab_size type ( unicode_type ) :: string_out string_out = expandtabs ( self , tab_size ) end function oop_expandtabs !=================================================================================================================================== function oop_escape ( self , protect ) result ( string_out ) class ( unicode_type ), intent ( in ) :: self character ( len = 1 ), intent ( in ), optional :: protect type ( unicode_type ) :: string_out string_out = escape ( self , protect ) end function oop_escape !=================================================================================================================================== function oop_upper ( self ) result ( string_out ) class ( unicode_type ), intent ( in ) :: self type ( unicode_type ) :: string_out string_out = upper ( self ) end function oop_upper !=================================================================================================================================== function oop_lower ( self ) result ( string_out ) class ( unicode_type ), intent ( in ) :: self type ( unicode_type ) :: string_out string_out = lower ( self ) end function oop_lower !=================================================================================================================================== function oop_adjustl ( self , glyphs ) result ( string_out ) class ( unicode_type ), intent ( in ) :: self integer , intent ( in ), optional :: glyphs type ( unicode_type ) :: string_out string_out = adjustl_str ( self , glyphs ) end function oop_adjustl !=================================================================================================================================== function oop_adjustr ( self , glyphs ) result ( string_out ) class ( unicode_type ), intent ( in ) :: self integer , intent ( in ), optional :: glyphs type ( unicode_type ) :: string_out string_out = adjustr_str ( self , glyphs ) end function oop_adjustr !=================================================================================================================================== function oop_sub ( self , first , last , step ) result ( str_out ) class ( unicode_type ), intent ( in ) :: self integer , intent ( in ), optional :: first , last , step type ( unicode_type ) :: str_out str_out = sub ( self , first , last , step ) end function oop_sub !=================================================================================================================================== function oop_get_arg_iu ( self , position ) result ( value ) class ( unicode_type ), intent ( in ) :: self integer , intent ( in ) :: position type ( unicode_type ) :: value value = get_arg_iu ( position , self ) end function oop_get_arg_iu !=================================================================================================================================== function oop_get_env_ua ( self , default ) result ( value ) class ( unicode_type ), intent ( in ) :: self character ( len =* ), intent ( in ) :: default type ( unicode_type ) :: value value = get_env_ua ( self , default ) end function oop_get_env_ua !=================================================================================================================================== function oop_get_env_uu ( self , default ) result ( value ) class ( unicode_type ), intent ( in ) :: self type ( unicode_type ), intent ( in ) :: default type ( unicode_type ) :: value value = get_env_uu ( self , default ) end function oop_get_env_uu !=================================================================================================================================== function oop_join ( self , array , clip ) result ( out ) ! ident_16=\"@(#) M_unicode oop_join(3f) merge string array into a single string value adding specified separator\" class ( unicode_type ), intent ( in ) :: self type ( unicode_type ), intent ( in ) :: array (:) logical , intent ( in ), optional :: clip type ( unicode_type ) :: out if ( allocated ( self % codes )) then out = join ( array , self , clip ) else out = join ( array , unicode_type ( '' ), clip ) endif end function oop_join !=================================================================================================================================== function oop_pad ( self , length , pattern , right , clip ) result ( out ) ! ident_17=\"@(#) M_unicode pad(3f) pad string with repeating pattern to at least specified length\" class ( unicode_type ), intent ( in ) :: self ! input line to be changed integer , intent ( in ) :: length type ( unicode_type ), intent ( in ), optional :: pattern logical , optional , intent ( in ) :: right logical , optional , intent ( in ) :: clip ! returns type ( unicode_type ) :: out out = pad ( self , length , pattern , right , clip ) end function oop_pad !=================================================================================================================================== function oop_character ( self , first , last , step ) result ( str_out ) class ( unicode_type ), intent ( in ) :: self integer , intent ( in ), optional :: first , last , step character ( len = :), allocatable :: str_out integer :: start , end , inc type ( unicode_type ) :: temp integer :: which which = 4 * merge ( 1 , 0 , present ( first )) + 2 * merge ( 1 , 0 , present ( last )) + 1 * merge ( 1 , 0 , present ( step )) select case ( which ) case ( int ( b '000' )) ; start = 1 ; end = len ( self ) ; inc = 1 case ( int ( b '001' )) ; start = 1 ; end = len ( self ) ; inc = step case ( int ( b '010' )) ; start = 1 ; end = last ; inc = 1 case ( int ( b '011' )) ; start = 1 ; end = last ; inc = step case ( int ( b '100' )) ; start = first ; end = first ; inc = 1 case ( int ( b '101' )) ; start = first ; end = len ( self ) ; inc = step case ( int ( b '110' )) ; start = first ; end = last ; inc = 1 case ( int ( b '111' )) ; start = first ; end = last ; inc = step end select temp = self % codes ( start : end : inc ) str_out = str_to_char ( temp ) end function oop_character !=================================================================================================================================== function oop_byte ( self , first , last , step ) result ( bytes_out ) class ( unicode_type ), intent ( in ) :: self integer , intent ( in ), optional :: first , last , step character ( len = 1 ), allocatable :: bytes_out (:) bytes_out = s2a ( oop_character ( self , first , last , step )) end function oop_byte !=================================================================================================================================== ! return codepoint value of first character as is done by intrinsic ichar() elemental function oop_ichar ( self ) result ( code ) class ( unicode_type ), intent ( in ) :: self integer :: code if ( size ( self % codes ) == 0 ) then code = 0 else code = self % codes ( 1 ) endif end function oop_ichar !=================================================================================================================================== function oop_codepoint ( self , first , last , step ) result ( codes_out ) class ( unicode_type ), intent ( in ) :: self integer , allocatable :: codes_out (:) integer , intent ( in ), optional :: first , last , step integer :: start , end , inc integer :: which which = 4 * merge ( 1 , 0 , present ( first )) + 2 * merge ( 1 , 0 , present ( last )) + 1 * merge ( 1 , 0 , present ( step )) select case ( which ) case ( int ( b '000' )) ; start = 1 ; end = len ( self ) ; inc = 1 case ( int ( b '001' )) ; start = 1 ; end = len ( self ) ; inc = step case ( int ( b '010' )) ; start = 1 ; end = last ; inc = 1 case ( int ( b '011' )) ; start = 1 ; end = last ; inc = step case ( int ( b '100' )) ; start = first ; end = first ; inc = 1 case ( int ( b '101' )) ; start = first ; end = len ( self ) ; inc = step case ( int ( b '110' )) ; start = first ; end = last ; inc = 1 case ( int ( b '111' )) ; start = first ; end = last ; inc = step end select codes_out = self % codes ( start : end : inc ) end function oop_codepoint !=================================================================================================================================== impure function oop_verify ( self , set , back ) result ( pos ) class ( unicode_type ), intent ( in ) :: self class ( unicode_type ), intent ( in ) :: set logical , intent ( in ), optional :: back integer :: pos pos = verify_uu ( self , set , back = back ) end function oop_verify !=================================================================================================================================== pure function oop_scan ( self , set , back ) result ( pos ) class ( unicode_type ), intent ( in ) :: self class ( unicode_type ), intent ( in ) :: set logical , optional , intent ( in ) :: back integer :: pos pos = scan_uu ( self , set , back = back ) end function oop_scan !=================================================================================================================================== function oop_tokenize ( self , set ) result ( tokens ) class ( unicode_type ), intent ( in ) :: self type ( unicode_type ), intent ( in ) :: set type ( unicode_type ), allocatable :: tokens (:) integer , allocatable :: begin (:) integer , allocatable :: end (:) integer :: i call split ( self , set , begin , end ) if ( allocated ( tokens )) deallocate ( tokens ) allocate ( tokens ( size ( begin ))) do i = 1 , size ( begin ) tokens ( i ) = self % character ( begin ( i ), end ( i )) enddo end function oop_tokenize !=================================================================================================================================== function oop_split ( self , set ) result ( tokens ) class ( unicode_type ), intent ( in ) :: self type ( unicode_type ), intent ( in ) :: set type ( unicode_type ), allocatable :: tokens (:) call split ( self , set , tokens ) end function oop_split !=================================================================================================================================== pure function oop_trim ( self ) result ( string_out ) class ( unicode_type ), intent ( in ) :: self type ( unicode_type ) :: string_out string_out = trim ( self ) end function oop_trim !=================================================================================================================================== pure function oop_len_trim ( self ) result ( len_trim_out ) class ( unicode_type ), intent ( in ) :: self integer :: len_trim_out len_trim_out = len_trim ( self ) end function oop_len_trim !=================================================================================================================================== pure function oop_len ( self ) result ( len_out ) class ( unicode_type ), intent ( in ) :: self integer :: len_out len_out = len ( self ) end function oop_len !=================================================================================================================================== impure function oop_index ( self , substring ) result ( index_out ) class ( unicode_type ), intent ( in ) :: self class ( * ), intent ( in ) :: substring integer :: index_out select type ( substring ) type is ( character ( len =* )) index_out = index ( self , unicode_type ( substring )) type is ( unicode_type ) index_out = index ( self , substring ) class default stop '<ERROR>*oop_index* unknown type' end select end function oop_index !=================================================================================================================================== impure function oop_eq ( self , string ) result ( is_eq ) class ( unicode_type ), intent ( in ) :: self class ( * ), intent ( in ) :: string logical :: is_eq select type ( string ) type is ( character ( len =* )) is_eq = leq_str_char ( self , string ) type is ( unicode_type ) is_eq = leq_str_str ( self , string ) class default stop '<ERROR>*oop_eq* unknown type' end select end function oop_eq !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!     READLINE(3f) - [M_unicode:READ] read a line from specified LUN into !!                    string up to line length limit !!                    (LICENSE:MIT) !! !!##SYNTAX !!    function readline(lun,iostat) result(line) !! !!     integer,intent(in),optional  :: lun !!     integer,intent(out),optional :: iostat !!     type(unicode_type)           :: line !! !!##DESCRIPTION !!    Read a line of any length up to programming environment maximum !!    line length. Requires Fortran 2003+. !! !!    It is primarily expected to be used when reading input which will !!    then be parsed. !! !!    The input file must have a PAD attribute of YES for the function !!    to work properly, which is typically true. !! !!    The simple use of a loop that repeatedly re-allocates a character !!    variable in addition to reading the input file one buffer at a !!    time could (depending on the programming environment used) be !!    inefficient, as it could reallocate and allocate memory used for !!    the output string with each buffer read. !! !!##OPTIONS !!     LUN     optional LUN (Fortran logical I/O unit) number. Defaults !!             to stdin. !!     IOSTAT  status returned by READ(IOSTAT=IOS). If not zero, an error !!             occurred or an end-of-file or end-of-record was encountered. !!##RETURNS !!     LINE    line read. !!             if IOSTAT is not zero, LINE returns the I/O error message. !! !!##EXAMPLE !! !! !!    Sample program: !! !!     program demo_readline !!     use,intrinsic :: iso_fortran_env, only : stdin=>input_unit !!     use,intrinsic :: iso_fortran_env, only : iostat_end !!     use M_unicode, only : readline, len, trim !!     use M_unicode, only : assignment(=), ch=>character, ut=>unicode_type !!     implicit none !!     type(ut)                     :: line !!     character(len=:),allocatable :: aline !!     integer,allocatable          :: ints(:) !!     integer                      :: iostat !!        open(unit=stdin,pad='yes') !!        ! !!        INFINITE: do !!           line=readline(iostat=iostat) !!           if(iostat.ne.0)exit !!           ! write the length, line in brackets and its Unicode codepoints !!           write(*,'(*(g0,1x))')len(line),'['//ch(line)//']',line%codepoint() !!           ! or assign the string to an allocatable array of integers !!           ints=line !!           ! and the string to a character variable !!           aline=line !!           write(*,'(*(g0,1x))')len(line),'['//ch(line)//']',ints !!        enddo INFINITE !!        ! !!        if(iostat /= iostat_end)then !!           write(*,*)'error reading input:',ch(trim(line)) !!        endif !!        ! !!     end program demo_readline !! !!##AUTHOR !!     John S. Urban !! !!##LICENSE !!     MIT function readline ( lun , iostat ) result ( line ) implicit none ! ident_18=\"@(#) M_unicode readline(3f) read a line from specified LUN into string up to line length limit\" type ( unicode_type ) :: line integer , intent ( in ), optional :: lun integer , intent ( out ), optional :: iostat integer :: iostat_local character ( len = 4096 ) :: message integer , parameter :: buflen = 1024 character ( len = :), allocatable :: line_local character ( len = buflen ) :: buffer integer :: isize integer :: lun_local line_local = '' iostat_local = 0 if ( present ( lun )) then lun_local = lun else lun_local = stdin endif INFINITE : do ! read characters from line and append to result read ( lun_local , pad = 'yes' , iostat = iostat_local , fmt = '(a)' , advance = 'no' , & & size = isize , iomsg = message ) buffer ! read next buffer (might use stream I/O for files ! other than stdin so system line limit is not limiting if ( isize > 0 ) line_local = line_local // buffer (: isize ) ! append what was read to result if ( is_iostat_eor ( iostat_local )) then ! if hit EOR reading is complete unless backslash ends the line iostat_local = 0 ! hitting end of record is not an error for this routine exit INFINITE ! end of reading line elseif ( iostat_local /= 0 ) then ! end of file or error line = trim ( message ) exit INFINITE endif enddo INFINITE line = line_local ! trim line if ( present ( iostat )) iostat = iostat_local end function readline !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!     FMT(3f) - [M_unicode:CONVERSION] convert any intrinsic to a string using specified format !!     (LICENSE:MIT) !!##SYNOPSIS !! !! !!     function fmt(value,format) result(string) !! !!      class(*),intent(in),optional           :: value !! !!      character(len=*),intent(in),optional   :: format !!         or !!      type(unicode_type),intent(in),optional :: format !! !!      type(unicode_type)                     :: string !!##DESCRIPTION !!     FMT(3f) converts any standard intrinsic value to a string using the specified !!     format. !!##OPTIONS !!     value    value to print the value of. May be of type INTEGER, LOGICAL, !!              REAL, DOUBLEPRECISION, COMPLEX, or CHARACTER as well as !!              TYPE(UNICODE_TYPE). !!     format   format to use to print value. It is up to the user to use an !!              appropriate format. The format does not require being !!              surrounded by parenthesis. If not present a default is selected !!              similar to what would be produced with free format, with !!              trailing zeros removed. !!##RETURNS !!     string   A string value !!##EXAMPLES !! !! !!    Sample program: !! !!      program demo_fmt !!      use :: M_unicode, only : fmt, assignment(=) !!      use :: M_unicode, only : ut=>unicode_type, ch=>character !!      implicit none !!      character(len=:),allocatable :: Astr, Aformat !!      type(ut) :: Ustr !!         ! format can be CHARACTER !!         Aformat=\"('[',i0,']')\" !!         Astr=fmt(10,Aformat) !!         write(*,*)'result is ',Astr !!         ! format can be string !!         Astr=fmt(10.0/3.0,ut(\"'[',g0.5,']'\")) !!         write(*,*)'result is ',Astr !!         ! Output is a string, so use ch() !!         write(*,*)'result is ', ch(fmt(.true.,\"'The answer is [',g0,']'\")) !!         ! OOP !!         Ustr='A B C' !!         Ustr=Ustr%fmt(\"'[',g0,']'\") !!         write(*,*)'result is ',ch(Ustr) !!      end program demo_fmt !! !!    Results: !! !!      result is [10] !!      result is [3.3333] !!      result is The final answer is [T] !!      result is [A B C] !! !!##AUTHOR !!     John S. Urban !! !!##LICENSE !!     MIT recursive function afmt ( generic , format ) result ( line ) ! ident_19=\"@(#) M_unicode afmt(3f) convert any intrinsic to a CHARACTER variable using specified format\" class ( * ), intent ( in ) :: generic character ( len =* ), intent ( in ), optional :: format character ( len = :), allocatable :: line character ( len = :), allocatable :: fmt_local character ( len = :), allocatable :: re , im integer :: iostat character ( len = 255 ) :: iomsg character ( len = 1 ), parameter :: null = char ( 0 ) integer :: iilen logical :: trimit if ( present ( format )) then fmt_local = format trimit = . false . else fmt_local = '' trimit = . true . endif ! add \",a\" and print null and use position of null to find length of output ! add cannot use SIZE= or POS= or ADVANCE='NO' on WRITE() on INTERNAL READ, ! and do not want to trim as trailing spaces can be significant if ( fmt_local == '' ) then select type ( generic ) type is ( integer ( kind = int8 )); fmt_local = '(i0,a)' type is ( integer ( kind = int16 )); fmt_local = '(i0,a)' type is ( integer ( kind = int32 )); fmt_local = '(i0,a)' type is ( integer ( kind = int64 )); fmt_local = '(i0,a)' type is ( real ( kind = real32 )); fmt_local = '(1pg0,a)' type is ( real ( kind = real64 )); fmt_local = '(1pg0,a)' #ifdef FLOAT128 type is ( real ( kind = real128 )); fmt_local = '(1pg0,a)' #endif type is ( logical ); fmt_local = '(l1,a)' type is ( character ( len =* )); fmt_local = '(a,a)' trimit = . false . type is ( unicode_type ); fmt_local = '(a,a)' trimit = . false . type is ( complex ); fmt_local = '(\"(\",1pg0,\",\",1pg0,\")\",a)' type is ( complex ( kind = real64 )); fmt_local = '(\"(\",1pg0,\",\",1pg0,\")\",a)' class default fmt_local = '(*(g0,1x)' stop '<ERROR>*afmt* unknown type.' end select else if ( format ( 1 : 1 ) == '(' ) then fmt_local = format (: len_trim ( format ) - 1 ) // ',a)' else fmt_local = '(' // fmt_local // ',a)' endif endif if ( allocated ( line )) deallocate ( line ) allocate ( character ( len = 256 ) :: line ) ! cannot currently write into allocatable variable iostat = 0 select type ( generic ) type is ( integer ( kind = int8 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , null type is ( integer ( kind = int16 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , null type is ( integer ( kind = int32 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , null type is ( integer ( kind = int64 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , null type is ( real ( kind = real32 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , null type is ( real ( kind = real64 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , null #ifdef FLOAT128 type is ( real ( kind = real128 )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , null #endif type is ( logical ); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , null type is ( character ( len =* )); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , null type is ( unicode_type ); write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) character ( generic ), null type is ( complex ); if ( trimit ) then re = afmt ( real ( generic )) im = afmt ( aimag ( generic )) call trimzeros_ ( re ) call trimzeros_ ( im ) fmt_local = '(\"(\",g0,\",\",g0,\")\",a)' write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) trim ( re ), trim ( im ), null trimit = . false . else write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , null endif type is ( complex ( kind = real64 )); if ( trimit ) then re = afmt ( real ( generic )) im = afmt ( aimag ( generic )) call trimzeros_ ( re ) call trimzeros_ ( im ) fmt_local = '(\"(\",g0,\",\",g0,\")\",a)' write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) trim ( re ), trim ( im ), null trimit = . false . else write ( line , fmt_local , iostat = iostat , iomsg = iomsg ) generic , null endif class default stop '<ERROR>*afmt* unknown type' end select if ( iostat /= 0 ) then line = '<ERROR>' // trim ( iomsg ) else iilen = index ( line , null , back = . true .) if ( iilen == 0 ) iilen = len ( line ) line = line (: iilen - 1 ) endif if ( index ( line , '.' ) /= 0 . and . trimit ) call trimzeros_ ( line ) end function afmt !=================================================================================================================================== recursive function fmt_ga ( generic , format ) result ( line ) ! ident_20=\"@(#) M_unicode afmt(3f) convert any intrinsic to a CHARACTER variable using specified format\" class ( * ), intent ( in ) :: generic character ( len =* ), intent ( in ), optional :: format type ( unicode_type ) :: line line = afmt ( generic , format ) end function fmt_ga recursive function fmt_gs ( generic , format ) result ( line ) ! ident_21=\"@(#) M_unicode afmt(3f) convert any intrinsic to a CHARACTER variable using specified format\" class ( * ), intent ( in ) :: generic type ( unicode_type ), intent ( in ) :: format type ( unicode_type ) :: line character ( len = :), allocatable :: aformat aformat = format line = afmt ( generic , aformat ) end function fmt_gs !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> !!##NAME !!     TRIMZEROS_(3fp) - [M_unicode:EDITING] Delete trailing zeros from !!     numeric decimal string !!     (LICENSE:MIT) !! !!##SYNOPSIS !! !! !!     subroutine trimzeros_(str) !! !!      character(len=*)  :: str !! !!##DESCRIPTION !!     TRIMZEROS_(3f) deletes trailing zeros from a string representing a !!     number. If the resulting string would end in a decimal point, one !!     trailing zero is added. !! !!##OPTIONS !!     str   input string will be assumed to be a numeric value and have !!           trailing zeros removed !!##EXAMPLES !! !! !!     Sample program: !! !!        program demo_trimzeros_ !!        use M_unicode, only : trimzeros_ !!        character(len=:),allocatable :: string !!           string= '123.450000000000' !!           call trimzeros_(string) !!           write(*,*)string !!           string='12345' !!           call trimzeros_(string) !!           write(*,*)string !!           string='12345.' !!           call trimzeros_(string) !!           write(*,*)string !!           string='12345.00e3' !!           call trimzeros_(string) !!           write(*,*)string !!        end program demo_trimzeros_ !! !!    Results: !! !!      > 123.45 !!      > 12345 !!      > 12345 !!      > 12345e3 !! !!##AUTHOR !!     John S. Urban !! !!##LICENSE !!     MIT subroutine trimzeros_ ( string ) ! ident_22=\"@(#) M_unicode trimzeros_(3fp) Delete trailing zeros from numeric decimal string\" ! if zero needs added at end assumes input string has room character ( len =* ) :: string character ( len = len ( string ) + 2 ) :: str character ( len = len ( string )) :: eexp ! the exponent string if present integer :: ipos ! where exponent letter appears if present integer :: i , ii intrinsic scan , index , len_trim !intrinsic operator(//)  ! any way to do something like this? str = string ! working copy of string ipos = scan ( str , 'eEdD' ) ! find end of real number if string uses exponent notation if ( ipos > 0 ) then ! letter was found eexp = str ( ipos :) ! keep exponent string so it can be added back as a suffix str = str ( 1 : ipos - 1 ) ! just the real part, exponent removed will not have trailing zeros removed endif if ( index ( str , '.' ) == 0 ) then ! if no decimal character in original string add one to end of string ii = len_trim ( str ) str ( ii + 1 : ii + 1 ) = '.' ! add decimal to end of string endif do i = len_trim ( str ), 1 , - 1 ! scanning from end find a non-zero character select case ( str ( i : i )) case ( '0' ) ! found a trailing zero so keep trimming cycle case ( '.' ) ! found a decimal character at end of remaining string if ( i <= 1 ) then str = '0' else str = str ( 1 : i - 1 ) endif exit case default str = str ( 1 : i ) ! found a non-zero character so trim string and exit exit end select end do if ( ipos > 0 ) then ! if originally had an exponent place it back on string = trim ( str ) // trim ( eexp ) else string = str endif end subroutine trimzeros_ !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function concat_uu_ ( lhs , rhs ) result ( string ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs type ( unicode_type ) :: string1 , string2 , string string1 = fmt ( lhs ) string2 = fmt ( rhs ) string % codes = [ string1 % codes , string2 % codes ] end function concat_uu_ !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! worked fine with gfortran, ifx produced an error ! ././src/M_unicode.F90(5530): error #9186: The dummy arguments of the ! specific procedure defining a defined assignment or defined operator ! cannot both be unlimited polymorphic. [CONCAT_G_G] ! function concat_g_g ( lhs , rhs ) result ( string ) ! ident_23=\"@(#) M_overload g_g(3f) convert two single intrinsic values or strings to a string\" ! ! use this instead of str() so character variables are not trimmed and/or spaces are not added class ( * ), intent ( in ) :: lhs , rhs type ( unicode_type ) :: string1 , string2 , string string1 = fmt ( lhs ) string2 = fmt ( rhs ) string % codes = [ string1 % codes , string2 % codes ] end function concat_g_g !=================================================================================================================================== ! maybe concat_g_g is non-standard, but intel compiler requires naming everything function concat_u_g ( lhs , rhs ) result ( string ) type ( unicode_type ), intent ( in ) :: lhs class ( * ), intent ( in ) :: rhs type ( unicode_type ) :: string1 , string2 , string string1 = fmt ( lhs ) string2 = fmt ( rhs ) string % codes = [ string1 % codes , string2 % codes ] end function concat_u_g function concat_g_u ( lhs , rhs ) result ( string ) class ( * ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs type ( unicode_type ) :: string1 , string2 , string string1 = fmt ( lhs ) string2 = fmt ( rhs ) string % codes = [ string1 % codes , string2 % codes ] end function concat_g_u function concat_i_g ( lhs , rhs ) result ( string ) integer , intent ( in ) :: lhs class ( * ), intent ( in ) :: rhs type ( unicode_type ) :: string1 , string2 , string string1 = fmt ( lhs ) string2 = fmt ( rhs ) string % codes = [ string1 % codes , string2 % codes ] end function concat_i_g function concat_g_i ( lhs , rhs ) result ( string ) class ( * ), intent ( in ) :: lhs integer , intent ( in ) :: rhs type ( unicode_type ) :: string1 , string2 , string string1 = fmt ( lhs ) string2 = fmt ( rhs ) string % codes = [ string1 % codes , string2 % codes ] end function concat_g_i function concat_r_g ( lhs , rhs ) result ( string ) real , intent ( in ) :: lhs class ( * ), intent ( in ) :: rhs type ( unicode_type ) :: string1 , string2 , string string1 = fmt ( lhs ) string2 = fmt ( rhs ) string % codes = [ string1 % codes , string2 % codes ] end function concat_r_g function concat_g_r ( lhs , rhs ) result ( string ) class ( * ), intent ( in ) :: lhs real , intent ( in ) :: rhs type ( unicode_type ) :: string1 , string2 , string string1 = fmt ( lhs ) string2 = fmt ( rhs ) string % codes = [ string1 % codes , string2 % codes ] end function concat_g_r function concat_d_g ( lhs , rhs ) result ( string ) doubleprecision , intent ( in ) :: lhs class ( * ), intent ( in ) :: rhs type ( unicode_type ) :: string1 , string2 , string string1 = fmt ( lhs ) string2 = fmt ( rhs ) string % codes = [ string1 % codes , string2 % codes ] end function concat_d_g function concat_g_d ( lhs , rhs ) result ( string ) class ( * ), intent ( in ) :: lhs doubleprecision , intent ( in ) :: rhs type ( unicode_type ) :: string1 , string2 , string string1 = fmt ( lhs ) string2 = fmt ( rhs ) string % codes = [ string1 % codes , string2 % codes ] end function concat_g_d function concat_c_g ( lhs , rhs ) result ( string ) complex , intent ( in ) :: lhs class ( * ), intent ( in ) :: rhs type ( unicode_type ) :: string1 , string2 , string string1 = fmt ( lhs ) string2 = fmt ( rhs ) string % codes = [ string1 % codes , string2 % codes ] end function concat_c_g function concat_g_c ( lhs , rhs ) result ( string ) class ( * ), intent ( in ) :: lhs complex , intent ( in ) :: rhs type ( unicode_type ) :: string1 , string2 , string string1 = fmt ( lhs ) string2 = fmt ( rhs ) string % codes = [ string1 % codes , string2 % codes ] end function concat_g_c function concat_s_g ( lhs , rhs ) result ( string ) character ( len =* ), intent ( in ) :: lhs class ( * ), intent ( in ) :: rhs type ( unicode_type ) :: string1 , string2 , string string1 = fmt ( lhs ) string2 = fmt ( rhs ) string % codes = [ string1 % codes , string2 % codes ] end function concat_s_g function concat_g_s ( lhs , rhs ) result ( string ) class ( * ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs type ( unicode_type ) :: string1 , string2 , string string1 = fmt ( lhs ) string2 = fmt ( rhs ) string % codes = [ string1 % codes , string2 % codes ] end function concat_g_s function concat_l_g ( lhs , rhs ) result ( string ) logical , intent ( in ) :: lhs class ( * ), intent ( in ) :: rhs type ( unicode_type ) :: string1 , string2 , string string1 = fmt ( lhs ) string2 = fmt ( rhs ) string % codes = [ string1 % codes , string2 % codes ] end function concat_l_g function concat_g_l ( lhs , rhs ) result ( string ) class ( * ), intent ( in ) :: lhs logical , intent ( in ) :: rhs type ( unicode_type ) :: string1 , string2 , string string1 = fmt ( lhs ) string2 = fmt ( rhs ) string % codes = [ string1 % codes , string2 % codes ] end function concat_g_l !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !> Write string to connected formatted unit. subroutine write_formatted ( string , unit , iotype , v_list , iostat , iomsg ) class ( unicode_type ), intent ( in ) :: string integer , intent ( in ) :: unit character ( len =* ), intent ( in ) :: iotype integer , intent ( in ) :: v_list (:) integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg select case ( iotype ) case ( \"LISTDIRECTED\" ) write ( unit , '(a)' , iostat = iostat , iomsg = iomsg ) character ( string ) case ( \"NAMELIST\" ) error stop \"[Fatal] This implementation does not support namelist output\" case default ! DT* select case ( size ( v_list )) case ( 0 ) ! DT if ( allocated ( string % codes )) then write ( unit , '(a)' , iostat = iostat , iomsg = iomsg ) character ( string ) endif case default error stop \"[Fatal] This implementation does not support v_list formatters\" end select end select end subroutine write_formatted !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== end module M_unicode","tags":"","url":"sourcefile/m_unicode.f90.html"},{"title":"demo_tokenize.f90 ‚Äì M_unicode","text":"Source Code program demo_tokenize use M_unicode , only : tokenize , ut => unicode_type , ch => character use M_unicode , only : assignment ( = ), operator ( /= ) implicit none ! ! some useful formats character ( len =* ), parameter :: & & brackets = '(*(\"[\",g0,\"]\":,\",\"))' ,& & a_commas = '(a,*(g0:,\",\"))' ,& & gen = '(*(g0))' ! ! Execution of TOKEN form (return array of tokens) ! block type ( ut ) :: string type ( ut ), allocatable :: tokens (:) integer :: i string = '  first,second ,third       ' call tokenize ( string , set = ';,' , tokens = tokens ) write ( * , brackets ) ch ( tokens ) string = '  first , second ,third       ' call tokenize ( string , set = ' ,' , tokens = tokens ) write ( * , brackets )( tokens ( i )% character (), i = 1 , size ( tokens )) ! remove blank tokens tokens = pack ( tokens , tokens /= '' ) write ( * , brackets ) ch ( tokens ) ! endblock ! ! Execution of BOUNDS form (return position of tokens) ! block type ( ut ) :: string character ( len =* ), parameter :: set = \" ,\" integer , allocatable :: first (:), last (:) write ( * , gen ) repeat ( '1234567890' , 6 ) string = 'first,second,,fourth' write ( * , gen ) ch ( string ) call tokenize ( string , set , first , last ) write ( * , a_commas ) 'FIRST=' , first write ( * , a_commas ) 'LAST=' , last write ( * , a_commas ) 'HAS LENGTH=' , last - first . gt . 0 endblock ! end program demo_tokenize","tags":"","url":"sourcefile/demo_tokenize.f90.html"},{"title":"demo_split.f90 ‚Äì M_unicode","text":"Source Code program demo_split use iso_fortran_env , only : stdout => output_unit use M_unicode , only : unicode_type , assignment ( = ) use M_unicode , only : split , len , character use M_unicode , only : ut => unicode_type implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' type ( ut ) :: proverb type ( ut ) :: delims type ( ut ), allocatable :: array (:) integer :: first integer :: last integer :: pos integer :: i ! delims = '=|; ' ! proverb = \"M√°s vale p√°jaro en mano, que ciento volando.\" call printwords ( proverb ) ! there really are not spaces between these glyphs array = [ & ut ( \"‰∏ÉËª¢„Å≥ÂÖ´Ëµ∑„Åç„ÄÇ\" ), & ut ( \"Ëª¢„Çì„Åß„ÇÇ„Åæ„ÅüÁ´ã„Å°‰∏ä„Åå„Çã„ÄÇ\" ), & ut ( \"„Åè„Åò„Åë„Åö„Å´Ââç„ÇíÂêë„ÅÑ„Å¶Ê≠©„ÅÑ„Å¶„ÅÑ„Åì„ÅÜ„ÄÇ\" )] call printwords ( array ) ! write ( stdout , g ) 'OOP' array = proverb % split ( ut ( ' ' )) write ( stdout , '(*(:\"[\",a,\"]\"))' )( character ( array ( i )), i = 1 , size ( array )) contains impure elemental subroutine printwords ( line ) type ( ut ), intent ( in ) :: line pos = 0 write ( stdout , g ) line % character (), len ( line ) do while ( pos < len ( line )) first = pos + 1 call split ( line , delims , pos ) last = pos - 1 print g , line % character ( first , last ), first , last , pos end do end subroutine printwords end program demo_split","tags":"","url":"sourcefile/demo_split.f90.html"},{"title":"note.f90 ‚Äì M_unicode","text":"Source Code program note use , intrinsic :: iso_fortran_env , only : stdout => output_unit use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use M_unicode implicit none integer , parameter :: manicules ( * ) = [ int ( z '261A' ), int ( z '261B' ) ] type ( unicode_type ) :: uline ! ! manicule ! ! Miscellaneous Symbols block: ! !     U+261A ‚òö BLACK LEFT POINTING INDEX !     U+261B ‚òõ BLACK RIGHT POINTING INDEX !     U+261C ‚òú WHITE LEFT POINTING INDEX !     U+261D ‚òù WHITE UP POINTING INDEX !     U+261E ‚òû WHITE RIGHT POINTING INDEX !     U+261F ‚òü WHITE DOWN POINTING INDEX ! ! Unicode 6.0 (2010) included four more pointing hands in Miscellaneous Symbols and Pictographs: ! !     U+1F446 üëÜ WHITE UP POINTING BACKHAND INDEX !     U+1F447 üëá WHITE DOWN POINTING BACKHAND INDEX !     U+1F448 üëà WHITE LEFT POINTING BACKHAND INDEX !     U+1F449 üëâ WHITE RIGHT POINTING BACKHAND INDEX ! ! Unicode 7.0 (2014) added several more indices to the Miscellaneous Symbols and Pictographs block, sourced from the Wingdings 2 font: ! !     U+1F597 üñó WHITE DOWN POINTING LEFT HAND INDEX !     U+1F598 üñò SIDEWAYS WHITE LEFT POINTING INDEX !     U+1F599 üñô SIDEWAYS WHITE RIGHT POINTING INDEX !     U+1F59A üñö SIDEWAYS BLACK LEFT POINTING INDEX !     U+1F59B üñõ SIDEWAYS BLACK RIGHT POINTING INDEX !     U+1F59C üñú BLACK LEFT POINTING BACKHAND INDEX !     U+1F59D üñù BLACK RIGHT POINTING BACKHAND INDEX !     U+1F59E üñû SIDEWAYS WHITE UP POINTING INDEX !     U+1F59F üñü SIDEWAYS WHITE DOWN POINTING INDEX !     U+1F5A0 üñ† SIDEWAYS BLACK UP POINTING INDEX !     U+1F5A1 üñ° SIDEWAYS BLACK DOWN POINTING INDEX !     U+1F5A2 üñ¢ BLACK UP POINTING BACKHAND INDEX !     U+1F5A3 üñ£ BLACK DOWN POINTING BACKHAND INDEX ! ! Unicode 13.0 (2020) added a three-part index (üØÅüØÇüØÉ) in the Symbols for Legacy Computing block: ! !     U+1FBC1 üØÅ LEFT THIRD WHITE RIGHT POINTING INDEX !     U+1FBC2 üØÇ MIDDLE THIRD WHITE RIGHT POINTING INDEX !     U+1FBC3 üØÉ RIGHT THIRD WHITE RIGHT POINTING INDEX ! ! Emoji ! ! Five Unicode manicule characters are emoji, including one of those in ! Unicode 1.0 and all four introduced in Unicode 6.0.[15][16] All five ! have standardized variants for text and emoji presentation.[17] ! ! Emoji variation sequences U+ \t261D \t1F446 \t1F447 \t1F448 \t1F449 ! default presentation \ttext \temoji \temoji \temoji \temoji ! base code point \t‚òù \tüëÜ \tüëá \tüëà \tüëâ ! base+VS15 (text) \t‚òùÔ∏é \tüëÜÔ∏é \tüëáÔ∏é \tüëàÔ∏é \tüëâÔ∏é ! base+VS16 (emoji) \t‚òùÔ∏è \tüëÜÔ∏è \tüëáÔ∏è \tüëàÔ∏è \tüëâÔ∏è ! See also ! !     Arrow (symbol) !     V sign !     Obelus (historic text pointer) !     Hand (hieroglyph) ‚Äì Egyptian hieroglyph ! ! Notes ! ! Although the canonical name is Black left pointing index, Unicode uses ! the word 'black' to mean 'solid' and 'white' to mean 'outlined'. The ! actual colour is a user choice, for example ‚òö and ‚òû. uline = manicules write ( stdout , '(*(g0))' ) uline % character () write ( stdout , '(\"CHARACTER STRING  :\",*(g0))' ) uline % character () write ( stdout , '(\"SINGLE CHARACTERS :\",*(g0))' ) uline % byte () write ( stdout , '(\"HEX BYTES         :\",*(z0,1x))' ) ichar ( uline % byte ()) write ( stdout , '(\"UNICODE CODEPOINTS:\",*(g0,1x))' ) uline % codepoint () write ( stdout , '(\"HEX CODEPOINTS    :\",*(z0,1x))' ) uline % codepoint () end program note","tags":"","url":"sourcefile/note.f90.html"},{"title":"demo_repeat.f90 ‚Äì M_unicode","text":"Source Code program demo_repeat use M_unicode , only : ut => unicode_type , repeat , escape , write ( formatted ) implicit none write ( * , '(DT)' ) repeat ( escape ( \"\\u2025*\" ), 35 ) write ( * , '(DT)' ) repeat ( ut ( \"_\" ), 70 ) ! line break write ( * , '(DT)' ) repeat ( ut ( \"1234567890\" ), 7 ) ! number line write ( * , '(DT)' ) repeat ( ut ( \"         |\" ), 7 ) ! end program demo_repeat","tags":"","url":"sourcefile/demo_repeat.f90.html"},{"title":"demo_lower.f90 ‚Äì M_unicode","text":"Source Code program demo_lower use iso_fortran_env , only : stdout => output_unit use M_unicode , only : lower , unicode_type , assignment ( = ), trim use M_unicode , only : ut => unicode_type , operator ( == ) implicit none character ( len =* ), parameter :: g = '(*(g0))' type ( unicode_type ) :: pangram type ( unicode_type ) :: diacritics type ( unicode_type ) :: expected ! ! a sentence containing every letter of the English alphabet pangram = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\" expected = \"the quick brown fox jumps over the lazy dog\" call test ( pangram , expected ) ! ! Slovak pangram PANGRAM = 'VYP√ÑT√Å DC√âRA GR√ìFA MAXWELLA S IQ NI≈Ω≈†√çM AKO & &K√î≈á N√öTI ƒåEƒΩAƒé HR√ùZ≈§ H≈îBU JABƒπK.' expected = 'vyp√§t√° dc√©ra gr√≥fa maxwella s iq ni≈æ≈°√≠m ako & &k√¥≈à n√∫ti ƒçeƒæaƒè hr√Ωz≈• h≈ïbu jabƒ∫k.' call test ( pangram , expected ) ! ! contains each special Czech letter with diacritics exactly once DIACRITICS = 'P≈ò√çLI≈† ≈ΩLU≈§OUƒåK√ù K≈Æ≈á √öPƒöL ƒé√ÅBELSK√â √ìDY.' expected = 'p≈ô√≠li≈° ≈ælu≈•ouƒçk√Ω k≈Ø≈à √∫pƒõl ƒè√°belsk√© √≥dy.' print g , '(\"A horse that was too yellow-ish moaned devilish odes\")' call test ( diacritics , expected ) contains subroutine test ( in , expected ) type ( unicode_type ), intent ( in ) :: in type ( unicode_type ), intent ( in ) :: expected type ( unicode_type ) :: lowercase character ( len =* ), parameter :: nl = new_line ( 'A' ) write ( stdout , g ) in % character () lowercase = lower ( in ) write ( stdout , g ) lowercase % character () write ( stdout , g ) merge ( 'PASSED' , 'FAILED' , lowercase == expected ), nl end subroutine test end program demo_lower","tags":"","url":"sourcefile/demo_lower.f90.html"},{"title":"demo_join.f90 ‚Äì M_unicode","text":"Source Code program demo_join use M_unicode , only : join , ut => unicode_type , ch => character , assignment ( = ) !use M_unicode, only : write(formatted) implicit none character ( len =* ), parameter :: w = '((g0,/,g0))' !character(len=*),parameter   :: v='((g0,/,DT))' character ( len = 20 ), allocatable :: proverb (:) type ( ut ), allocatable :: s (:) type ( ut ), allocatable :: sep ! proverb = [ character ( len = 13 ) :: & & ' United' ,& & '  we' ,& & '   stand,' ,& & '    divided' ,& & '     we fall.' ] ! if ( allocated ( s )) deallocate ( s ) allocate ( s ( size ( proverb ))) ! avoid GNU Fortran (GCC) 16.0.0 bug s = proverb write ( * , w ) 'SIMPLE JOIN:         ' , ch ( join ( s ) ) write ( * , w ) 'JOIN WITH SEPARATOR: ' , ch ( join ( s , sep = ut ( ' ' )) ) write ( * , w ) 'CUSTOM SEPARATOR:    ' , ch ( join ( s , sep = ut ( '<-->' )) ) write ( * , w ) 'NO TRIMMING:         ' , ch ( join ( s , clip = . false .) ) ! sep = ut () write ( * , w ) 'SIMPLE JOIN:         ' , ch ( sep % join ( s ) ) sep = ' ' write ( * , w ) 'JOIN WITH SEPARATOR: ' , ch ( sep % join ( s ) ) sep = '<-->' write ( * , w ) 'CUSTOM SEPARATOR:    ' , ch ( sep % join ( s ) ) sep = '' write ( * , w ) 'NO TRIMMING:         ' , ch ( sep % join ( s , clip = . false .) ) end program demo_join","tags":"","url":"sourcefile/demo_join.f90.html"},{"title":"multi_lines.f90 ‚Äì M_unicode","text":"Source Code program multi_line use iso_fortran_env , only : stdout => output_unit use M_unicode use M_unicode , only : ut => unicode_type implicit none integer :: i , longest type ( ut ), allocatable :: upagain (:) upagain = [ & ! ROMANIZATION                         ! ENGLISH ut ( \"‰∏ÉËª¢„Å≥ÂÖ´Ëµ∑„Åç„ÄÇ\" ), & ! Nanakorobi yaoki.                    ! Fall seven times, stand up eight. ut ( \"Ëª¢„Çì„Åß„ÇÇ„Åæ„ÅüÁ´ã„Å°‰∏ä„Åå„Çã„ÄÇ\" ), & ! Koronde mo mata tachiagaru.          ! Even if you fall down, you will get up again. ut ( \"„Åè„Åò„Åë„Åö„Å´Ââç„ÇíÂêë„ÅÑ„Å¶Ê≠©„ÅÑ„Å¶„ÅÑ„Åì„ÅÜ„ÄÇ\" )] ! Kujikezu ni mae o muite aruite ikou. ! Don't be discouraged, just keep walking forward. ! longest = 0 ! get longest trimmed line do i = 1 , size ( upagain ) longest = max ( longest , len_trim ( upagain ( i ))) write ( stdout , * ) 'LEN=' , len_trim ( upagain ( i )) enddo write ( stdout , * ) 'longest=' , longest write ( stdout , * ) do i = 1 , size ( upagain ) write ( stdout , '(g0)' ) character ( upagain ( i )), len_trim ( upagain ( i )) enddo end program multi_line","tags":"","url":"sourcefile/multi_lines.f90.html"},{"title":"demo_sort.f90 ‚Äì M_unicode","text":"Source Code program demo_sort use iso_fortran_env , only : stdout => output_unit use M_unicode , only : sort , unicode_type , assignment ( = ) use M_unicode , only : ut => unicode_type , write ( formatted ) use M_unicode , only : ch => character implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' integer , parameter :: isz = 4 type ( unicode_type ) :: rr ( isz ) integer :: ii ( isz ) integer :: i ! write ( stdout , g ) 'sort array with sort(3f)' rr = [ & ut ( \"the\" ), & ut ( \"quick\" ), & ut ( \"brown\" ), & ut ( \"fox\" ) ] ! write ( stdout , g ) 'original order' write ( stdout , g ) ch ( rr ) ! call sort ( rr , ii ) ! write ( stdout , g ) 'sorted order' ! convert to character do i = 1 , size ( rr ) write ( stdout , '(i3.3,1x,a)' ) i , rr ( ii ( i ))% character () enddo ! write ( stdout , g ) 'reorder original' rr = rr ( ii ) write ( stdout , g ) ch ( rr ) end program demo_sort","tags":"","url":"sourcefile/demo_sort.f90.html"},{"title":"demo_escape.f90 ‚Äì M_unicode","text":"Source Code program demo_escape ! demonstrate filter to expand C-like escape sequences in input lines use iso_fortran_env , only : stdout => output_unit use M_unicode , only : ut => unicode_type , ch => character , len , escape use M_unicode , only : assignment ( = ), trim implicit none type ( ut ), allocatable :: poem (:) type ( ut ) :: test ( 5 ) integer :: i ! ! ‚ÄúThe Crow and the Fox‚Äù by Jean de la Fontaine write ( stdout , '(a,/)' ) & 'Le Corbeau et le Renard -- Jean de la Fontaine' ! poem = [& ut ( 'Le Corbeau et le Renard' ),& ut ( '' ),& ut ( 'Ma\\u00EEtre Corbeau, sur un arbre perch\\u00E9,' ),& ut ( 'Tenait en son bec un fromage.' ),& ut ( 'Ma\\u00EEtre Renard, par l\\u2019odeur all\\u00E9ch\\u00E9,' ),& ut ( 'Lui tint \\U000000E0 peu pr\\U000000E8s ce langage :' ),& ut ( '\\U000000ABH\\U000000E9 ! bonjour, Monsieur du Corbeau.' ),& ut ( 'Que vous \\U000000EAtes joli ! que vous me semblez beau !' ),& ut ( 'Sans mentir, si votre ramage' ),& ut ( 'Se rapporte \\U000000E0 votre plumage,' ),& ut ( 'Vous \\xEAtes le Ph\\xE9nix des h\\xF4tes de ces bois.\\xBB' ),& ut ( 'A ces mots le Corbeau ne se sent pas de joie ;' ),& ut ( 'Et pour montrer sa belle voix,' ),& ut ( 'Il ouvre un large bec, laisse tomber sa proie.' ),& ut ( 'Le Renard s\\u2019en saisit, et dit : \\xABMon bon Monsieur,' ),& ut ( 'Apprenez que tout flatteur' ),& ut ( 'Vit aux d\\xE9pens de celui qui l\\U00002019\\u00E9coute :' ),& ut ( 'Cette le\\xE7on vaut bien un fromage, sans doute.\\xBB' ),& ut ( 'Le Corbeau, honteux et confus,' ),& ut ( & 'Jura, mais un peu tard, qu\\u2019on ne l\\u2019y prendrait plus.' ),& ut ( ' -- Jean de la Fontaine' )] ! poem = escape ( poem ) write ( stdout , '(g0)' ) ch ( poem ) ! test = [ & '\\e[H\\e[2J           ' ,& ! home cursor and clear screen ! on ANSI terminals '\\tABC\\tabc          ' ,& ! write some tabs in the output '\\tA\\a               ' ,& ! ring bell at end if supported '\\nONE\\nTWO\\nTHREE   ' ,& ! place one word per line '\\\\                  ' ] test = trim ( escape ( test )) write ( * , '(a)' )( test ( i )% character (), i = 1 , size ( test )) ! end program demo_escape","tags":"","url":"sourcefile/demo_escape.f90.html"},{"title":"demo_verify_2.f90 ‚Äì M_unicode","text":"Source Code program fortran_ints use M_unicode , only : ut => unicode_type , assignment ( = ) use M_unicode , only : adjustr , verify , trim , len use M_unicode , only : write ( formatted ) use M_unicode , only : operator (. cat .) use M_unicode , only : operator ( == ) implicit none integer :: i character ( len =* ), parameter :: asciiints ( * ) = [ character ( len = 10 ) :: & \"+1 \" , & \"3044848 \" , & \"30.40 \" , & \"September \" , & \"1 2 3\" , & \"  -3000 \" , & \" \" ] type ( ut ), allocatable :: ints (:) allocate ( ints ( size ( asciiints ))) ! gfortran bug ints = asciiints ints = trim ( ints ) ! show if strings pass or fail the test done by isint(3) write ( * , \"('is integer?')\" ) do i = 1 , size ( ints ) write ( * , '(\"|\",DT,T14,\"|\",l1,\"|\")' ) ints ( i ), isint ( ints ( i )) enddo ! elemental write ( * , \"(*(g0,1x))\" ) isint ( ints ) contains impure elemental function isint ( line ) result ( lout ) use M_unicode , only : adjustl , verify , trim ! ! determine if string is a valid integer representation ! ignoring trailing spaces and leading spaces ! character ( len =* ), parameter :: digits = \"0123456789\" type ( ut ), intent ( in ) :: line type ( ut ) :: name logical :: lout lout = . false . ! make sure at least two characters long to simplify tests name = adjustl ( line ). cat . '  ' ! blank string if ( name == '' ) return ! allow one leading sign if ( verify ( name % sub ( 1 , 1 ), ut ( '+‚Äê-' )) == 0 ) name = name % sub ( 2 , len ( name )) ! was just a sign if ( name == '' ) return lout = verify ( trim ( name ), digits ) == 0 end function isint end program fortran_ints","tags":"","url":"sourcefile/demo_verify_2.f90.html"},{"title":"demo_verify_3.f90 ‚Äì M_unicode","text":"Source Code program fortran_symbol_name use M_unicode , only : ut => unicode_type , trim , verify , len use M_unicode , only : ch => character use M_unicode , only : write ( formatted ) implicit none integer :: i type ( ut ), allocatable :: symbols (:) symbols = [ & ut ( 'A_' ), ut ( '10' ), ut ( 'a10' ), ut ( 'September' ), ut ( 'A B' ), & ut ( '_A' ), ut ( ' ' )] do i = 1 , size ( symbols ) write ( * , '(1x,DT,T11,\"|\",l2)' ) symbols ( i ), fortran_name ( symbols ( i )) enddo contains impure elemental function fortran_name ( line ) result ( lout ) ! ! determine if a string is a valid Fortran name ! ignoring trailing spaces (but not leading spaces) ! character ( len =* ), parameter :: int = \"0123456789\" character ( len =* ), parameter :: lower = \"abcdefghijklmnopqrstuvwxyz\" character ( len =* ), parameter :: upper = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" character ( len =* ), parameter :: allowed = upper // lower // int // \"_\" type ( ut ), intent ( in ) :: line type ( ut ) :: name logical :: lout name = trim ( line ) if ( len ( name ). ne . 0 ) then ! first character is alphameric lout = verify ( name % sub ( 1 , 1 ), lower // upper ) == 0 & ! other characters are allowed in a symbol name & . and . verify ( name , allowed ) == 0 & ! allowable length & . and . len ( name ) <= 63 else lout = . false . endif end function fortran_name end program fortran_symbol_name","tags":"","url":"sourcefile/demo_verify_3.f90.html"},{"title":"demo_transliterate.f90 ‚Äì M_unicode","text":"Source Code program demo_transliterate use M_unicode , only : transliterate , ut => unicode_type use M_unicode , only : write ( formatted ), ch => character use M_unicode , only : assignment ( = ) implicit none character ( len =* ), parameter :: u = '(DT)' type ( ut ) :: STRING , UPPER , LOWER type ( ut ) :: MIDDLE_DOT STRING = 'aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ' LOWER = 'abcdefghijklmnopqrstuvwxyz' UPPER = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' call callit () print u print u , ut ( 'Greek' ) ! ! | Œë Œ± | Œí Œ≤ | Œì Œ≥ | Œî Œ¥ | Œï Œµ | Œñ Œ∂       | ! | Œó Œ∑ | Œò Œ∏ | Œô Œπ | Œö Œ∫ | Œõ Œª | Œú Œº       | ! | Œù ŒΩ | Œû Œæ | Œü Œø | Œ† œÄ | Œ° œÅ | Œ£ œÉ œÇ | ! | Œ§ œÑ | Œ• œÖ | Œ¶ œÜ | Œß œá | Œ® œà | Œ© œâ       | ! STRING = 'ŒëŒ±ŒíŒ≤ŒìŒ≥ŒîŒ¥ŒïŒµŒñŒ∂ŒóŒ∑ŒòŒ∏ŒôŒπŒöŒ∫ŒõŒªŒúŒºŒùŒΩŒûŒæŒüŒøŒ†œÄŒ°œÅŒ£œÉœÇŒ§œÑŒ•œÖŒ¶œÜŒßœáŒ®œàŒ©œâ' ! ignoring œÇ for simplicity UPPER = 'ŒëŒíŒìŒîŒïŒñŒóŒòŒôŒöŒõŒúŒùŒûŒüŒ†Œ°Œ£Œ§Œ•Œ¶ŒßŒ®Œ©' LOWER = 'Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÉœÑœÖœÜœáœàœâ' call callit () ! OOP print u print u , ut ( 'OOP!' ) print u , STRING % TRANSLITERATE ( UPPER , '_' ) ! U+00B7 Middle Dot Unicode Character print u , STRING % TRANSLITERATE ( LOWER , '¬∑' ) ! ASCII bytes print u , STRING % TRANSLITERATE ( LOWER , ut ( '¬∑' )) ! cast MIDDLE_DOT = int ( z '00B7' ) print u , STRING % TRANSLITERATE ( LOWER , MIDDLE_DOT ) ! hexadecimal contains subroutine callit () print u , STRING ! convert -7 string to uppercase: print u , TRANSLITERATE ( STRING , LOWER , UPPER ) ! change all miniscule letters to a colon (\":\"): print u , TRANSLITERATE ( STRING , LOWER , ':' ) ! delete all miniscule letters print u , TRANSLITERATE ( STRING , LOWER , '' ) end subroutine callit end program demo_transliterate","tags":"","url":"sourcefile/demo_transliterate.f90.html"},{"title":"test_M_unicode.f90 ‚Äì M_unicode","text":"Source Code module testsuite_M_unicode use iso_fortran_env , only : output_unit ! overload intrinsics use M_unicode , only : adjustl , adjustr , index use M_unicode , only : trim , len , len_trim use M_unicode , only : repeat use M_unicode , only : upper , lower use M_unicode , only : expandtabs use M_unicode , only : escape use M_unicode , only : sort use M_unicode , only : scan , verify use M_unicode , only : tokenize , split use M_unicode , only : ichar use M_unicode , only : replace use M_unicode , only : sub use M_unicode , only : pad use M_unicode , only : join use M_unicode , only : fmt , afmt use M_unicode , only : transliterate use M_unicode , only : assignment ( = ), unicode_type use M_unicode , only : operator (. cat .) !use M_unicode, only : operator(//) use M_unicode , only : operator ( <= ), lle use M_unicode , only : operator ( < ), llt use M_unicode , only : operator ( /= ), lne use M_unicode , only : operator ( == ), leq use M_unicode , only : operator ( > ), lgt use M_unicode , only : operator ( >= ), lge use M_unicode , only : character use M_unicode , only : utf8_to_codepoints , codepoints_to_utf8 use M_unicode , only : ut => unicode_type use M_unicode , only : ch => character implicit none character ( len =* ), parameter :: g0 = '(*(g0))' character ( len =* ), parameter :: g1 = '(*(g0,1x))' logical , parameter :: T = . true . logical , parameter :: F = . false . integer :: total contains subroutine checkit ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline character ( len =* ), intent ( in ) :: answer character ( len =* ), intent ( in ) :: expected write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , answer . eq . expected ), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( answer . ne . expected ) total = total + 1 end subroutine checkit subroutine checkits ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline character ( len =* ), intent ( in ) :: answer (:) character ( len =* ), intent ( in ) :: expected (:) if ( size ( answer ). eq . size ( expected ) ) then write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , all ( answer . eq . expected )), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( all ( answer . ne . expected )) total = total + 1 else write ( * , g0 ) 'FAILED' , ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' total = total + 1 endif end subroutine checkits subroutine checkits_l ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline logical , intent ( in ) :: answer (:) logical , intent ( in ) :: expected (:) write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , all ( answer . eqv . expected )), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( all ( answer . neqv . expected )) total = total + 1 end subroutine checkits_l subroutine check ( label , test , description ) character ( len =* ), intent ( in ) :: label logical , intent ( in ) :: test character ( len =* ), intent ( in ), optional :: description if ( present ( description ) ) then write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , test ), ' ' , label , ':' , description else write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , test ), ' ' , label endif if (. not . test ) total = total + 1 end subroutine check subroutine programming_environment () use , intrinsic :: iso_fortran_env , only : compiler_version use , intrinsic :: iso_fortran_env , only : compiler_options implicit none character ( len = :), allocatable :: version , options character ( len =* ), parameter :: nl = new_line ( 'a' ) integer :: where , start , break version = compiler_version () options = ' ' // compiler_options () start = 1 do where = index ( options ( start :), ' -' ) if ( where . eq . 0 ) exit break = where + start - 1 options ( break : break ) = nl start = where enddo if ( start . eq . 1 ) then do where = index ( options ( start :), ' /' ) if ( where . eq . 0 ) exit break = where + start - 1 options ( break : break ) = nl start = where enddo endif print '(*(1x,a))' , & 'This file was compiled by ' , & version , nl , & 'using the options ' , & options end subroutine programming_environment subroutine test_index () type ( unicode_type ) :: string , substring character ( len = :), allocatable :: astr string = \" can you find me here? \" substring = \"find me\" astr = character ( substring ) call check ( 'index ' // string % character () // ':' // substring % character (), index ( string , substring ). eq . 10 ) call check ( 'index ' // string % character () // ':' // astr , index ( string , astr ). eq . 10 ) string = \" can you find me here? \" substring = \"not there\" astr = character ( substring ) call check ( 'index ' // string % character () // ':' // substring % character (), index ( string , substring ). eq . 0 ) call check ( 'index ' // string % character () // ':' // astr , index ( string , astr ). eq . 0 ) string = \"short\" substring = \"shortnot\" astr = character ( substring ) call check ( 'index ' // string % character () // ':' // substring % character (), index ( string , substring ). eq . 0 ) call check ( 'index ' // string % character () // ':' // astr , index ( string , astr ). eq . 0 ) end subroutine test_index subroutine test_repeat () character ( len = :), allocatable :: astr type ( unicode_type ) :: ut_str integer :: i ut_str = 'üí£üí•üí£üí•üí£üí•' astr = ut_str % character () ut_str = repeat ( ut_str , 5 ) call checkit ( 'repeat' , astr , ut_str % character (),& 'üí£üí•üí£üí•üí£üí•üí£üí•üí£üí•üí£üí•üí£üí•üí£üí•üí£üí•üí£üí•üí£üí•üí£üí•üí£üí•üí£üí•üí£üí•' ) ut_str = [( i , i = 48 , 57 )] ut_str = ut_str % character ( 2 , 10 ) // ut_str % character ( 1 , 1 ) call checkit ( 'repeat' , ut_str % character (), character ( repeat ( ut_str , 3 )), '123456789012345678901234567890' ) end subroutine test_repeat subroutine test_adjustl () character ( len = :), allocatable :: astr type ( unicode_type ) :: ut_str astr = \"  this is a string    \" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), 'this is a string      ' ) astr = \"  \" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), '  ' ) astr = \"\" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), '' ) astr = \"ALLFULL\" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), 'ALLFULL' ) ut_str = [ 32 , 32 , int ( z '1F603' ), 32 , 32 , 32 ] astr = character ( ut_str ) call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), 'üòÉ     ' ) astr = \"this is a string              \" ut_str = \"  this is a string    \" call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ( 30 )), astr ) end subroutine test_adjustl subroutine test_adjustr () character ( len = :), allocatable :: astr type ( unicode_type ) :: ut_str astr = \"  this is a string    \" ut_str = astr call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '      this is a string' ) astr = \"  \" ut_str = astr call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '  ' ) astr = \"\" ut_str = astr call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '' ) astr = \"ALLFULL\" ut_str = astr call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), 'ALLFULL' ) ut_str = [ 32 , 32 , int ( z '1F603' ), 32 , 32 , 32 ] astr = character ( ut_str ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '     üòÉ' ) astr = \"              this is a string\" ut_str = \"  this is a string    \" call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ( 30 )), astr ) end subroutine test_adjustr subroutine test_len () character ( len = :), allocatable :: astr type ( unicode_type ) :: ut_str astr = \"  this is a string    \" ut_str = astr call check ( 'len' , ut_str % len (). eq . 22 ) call check ( 'len' , len ( ut_str ). eq . 22 ) astr = \"  \" ut_str = astr call check ( 'len' , ut_str % len (). eq . 2 ) astr = \"\" ut_str = astr call check ( 'len' , ut_str % len (). eq . 0 ) astr = \"ALLFULL\" ut_str = astr call check ( 'len' , ut_str % len (). eq . 7 ) ut_str = [ 32 , 32 , int ( z '1F603' ), 32 , 32 , 32 ] astr = character ( ut_str ) call check ( 'len' , ut_str % len (). eq . 6 ) end subroutine test_len subroutine test_len_trim () character ( len = :), allocatable :: astr type ( unicode_type ) :: ut_str astr = \"  this is a string    \" ut_str = astr call check ( 'len_trim' , ut_str % len_trim (). eq . 18 ) call check ( 'len_trim' , len_trim ( ut_str ). eq . 18 ) astr = \"  \" ut_str = astr call check ( 'len_trim' , ut_str % len_trim (). eq . 0 ) astr = \"\" ut_str = astr call check ( 'len_trim' , ut_str % len_trim (). eq . 0 ) astr = \"ALLFULL\" ut_str = astr call check ( 'len_trim' , ut_str % len_trim (). eq . 7 ) ut_str = [ 32 , 32 , int ( z '1F603' ), 32 , 32 , 32 ] astr = character ( ut_str ) call check ( 'len_trim' , ut_str % len_trim (). eq . 3 ) end subroutine test_len_trim subroutine test_trim () character ( len = :), allocatable :: astr type ( unicode_type ) :: ut_str astr = \"  this is a string    \" ut_str = astr call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '  this is a string' ) astr = \"  \" ut_str = astr call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '' ) astr = \"\" ut_str = astr call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '' ) astr = \"ALLFULL\" ut_str = astr call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), 'ALLFULL' ) ut_str = [ 32 , 32 , int ( z '1F603' ), 32 , 32 , 32 ] astr = character ( ut_str ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '  üòÉ' ) end subroutine test_trim subroutine test_concatenate () type ( ut ) :: str integer :: ten = 10 , twenty = 20 !need clarification! () required by ifx, not flang_new or gfortran !str='so '//ten//'+'//twenty//'='//(ten+twenty)//' üòÉ' str = 'so ' . cat . ten . cat . '+' . cat . twenty . cat . '=' . cat .( ten + twenty ). cat . ' üòÉ' ! ifx cannot print when // overloaded call check ( '//' , str == 'so 10+20=30 üòÉ' , 'concatenate got ' // str % character ()) end subroutine test_concatenate subroutine test_expandtabs () character ( len = :), allocatable :: str type ( unicode_type ) :: in type ( unicode_type ) :: expected integer :: i str = '  this is my string  ' ! change spaces to tabs to make a sample input do i = 1 , len ( str ) if ( str ( i : i ) == ' ' ) str ( i : i ) = char ( 9 ) enddo in = str expected = \"                this    is      my      string\" call check ( 'expandtabs' , expandtabs ( in ). eq . expected , character ( expandtabs ( in ))) call check ( 'expandtabs' , in % expandtabs (). eq . expected , character ( expandtabs ( in ))) expected = \"thisismystring\" call check ( 'expandtabs' , in % expandtabs ( tab_size = 0 ). eq . expected , character ( in % expandtabs ( tab_size = 0 ))) end subroutine test_expandtabs subroutine test_fmt () call add ( 'INTEGER' , fmt ( 10 ), '10' ) call add ( 'LOGICAL' , fmt (. false .), 'F' ) call add ( 'LOGICAL' , fmt (. true .), 'T' ) call add ( 'REAL' , fmt ( 10 0.0 ), '100' ) call add ( 'COMPLEX' , fmt (( 1 1.0 , 2 2.0 )), '(11,22)' ) call add ( 'REAL' , fmt ( 10 0.0 , 'f0.2' ), '100.00' ) contains subroutine add ( message , question , answer ) character ( len =* ), intent ( in ) :: message type ( ut ), intent ( in ) :: question character ( len =* ), intent ( in ) :: answer call check ( 'fmt' , question . eq . answer , 'testing ' // message // ' expected ' // answer // ' got ' // ch ( question )) end subroutine add end subroutine test_fmt subroutine test_upper () type ( unicode_type ) :: upp , low , temp integer :: i character ( len = 128 ) :: ascii7 ! ! remember unicode characters are multi-byte so be careful ! with older compilers to not exceed 132 bytes per line ! low = '& &abcdefghijklmnopqrstuvwxyz√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨& &√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∏√π√∫√ª√º√Ω√æ√øƒÅƒÉƒÖƒáƒâƒãƒçƒèƒëƒìƒïƒóƒôƒõƒùƒüƒ°ƒ£ƒ•ƒßƒ©ƒ´ƒ≠& &ƒØƒ±ƒ≥ƒµƒ∑ƒ∫ƒºƒæ≈Ä≈Ç≈Ñ≈Ü≈à≈ã≈ç≈è≈ë≈ì≈ï≈ó≈ô≈õ≈ù≈ü≈°≈£≈•≈ß≈©≈´≈≠≈Ø≈±≈≥≈µ≈∑≈∫≈º≈æ& &∆É∆Ö∆à∆å∆í∆ô∆°∆£∆•∆®∆≠∆∞∆¥∆∂∆π∆Ω«Ü«â«å«é«ê«í«î«ñ«ò«ö«ú«ü«°«£«•«ß«©«´«≠«Ø«≥«µ«ª«Ω«ø& &»Å»É»Ö»á»â»ã»ç»è»ë»ì»ï»ó…ì…î…ó…ò…ô…õ…†…£…®…©…Ø…≤…µ É à ä ã íŒ¨Œ≠ŒÆŒØ& &Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÉœÑœÖœÜœáœàœâœäœãœåœçœéœ£œ•œßœ©œ´œ≠œØ–∞–±–≤–≥–¥–µ–∂–∑–∏–π& &–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è—ë—í—ì—î—ï—ñ—ó—ò—ô—ö—õ—ú—û—ü& &—°—£—•—ß—©—´—≠—Ø—±—≥—µ—∑—π—ª—Ω—ø“Å“ë“ì“ï“ó“ô“õ“ù“ü“°“£“•“ß“©“´“≠“Ø“±“≥“µ“∑“π“ª“Ω“ø”Ç”Ñ”à& &”å”ë”ì”ï”ó”ô”õ”ù”ü”°”£”•”ß”©”´”Ø”±”≥”µ”π’°’¢’£’§’•’¶’ß’®’©’™’´’¨’≠’Æ’Ø’∞’±’≤& &’≥’¥’µ’∂’∑’∏’π’∫’ª’º’Ω’æ’ø÷Ä÷Å÷Ç÷É÷Ñ÷Ö÷Ü·Éê·Éë·Éí·Éì·Éî·Éï·Éñ·Éó·Éò·Éô·Éö·Éõ·Éú·Éù·Éû·Éü·É†·É°·É¢·É£·É§·É•& &·É¶·Éß·É®·É©·É™·É´·É¨·É≠·ÉÆ·ÉØ·É∞·É±·É≤·É≥·É¥·Éµ·∏Å·∏É·∏Ö·∏á·∏â·∏ã·∏ç·∏è·∏ë·∏ì·∏ï·∏ó·∏ô·∏õ·∏ù·∏ü·∏°·∏£·∏•·∏ß& &·∏©·∏´·∏≠·∏Ø·∏±·∏≥·∏µ·∏∑·∏π·∏ª·∏Ω·∏ø·πÅ·πÉ·πÖ·πá·πâ·πã·πç·πè·πë·πì·πï·πó·πô& &·πõ·πù·πü·π°·π£·π•·πß·π©·π´·π≠·πØ·π±·π≥·πµ·π∑·ππ·πª·πΩ·πø& &·∫Å·∫É·∫Ö·∫á·∫â·∫ã·∫ç·∫è·∫ë·∫ì·∫ï·∫°·∫£·∫•·∫ß·∫©·∫´·∫≠·∫Ø·∫±·∫≥·∫µ·∫∑·∫π·∫ª·∫Ω·∫ø·ªÅ·ªÉ·ªÖ·ªá·ªâ·ªã·ªç·ªè·ªë·ªì·ªï·ªó& &·ªô·ªõ·ªù·ªü·ª°·ª£·ª•·ªß·ª©·ª´·ª≠·ªØ·ª±·ª≥·ªµ·ª∑·ªπ·ºÄ·ºÅ·ºÇ·ºÉ·ºÑ·ºÖ·ºÜ·ºá·ºê·ºë·ºí·ºì·ºî·ºï·º†·º°·º¢·º£·º§·º•·º¶·ºß·º∞·º±& &·º≤·º≥·º¥·ºµ·º∂·º∑·ΩÄ·ΩÅ·ΩÇ·ΩÉ·ΩÑ·ΩÖ·Ωë·Ωì·Ωï·Ωó·Ω†·Ω°·Ω¢·Ω£·Ω§·Ω•·Ω¶·Ωß·æÄ·æÅ·æÇ·æÉ·æÑ·æÖ·æÜ·æá·æê·æë·æí·æì·æî·æï·æñ·æó& &·æ†·æ°·æ¢·æ£·æ§·æ•·æ¶·æß·æ∞·æ±·øê·øë·ø†·ø°‚ìê‚ìë‚ìí‚ìì‚ìî‚ìï‚ìñ‚ìó‚ìò‚ìô‚ìö‚ìõ‚ìú‚ìù‚ìû‚ìü‚ì†‚ì°‚ì¢‚ì£‚ì§‚ì•‚ì¶‚ìß‚ì®‚ì©& &ÔΩÅÔΩÇÔΩÉÔΩÑÔΩÖÔΩÜÔΩáÔΩàÔΩâÔΩäÔΩãÔΩåÔΩçÔΩéÔΩèÔΩêÔΩëÔΩíÔΩìÔΩîÔΩïÔΩñÔΩóÔΩòÔΩôÔΩö' upp = '& &ABCDEFGHIJKLMNOPQRSTUVWXYZ√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã& &√å√ç√é√è√ê√ë√í√ì√î√ï√ñ√ò√ô√ö√õ√ú√ù√û≈∏ƒÄƒÇƒÑƒÜƒàƒäƒåƒéƒêƒíƒîƒñƒòƒöƒúƒûƒ†ƒ¢ƒ§ƒ¶ƒ®ƒ™ƒ¨& &ƒÆIƒ≤ƒ¥ƒ∂ƒπƒªƒΩƒø≈Å≈É≈Ö≈á≈ä≈å≈é≈ê≈í≈î≈ñ≈ò≈ö≈ú≈û≈†≈¢≈§≈¶≈®≈™≈¨≈Æ≈∞≈≤≈¥≈∂≈π≈ª& &≈Ω∆Ç∆Ñ∆á∆ã∆ë∆ò∆†∆¢∆§∆ß∆¨∆Ø∆≥∆µ∆∏∆º«Ñ«á«ä«ç«è«ë«ì«ï«ó«ô«õ«û«†«¢«§«¶«®«™«¨«Æ«±«¥«∫«º«æ& &»Ä»Ç»Ñ»Ü»à»ä»å»é»ê»í»î»ñ∆Å∆Ü∆ä∆é∆è∆ê∆ì∆î∆ó∆ñ∆ú∆ù∆ü∆©∆Æ∆±∆≤∆∑ŒÜŒàŒâŒäŒëŒíŒìŒîŒïŒñŒóŒò& &ŒôŒöŒõŒúŒùŒûŒüŒ†Œ°Œ£Œ§Œ•Œ¶ŒßŒ®Œ©Œ™Œ´ŒåŒéŒèœ¢œ§œ¶œ®œ™œ¨œÆ–ê–ë–í–ì–î–ï–ñ–ó–ò–ô& &–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–Å–Ç–É–Ñ–Ö–Ü–á–à–â–ä–ã–å–é–è—†—¢—§—¶—®—™—¨& &—Æ—∞—≤—¥—∂—∏—∫—º—æ“Ä“ê“í“î“ñ“ò“ö“ú“û“†“¢“§“¶“®“™“¨“Æ“∞“≤“¥“∂“∏“∫“º“æ”Å”É”á& &”ã”ê”í”î”ñ”ò”ö”ú”û”†”¢”§”¶”®”™”Æ”∞”≤”¥”∏‘±‘≤‘≥‘¥‘µ‘∂‘∑‘∏‘π‘∫‘ª‘º‘Ω‘æ‘ø’Ä’Å’Ç’É’Ñ& &’Ö’Ü’á’à’â’ä’ã’å’ç’é’è’ê’ë’í’ì’î’ï’ñ·Ç†·Ç°·Ç¢·Ç£·Ç§·Ç•·Ç¶·Çß·Ç®·Ç©·Ç™·Ç´·Ç¨·Ç≠·ÇÆ·ÇØ·Ç∞·Ç±·Ç≤·Ç≥·Ç¥·Çµ& &·Ç∂·Ç∑·Ç∏·Çπ·Ç∫·Çª·Çº·ÇΩ·Çæ·Çø·ÉÄ·ÉÅ·ÉÇ·ÉÉ·ÉÑ·ÉÖ·∏Ä·∏Ç·∏Ñ·∏Ü·∏à·∏ä·∏å·∏é·∏ê·∏í·∏î·∏ñ·∏ò·∏ö·∏ú·∏û·∏†·∏¢·∏§·∏¶·∏®·∏™·∏¨·∏Æ& &·∏∞·∏≤·∏¥·∏∂·∏∏·∏∫·∏º·∏æ·πÄ·πÇ·πÑ·πÜ·πà·πä·πå·πé·πê·πí·πî·πñ·πò·πö·πú·πû·π†·π¢·π§·π¶·π®·π™·π¨·πÆ·π∞·π≤·π¥·π∂·π∏·π∫·πº·πæ& &·∫Ä·∫Ç·∫Ñ·∫Ü·∫à·∫ä·∫å·∫é·∫ê·∫í·∫î·∫†·∫¢·∫§·∫¶·∫®·∫™·∫¨·∫Æ·∫∞·∫≤·∫¥·∫∂·∫∏·∫∫·∫º·∫æ·ªÄ·ªÇ·ªÑ·ªÜ·ªà·ªä& &·ªå·ªé·ªê·ªí·ªî·ªñ·ªò·ªö·ªú·ªû·ª†·ª¢·ª§·ª¶·ª®·ª™·ª¨·ªÆ·ª∞·ª≤·ª¥·ª∂·ª∏& &·ºà·ºâ·ºä·ºã·ºå·ºç·ºé·ºè·ºò·ºô·ºö·ºõ·ºú·ºù·º®·º©·º™·º´·º¨·º≠·ºÆ·ºØ·º∏·ºπ& &·º∫·ºª·ºº·ºΩ·ºæ·ºø·Ωà·Ωâ·Ωä·Ωã·Ωå·Ωç·Ωô·Ωõ·Ωù·Ωü·Ω®·Ω©·Ω™·Ω´·Ω¨·Ω≠·ΩÆ·ΩØ& &·æà·æâ·æä·æã·æå·æç·æé·æè·æò·æô·æö·æõ·æú·æù·æû·æü·æ®·æ©·æ™·æ´·æ¨·æ≠·æÆ·æØ·æ∏·æπ& &·øò·øô·ø®·ø©‚í∂‚í∑‚í∏‚íπ‚í∫‚íª‚íº‚íΩ‚íæ‚íø‚ìÄ‚ìÅ‚ìÇ‚ìÉ‚ìÑ‚ìÖ‚ìÜ‚ìá‚ìà‚ìâ‚ìä‚ìã‚ìå‚ìç‚ìé‚ìè& &Ôº°Ôº¢Ôº£Ôº§Ôº•Ôº¶ÔºßÔº®Ôº©Ôº™Ôº´Ôº¨Ôº≠ÔºÆÔºØÔº∞Ôº±Ôº≤Ôº≥Ôº¥ÔºµÔº∂Ôº∑Ôº∏ÔºπÔº∫' call check ( 'upper' , upper ( low ) == upp ) call check ( 'upper' , character ( upper ( low )) == character ( upp ) ) call check ( 'upper' , upper ( low ) == upp ) write ( ascii7 , g0 )( achar ( i ), i = 0 , 127 ) ascii7 ( ichar ( 'a' ) + 1 : ichar ( 'z' ) + 1 ) = ' ' ascii7 ( ichar ( 'A' ) + 1 : ichar ( 'Z' ) + 1 ) = ' ' temp = ascii7 call check ( 'upper' , temp % character () == ascii7 , 'check non-alphameric like' // ascii7 ( ichar ( ' ' ) + 1 : len ( ascii7 ) - 1 ) ) call check ( 'upper' , upper ( temp ) == lower ( temp ), 'expect no difference' ) call check ( 'upper' , temp == upper ( temp ), 'expect no change' ) call check ( '%upper' , low % upper () == upp ) call check ( '%upper' , character ( low % upper ()) == character ( upp ) ) end subroutine test_upper subroutine test_lower () type ( unicode_type ) :: upp , low , lowkludge , temp , letter1 , letter2 , letter3 , letter4 integer :: i integer , allocatable :: codes (:) character ( len = 128 ) :: ascii7 ! ! remember unicode characters are multi-byte so be careful ! with older compilers to not exceed 132 bytes per line ! low = '& &abcdefghijklmnopqrstuvwxyz√†√°√¢√£√§√•√¶√ß√®√©√™√´√¨& &√≠√Æ√Ø√∞√±√≤√≥√¥√µ√∂√∏√π√∫√ª√º√Ω√æ√øƒÅƒÉƒÖƒáƒâƒãƒçƒèƒëƒìƒïƒóƒôƒõƒùƒüƒ°ƒ£ƒ•ƒßƒ©ƒ´ƒ≠& &ƒØƒ±ƒ≥ƒµƒ∑ƒ∫ƒºƒæ≈Ä≈Ç≈Ñ≈Ü≈à≈ã≈ç≈è≈ë≈ì≈ï≈ó≈ô≈õ≈ù≈ü≈°≈£≈•≈ß≈©≈´≈≠≈Ø≈±≈≥≈µ≈∑≈∫≈º≈æ& &∆É∆Ö∆à∆å∆í∆ô∆°∆£∆•∆®∆≠∆∞∆¥∆∂∆π∆Ω«Ü«â«å«é«ê«í«î«ñ«ò«ö«ú«ü«°«£«•«ß«©«´«≠«Ø«≥«µ«ª«Ω«ø& &»Å»É»Ö»á»â»ã»ç»è»ë»ì»ï»ó…ì…î…ó…ò…ô…õ…†…£…®…©…Ø…≤…µ É à ä ã íŒ¨Œ≠ŒÆŒØ& &Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÉœÑœÖœÜœáœàœâœäœãœåœçœéœ£œ•œßœ©œ´œ≠œØ–∞–±–≤–≥–¥–µ–∂–∑–∏–π& &–∫–ª–º–Ω–æ–ø—Ä—Å—Ç—É—Ñ—Ö—Ü—á—à—â—ä—ã—å—ç—é—è—ë—í—ì—î—ï—ñ—ó—ò—ô—ö—õ—ú—û—ü& &—°—£—•—ß—©—´—≠—Ø—±—≥—µ—∑—π—ª—Ω—ø“Å“ë“ì“ï“ó“ô“õ“ù“ü“°“£“•“ß“©“´“≠“Ø“±“≥“µ“∑“π“ª“Ω“ø”Ç”Ñ”à& &”å”ë”ì”ï”ó”ô”õ”ù”ü”°”£”•”ß”©”´”Ø”±”≥”µ”π’°’¢’£’§’•’¶’ß’®’©’™’´’¨’≠’Æ’Ø’∞’±’≤& &’≥’¥’µ’∂’∑’∏’π’∫’ª’º’Ω’æ’ø÷Ä÷Å÷Ç÷É÷Ñ÷Ö÷Ü·Éê·Éë·Éí·Éì·Éî·Éï·Éñ·Éó·Éò·Éô·Éö·Éõ·Éú·Éù·Éû·Éü·É†·É°·É¢·É£·É§·É•& &·É¶·Éß·É®·É©·É™·É´·É¨·É≠·ÉÆ·ÉØ·É∞·É±·É≤·É≥·É¥·Éµ·∏Å·∏É·∏Ö·∏á·∏â·∏ã·∏ç·∏è·∏ë·∏ì·∏ï·∏ó·∏ô·∏õ·∏ù·∏ü·∏°·∏£·∏•·∏ß& &·∏©·∏´·∏≠·∏Ø·∏±·∏≥·∏µ·∏∑·∏π·∏ª·∏Ω·∏ø·πÅ·πÉ·πÖ·πá·πâ·πã·πç·πè·πë·πì·πï·πó·πô& &·πõ·πù·πü·π°·π£·π•·πß·π©·π´·π≠·πØ·π±·π≥·πµ·π∑·ππ·πª·πΩ·πø& &·∫Å·∫É·∫Ö·∫á·∫â·∫ã·∫ç·∫è·∫ë·∫ì·∫ï·∫°·∫£·∫•·∫ß·∫©·∫´·∫≠·∫Ø·∫±·∫≥·∫µ·∫∑·∫π·∫ª·∫Ω·∫ø·ªÅ·ªÉ·ªÖ·ªá·ªâ·ªã·ªç·ªè·ªë·ªì·ªï·ªó& &·ªô·ªõ·ªù·ªü·ª°·ª£·ª•·ªß·ª©·ª´·ª≠·ªØ·ª±·ª≥·ªµ·ª∑·ªπ·ºÄ·ºÅ·ºÇ·ºÉ·ºÑ·ºÖ·ºÜ·ºá·ºê·ºë·ºí·ºì·ºî·ºï·º†·º°·º¢·º£·º§·º•·º¶·ºß·º∞·º±& &·º≤·º≥·º¥·ºµ·º∂·º∑·ΩÄ·ΩÅ·ΩÇ·ΩÉ·ΩÑ·ΩÖ·Ωë·Ωì·Ωï·Ωó·Ω†·Ω°·Ω¢·Ω£·Ω§·Ω•·Ω¶·Ωß·æÄ·æÅ·æÇ·æÉ·æÑ·æÖ·æÜ·æá·æê·æë·æí·æì·æî·æï·æñ·æó& &·æ†·æ°·æ¢·æ£·æ§·æ•·æ¶·æß·æ∞·æ±·øê·øë·ø†·ø°‚ìê‚ìë‚ìí‚ìì‚ìî‚ìï‚ìñ‚ìó‚ìò‚ìô‚ìö‚ìõ‚ìú‚ìù‚ìû‚ìü‚ì†‚ì°‚ì¢‚ì£‚ì§‚ì•‚ì¶‚ìß‚ì®‚ì©& &ÔΩÅÔΩÇÔΩÉÔΩÑÔΩÖÔΩÜÔΩáÔΩàÔΩâÔΩäÔΩãÔΩåÔΩçÔΩéÔΩèÔΩêÔΩëÔΩíÔΩìÔΩîÔΩïÔΩñÔΩóÔΩòÔΩôÔΩö' upp = '& &ABCDEFGHIJKLMNOPQRSTUVWXYZ√Ä√Å√Ç√É√Ñ√Ö√Ü√á√à√â√ä√ã& &√å√ç√é√è√ê√ë√í√ì√î√ï√ñ√ò√ô√ö√õ√ú√ù√û≈∏ƒÄƒÇƒÑƒÜƒàƒäƒåƒéƒêƒíƒîƒñƒòƒöƒúƒûƒ†ƒ¢ƒ§ƒ¶ƒ®ƒ™ƒ¨& &ƒÆIƒ≤ƒ¥ƒ∂ƒπƒªƒΩƒø≈Å≈É≈Ö≈á≈ä≈å≈é≈ê≈í≈î≈ñ≈ò≈ö≈ú≈û≈†≈¢≈§≈¶≈®≈™≈¨≈Æ≈∞≈≤≈¥≈∂≈π≈ª& &≈Ω∆Ç∆Ñ∆á∆ã∆ë∆ò∆†∆¢∆§∆ß∆¨∆Ø∆≥∆µ∆∏∆º«Ñ«á«ä«ç«è«ë«ì«ï«ó«ô«õ«û«†«¢«§«¶«®«™«¨«Æ«±«¥«∫«º«æ& &»Ä»Ç»Ñ»Ü»à»ä»å»é»ê»í»î»ñ∆Å∆Ü∆ä∆é∆è∆ê∆ì∆î∆ó∆ñ∆ú∆ù∆ü∆©∆Æ∆±∆≤∆∑ŒÜŒàŒâŒäŒëŒíŒìŒîŒïŒñŒóŒò& &ŒôŒöŒõŒúŒùŒûŒüŒ†Œ°Œ£Œ§Œ•Œ¶ŒßŒ®Œ©Œ™Œ´ŒåŒéŒèœ¢œ§œ¶œ®œ™œ¨œÆ–ê–ë–í–ì–î–ï–ñ–ó–ò–ô& &–ö–õ–ú–ù–û–ü–†–°–¢–£–§–•–¶–ß–®–©–™–´–¨–≠–Æ–Ø–Å–Ç–É–Ñ–Ö–Ü–á–à–â–ä–ã–å–é–è—†—¢—§—¶—®—™—¨& &—Æ—∞—≤—¥—∂—∏—∫—º—æ“Ä“ê“í“î“ñ“ò“ö“ú“û“†“¢“§“¶“®“™“¨“Æ“∞“≤“¥“∂“∏“∫“º“æ”Å”É”á& &”ã”ê”í”î”ñ”ò”ö”ú”û”†”¢”§”¶”®”™”Æ”∞”≤”¥”∏‘±‘≤‘≥‘¥‘µ‘∂‘∑‘∏‘π‘∫‘ª‘º‘Ω‘æ‘ø’Ä’Å’Ç’É’Ñ& &’Ö’Ü’á’à’â’ä’ã’å’ç’é’è’ê’ë’í’ì’î’ï’ñ·Ç†·Ç°·Ç¢·Ç£·Ç§·Ç•·Ç¶·Çß·Ç®·Ç©·Ç™·Ç´·Ç¨·Ç≠·ÇÆ·ÇØ·Ç∞·Ç±·Ç≤·Ç≥·Ç¥·Çµ& &·Ç∂·Ç∑·Ç∏·Çπ·Ç∫·Çª·Çº·ÇΩ·Çæ·Çø·ÉÄ·ÉÅ·ÉÇ·ÉÉ·ÉÑ·ÉÖ·∏Ä·∏Ç·∏Ñ·∏Ü·∏à·∏ä·∏å·∏é·∏ê·∏í·∏î·∏ñ·∏ò·∏ö·∏ú·∏û·∏†·∏¢·∏§·∏¶·∏®·∏™·∏¨·∏Æ& &·∏∞·∏≤·∏¥·∏∂·∏∏·∏∫·∏º·∏æ·πÄ·πÇ·πÑ·πÜ·πà·πä·πå·πé·πê·πí·πî·πñ·πò·πö·πú·πû·π†·π¢·π§·π¶·π®·π™·π¨·πÆ·π∞·π≤·π¥·π∂·π∏·π∫·πº·πæ& &·∫Ä·∫Ç·∫Ñ·∫Ü·∫à·∫ä·∫å·∫é·∫ê·∫í·∫î·∫†·∫¢·∫§·∫¶·∫®·∫™·∫¨·∫Æ·∫∞·∫≤·∫¥·∫∂·∫∏·∫∫·∫º·∫æ·ªÄ·ªÇ·ªÑ·ªÜ·ªà·ªä& &·ªå·ªé·ªê·ªí·ªî·ªñ·ªò·ªö·ªú·ªû·ª†·ª¢·ª§·ª¶·ª®·ª™·ª¨·ªÆ·ª∞·ª≤·ª¥·ª∂·ª∏& &·ºà·ºâ·ºä·ºã·ºå·ºç·ºé·ºè·ºò·ºô·ºö·ºõ·ºú·ºù·º®·º©·º™·º´·º¨·º≠·ºÆ·ºØ·º∏·ºπ& &·º∫·ºª·ºº·ºΩ·ºæ·ºø·Ωà·Ωâ·Ωä·Ωã·Ωå·Ωç·Ωô·Ωõ·Ωù·Ωü·Ω®·Ω©·Ω™·Ω´·Ω¨·Ω≠·ΩÆ·ΩØ& &·æà·æâ·æä·æã·æå·æç·æé·æè·æò·æô·æö·æõ·æú·æù·æû·æü·æ®·æ©·æ™·æ´·æ¨·æ≠·æÆ·æØ·æ∏·æπ& &·øò·øô·ø®·ø©‚í∂‚í∑‚í∏‚íπ‚í∫‚íª‚íº‚íΩ‚íæ‚íø‚ìÄ‚ìÅ‚ìÇ‚ìÉ‚ìÑ‚ìÖ‚ìÜ‚ìá‚ìà‚ìâ‚ìä‚ìã‚ìå‚ìç‚ìé‚ìè& &Ôº°Ôº¢Ôº£Ôº§Ôº•Ôº¶ÔºßÔº®Ôº©Ôº™Ôº´Ôº¨Ôº≠ÔºÆÔºØÔº∞Ôº±Ôº≤Ôº≥Ôº¥ÔºµÔº∂Ôº∑Ôº∏ÔºπÔº∫' temp = lower ( upp ) call reportit () codes = low % codepoint () codes ( 82 ) = ichar ( 'i' ) lowkludge = codes !call check('lower', temp==low ) !call check('lower', character(temp)==character(low) ) call check ( 'lower' , temp == lowkludge ) call check ( 'lower' , character ( temp ) == character ( lowkludge ) ) write ( ascii7 , g0 )( achar ( i ), i = 0 , 127 ) ascii7 ( ichar ( 'a' ) + 1 : ichar ( 'z' ) + 1 ) = ' ' ascii7 ( ichar ( 'A' ) + 1 : ichar ( 'Z' ) + 1 ) = ' ' temp = ascii7 !call check('lower',temp%character()==ascii7,'check non-alphameric like'//ascii7(ichar(' ')+1:len(ascii7)-1) ) call check ( 'lower' , upper ( temp ) == lower ( temp ), 'expect no difference' ) call check ( 'lower' , temp == lower ( temp ), 'expect no change' ) temp = upp % lower () !write(*,*)character(temp,82,82) ! known conundrum at 82 i ƒ± letter1 = int ( z \"0049\" ) ! * U+0049 I LATIN CAPITAL LETTER I. letter2 = int ( z \"0130\" ) ! * U+0130 ƒ∞ LATIN CAPITAL LETTER I WITH DOT ABOVE. letter3 = int ( z \"0069\" ) ! * U+0069 i LATIN SMALL LETTER I. (dotted) letter4 = int ( z \"0131\" ) ! * U+0131 ƒ± LATIN SMALL LETTER I DOTLESS temp = replace ( temp , 82 , 82 , letter4 ) call check ( '%lower' , temp == low ) call check ( '%lower' , character ( temp ) == character ( low ) ) contains subroutine reportit () ! known conundrum at 82 i ƒ± do i = 1 , len ( temp ) letter1 = temp % character ( i ) letter2 = low % character ( i , i ) if ( letter1 /= letter2 ) then if ( i . eq . 82 ) then call check ( 'lower' , i == 82 , 'expected difference' // letter1 % character () // letter2 % character ()) else call check ( 'lower' , letter1 == letter2 , 'failed' // letter1 % character () // letter2 % character ()) endif endif enddo end subroutine reportit end subroutine test_lower subroutine test_tokenize () type ( unicode_type ), allocatable :: tokens (:), expected (:) type ( unicode_type ), allocatable :: separators (:) type ( unicode_type ) :: delims type ( unicode_type ) :: herbs character ( len = :), allocatable :: line integer , allocatable , dimension (:) :: begins integer , allocatable , dimension (:) :: ends integer :: i delims = ' ,&' herbs = 'parsley,sage,rosemary&thyme' expected = [ ut ( 'parsley' ), ut ( 'sage' ), ut ( 'rosemary' ), ut ( 'thyme' ) ] CALL TOKENIZE ( herbs , delims , tokens , separators ) line = 'tokens:' do i = 1 , size ( tokens ) line = line // '[' // tokens ( i )% character () // ']' enddo call check ( 'tokenize' , all ( tokens == expected ), line ) expected = [ ut ( ',' ), ut ( ',' ), ut ( '&' ) ] line = 'separators:' do i = 1 , size ( separators ) line = line // '[' // separators ( i )% character () // ']' enddo call check ( 'tokenize' , all ( separators == expected ), line ) CALL TOKENIZE ( herbs , delims , begins , ends ) call check ( 'tokenize' , size ( begins ) == 4 , 'size of begins' ) call check ( 'tokenize' , size ( ends ) == 4 , 'size of ends' ) if ( size ( begins ). eq . 4 . and . size ( ends ). eq . 4 ) then call check ( 'tokenize' , all ( begins == [ 1 , 9 , 14 , 23 ]) , 'begins' ) call check ( 'tokenize' , all ( ends == [ 7 , 12 , 21 , 27 ]) , 'ends' ) endif ! OOP herbs = 'parsleyüòÉsageüòÉrosemaryüòÉüòÉthyme' delims = 'üòÉ' expected = [ ut ( 'parsley' ), ut ( 'sage' ), ut ( 'rosemary' ), ut ( '' ), ut ( 'thyme' ) ] tokens = herbs % tokenize ( delims ) line = 'tokens:' do i = 1 , size ( tokens ) line = line // '[' // tokens ( i )% character () // ']' enddo call check ( 'tokenize' , all ( tokens == expected ), line ) end subroutine test_tokenize subroutine test_sort () type ( unicode_type ), allocatable :: array (:) ! create using ASCII array ! -------------------------------- ! bug? ! array= [ 'red    ','green  ','blue   ','yellow ','orange ','black  ','white  ','brown  ','gray   ','cyan   ','magenta','purple '] ! Fortran runtime error: Array bound mismatch for dimension 1 of array 'array' (25769804402/12) ! -------------------------------- allocate ( array ( 12 )) ! gfortran requires this array (:) = [ 'red    ' , 'green  ' , 'blue   ' , 'yellow ' , 'orange ' , 'black  ' , 'white  ' , 'brown  ' , 'gray   ' , 'cyan   ' , 'magenta' , 'purple ' ] call chk () ! create using UNICODE_TYPE array array = [ ut ( 'RED' ), ut ( 'GREEN' ), ut ( 'BLUE' ), ut ( 'YELLOW' ), ut ( 'ORANGE' ), ut ( 'BLACK' ), & & ut ( 'WHITE' ), ut ( 'BROWN' ), ut ( 'GRAY' ), ut ( 'CYAN' ), ut ( 'MAGENTA' ), ut ( 'PURPLE' )] call chk () contains subroutine chk () integer :: temp integer :: csz integer :: i integer , allocatable :: ints (:) if ( allocated ( ints )) deallocate ( ints ) allocate ( ints ( size ( array ))) call sort ( array , ints ) csz = size ( array ) array = array ( ints ) temp = total call check ( 'sort' , all ( array ( 1 : csz - 1 ) . le . array ( 2 : csz )), 'sort array' ) ! verify in ascending order if ( total . ne . temp ) then do i = 1 , size ( array ) write ( * , g0 ) array ( i )% character () enddo endif end subroutine chk end subroutine test_sort subroutine test_other () type ( unicode_type ) :: string character ( len =* ), parameter :: upagain = & \"‰∏ÉËª¢„Å≥ÂÖ´Ëµ∑„Åç„ÄÇËª¢„Çì„Åß„ÇÇ„Åæ„ÅüÁ´ã„Å°‰∏ä„Åå„Çã„ÄÇ„Åè„Åò„Åë„Åö„Å´Ââç„ÇíÂêë„ÅÑ„Å¶Ê≠©„ÅÑ„Å¶„ÅÑ„Åì„ÅÜ„ÄÇ\" ! Romanization: ! Nanakorobi yaoki. Koronde mo mata tachiagaru. Kujikezu ni mae o muite aruite ikou. ! or English translation ! \"Fall seven times, stand up eight. Even if you fall down, you will get up again. Don't be discouraged, just keep walking forward.\" ! string = upagain write ( * , g0 ) 'original bytes  :' , upagain !------------------- ! doing this generates non-unicode byte sequences in UTF-8, which means ! the OS may not longer recognize the output as UTF-8 !write(*,g0)'bytes reversed  :', (upagain(i:i),i=len(upagain),1,-1) !------------------- write ( * , g0 ) 'original string :' , string % character () write ( * , g0 ) 'string reversed :' , string % character ( string % len (), 1 , - 1 ) end subroutine test_other subroutine test_operators () type ( unicode_type ) :: lhs , rhs character ( len = :), allocatable :: astr type ( unicode_type ) :: smiley type ( unicode_type ) :: ut_str smiley = 'üòÉ' write ( * , g0 ) astr = 'Hello World and Ni Hao -- ‰Ω†Â•Ω' ut_str = astr call checkits ( 'convert to ASCII bytes' , astr , ut_str % byte (), transfer ( 'Hello World and Ni Hao -- ‰Ω†Â•Ω' ,[ 'A' ])) ut_str = smiley . cat . ' and ' . cat . smiley . cat . 'and' . cat . smiley . cat . smiley . cat . 'is it' astr = 'üòÉ and üòÉandüòÉüòÉis it' call checkit ( 'concatenation' , astr , character ( ut_str ), 'üòÉ and üòÉandüòÉüòÉis it' ) lhs = 'this is the left' rhs = 'this is the right' call checkits_l ( 'LLE' , ' ' , [ lle ( lhs , rhs ), lhs <= rhs , lle ( rhs , lhs ), rhs <= lhs ] , [ T , T , F , F ] ) call checkits_l ( 'LLT' , ' ' , [ llt ( lhs , rhs ), lhs < rhs , llt ( rhs , lhs ), rhs < lhs ] , [ T , T , F , F ] ) call checkits_l ( 'LNE' , ' ' , [ lne ( lhs , rhs ), lhs /= rhs , lne ( rhs , lhs ), rhs /= lhs ] , [ T , T , T , T ] ) call checkits_l ( 'LEQ' , ' ' , [ leq ( lhs , rhs ), lhs == rhs , leq ( rhs , lhs ), rhs == lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LGT' , ' ' , [ lgt ( lhs , rhs ), lhs > rhs , lgt ( rhs , lhs ), rhs > lhs ] , [ F , F , T , T ] ) call checkits_l ( 'LGE' , ' ' , [ lge ( lhs , rhs ), lhs >= rhs , lge ( rhs , lhs ), rhs >= lhs ] , [ F , F , T , T ] ) lhs = 'abc' rhs = 'abc ' call checkits_l ( 'LLE' , ' ' , [ lle ( lhs , rhs ), lhs <= rhs , lle ( rhs , lhs ), rhs <= lhs ] , [ T , T , T , T ] ) call checkits_l ( 'LLT' , ' ' , [ llt ( lhs , rhs ), lhs < rhs , llt ( rhs , lhs ), rhs < lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LNE' , ' ' , [ lne ( lhs , rhs ), lhs /= rhs , lne ( rhs , lhs ), rhs /= lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LEQ' , ' ' , [ leq ( lhs , rhs ), lhs == rhs , leq ( rhs , lhs ), rhs == lhs ] , [ T , T , T , T ] ) call checkits_l ( 'LGT' , ' ' , [ lgt ( lhs , rhs ), lhs > rhs , lgt ( rhs , lhs ), rhs > lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LGE' , ' ' , [ lge ( lhs , rhs ), lhs >= rhs , lge ( rhs , lhs ), rhs >= lhs ] , [ T , T , T , T ] ) end subroutine test_operators function random_ascii_string ( chars , length ) result ( out ) !$@(#) M_random::random_string(3f): create random string composed of provided characters of specified length character ( len =* ), intent ( in ) :: chars integer , intent ( in ) :: length character ( len = :), allocatable :: out real :: x integer :: ilen ! length of list of characters integer :: which integer :: i ilen = len ( chars ) out = '' if ( ilen . gt . 0 ) then do i = 1 , length call random_number ( x ) which = nint ( real ( ilen - 1 ) * x ) + 1 out = out // chars ( which : which ) enddo endif end function random_ascii_string subroutine test_split () type ( ut ) :: proverb type ( ut ) :: delims type ( ut ), allocatable :: expected (:) type ( ut ), allocatable :: answer (:) integer :: first integer :: last integer :: pos integer :: i delims = '=|; ' proverb = \"M√°s vale p√°jaro en mano, que ciento volando.\" expected = [ ut ( \"M√°s\" ), ut ( \"vale\" ), ut ( \"p√°jaro\" ), ut ( \"en\" ), ut ( \"mano,\" ), ut ( \"que\" ), ut ( \"ciento\" ), ut ( \"volando.\" ) ] pos = 0 i = 0 do while ( pos < len ( proverb )) first = pos + 1 call split ( proverb , delims , pos ) last = pos - 1 i = i + 1 call check ( 'split' , proverb % character ( first , last ) == expected ( i )% character () , expected ( i )% character () ) enddo ! OOP answer = proverb % split ( ut ( ' ' )) call check ( 'split' , size ( answer ) == size ( expected ) , 'size' ) if ( size ( answer ) == size ( expected ) ) then call check ( 'split' , all ( answer == expected ) , ' oop all at once' ) endif end subroutine test_split subroutine test_scan () type ( ut ) :: line type ( ut ) :: set !     1234567890123456789012345678901234567890 line = 'parsley?|sage?|rosemary?|?|thyme' line = 'parsleyüòÉ|sageüòÉ|rosemaryüòÉ|üòÉ|thyme' set = 'üòÉ|' call check ( 'scan' , scan ( line , set ) == 8 , 'default' ) call check ( 'scan' , scan ( line , set , back = . true .) == 27 , 'back=true' ) call check ( 'scan' , scan ( line , set , back = . false .) == 8 , 'back=false' ) call check ( 'scan' , scan ( line , unicode_type ( \"NOT\" )) == 0 , 'no match' ) ! OOP call check ( 'scan' , line % scan ( set ) == 8 , 'oop test' ) call check ( 'scan' , line % scan ( ut ( \"o\" )) == 17 , 'oop test' ) end subroutine test_scan subroutine test_verify () character ( len =* ), parameter :: int = '1234567890' character ( len =* ), parameter :: hex = 'abcdefABCDEF0123456789' logical :: lout type ( unicode_type ) :: chars type ( unicode_type ) :: str chars = '32‚Äêaf43d' lout = . true . ! are the first two characters integer characters? str = chars % character ( 1 , 2 ) lout = ( verify ( str , ut ( int ) ) == 0 ) . and . lout ! is the third character a dash? str = chars % character ( 3 , 3 ) lout = ( verify ( str , ut ( '‚Äê-' ) ) == 0 ) . and . lout ! is remaining string a valid representation of a hex value? str = chars % character ( 4 , 8 ) lout = ( verify ( str , ut ( hex ) ) == 0 ) . and . lout call check ( 'verify' , lout , chars % character () ) end subroutine test_verify subroutine test_ichar () type ( unicode_type ) :: ut_str ut_str = 'ABC' call check ( 'ichar' , ut_str % ichar (). eq . ichar ( 'A' ), 'string%ichar()' ) call check ( 'ichar' , ichar ( ut ( 'A' )). eq . ichar ( 'A' ), 'ichar(ut(\"A\")' ) call check ( 'ichar' , ichar ( ut_str % sub ( 2 , 3 )). eq . ichar ( 'B' ), 'ichar(ut_str%sub(2,3))' ) end subroutine test_ichar subroutine test_escape () type ( unicode_type ) :: ut_str integer , allocatable :: ints (:) !    \\      backslash !    a      alert (BEL) -- g is an alias for a !    b      backspace !    c      suppress further output !    e      escape !    f      form feed !    n      new line !    r      carriage return !    t      horizontal tab !    v      vertical tab ! !    oNNN   byte with octal value NNN (3 digits) !    0-9    up to three digits following will be treated !           as an octal value !    dNNN   byte with decimal value NNN (3 digits) !    xHH        byte with hexadecimal value HH (2 digits); !               h is an alias for x !    uZZZZ      translate Unicode codepoint value to bytes !    UZZZZZZZZ  translate Unicode codepoint value to bytes ut_str = '\\\\\\a\\b\\e\\f\\n\\r\\t\\v\\c' ints = [ 92 , 7 , 8 , 27 , 12 , 10 , 13 , 9 , 11 ] ut_str = escape ( ut_str ) call check ( 'escape' , len ( ut_str ). eq . 9 , 'size' ) if ( len ( ut_str ). eq . 9 ) then call check ( 'escape' , all ( ut_str % codepoint (). eq . ints ), 'codes' ) endif call check ( 'escape' , escape ( ut ( '\\')).eq.' \\ ',' backslash at end of line ') call check(' escape ',escape(ut(' text \\ 0 ')).eq.' text '//char(0),' null at end ') call check(' escape ',escape(ut(' \\ 122 \\ 123 A ')).eq.' RSA ',' two ') ! (kaufii hai?) [Literal Meaning: ‚ÄúIs there coffee?‚Äù] ‚ÄúDo you have coffee?‚Äù (Informal) ut_str=' \\ u0915 \\ u0949 \\ u092B \\ U0000093C \\ U00000940 \\ x20 \\ u0939 \\ u0948 \\ x3F ' call check(' escape ',escape(ut_str).eq.' ‡§ï‡•â‡§´‡§º‡•Ä ‡§π‡•à? ',' hexadecimal ') end subroutine test_escape subroutine test_join() character(len=20),allocatable :: proverb(:) type(ut),allocatable       :: s(:) type(ut),allocatable       :: sep type(ut)                   :: expected proverb=[ character(len=13) :: & & ' United '       ,& & ' we '          ,& & ' stand , '     ,& & ' divided '   ,& & ' we fall . ' ] allocate(s(size(proverb))) ! avoid GNU Fortran (GCC) 16.0.0 bug s=proverb expected=' Unitedwestand , dividedwe fall . ' call check(' join ', join(s) == expected, ' SIMPLE JOIN ' ) expected=' United we stand , divided we fall . ' call check(' join ', join(s,sep=ut(' ') ) == expected, ' JOIN WITH SEPARATOR ' ) expected=' United <--> we <--> stand , <--> divided <--> we fall . ' call check(' join ', join(s,sep=ut(' <--> ')) == expected, ' CUSTOM SEPARATOR ' ) expected=' United we stand , divided we fall . ' call check(' join ', join(s,clip=.false.)  == expected, ' NO TRIMMING ' ) sep=ut() expected=' Unitedwestand , dividedwe fall . ' call check(' join ', sep%join(s)==expected, ' OOP SIMPLE JOIN ') sep=' ' expected=' United we stand , divided we fall . ' call check(' join ', sep%join(s)==expected, ' OOP JOIN WITH SEPARATOR ') sep=' <--> ' expected=' United <--> we <--> stand , <--> divided <--> we fall . ' call check(' join ', sep%join(s)==expected, ' OOP CUSTOM SEPARATOR ') sep='' expected=' United we stand , divided we fall . ' call check(' join ', sep%join(s,clip=.false.)==expected, ' OOP NO TRIMMING ') end subroutine test_join subroutine test_pad() type(ut)                   :: string type(ut)                   :: answer ! string=' abcdefghij ' answer=' [ abcdefghij ] ' call check(' pad ',bracket(pad(string,20)) == answer,' pad on right till 20 characters long ') answer=' [ abcdefghij ] ' call check(' pad ',bracket(pad(string,5)) == answer,' original is not truncated for short specified length ') ! non-blank pattern ! pad on left call check(' pad ', pad(ut(' 12 '),5,ut(' 0 '),right=.false.) == ' 00012 ', ' pad on left with zeros ') string=' 12345 ' call check(' pad ', bracket(pad(string,15,ut(' _ '),right=.false.,clip=.true.)) == ' [ __________ 12345 ] ',& &character(bracket(pad(string,15,ut(' _ '),right=.false.,clip=.true.))) ) call check(' pad ', bracket(pad(string,15,ut(' _ '),right=.false.,clip=.false.)) == ' [ _________ 12345 ] ',& &character(bracket(pad(string,15,ut(' _ '),right=.false.,clip=.false.))) ) call check(' pad ', bracket(pad(string, 7,ut(' _ '),right=.false.,clip=.true.)) == ' [ __ 12345 ] ',& &character(bracket(pad(string,7,ut(' _ '),right=.false.,clip=.true.))) ) call check(' pad ', bracket(pad(string, 7,ut(' _ '),right=.false.,clip=.false.)) == ' [ _ 12345 ] ',& &character(bracket(pad(string,7,ut(' _ '),right=.false.,clip=.false.))) ) call check(' pad ', bracket(pad(ut(' 12345 '), 6,ut(' _ '),right=.false.,clip=.true.)) == ' [ _ 12345 ] ',& &character(bracket(pad(string,6,ut(' _ '),right=.false.,clip=.true.))) ) call check(' pad ', bracket(pad(ut(' 12345 '), 6,ut(' _ '),right=.false.,clip=.false.)) == ' [ 12345 ] ',& &character(bracket(pad(string,6,ut(' _ '),right=.false.,clip=.false.))) ) call check(' pad ', bracket(pad(ut(' 12345 '), 5,ut(' _ '),right=.false.,clip=.true.)) == ' [ 12345 ] ',& &character(bracket(pad(string,5,ut(' _ '),right=.false.,clip=.true.))) ) call check(' pad ', bracket(pad(ut(' 12345 '), 5,ut(' _ '),right=.false.,clip=.false.)) == ' [ 12345 ] ',& &character(bracket(pad(string,5,ut(' _ '),right=.false.,clip=.false.))) ) call check(' pad ', bracket(pad(ut(' 12345 '), 4,ut(' _ '),right=.false.,clip=.true.)) == ' [ 12345 ] ',& &character(bracket(pad(string,4,ut(' _ '),right=.false.,clip=.true.))) ) call check(' pad ', bracket(pad(ut(' 12345 '), 4,ut(' _ '),right=.false.,clip=.false.)) == ' [ 12345 ] ',& &character(bracket(pad(string,4,ut(' _ '),right=.false.,clip=.false.))) ) contains function bracket(line) result (bracketed) type(unicode_type),intent(in) :: line type(unicode_type)            :: bracketed bracketed=' [ '.cat.line.cat.' ] ' end function bracket end subroutine test_pad subroutine test_sub() type(unicode_type)           :: line line=' this is the string ' call check(' sub ', ' this is the string '  == character( sub(line    ) ) ) call check(' sub ', ' the string '          == character( sub(line, 9 ) ) ) call check(' sub ', ' this is '  == character( sub(line,  1,        8) ) ) call check(' sub ', ' the string '== character( sub(line,  9,len(line)) ) ) call check(' sub ', ' is the '    == character( sub(line,  6,       11) ) ) call check(' sub ', ' this is the string '  == character( line%sub(            ) ) ) call check(' sub ', ' the string '          == character( line%sub( 9          ) ) ) call check(' sub ', ' this is '            == character( line%sub( 1,        8) ) ) call check(' sub ', ' the string '          == character( line%sub( 9,len(line)) ) ) call check(' sub ', ' is the '              == character( line%sub( 6,       11) ) ) ! end subroutine test_sub subroutine test_replace() type(unicode_type)           :: line character(len=:),allocatable :: aline ! call check(' replace ',& ' this is the string ' == character( replace(ut(' Xis is Xe string '),ut(' X '),ut(' th ') ) ) ) call check(' replace ',& ' this is the string '==character( replace(ut(' Xis is xe string '),ut(' x '),ut(' th '),ignorecase=.true.) ) ) call check(' replace ',& ' this is xe string '==character( replace(ut(' Xis is xe string '),ut(' X '),ut(' th '),ignorecase=.false.) ) ) call check(' replace ',& ' BEFORE : my line of text '==character(replace(ut(' my line of text '),ut(''),ut(' BEFORE : '))),& ' a null new substring means \"at beginning of line\" ' ) ! call check(' replace ',& ' I wonder '== character(replace(ut(' I wonder i ii iii '),ut(' i '),ut('')) ),& ' a null new string deletes occurrences of the old substring ' ) ! ! Examples of the use of RANGE ! line=replace(ut(' aaaaaaaaa '),ut(' a '),ut(' A '),occurrence=1,repeat=1) call check(' replace ', line == ut(' Aaaaaaaaa '), ' replace first a with A [ '//line%character()//' ] ' ) ! line=replace(ut(' aaaaaaaaa '),ut(' a '),ut(' A '),occurrence=3,repeat=3) call check(' replace ', line==ut(' aaAAAaaaa '),' replace a with A for 3 rd to 5 th occurrence [ '//line%character()//' ] ') ! line=replace(ut(' ababababa '),ut(' a '),ut(''),occurrence=3,repeat=3) call check(' replace ',line==ut(' ababbb '),' replace a with null instances 3 to 5 [ '//line%character()//' ] ' ) ! line=replace( & & ut(' a b ab baaa aaaa aa aa a a a aa aaaaaa '),& & ut(' aa '),ut(' CCCC '),occurrence=-1,repeat=1) call check(' replace ', line == ut(' a b ab baaa aaaa aa aa a a a aa aaaaCCCC '),' replace last aa with CCCC [ '//line%character()//' ] ') ! line=replace(ut(' myf90stuff . f90 . f90 '),ut(' f90 '),ut(' for '),occurrence=-1,repeat=1) call check(' replace ',line== ' myf90stuff . f90 . for ') line=replace(ut(' myf90stuff . f90 . f90 '),ut(' f90 '),ut(' for '),occurrence=-2,repeat=2) call check(' replace ',line==' myforstuff . for . f90 ') ! line=' ABCDEFGHIJ ' call check(' replace ',ut(' ABCdEFGHIJ ')   == replace(line,4,4,' d '),    ' replace a column ') call check(' replace ',ut(' ABCGHIJ ')      == replace(line,4,6,''),     ' remove columns in middle ') call check(' replace ',ut(' ABCDE ')        == replace(line,6,10,''),    ' remove columns at end ') call check(' replace ',ut(' ABCDEend ')     == replace(line,6,10,' end '), ' replace end ') call check(' replace ',ut(' startDEFGHIJ ') == replace(line,1,3,' start '),' replace start ') call check(' replace ',ut(' FGHIJ ')        == replace(line,1,5,''),     ' remove start '//ch(replace(line,1,5,''))) ! ! combinations of character and string parameters call check(' replace ',ut(' ABC [ def ] GHIJ ') == replace( line,   ' DEF ',    ' [ def ] '), ' replace string ') call check(' replace ',ut(' ABC [ def ] GHIJ ') == replace( line,ut(' DEF '),ut(' [ def ] ')),' replace string ') call check(' replace ',ut(' ABC [ def ] GHIJ ') == replace( line,   ' DEF ', ut(' [ def ] ')),' replace string ') call check(' replace ',ut(' ABC [ def ] GHIJ ') == replace( line,ut(' DEF '),   ' [ def ] '), ' replace string ') aline=line call check(' replace ',ut(' ABC [ def ] GHIJ ') == replace(aline,   ' DEF ',    ' [ def ] '), ' replace string ') call check(' replace ',ut(' ABC [ def ] GHIJ ') == replace(aline,ut(' DEF '),ut(' [ def ] ')),' replace string ') call check(' replace ',ut(' ABC [ def ] GHIJ ') == replace(aline,   ' DEF ', ut(' [ def ] ')),' replace string ') call check(' replace ',ut(' ABC [ def ] GHIJ ') == replace(aline,ut(' DEF '),   ' [ def ] '), ' replace string ') !ifx bug!call check(' replace ',ut(' ABC [ def ] GHIJ ') == line%replace(   ' DEF ',    ' [ def ] '), ' replace string ') !ifx bug!call check(' replace ',ut(' ABC [ def ] GHIJ ') == line%replace(ut(' DEF '),ut(' [ def ] ')),' replace string ') !ifx bug!call check(' replace ',ut(' ABC [ def ] GHIJ ') == line%replace(   ' DEF ', ut(' [ def ] ')),' replace string ') !ifx bug!call check(' replace ',ut(' ABC [ def ] GHIJ ') == line%replace(ut(' DEF '),   ' [ def ] '), ' replace string ') !ifx bug!call check(' replace ',ut(' ABCdEFGHIJ ')  == line%replace(4,4,' d '),     ' oop replace a column ') !ifx bug!call check(' replace ',ut(' ABCDE ')       == line%replace(6,10,''),     ' oop remove columns ') !ifx bug!call check(' replace ',ut(' ABCDEend ')    == line%replace(6,10,' end '),  ' oop replace end ') !ifx bug!call check(' replace ',ut(' startDEFGHIJ ')== line%replace(1,3,' start '), ' oop replace start ') end subroutine test_replace subroutine test_transliterate() type(ut)  :: STRING, UPPER, LOWER, ANSWER, EXPECTED type(ut)  :: MIDDLE_DOT ! ! | Œë Œ± | Œí Œ≤ | Œì Œ≥ | Œî Œ¥ | Œï Œµ | Œñ Œ∂   | ! | Œó Œ∑ | Œò Œ∏ | Œô Œπ | Œö Œ∫ | Œõ Œª | Œú Œº   | ! | Œù ŒΩ | Œû Œæ | Œü Œø | Œ† œÄ | Œ° œÅ | Œ£ œÉ œÇ | ! | Œ§ œÑ | Œ• œÖ | Œ¶ œÜ | Œß œá | Œ® œà | Œ© œâ   | ! STRING=' ŒëŒ±ŒíŒ≤ŒìŒ≥ŒîŒ¥ŒïŒµŒñŒ∂ŒóŒ∑ŒòŒ∏ŒôŒπŒöŒ∫ŒõŒªŒúŒºŒùŒΩŒûŒæŒüŒøŒ†œÄŒ°œÅŒ£œÉœÇŒ§œÑŒ•œÖŒ¶œÜŒßœáŒ®œàŒ©œâ ' ! ignoring œÇ for simplicity UPPER=' ŒëŒíŒìŒîŒïŒñŒóŒòŒôŒöŒõŒúŒùŒûŒüŒ†Œ°Œ£Œ§Œ•Œ¶ŒßŒ®Œ© ' LOWER=' Œ±Œ≤Œ≥Œ¥ŒµŒ∂Œ∑Œ∏ŒπŒ∫ŒªŒºŒΩŒæŒøœÄœÅœÉœÑœÖœÜœáœàœâ ' ANSWER=TRANSLITERATE(STRING , LOWER, UPPER ) ! convert ASCII-7 string to uppercase: EXPECTED=' ŒëŒëŒíŒíŒìŒìŒîŒîŒïŒïŒñŒñŒóŒóŒòŒòŒôŒôŒöŒöŒõŒõŒúŒúŒùŒùŒûŒûŒüŒüŒ†Œ†Œ°Œ°Œ£Œ£œÇŒ§Œ§Œ•Œ•Œ¶Œ¶ŒßŒßŒ®Œ®Œ©Œ© ' call check(' transliterate ', answer == expected, ' one - to - one correspondence ') ANSWER=TRANSLITERATE(STRING, LOWER, ' : ')     ! change all miniscule letters to a colon (\":\"): EXPECTED=' Œë : Œí : Œì : Œî : Œï : Œñ : Œó : Œò : Œô : Œö : Œõ : Œú : Œù : Œû : Œü : Œ† : Œ° : Œ£ : œÇŒ§ : Œ• : Œ¶ : Œß : Œ® : Œ© : ' call check(' transliterate ', answer == expected, ' set to a single character ') ANSWER=TRANSLITERATE(STRING, LOWER, '')      ! delete all miniscule letters EXPECTED=' ŒëŒíŒìŒîŒïŒñŒóŒòŒôŒöŒõŒúŒùŒûŒüŒ†Œ°Œ£œÇŒ§Œ•Œ¶ŒßŒ®Œ© ' call check(' transliterate ', answer == expected, ' delete all miniscule letters ') ! OOP EXPECTED=' _Œ±_Œ≤_Œ≥_Œ¥_Œµ_Œ∂_Œ∑_Œ∏_Œπ_Œ∫_Œª_Œº_ŒΩ_Œæ_Œø_œÄ_œÅ_œÉœÇ_œÑ_œÖ_œÜ_œá_œà_œâ ' ANSWER=STRING%TRANSLITERATE(UPPER,' _ ') call check(' transliterate ', answer == expected, ' OOP unicode : ASCII ') ! U+00B7 Middle Dot Unicode Character EXPECTED=' Œë¬∑Œí¬∑Œì¬∑Œî¬∑Œï¬∑Œñ¬∑Œó¬∑Œò¬∑Œô¬∑Œö¬∑Œõ¬∑Œú¬∑Œù¬∑Œû¬∑Œü¬∑Œ†¬∑Œ°¬∑Œ£¬∑œÇŒ§¬∑Œ•¬∑Œ¶¬∑Œß¬∑Œ®¬∑Œ©¬∑ ' ANSWER=STRING%TRANSLITERATE(LOWER,' ¬∑ ') ! ASCII bytes call check(' transliterate ', answer == expected, ' OOP unicode : ascii stream ') EXPECTED=' Œë¬∑Œí¬∑Œì¬∑Œî¬∑Œï¬∑Œñ¬∑Œó¬∑Œò¬∑Œô¬∑Œö¬∑Œõ¬∑Œú¬∑Œù¬∑Œû¬∑Œü¬∑Œ†¬∑Œ°¬∑Œ£¬∑œÇŒ§¬∑Œ•¬∑Œ¶¬∑Œß¬∑Œ®¬∑Œ©¬∑ ' ANSWER=STRING%TRANSLITERATE(LOWER,ut(' ¬∑ ')) ! cast call check(' transliterate ', answer == expected, ' OOP unicode : unicode ') EXPECTED=' Œë¬∑Œí¬∑Œì¬∑Œî¬∑Œï¬∑Œñ¬∑Œó¬∑Œò¬∑Œô¬∑Œö¬∑Œõ¬∑Œú¬∑Œù¬∑Œû¬∑Œü¬∑Œ†¬∑Œ°¬∑Œ£¬∑œÇŒ§¬∑Œ•¬∑Œ¶¬∑Œß¬∑Œ®¬∑Œ©¬∑ ' MIDDLE_DOT=int(z' 00 B7 ') ANSWER=STRING%TRANSLITERATE(LOWER,MIDDLE_DOT) ! hexadecimal call check(' transliterate ', answer == expected, ' OOP unicode : unicode ') end subroutine test_transliterate end module testsuite_M_unicode program test_M_unicode use testsuite_M_unicode total = 0 !write(*,g0)' encoding can be altered on an open file ' !open (output_unit, encoding=' UTF - 8 ') call programming_environment() call test_adjustl() call test_adjustr() call test_trim() call test_len_trim() call test_len() call test_index() call test_repeat() call test_transliterate() call test_upper() call test_lower() call test_tokenize() call test_sort() call test_operators() call test_split() call test_scan() call test_verify() call test_ichar() call test_replace() call test_sub() call test_pad() call test_join() call test_expandtabs() call test_fmt() call test_escape() call test_concatenate() call test_other() write(*,g0) if(total.ne.0)then write(*,g0)total,' failures ' stop 1 else write(*,g0)' all passed ' endif end program test_M_unicode","tags":"","url":"sourcefile/test_m_unicode.f90.html"},{"title":"demo_sub.f90 ‚Äì M_unicode","text":"Source Code program demo_sub use M_unicode , only : sub , assignment ( = ) use M_unicode , only : len use M_unicode , only : ut => unicode_type implicit none type ( ut ) :: string type ( ut ) :: piece ! string = 'abcdefghij' ! piece = sub ( string , 3 , 5 ) call printme ( 'selected range:' ) piece = sub ( string , 6 ) call printme ( 'from character to end:' ) piece = sub ( string , 5 , 5 ) call printme ( 'single character:' ) piece = sub ( string , step =- 1 ) call printme ( 'reverse string:' ) contains subroutine printme ( label ) character ( len =* ), intent ( in ) :: label write ( * , '(a,\"[\",g0,\"]\",/)' ) label , piece % character () end subroutine printme end program demo_sub","tags":"","url":"sourcefile/demo_sub.f90.html"}]}