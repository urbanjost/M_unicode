var tipuesearch = {"pages":[{"title":" M_unicode ","text":"M_unicode A WIP (Work In Progress) The intent is for the M_unicode module to be useful on many platforms, but currently\nit is primarily tested with GCC/gfortran and Intel/ifx on Linux and Cygwin. It needs\na DT for printing. M_unicode module This module provides support for operating on byte streams\nrepresenting UTF-8 encoded text and Unicode codepoints.\nConversion of UTF-8 to and from Unicode codepoints is supported\nas well as all basic intrinsics and operators and ragged arrays\nof strings using a user-defined type. program testit use iso_fortran_env , only : stdout => output_unit ! user-defined type to hold Unicode text use M_unicode , only : unicode_type ! convert unicode_type to CHARACTER variables use M_unicode , only : character ! intrinsic overloads use M_unicode , only : adjustl , adjustr use M_unicode , only : trim , len , len_trim use M_unicode , only : index , scan , verify use M_unicode , only : repeat use M_unicode , only : split , tokenize use M_unicode , only : upper , lower use M_unicode , only : sort ! operators (and overloads) and assignment use M_unicode , only : assignment ( = ) use M_unicode , only : operator ( <= ), lle use M_unicode , only : operator ( < ), llt use M_unicode , only : operator ( /= ), lne use M_unicode , only : operator ( == ), leq use M_unicode , only : operator ( > ), lgt use M_unicode , only : operator ( >= ), lge use M_unicode , only : operator ( // ) ! low-level text conversion to integer codepoint arrays: use M_unicode , only : utf8_to_codepoints , codepoints_to_utf8 implicit none type ( unicode_type ) :: ustr character ( len =* ), parameter :: g = '(*(g0))' !open (stdout, encoding='UTF-8') ! preferred, but not required if not supported ! Constructors ! UNICODE_VARIABLE= UNICODE_VARIABLE|CHARACTER(LEN=*)|INTEGER_ARRAY ! VARiABLE%CHARACTER(start,end,step) returns a CHARACTER string ! VARiABLE%BYTES() returns an array of CHARACTER(len=1) values ustr = 'Hello World and Ni Hao -- 你好  ' write ( stdout , g ) character ( ustr ) ! convert to intrinsic CHARACTER variable write ( stdout , g ) len ( ustr ) write ( stdout , g ) len_trim ( ustr ) write ( stdout , g ) ustr % character ( 27 , 28 ) ! similiar to LINE(27:28) write ( stdout , g ) index ( ustr , '你' ) ! OOPS write ( stdout , g ) ustr % character ( len ( ustr ), 1 , - 1 ) ! reverse string write ( stdout , g ) ustr % codepoint () ! Unicode codepoint values end program testit Unicode usage from Fortran when UTF-8 source files are supported Fortran 2003 and later standards describe internal representation of\nUnicode using 4-byte-per-character UCS-4 encoding for characters/glyphs,\nincluding an ability to automatically encode and decode data read and\nwritten to UTF-8 files. But Unicode support is optional. Where Unicode is supported (ie. where CHARACTER(KIND=”ISO_10646”)\nis provided)\nThe M_utf8 repository\nsupplements Unicode usage – emphasizing adherence to the standard to\npromote portability. When the compiler does not support CHARACTER(KIND=”ISO_10646”) it\nstill may support UTF-8 source files and permit entering multi-byte\nUnicode characters in comments and (more importantly) in constant\nstrings. This is now very common, as nearly all current operating systems\nand many applications support UTF-8 text files. But whether in input and output files, or as what-you-see-is-what-you-get\ncharacter constants the compiler will see this text as byte streams, and\nwill be unaware of how many Unicode glyphs/characters are represented. So it may often be easy to place Unicode characters in fixed messages, but\nif the text needs manipulated or processed in any way dealing with Unicode\nas a raw series of 8-bit-bytes becomes complex and non-intuitive. To keep processing of Unicode as simple as processing ASCII-7 characters\nthe M_unicode module provides a user-defined type named UNICODE_TYPE and a number of procedures for converting byte streams that represent\nUTF8-encoded text into Unicode code points (ie, 32-bit integer values\nthat generally identify one specific Unicode character). Additionally the most common character-related intrinsics and operators\nare overloaded to work with the UNICODE_TYPE variables; and the type is\nextended to include the procedures and operators as type-bound procedures\nfor programmers that prefer OOP (Object-Oriented Programming) capabilities. UTF-8 source files – just in comments and constants The Fortran character set is the set of characters used in constructing\nFortran code. It is now the same as the ASCII 7-bit character set sans\nthe unprintable control characters. The letters a-z,A-Z and digits 0-9\nand underscore are the only characters allowed in operator symbols. These\nsame characters and the “special” characters (the remaining printable\nASCII 7-bit characters) are used for operators and bracketing, and\nvarious forms of separating and delimiting other lexical tokens. But what about other non-ASCII-7 characters representable by the\nprocessor?  Possibilities include the extended ASCII characters or\nmulti-byte characters as defined for UTF-8 text files. The standard\nstates that, whatever those “additional characters” are, they may appear\nin character constants: 6.1.6 Other characters Additional characters may be representable in the processor , but shall appear on ly in comments ( 6.3.2.3 , 6.3.3.2 ), character constants ( 7.4.4 ), input / output records ( 12.2.2 ), and character string edit descriptors ( 13.3.2 ) . Since ASCII-7-bit is a subset of UTF-8 it is very likely that if your\nsystem supports UTF-8 files that it therefore will allow multi-byte\ncharacters to be represented in comments and character constants. But it is up to the processor whether it supports or even allows\nUTF-8 files.  In the past when UTF-8 file support was rare this meant\nusing UTF-8 multi-byte characters in source files was likely to be very\nnon-portable.  Now that UTF-8 files are supported on most systems this\nextension can be useful, particularly with compilers that do not support\nUCS-4 yet. Without using any Fortran Unicode support features, if the output\nis redirected to a file does it appear correctly? program multibyte character ( len =* ), parameter :: all = '(*(g0))' print all , 'Confucius never claimed to be a prophet, ' print all , 'but I think he foresaw AI! He said ' print all print all , ' \"学而不思则罔，思而不学则殆\"' print all , 'or ' print all , ' (xué ér bù sī zé wǎng, sī ér bù xué zé dài),' print all , 'or ' print all , ' \"To learn without thinking is to be lost, ' print all , ' to think without learning is to be in danger\".' end program multibyte Does it display properly when written to the screen? You might have\na terminal that does not support UTF-8 characters, or might have to\nset your locale properly. If it is not the terminal and your compiler\ndoes support ISO-10646 specifying the encoding of the output file\nas UTF-8 will likely correct any output issues even though the strings\nare a series of bytes and not UCS-4 encoded: program multibyte_encoded use , intrinsic :: iso_fortran_env , only : stdout => output_unit implicit none open ( stdout , encoding = 'utf-8' ) write ( stdout , '(a)' ) & 'Confucius never claimed to be a prophet, ' ,& 'but I think he foresaw AI! He said ' ,& '' ,& ' \"学而不思则罔，思而不学则殆\"' ,& 'or' ,& ' (xué ér bù sī zé wǎng, sī ér bù xué zé dài),' ,& 'or' ,& ' \"To learn without thinking is to be lost, ' ,& ' to think without learning is to be in danger\".' end program multibyte_encoded Remember that unless the compiler directly supports UTF-8 representation\n( so far I have identified no compilers that do so) these strings are seen\nby the compiler as a string of bytes, and is otherwise unaware they\nrepresent Unicode characters. If they are just to be read and written as-is\nas in the previous example program that is not a major concern; but if you\nare manipulating or processing the strings in significant ways you probably\nwant to convert the strings to TYPE(UNICODE_TYPE). Summary Yes, a Fortran source file can contain multibyte Unicode characters, but\nthe level of support and how they are handled depends on the specific\nFortran compiler and operating system and is not otherwise defined by\nthe Fortran standard. The appearance of multi-byte characters in comments and character\nconstants is typically all that is allowed and compiler errors occur\nwhen unsupported characters outside the Fortran character set are used\nin the body of the code – unless the vendor extends Fortran beyond the\nrequirements of the Fortran standard. It is assumed here that is not\nthe case; so be careful that outside of quoted strings and comments that\nonly ASCII-7-bit characters are used to write the actual coding instructions. Some editors might try to be “helpful” and change ASCII quote and dash\ncharacters to other characters when editing UTF-8 files, so be aware\nyou might need to normalize your source files into the allowed Fortran\ncharacter set. When using Unicode as byte streams avoid list-directed output. It\ndoes not know which bytes are composing a glyph and may split lines at\ninappropriate points. Compiler Support: Even with standard features, compiler support for Unicode in source\n   files can vary. Some compilers might require specific flags (e.g.,\n   -qmbcs for XL Fortran) or might offer better integration with\n   system-level Unicode functionalities. Source File Encoding: The encoding of the Fortran source file itself is crucial. If the\n    file is saved in a Unicode encoding like UTF-8, the compiler needs\n   to be able to correctly interpret these characters during compilation. Limitations: While modern Fortran can handle Unicode characters, there might still be\nlimitations compared to languages like C++ regarding the ease of use with\ncomplex Unicode features (e.g., surrogate pairs, text directionality, normalization). In summary: While it is possible to include multibyte Unicode characters in Fortran\nsource files, especially with modern Fortran standards and supportive\ncompilers, it requires careful consideration of the compiler’s\ncapabilities and the source file’s encoding. ## References\n * Initially based on a discussion begun in\nhttps://fortran-lang.discourse.group/t/how-to-use-utf-8-in-gfortran/9949, 2025-08;\nincluding features and enhancements from Francois Jacq. The improvements include procedures for handling ASCII encoding extensions\n   often used for internationalization that pre-date Unicode, such as the\n   Latin encodings now in module M_isolatin . See Also https://fortran-lang.discourse.group/t/how-to-use-utf-8-in-gfortran/9949 https://fortran-lang.discourse.group/t/how-do-i-file-read-french-special-characters-like-e-etc/6618 https://fortran-lang.discourse.group/t/using-unicode-characters-in-fortran/2764 Developer Info John S. Urban","tags":"home","url":"index.html"},{"title":"unicode_type – M_unicode ","text":"type, public :: unicode_type Constructor public        interface unicode_type private module function new_codes(codes) result(new) Arguments Type Intent Optional Attributes Name integer, intent(in) :: codes (:) Return Value type( unicode_type ) private elemental module function new_str(string) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Return Value type( unicode_type ) Type-Bound Procedures procedure, public :: adjustl => oop_adjustl private  function oop_adjustl(self) result(string_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self Return Value type( unicode_type ) procedure, public :: adjustr => oop_adjustr private  function oop_adjustr(self) result(string_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self Return Value type( unicode_type ) procedure, public :: bytes => oop_bytes private  function oop_bytes(self, first, last, step) result(bytes_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self integer, intent(in), optional :: first integer, intent(in), optional :: last integer, intent(in), optional :: step Return Value character(len=1), allocatable, (:) procedure, public :: character => oop_character private  function oop_character(self, first, last, step) result(str_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self integer, intent(in), optional :: first integer, intent(in), optional :: last integer, intent(in), optional :: step Return Value character(len=:), allocatable procedure, public :: codepoint => oop_codepoint private  function oop_codepoint(self, first, last, step) result(codes_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self integer, intent(in), optional :: first integer, intent(in), optional :: last integer, intent(in), optional :: step Return Value integer, allocatable, (:) procedure, public :: index => oop_index private impure function oop_index(self, substring) result(index_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self class(*), intent(in) :: substring Return Value integer procedure, public :: len => oop_len private pure function oop_len(self) result(len_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self Return Value integer procedure, public :: len_trim => oop_len_trim private pure function oop_len_trim(self) result(len_trim_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self Return Value integer procedure, public :: lower => oop_lower private  function oop_lower(self) result(string_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self Return Value type( unicode_type ) procedure, public :: scan => oop_scan private pure function oop_scan(self, set, back) result(pos) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self class( unicode_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer procedure, public :: split => oop_split private  function oop_split(self, set) result(tokens) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self type( unicode_type ), intent(in) :: set Return Value type( unicode_type ), allocatable, (:) procedure, public :: tokenize => oop_tokenize private  function oop_tokenize(self, set) result(tokens) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self type( unicode_type ), intent(in) :: set Return Value type( unicode_type ), allocatable, (:) procedure, public :: trim => oop_trim private pure function oop_trim(self) result(string_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self Return Value type( unicode_type ) procedure, public :: upper => oop_upper private  function oop_upper(self) result(string_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self Return Value type( unicode_type ) procedure, public :: verify => oop_verify private impure function oop_verify(self, set, back) result(pos) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self class( unicode_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer Source Code type :: unicode_type ! Unicode string type holding an arbitrary sequence of integer codes. !sequence ! not used for storage association; a kludge to prevent extending this type. private integer , allocatable :: codes (:) contains ! METHODS: procedure :: character => oop_character procedure :: codepoint => oop_codepoint procedure :: bytes => oop_bytes procedure :: adjustl => oop_adjustl procedure :: adjustr => oop_adjustr procedure :: index => oop_index procedure :: len => oop_len procedure :: len_trim => oop_len_trim procedure :: trim => oop_trim procedure :: split => oop_split procedure :: tokenize => oop_tokenize procedure :: scan => oop_scan procedure :: verify => oop_verify procedure :: upper => oop_upper procedure :: lower => oop_lower !DECLARATION OF OVERLOADED OPERATORS FOR TYPE(UNICODE_TYPE) procedure , private :: eq => oop_eq !   generic           :: operator(==) => eq !   procedure,private :: ge => oop_ge !   generic           :: operator(>=) => oop_ge !   procedure,private :: lt => oop_lt !   generic           :: operator(<)  => oop_lt !   procedure,private :: gt => oop_gt !   generic           :: operator(>)  => oop_gt !   procedure,private :: le => oop_le !   generic           :: operator(<=) => oop_le !   procedure,private :: ne => oop_ne !   generic           :: operator(/=) => oop_ne !   procedure,private :: string_append_value !   generic           :: operator(//) => string_append_value end type unicode_type","tags":"","url":"type/unicode_type.html"},{"title":"printwords – M_unicode","text":"impure elemental subroutine printwords(line) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: line Source Code impure elemental subroutine printwords ( line ) type ( ut ), intent ( in ) :: line pos = 0 write ( * , g ) line % character (), len ( line ) do while ( pos < len ( line )) first = pos + 1 call split ( line , delims , pos ) last = pos - 1 print g , line % character ( first , last ), first , last , pos end do end subroutine printwords","tags":"","url":"proc/printwords.html"},{"title":"lower – M_unicode","text":"public pure elemental function lower(str) result(string) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: str Return Value type( unicode_type ) Source Code elemental pure function lower ( str ) result ( string ) ! ident_25=\"@(#) M_unicode lower(3f) returns a lowercase string\" type ( unicode_type ), intent ( in ) :: str ! input string to convert to all lowercase type ( unicode_type ) :: string ! output string that contains no miniscule letters integer :: i ! loop counter integer :: pos integer , parameter :: ade_a = iachar ( 'A' ), ade_z = iachar ( 'Z' ) integer , parameter :: diff = iachar ( 'A' ) - iachar ( 'a' ) string = str do i = 1 , len ( str ) ! step thru each letter in the string in specified range select case ( str % codes ( i )) case ( ade_a : ade_z ) string % codes ( i ) = str % codes ( i ) - diff case default pos = binary_search ( uplow (:, 1 ), str % codes ( i )) if ( pos > 0 ) then string % codes ( i ) = uplow ( pos , 2 ) endif end select enddo if ( len ( str ). eq . 0 ) string = str end function lower","tags":"","url":"proc/lower.html"},{"title":"upper – M_unicode","text":"public pure elemental function upper(str) result(string) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: str Return Value type( unicode_type ) Source Code elemental pure function upper ( str ) result ( string ) ! ident_25=\"@(#) M_unicode upper(3f) returns an uppercase string\" type ( unicode_type ), intent ( in ) :: str ! input string to convert to all uppercase type ( unicode_type ) :: string ! output string that contains no miniscule letters integer :: i ! loop counter integer :: pos integer , parameter :: ade_a = iachar ( 'a' ), ade_z = iachar ( 'z' ) integer , parameter :: diff = iachar ( 'A' ) - iachar ( 'a' ) string = str do i = 1 , len ( str ) ! step thru each letter in the string in specified range select case ( str % codes ( i )) case ( ade_a : ade_z ) string % codes ( i ) = str % codes ( i ) + diff case default pos = binary_search ( lowup (:, 1 ), str % codes ( i )) if ( pos > 0 ) then string % codes ( i ) = lowup ( pos , 2 ) endif end select enddo if ( len ( str ). eq . 0 ) string = str end function upper","tags":"","url":"proc/upper.html"},{"title":"adjustl – M_unicode","text":"public interface adjustl Module Procedures private elemental function adjustl_str(string) result(adjusted) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value type( unicode_type )","tags":"","url":"interface/adjustl.html"},{"title":"adjustr – M_unicode","text":"public interface adjustr Module Procedures private impure elemental function adjustr_str(string) result(adjusted) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value type( unicode_type )","tags":"","url":"interface/adjustr.html"},{"title":"assignment(=) – M_unicode","text":"public interface assignment(=) Module Procedures private elemental subroutine assign_str_char(lhs, rhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(inout) :: lhs character(len=*), intent(in) :: rhs private  subroutine assign_str_codes(lhs, rhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(inout) :: lhs integer, intent(in) :: rhs (:)","tags":"","url":"interface/assignment(=).html"},{"title":"character – M_unicode","text":"public interface character Module Procedures private pure function char_str(string) result(aline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value character(len=:), allocatable private pure function char_strs(string) result(lines) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string (:) Return Value character(len=:), allocatable, (:) private pure function char_str_range(string, first, last) result(aline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in) :: first integer, intent(in) :: last Return Value character(len=:), allocatable private pure function char_strs_range(string, first, last) result(lines) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string (:) integer, intent(in) :: first integer, intent(in) :: last Return Value character(len=:), allocatable, (:) private pure function char_str_range_step(string, first, last, step) result(aline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in) :: first integer, intent(in) :: last integer, intent(in) :: step Return Value character(len=:), allocatable private pure function char_strs_range_step(string, first, last, step) result(lines) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string (:) integer, intent(in) :: first integer, intent(in) :: last integer, intent(in) :: step Return Value character(len=:), allocatable, (:)","tags":"","url":"interface/character.html"},{"title":"codepoints_to_utf8 – M_unicode","text":"public interface codepoints_to_utf8 Module Procedures private pure subroutine codepoints_to_utf8_str(unicode, utf8, nerr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unicode (:) character(len=:), intent(out), allocatable :: utf8 integer, intent(out) :: nerr private pure subroutine codepoints_to_utf8_chars(unicode, utf8, nerr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unicode (:) character(len=1), intent(out), allocatable :: utf8 (:) integer, intent(out) :: nerr","tags":"","url":"interface/codepoints_to_utf8.html"},{"title":"index – M_unicode","text":"public interface index Module Procedures private elemental function index_str_str(string, substring, back) result(foundat) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function index_str_char(string, substring, back) result(foundat) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string character(len=*), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function index_char_str(string, substring, back) result(foundat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( unicode_type ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer","tags":"","url":"interface/index.html"},{"title":"len – M_unicode","text":"public interface len Module Procedures private elemental function len_str(string) result(length) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value integer","tags":"","url":"interface/len.html"},{"title":"len_trim – M_unicode","text":"public interface len_trim Module Procedures private elemental function len_trim_str(string) result(length) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value integer","tags":"","url":"interface/len_trim.html"},{"title":"leq – M_unicode","text":"public interface leq Module Procedures private elemental function leq_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function leq_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function leq_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/leq.html"},{"title":"lge – M_unicode","text":"public interface lge Module Procedures private elemental function lge_str_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lge_str_char(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lge_char_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/lge.html"},{"title":"lgt – M_unicode","text":"public interface lgt Module Procedures private elemental function lgt_str_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lgt_str_char(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lgt_char_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/lgt.html"},{"title":"lle – M_unicode","text":"public interface lle Module Procedures private elemental function lle_str_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lle_str_char(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lle_char_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/lle.html"},{"title":"llt – M_unicode","text":"public interface llt Module Procedures private elemental function llt_str_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function llt_str_char(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function llt_char_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/llt.html"},{"title":"lne – M_unicode","text":"public interface lne Module Procedures private elemental function lne_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lne_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lne_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/lne.html"},{"title":"operator(//) – M_unicode","text":"public interface operator(//) Module Procedures private elemental function concat_str_str(lhs, rhs) result(lhsrhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value type( unicode_type ) private elemental function concat_str_char(lhs, rhs) result(lhsrhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value type( unicode_type ) private elemental function concat_char_str(lhs, rhs) result(lhsrhs) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value type( unicode_type )","tags":"","url":"interface/operator(SLASHSLASH).html"},{"title":"operator(/=) – M_unicode","text":"public interface operator(/=) Module Procedures private elemental function lne_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lne_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lne_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(SLASH=).html"},{"title":"operator(<) – M_unicode","text":"public interface operator(<) Module Procedures private elemental function llt_str_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function llt_str_char(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function llt_char_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(lt).html"},{"title":"operator(<=) – M_unicode","text":"public interface operator(<=) Module Procedures private elemental function lle_str_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lle_str_char(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lle_char_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(lt=).html"},{"title":"operator(==) – M_unicode","text":"public interface operator(==) Module Procedures private elemental function leq_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function leq_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function leq_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(==).html"},{"title":"operator(>) – M_unicode","text":"public interface operator(>) Module Procedures private elemental function lgt_str_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lgt_str_char(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lgt_char_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(gt).html"},{"title":"operator(>=) – M_unicode","text":"public interface operator(>=) Module Procedures private elemental function lge_str_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lge_str_char(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lge_char_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(gt=).html"},{"title":"repeat – M_unicode","text":"public interface repeat Module Procedures private elemental function repeat_str(string, ncopies) result(repeated_str) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in) :: ncopies Return Value type( unicode_type )","tags":"","url":"interface/repeat.html"},{"title":"scan – M_unicode","text":"public interface scan Module Procedures private pure elemental function uscan(string, set, back) result(pos) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer","tags":"","url":"interface/scan.html"},{"title":"sort – M_unicode","text":"public interface sort Module Procedures private  subroutine sort_quick_rx(data, indx) NAME sort_quick_rx(3f) - [M_unicode:sort:quicksort] indexed hybrid quicksort of an array\n(LICENSE:PD) SYNOPSIS subroutine sort_quick_rx(data,index)\n\n      type(unicode_type),intent(in) :: data(:)\n      integer,intent(out)           :: indx(size(data)) DESCRIPTION A rank hybrid quicksort . The data is not moved . An integer array is generated instead with values that are indices to the sorted order of the data . This requires a second array the size of the input array , which for large arrays would require a significant amount of memory . One major advantage of this method is that the indices can be used to access an entire user - defined type in sorted order . This makes this seemingly simple sort procedure usuable with the vast majority of user - defined types . or other correlated data . BACKGROUND From Leonard J . Moss of SLAC : Here ' s a hybrid QuickSort I wrote a number of years ago . It ' s based on suggestions in Knuth , Volume 3 , and performs much better than a pure QuickSort on short or partially ordered input arrays . This routine performs an in - memory sort of the first N elements of array DATA , returning into array INDEX the indices of elements of DATA arranged in ascending order . Thus , DATA ( INDX ( 1 )) will be the smallest number in array DATA ; DATA ( INDX ( N )) will be the largest number in DATA . The original data is not physically rearranged . The original order of equal input values is not necessarily preserved . sort_quick_rx ( 3f ) uses a hybrid QuickSort algorithm , based on several suggestions in Knuth , Volume 3 , Section 5.2.2 . In particular , the \"pivot key\" [ my term ] for dividing each subsequence is chosen to be the median of the first , last , and middle values of the subsequence ; and the QuickSort is cut off when a subsequence has 9 or fewer elements , and a straight insertion sort of the entire array is done at the end . The result is comparable to a pure insertion sort for very short arrays , and very fast for very large arrays ( of order 12 micro - sec / element on the 3081 K for arrays of 10 K elements ). It is also not subject to the poor performance of the pure QuickSort on partially ordered data . Complex values are sorted by the magnitude of sqrt ( r ** 2 + i ** 2 ). o Created : sortrx ( 3f ) : 15 Jul 1986 , Len Moss o saved from url = ( 0044 ) http : //www.fortran.com/fortran/quick_sort2.f o changed to update syntax from F77 style ; John S . Urban 20161021 o generalized from only real values to include other intrinsic types ; John S . Urban 20210110 o type ( unicode_type ) version JSU 2025-09 -20. See M_sort for other types . EXAMPLES Sample usage: program demo_sort_quick_rx use M_unicode , only : sort_quick_rx , unicode_type , assignment ( = ) implicit none character ( len =* ), parameter :: g = '( * ( g0 ))' integer , parameter :: isz = 4 type ( unicode_type ) :: rr ( isz ) integer :: ii ( isz ) integer :: i write ( * , g )' sort array with sort_quick_rx ( 3f )' rr ( 1 ) = \"the\" rr ( 2 ) = \"quick\" rr ( 3 ) = \"brown\" rr ( 4 ) = \"fox\" call sort_quick_rx ( rr , ii ) write ( * , g )' original order ' do i = 1 , size ( rr ) write ( * , g ) rr ( i ) % character () enddo write ( * , g )' sorted order ' do i = 1 , size ( rr ) write ( * , g ) rr ( ii ( i )) % character () enddo end program demo_sort_quick_rx Results: Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: data (:) integer(kind=int32), intent(out) :: indx (:)","tags":"","url":"interface/sort.html"},{"title":"split – M_unicode","text":"public interface split Module Procedures private impure subroutine split_first_last(string, set, first, last) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set integer, intent(out), allocatable :: first (:) integer, intent(out), allocatable :: last (:) private impure subroutine split_pos(string, set, pos, back) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set integer, intent(inout) :: pos logical, intent(in), optional :: back private impure subroutine split_tokens(string, set, tokens, separator) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set type( unicode_type ), intent(out), allocatable :: tokens (:) type( unicode_type ), intent(out), optional, allocatable :: separator (:)","tags":"","url":"interface/split.html"},{"title":"tokenize – M_unicode","text":"public interface tokenize Module Procedures private impure subroutine split_first_last(string, set, first, last) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set integer, intent(out), allocatable :: first (:) integer, intent(out), allocatable :: last (:) private impure subroutine split_pos(string, set, pos, back) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set integer, intent(inout) :: pos logical, intent(in), optional :: back private impure subroutine split_tokens(string, set, tokens, separator) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set type( unicode_type ), intent(out), allocatable :: tokens (:) type( unicode_type ), intent(out), optional, allocatable :: separator (:)","tags":"","url":"interface/tokenize.html"},{"title":"trim – M_unicode","text":"public interface trim Module Procedures private elemental function trim_str(string) result(trimmed_str) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value type( unicode_type )","tags":"","url":"interface/trim.html"},{"title":"unicode_type – M_unicode","text":"public interface unicode_type Functions private module function new_codes(codes) result(new) Arguments Type Intent Optional Attributes Name integer, intent(in) :: codes (:) Return Value type( unicode_type ) private elemental module function new_str(string) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Return Value type( unicode_type )","tags":"","url":"interface/unicode_type.html"},{"title":"utf8_to_codepoints – M_unicode","text":"public interface utf8_to_codepoints Module Procedures private pure subroutine utf8_to_codepoints_str(utf8, unicode, nerr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: utf8 integer, intent(out), allocatable :: unicode (:) integer, intent(out) :: nerr private pure subroutine utf8_to_codepoints_chars(utf8, unicode, nerr) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: utf8 (:) integer, intent(out), allocatable :: unicode (:) integer, intent(out) :: nerr","tags":"","url":"interface/utf8_to_codepoints.html"},{"title":"verify – M_unicode","text":"public interface verify Module Procedures private impure elemental function uverify(string, set, back) result(result) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer","tags":"","url":"interface/verify.html"},{"title":"getargs – M_unicode","text":"function getargs() result(command_line) Arguments None Return Value character(len=:), allocatable Variables Type Visibility Attributes Name Initial integer, public :: length Source Code function getargs () result ( command_line ) integer :: length character ( len = :), allocatable :: command_line call get_command ( length = length ) ! get command line length allocate ( character ( len = length ) :: command_line ) ! allocate string big enough to hold command line call get_command ( command = command_line ) ! get command line as a string call get_command_argument ( 0 , length = length ) ! remove argument 0 command_line = command_line ( length + 2 :) end function getargs","tags":"","url":"proc/getargs.html"},{"title":"check – M_unicode","text":"subroutine check(label, test) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label logical, intent(in) :: test Source Code subroutine check ( label , test ) character ( len =* ), intent ( in ) :: label logical , intent ( in ) :: test write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , test ), ' ' , label if (. not . test ) total = total + 1 end subroutine check","tags":"","url":"proc/check.html"},{"title":"checkit – M_unicode","text":"subroutine checkit(label, aline, answer, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label character(len=*), intent(in) :: aline character(len=*), intent(in) :: answer character(len=*), intent(in) :: expected Source Code subroutine checkit ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline character ( len =* ), intent ( in ) :: answer character ( len =* ), intent ( in ) :: expected write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , answer . eq . expected ), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( answer . ne . expected ) total = total + 1 end subroutine checkit","tags":"","url":"proc/checkit.html"},{"title":"checkits – M_unicode","text":"subroutine checkits(label, aline, answer, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label character(len=*), intent(in) :: aline character(len=*), intent(in) :: answer (:) character(len=*), intent(in) :: expected (:) Source Code subroutine checkits ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline character ( len =* ), intent ( in ) :: answer (:) character ( len =* ), intent ( in ) :: expected (:) write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , all ( answer . eq . expected )), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( all ( answer . ne . expected )) total = total + 1 end subroutine checkits","tags":"","url":"proc/checkits.html"},{"title":"checkits_l – M_unicode","text":"subroutine checkits_l(label, aline, answer, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label character(len=*), intent(in) :: aline logical, intent(in) :: answer (:) logical, intent(in) :: expected (:) Source Code subroutine checkits_l ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline logical , intent ( in ) :: answer (:) logical , intent ( in ) :: expected (:) write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , all ( answer . eqv . expected )), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( all ( answer . neqv . expected )) total = total + 1 end subroutine checkits_l","tags":"","url":"proc/checkits_l.html"},{"title":"M_unicode – M_unicode","text":"In computing, Unicode characters are typically sorted using one of two methods: a simple binary code point sort or a more sophisticated,\nlanguage-sensitive collation. The correct approach depends on whether a\nlinguistically accurate “alphabetical” order is needed or if a simple,\nfixed order is sufficient. Binary code point sort This is the simplest and fastest method, often used as a default by\nprogramming languages and databases. How it works: Strings are sorted based on the numeric value of their underlying Unicode code points . For example , a character with a code point of U + 0061 ( lowercase \"a\" ) will always be placed before U + 0062 ( lowercase \"b\" ) because 97 is less than 98. Limitations: While this works for the basic English alphabet , it produces non - intuitive results for other characters because the code point value does not correlate with linguistic sorting rules . For instance , it may place: Uppercase letters before all lowercase letters ( Z comes before a ). Accented letters in an order that is not linguistically correct for a given language ( e . g ., in German , an umlauted character like ö might be sorted differently than a plain o ). Characters from different scripts ( like Latin , Greek , and Cyrillic ) in an order determined solely by their assigned code point blocks . Unicode Collation Algorithm (UCA) This is the standard, more robust method for sorting that produces\ncorrect, language-sensitive results. It is described in Unicode Technical\nStandard #10. How it works: Instead of sorting by a single numeric value , the UCA uses a multi - level approach to determine a sort key for each string . The algorithm takes into account the specific rules ( or \"tailorings\" ) of a given language or locale , which are defined in the Common Locale Data Repository ( CLDR ). Multi - level sorting: The UCA uses a hierarchy of weights for each character: Primary: Compares the base letter , ignoring case and accents . This groups all versions of \"a\" ( a , á , A , Á ) together . Secondary: Compares accents and diacritics . This establishes the order for different versions of the same base letter ( e . g ., o , ó , ô ). Tertiary: Compares case differences ( uppercase vs . lowercase ). Quaternary: Deals with other special features , such as handling punctuation . Locale - specific rules: The UCA can apply different rules based on a user ' s location . For example: In German phonebooks , umlauted letters ( ä ) are often sorted as if they were ae . In other contexts , they are sorted with their base letter ( a ). The correct sorting order for Chinese characters can be based on pronunciation ( Pinyin ) or stroke count , depending on the dictionary or region . How to choose a sorting method Use binary sorting for performance when linguistic order doesn ' t matter . This is fine for internal data processing where you just need a consistent , quick sort . Use the UCA for user - facing applications where culturally appropriate sorting is critical . If your application supports multiple languages , you must use a language - sensitive collator to provide the sorting users will expect . Most modern programming languages and databases have built - in libraries that implement the Unicode Collation Algorithm . Uses iso_fortran_env Interfaces public        interface adjustl private elemental function adjustl_str(string) result(adjusted) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value type( unicode_type ) public        interface adjustr private impure elemental function adjustr_str(string) result(adjusted) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value type( unicode_type ) public        interface assignment(=) private elemental subroutine assign_str_char(lhs, rhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(inout) :: lhs character(len=*), intent(in) :: rhs private  subroutine assign_str_codes(lhs, rhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(inout) :: lhs integer, intent(in) :: rhs (:) public        interface character private pure function char_str(string) result(aline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value character(len=:), allocatable private pure function char_strs(string) result(lines) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string (:) Return Value character(len=:), allocatable, (:) private pure function char_str_range(string, first, last) result(aline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in) :: first integer, intent(in) :: last Return Value character(len=:), allocatable private pure function char_strs_range(string, first, last) result(lines) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string (:) integer, intent(in) :: first integer, intent(in) :: last Return Value character(len=:), allocatable, (:) private pure function char_str_range_step(string, first, last, step) result(aline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in) :: first integer, intent(in) :: last integer, intent(in) :: step Return Value character(len=:), allocatable private pure function char_strs_range_step(string, first, last, step) result(lines) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string (:) integer, intent(in) :: first integer, intent(in) :: last integer, intent(in) :: step Return Value character(len=:), allocatable, (:) public        interface codepoints_to_utf8 private pure subroutine codepoints_to_utf8_str(unicode, utf8, nerr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unicode (:) character(len=:), intent(out), allocatable :: utf8 integer, intent(out) :: nerr private pure subroutine codepoints_to_utf8_chars(unicode, utf8, nerr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unicode (:) character(len=1), intent(out), allocatable :: utf8 (:) integer, intent(out) :: nerr public        interface index private elemental function index_str_str(string, substring, back) result(foundat) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function index_str_char(string, substring, back) result(foundat) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string character(len=*), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function index_char_str(string, substring, back) result(foundat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( unicode_type ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer public        interface len private elemental function len_str(string) result(length) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value integer public        interface len_trim private elemental function len_trim_str(string) result(length) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value integer public        interface leq private elemental function leq_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function leq_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function leq_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface lge private elemental function lge_str_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lge_str_char(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lge_char_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface lgt private elemental function lgt_str_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lgt_str_char(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lgt_char_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface lle private elemental function lle_str_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lle_str_char(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lle_char_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface llt private elemental function llt_str_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function llt_str_char(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function llt_char_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface lne private elemental function lne_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lne_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lne_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface operator(//) private elemental function concat_str_str(lhs, rhs) result(lhsrhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value type( unicode_type ) private elemental function concat_str_char(lhs, rhs) result(lhsrhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value type( unicode_type ) private elemental function concat_char_str(lhs, rhs) result(lhsrhs) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value type( unicode_type ) public        interface operator(/=) private elemental function lne_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lne_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lne_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface operator(<) private elemental function llt_str_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function llt_str_char(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function llt_char_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface operator(<=) private elemental function lle_str_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lle_str_char(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lle_char_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface operator(==) private elemental function leq_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function leq_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function leq_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface operator(>) private elemental function lgt_str_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lgt_str_char(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lgt_char_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface operator(>=) private elemental function lge_str_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lge_str_char(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lge_char_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface repeat private elemental function repeat_str(string, ncopies) result(repeated_str) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in) :: ncopies Return Value type( unicode_type ) public        interface scan private pure elemental function uscan(string, set, back) result(pos) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer public        interface sort private  subroutine sort_quick_rx(data, indx) NAME sort_quick_rx(3f) - [M_unicode:sort:quicksort] indexed hybrid quicksort of an array\n(LICENSE:PD) SYNOPSIS subroutine sort_quick_rx(data,index)\n\n      type(unicode_type),intent(in) :: data(:)\n      integer,intent(out)           :: indx(size(data)) DESCRIPTION A rank hybrid quicksort . The data is not moved . An integer array is generated instead with values that are indices to the sorted order of the data . This requires a second array the size of the input array , which for large arrays would require a significant amount of memory . One major advantage of this method is that the indices can be used to access an entire user - defined type in sorted order . This makes this seemingly simple sort procedure usuable with the vast majority of user - defined types . or other correlated data . BACKGROUND From Leonard J . Moss of SLAC : Here ' s a hybrid QuickSort I wrote a number of years ago . It ' s based on suggestions in Knuth , Volume 3 , and performs much better than a pure QuickSort on short or partially ordered input arrays . This routine performs an in - memory sort of the first N elements of array DATA , returning into array INDEX the indices of elements of DATA arranged in ascending order . Thus , DATA ( INDX ( 1 )) will be the smallest number in array DATA ; DATA ( INDX ( N )) will be the largest number in DATA . The original data is not physically rearranged . The original order of equal input values is not necessarily preserved . sort_quick_rx ( 3f ) uses a hybrid QuickSort algorithm , based on several suggestions in Knuth , Volume 3 , Section 5.2.2 . In particular , the \"pivot key\" [ my term ] for dividing each subsequence is chosen to be the median of the first , last , and middle values of the subsequence ; and the QuickSort is cut off when a subsequence has 9 or fewer elements , and a straight insertion sort of the entire array is done at the end . The result is comparable to a pure insertion sort for very short arrays , and very fast for very large arrays ( of order 12 micro - sec / element on the 3081 K for arrays of 10 K elements ). It is also not subject to the poor performance of the pure QuickSort on partially ordered data . Complex values are sorted by the magnitude of sqrt ( r ** 2 + i ** 2 ). o Created : sortrx ( 3f ) : 15 Jul 1986 , Len Moss o saved from url = ( 0044 ) http : //www.fortran.com/fortran/quick_sort2.f o changed to update syntax from F77 style ; John S . Urban 20161021 o generalized from only real values to include other intrinsic types ; John S . Urban 20210110 o type ( unicode_type ) version JSU 2025-09 -20. See M_sort for other types . EXAMPLES Sample usage: program demo_sort_quick_rx use M_unicode , only : sort_quick_rx , unicode_type , assignment ( = ) implicit none character ( len =* ), parameter :: g = '( * ( g0 ))' integer , parameter :: isz = 4 type ( unicode_type ) :: rr ( isz ) integer :: ii ( isz ) integer :: i write ( * , g )' sort array with sort_quick_rx ( 3f )' rr ( 1 ) = \"the\" rr ( 2 ) = \"quick\" rr ( 3 ) = \"brown\" rr ( 4 ) = \"fox\" call sort_quick_rx ( rr , ii ) write ( * , g )' original order ' do i = 1 , size ( rr ) write ( * , g ) rr ( i ) % character () enddo write ( * , g )' sorted order ' do i = 1 , size ( rr ) write ( * , g ) rr ( ii ( i )) % character () enddo end program demo_sort_quick_rx Results: Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: data (:) integer(kind=int32), intent(out) :: indx (:) public        interface split private impure subroutine split_first_last(string, set, first, last) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set integer, intent(out), allocatable :: first (:) integer, intent(out), allocatable :: last (:) private impure subroutine split_pos(string, set, pos, back) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set integer, intent(inout) :: pos logical, intent(in), optional :: back private impure subroutine split_tokens(string, set, tokens, separator) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set type( unicode_type ), intent(out), allocatable :: tokens (:) type( unicode_type ), intent(out), optional, allocatable :: separator (:) public        interface tokenize private impure subroutine split_first_last(string, set, first, last) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set integer, intent(out), allocatable :: first (:) integer, intent(out), allocatable :: last (:) private impure subroutine split_pos(string, set, pos, back) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set integer, intent(inout) :: pos logical, intent(in), optional :: back private impure subroutine split_tokens(string, set, tokens, separator) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set type( unicode_type ), intent(out), allocatable :: tokens (:) type( unicode_type ), intent(out), optional, allocatable :: separator (:) public        interface trim private elemental function trim_str(string) result(trimmed_str) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value type( unicode_type ) public        interface unicode_type private module function new_codes(codes) result(new) Arguments Type Intent Optional Attributes Name integer, intent(in) :: codes (:) Return Value type( unicode_type ) private elemental module function new_str(string) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Return Value type( unicode_type ) public        interface utf8_to_codepoints private pure subroutine utf8_to_codepoints_str(utf8, unicode, nerr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: utf8 integer, intent(out), allocatable :: unicode (:) integer, intent(out) :: nerr private pure subroutine utf8_to_codepoints_chars(utf8, unicode, nerr) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: utf8 (:) integer, intent(out), allocatable :: unicode (:) integer, intent(out) :: nerr public        interface verify private impure elemental function uverify(string, set, back) result(result) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer Derived Types type, public :: unicode_type Constructor private\n\n                    module\n                    function new_codes (codes) private\n\n                    elemental, module\n                    function new_str (string) Type-Bound Procedures procedure, public :: adjustl => oop_adjustl procedure, public :: adjustr => oop_adjustr procedure, public :: bytes => oop_bytes procedure, public :: character => oop_character procedure, public :: codepoint => oop_codepoint procedure, public :: index => oop_index procedure, public :: len => oop_len procedure, public :: len_trim => oop_len_trim procedure, public :: lower => oop_lower procedure, public :: scan => oop_scan procedure, public :: split => oop_split procedure, public :: tokenize => oop_tokenize procedure, public :: trim => oop_trim procedure, public :: upper => oop_upper procedure, public :: verify => oop_verify Functions public pure elemental function lower (str) result(string) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: str Return Value type( unicode_type ) public pure elemental function upper (str) result(string) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: str Return Value type( unicode_type )","tags":"","url":"module/m_unicode.html"},{"title":"testit – M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial type( unicode_type ) :: low type( unicode_type ) :: upp Source Code program testit use M_unicode type ( unicode_type ) :: upp , low ! ! remember unicode characters are multi-byte so be careful ! with older compilers to not exceed 132 bytes per line ! low = '& &abcdefghijklmnopqrstuvwxyzàáâãäåæçèéêëì& &íîïðñòóôõöøùúûüýþÿāăąćĉċčďđēĕėęěĝğġģĥħĩīĭ& &įıĳĵķĺļľŀłńņňŋōŏőœŕŗřśŝşšţťŧũūŭůűųŵŷźżž& &ƃƅƈƌƒƙơƣƥƨƭưƴƶƹƽǆǉǌǎǐǒǔǖǘǚǜǟǡǣǥǧǩǫǭǯǳǵǻǽǿ& &ȁȃȅȇȉȋȍȏȑȓȕȗɓɔɗɘəɛɠɣɨɩɯɲɵʃʈʊʋʒάέήί& &αβγδεζηθικλμνξοπρστυφχψωϊϋόύώϣϥϧϩϫϭϯабвгдежзий& &клмнопрстуфхцчшщъыьэюяёђѓєѕіїјљњћќўџ& &ѡѣѥѧѩѫѭѯѱѳѵѷѹѻѽѿҁґғҕҗҙқҝҟҡңҥҧҩҫҭүұҳҵҷҹһҽҿӂӄӈ& &ӌӑӓӕӗәӛӝӟӡӣӥӧөӫӯӱӳӵӹաբգդեզէըթժիլխծկհձղ& &ճմյնշոչպջռսվտրցւփքօֆაბგდევზთიკლმნოპჟრსტუფქ& &ღყშჩცძწჭხჯჰჱჲჳჴჵḁḃḅḇḉḋḍḏḑḓḕḗḙḛḝḟḡḣḥḧ& &ḩḫḭḯḱḳḵḷḹḻḽḿṁṃṅṇṉṋṍṏṑṓṕṗṙ& &ṛṝṟṡṣṥṧṩṫṭṯṱṳṵṷṹṻṽṿ& &ẁẃẅẇẉẋẍẏẑẓẕạảấầẩẫậắằẳẵặẹẻẽếềểễệỉịọỏốồổỗ& &ộớờởỡợụủứừửữựỳỵỷỹἀἁἂἃἄἅἆἇἐἑἒἓἔἕἠἡἢἣἤἥἦἧἰἱ& &ἲἳἴἵἶἷὀὁὂὃὄὅὑὓὕὗὠὡὢὣὤὥὦὧᾀᾁᾂᾃᾄᾅᾆᾇᾐᾑᾒᾓᾔᾕᾖᾗ& &ᾠᾡᾢᾣᾤᾥᾦᾧᾰᾱῐῑῠῡⓐⓑⓒⓓⓔⓕⓖⓗⓘⓙⓚⓛⓜⓝⓞⓟⓠⓡⓢⓣⓤⓥⓦⓧⓨⓩ& &ａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚ' upp = '& &ABCDEFGHIJKLMNOPQRSTUVWXYZÀÁÂÃÄÅÆÇÈÉÊË& &ÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝÞŸĀĂĄĆĈĊČĎĐĒĔĖĘĚĜĞĠĢĤĦĨĪĬ& &ĮIĲĴĶĹĻĽĿŁŃŅŇŊŌŎŐŒŔŖŘŚŜŞŠŢŤŦŨŪŬŮŰŲŴŶŹŻ& &ŽƂƄƇƋƑƘƠƢƤƧƬƯƳƵƸƼǄǇǊǍǏǑǓǕǗǙǛǞǠǢǤǦǨǪǬǮǱǴǺǼǾ& &ȀȂȄȆȈȊȌȎȐȒȔȖƁƆƊƎƏƐƓƔƗƖƜƝƟƩƮƱƲƷΆΈΉΊΑΒΓΔΕΖΗΘ& &ΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩΪΫΌΎΏϢϤϦϨϪϬϮАБВГДЕЖЗИЙ& &КЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯЁЂЃЄЅІЇЈЉЊЋЌЎЏѠѢѤѦѨѪѬ& &ѮѰѲѴѶѸѺѼѾҀҐҒҔҖҘҚҜҞҠҢҤҦҨҪҬҮҰҲҴҶҸҺҼҾӁӃӇ& &ӋӐӒӔӖӘӚӜӞӠӢӤӦӨӪӮӰӲӴӸԱԲԳԴԵԶԷԸԹԺԻԼԽԾԿՀՁՂՃՄ& &ՅՆՇՈՉՊՋՌՍՎՏՐՑՒՓՔՕՖႠႡႢႣႤႥႦႧႨႩႪႫႬႭႮႯႰႱႲႳႴႵ& &ႶႷႸႹႺႻႼႽႾႿჀჁჂჃჄჅḀḂḄḆḈḊḌḎḐḒḔḖḘḚḜḞḠḢḤḦḨḪḬḮ& &ḰḲḴḶḸḺḼḾṀṂṄṆṈṊṌṎṐṒṔṖṘṚṜṞṠṢṤṦṨṪṬṮṰṲṴṶṸṺṼṾ& &ẀẂẄẆẈẊẌẎẐẒẔẠẢẤẦẨẪẬẮẰẲẴẶẸẺẼẾỀỂỄỆỈỊ& &ỌỎỐỒỔỖỘỚỜỞỠỢỤỦỨỪỬỮỰỲỴỶỸ& &ἈἉἊἋἌἍἎἏἘἙἚἛἜἝἨἩἪἫἬἭἮἯἸἹ& &ἺἻἼἽἾἿὈὉὊὋὌὍὙὛὝὟὨὩὪὫὬὭὮὯ& &ᾈᾉᾊᾋᾌᾍᾎᾏᾘᾙᾚᾛᾜᾝᾞᾟᾨᾩᾪᾫᾬᾭᾮᾯᾸᾹ& &ῘῙῨῩⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ& &ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺ' write ( * , '(g0)' ) low % character () write ( * , '(g0)' ) character ( upper ( low )) write ( * , '(g0)' ) character ( upp ) write ( * , '(g0)' ) character ( upp % lower ()) end program testit","tags":"","url":"program/testit.html"},{"title":"demo_split – M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial type( unicode_type ), allocatable :: array (:) type( unicode_type ) :: delims integer :: first character(len=*), parameter :: g = '(*(g0,1x))' integer :: i integer :: last integer :: pos type( unicode_type ) :: proverb Subroutines impure elemental subroutine printwords (line) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: line Source Code program demo_split use M_unicode , only : split , unicode_type , assignment ( = ), len , character use M_unicode , only : ut => unicode_type implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' type ( ut ) :: proverb type ( ut ) :: delims type ( ut ), allocatable :: array (:) integer :: first integer :: last integer :: pos integer :: i delims = '=|; ' proverb = \"Más vale pájaro en mano, que ciento volando.\" call printwords ( proverb ) ! there really are not spaces between these glyphs array = [ & ut ( \"七転び八起き。\" ), & ut ( \"転んでもまた立ち上がる。\" ), & ut ( \"くじけずに前を向いて歩いていこう。\" )] call printwords ( array ) write ( * , g ) 'OOP' array = proverb % split ( ut ( ' ' )) write ( * , '(*(:\"[\",a,\"]\"))' )( character ( array ( i )), i = 1 , size ( array )) contains impure elemental subroutine printwords ( line ) type ( ut ), intent ( in ) :: line pos = 0 write ( * , g ) line % character (), len ( line ) do while ( pos < len ( line )) first = pos + 1 call split ( line , delims , pos ) last = pos - 1 print g , line % character ( first , last ), first , last , pos end do end subroutine printwords end program demo_split","tags":"","url":"program/demo_split.html"},{"title":"demo_upper – M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0))' type( unicode_type ) :: pangram type( unicode_type ) :: upper_pangram Source Code program demo_upper use M_unicode , only : upper , unicode_type , assignment ( = ) implicit none character ( len =* ), parameter :: g = '(*(g0))' type ( unicode_type ) :: pangram type ( unicode_type ) :: upper_pangram ! a sentence containing every letter of the English alphabet pangram = \"The quick brown fox jumps over the lazy dog.\" write ( * , g ) pangram % character () upper_pangram = upper ( pangram ) write ( * , g ) upper_pangram % character () end program demo_upper","tags":"","url":"program/demo_upper.html"},{"title":"assign_exe – M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=:), allocatable :: aline character(len=*), parameter :: g = '(*(g0))' character(len=*), parameter :: smiley = '😃' type( unicode_type ) :: substring type( unicode_type ) :: uline Source Code program assign_exe use M_unicode , only : len , len_trim , repeat , trim , adjustr , adjustl use M_unicode , only : character use M_unicode , only : assignment ( = ), unicode_type character ( len =* ), parameter :: g = '(*(g0))' character ( len = :), allocatable :: aline type ( unicode_type ) :: uline , substring character ( len =* ), parameter :: smiley = '😃' aline = \"Доки не впріти, доти не вміти.\" write ( * , g ) '123456789012345678901234567890' write ( * , g ) aline write ( * , g ) 'length in bytes is: ' , len ( aline ) uline = aline write ( * , g ) 'length in glyphs is: ' , len ( uline ) write ( * , g ) 'string is: ' , character ( uline ) write ( * , g ) 'third word is: ' , character ( uline , 9 , 14 ) ! substring substring = character ( uline , 17 , 29 ) write ( * , g ) 'string is: ' , character ( substring ) uline = repeat ( smiley , 30 ) write ( * , g ) character ( uline ) write ( * , g ) len_trim ( uline ) uline = aline // '      ' write ( * , g ) len_trim ( uline ) uline = [ 32 , 160 , 8192 , 8193 , 8194 , 8195 , 8196 , 8197 , 8198 , 8199 , 8200 , 8201 , 8202 , 8239 , 8287 , 12288 ] write ( * , g ) 'spaces:' , character ( uline ), len ( uline ), len_trim ( uline ) uline = [ 32 , 160 , 8192 , 8193 , 8194 , 8195 , 8196 , 8197 , 8198 , 8199 , 8200 , 8201 , 8202 , 8239 , 8287 , 12288 ] uline = trim ( uline ) write ( * , g ) 'trim:' , '[' , character ( uline ), ']' uline = '    this  is just a    string        ' write ( * , g ) 'adjustr:' , '[' , character ( uline ), '] ==> [' , character ( adjustr ( uline )), ']' uline = '    this  is just a    string        ' write ( * , g ) 'adjustl:' , '[' , character ( uline ), '] ==> [' , character ( adjustl ( uline )), ']' !write(*,g)uline end program assign_exe","tags":"","url":"program/assign_exe.html"},{"title":"test_id – M_unicode","text":"Uses iso_fortran_env Variables Type Attributes Name Initial integer :: break character(len=*), parameter :: nl = new_line('a') character(len=:), allocatable :: options integer :: start character(len=:), allocatable :: version integer :: where Source Code program test_id use , intrinsic :: iso_fortran_env , only : compiler_version use , intrinsic :: iso_fortran_env , only : compiler_options implicit none character ( len = :), allocatable :: version , options character ( len =* ), parameter :: nl = new_line ( 'a' ) integer :: where , start , break version = compiler_version () options = ' ' // compiler_options () start = 1 do where = index ( options ( start :), ' -' ) if ( where . eq . 0 ) exit break = where + start - 1 options ( break : break ) = nl start = where enddo if ( start . eq . 1 ) then do where = index ( options ( start :), ' /' ) if ( where . eq . 0 ) exit break = where + start - 1 options ( break : break ) = nl start = where enddo endif print '(*(1x,a))' , & 'This file was compiled by ' , & version , nl , & 'using the options ' , & options end program test_id","tags":"","url":"program/test_id.html"},{"title":"note – M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial integer, parameter :: pointer (*) = [int(z'1FBC1'), int(z'1FBC2'), int(z'1FBC3')] type( unicode_type ) :: uline Source Code program note use M_unicode implicit none integer , parameter :: pointer ( * ) = [ int ( z '1FBC1' ), int ( z '1FBC2' ), int ( z '1FBC3' )] type ( unicode_type ) :: uline uline = pointer write ( * , '(*(g0))' ) uline % character () end program note","tags":"","url":"program/note.html"},{"title":"testit – M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial type( unicode_type ) :: low integer, parameter :: lowhigh = 666 integer, parameter :: lowup (lowhigh,2) = reshape([int(z'0061'), int(z'0041'), int(z'0062'), int(z'0042'), int(z'0063'), int(z'0043'), int(z'0064'), int(z'0044'), int(z'0065'), int(z'0045'), int(z'0066'), int(z'0046'), int(z'0067'), int(z'0047'), int(z'0068'), int(z'0048'), int(z'0069'), int(z'0049'), int(z'006A'), int(z'004A'), int(z'006B'), int(z'004B'), int(z'006C'), int(z'004C'), int(z'006D'), int(z'004D'), int(z'006E'), int(z'004E'), int(z'006F'), int(z'004F'), int(z'0070'), int(z'0050'), int(z'0071'), int(z'0051'), int(z'0072'), int(z'0052'), int(z'0073'), int(z'0053'), int(z'0074'), int(z'0054'), int(z'0075'), int(z'0055'), int(z'0076'), int(z'0056'), int(z'0077'), int(z'0057'), int(z'0078'), int(z'0058'), int(z'0079'), int(z'0059'), int(z'007A'), int(z'005A'), int(z'00E0'), int(z'00C0'), int(z'00E1'), int(z'00C1'), int(z'00E2'), int(z'00C2'), int(z'00E3'), int(z'00C3'), int(z'00E4'), int(z'00C4'), int(z'00E5'), int(z'00C5'), int(z'00E6'), int(z'00C6'), int(z'00E7'), int(z'00C7'), int(z'00E8'), int(z'00C8'), int(z'00E9'), int(z'00C9'), int(z'00EA'), int(z'00CA'), int(z'00EB'), int(z'00CB'), int(z'00EC'), int(z'00CC'), int(z'00ED'), int(z'00CD'), int(z'00EE'), int(z'00CE'), int(z'00EF'), int(z'00CF'), int(z'00F0'), int(z'00D0'), int(z'00F1'), int(z'00D1'), int(z'00F2'), int(z'00D2'), int(z'00F3'), int(z'00D3'), int(z'00F4'), int(z'00D4'), int(z'00F5'), int(z'00D5'), int(z'00F6'), int(z'00D6'), int(z'00F8'), int(z'00D8'), int(z'00F9'), int(z'00D9'), int(z'00FA'), int(z'00DA'), int(z'00FB'), int(z'00DB'), int(z'00FC'), int(z'00DC'), int(z'00FD'), int(z'00DD'), int(z'00FE'), int(z'00DE'), int(z'00FF'), int(z'0178'), int(z'0101'), int(z'0100'), int(z'0103'), int(z'0102'), int(z'0105'), int(z'0104'), int(z'0107'), int(z'0106'), int(z'0109'), int(z'0108'), int(z'010B'), int(z'010A'), int(z'010D'), int(z'010C'), int(z'010F'), int(z'010E'), int(z'0111'), int(z'0110'), int(z'0113'), int(z'0112'), int(z'0115'), int(z'0114'), int(z'0117'), int(z'0116'), int(z'0119'), int(z'0118'), int(z'011B'), int(z'011A'), int(z'011D'), int(z'011C'), int(z'011F'), int(z'011E'), int(z'0121'), int(z'0120'), int(z'0123'), int(z'0122'), int(z'0125'), int(z'0124'), int(z'0127'), int(z'0126'), int(z'0129'), int(z'0128'), int(z'012B'), int(z'012A'), int(z'012D'), int(z'012C'), int(z'012F'), int(z'012E'), int(z'0131'), int(z'0049'), int(z'0133'), int(z'0132'), int(z'0135'), int(z'0134'), int(z'0137'), int(z'0136'), int(z'013A'), int(z'0139'), int(z'013C'), int(z'013B'), int(z'013E'), int(z'013D'), int(z'0140'), int(z'013F'), int(z'0142'), int(z'0141'), int(z'0144'), int(z'0143'), int(z'0146'), int(z'0145'), int(z'0148'), int(z'0147'), int(z'014B'), int(z'014A'), int(z'014D'), int(z'014C'), int(z'014F'), int(z'014E'), int(z'0151'), int(z'0150'), int(z'0153'), int(z'0152'), int(z'0155'), int(z'0154'), int(z'0157'), int(z'0156'), int(z'0159'), int(z'0158'), int(z'015B'), int(z'015A'), int(z'015D'), int(z'015C'), int(z'015F'), int(z'015E'), int(z'0161'), int(z'0160'), int(z'0163'), int(z'0162'), int(z'0165'), int(z'0164'), int(z'0167'), int(z'0166'), int(z'0169'), int(z'0168'), int(z'016B'), int(z'016A'), int(z'016D'), int(z'016C'), int(z'016F'), int(z'016E'), int(z'0171'), int(z'0170'), int(z'0173'), int(z'0172'), int(z'0175'), int(z'0174'), int(z'0177'), int(z'0176'), int(z'017A'), int(z'0179'), int(z'017C'), int(z'017B'), int(z'017E'), int(z'017D'), int(z'0183'), int(z'0182'), int(z'0185'), int(z'0184'), int(z'0188'), int(z'0187'), int(z'018C'), int(z'018B'), int(z'0192'), int(z'0191'), int(z'0199'), int(z'0198'), int(z'01A1'), int(z'01A0'), int(z'01A3'), int(z'01A2'), int(z'01A5'), int(z'01A4'), int(z'01A8'), int(z'01A7'), int(z'01AD'), int(z'01AC'), int(z'01B0'), int(z'01AF'), int(z'01B4'), int(z'01B3'), int(z'01B6'), int(z'01B5'), int(z'01B9'), int(z'01B8'), int(z'01BD'), int(z'01BC'), int(z'01C6'), int(z'01C4'), int(z'01C9'), int(z'01C7'), int(z'01CC'), int(z'01CA'), int(z'01CE'), int(z'01CD'), int(z'01D0'), int(z'01CF'), int(z'01D2'), int(z'01D1'), int(z'01D4'), int(z'01D3'), int(z'01D6'), int(z'01D5'), int(z'01D8'), int(z'01D7'), int(z'01DA'), int(z'01D9'), int(z'01DC'), int(z'01DB'), int(z'01DF'), int(z'01DE'), int(z'01E1'), int(z'01E0'), int(z'01E3'), int(z'01E2'), int(z'01E5'), int(z'01E4'), int(z'01E7'), int(z'01E6'), int(z'01E9'), int(z'01E8'), int(z'01EB'), int(z'01EA'), int(z'01ED'), int(z'01EC'), int(z'01EF'), int(z'01EE'), int(z'01F3'), int(z'01F1'), int(z'01F5'), int(z'01F4'), int(z'01FB'), int(z'01FA'), int(z'01FD'), int(z'01FC'), int(z'01FF'), int(z'01FE'), int(z'0201'), int(z'0200'), int(z'0203'), int(z'0202'), int(z'0205'), int(z'0204'), int(z'0207'), int(z'0206'), int(z'0209'), int(z'0208'), int(z'020B'), int(z'020A'), int(z'020D'), int(z'020C'), int(z'020F'), int(z'020E'), int(z'0211'), int(z'0210'), int(z'0213'), int(z'0212'), int(z'0215'), int(z'0214'), int(z'0217'), int(z'0216'), int(z'0253'), int(z'0181'), int(z'0254'), int(z'0186'), int(z'0257'), int(z'018A'), int(z'0258'), int(z'018E'), int(z'0259'), int(z'018F'), int(z'025B'), int(z'0190'), int(z'0260'), int(z'0193'), int(z'0263'), int(z'0194'), int(z'0268'), int(z'0197'), int(z'0269'), int(z'0196'), int(z'026F'), int(z'019C'), int(z'0272'), int(z'019D'), int(z'0275'), int(z'019F'), int(z'0283'), int(z'01A9'), int(z'0288'), int(z'01AE'), int(z'028A'), int(z'01B1'), int(z'028B'), int(z'01B2'), int(z'0292'), int(z'01B7'), int(z'03AC'), int(z'0386'), int(z'03AD'), int(z'0388'), int(z'03AE'), int(z'0389'), int(z'03AF'), int(z'038A'), int(z'03B1'), int(z'0391'), int(z'03B2'), int(z'0392'), int(z'03B3'), int(z'0393'), int(z'03B4'), int(z'0394'), int(z'03B5'), int(z'0395'), int(z'03B6'), int(z'0396'), int(z'03B7'), int(z'0397'), int(z'03B8'), int(z'0398'), int(z'03B9'), int(z'0399'), int(z'03BA'), int(z'039A'), int(z'03BB'), int(z'039B'), int(z'03BC'), int(z'039C'), int(z'03BD'), int(z'039D'), int(z'03BE'), int(z'039E'), int(z'03BF'), int(z'039F'), int(z'03C0'), int(z'03A0'), int(z'03C1'), int(z'03A1'), int(z'03C3'), int(z'03A3'), int(z'03C4'), int(z'03A4'), int(z'03C5'), int(z'03A5'), int(z'03C6'), int(z'03A6'), int(z'03C7'), int(z'03A7'), int(z'03C8'), int(z'03A8'), int(z'03C9'), int(z'03A9'), int(z'03CA'), int(z'03AA'), int(z'03CB'), int(z'03AB'), int(z'03CC'), int(z'038C'), int(z'03CD'), int(z'038E'), int(z'03CE'), int(z'038F'), int(z'03E3'), int(z'03E2'), int(z'03E5'), int(z'03E4'), int(z'03E7'), int(z'03E6'), int(z'03E9'), int(z'03E8'), int(z'03EB'), int(z'03EA'), int(z'03ED'), int(z'03EC'), int(z'03EF'), int(z'03EE'), int(z'0430'), int(z'0410'), int(z'0431'), int(z'0411'), int(z'0432'), int(z'0412'), int(z'0433'), int(z'0413'), int(z'0434'), int(z'0414'), int(z'0435'), int(z'0415'), int(z'0436'), int(z'0416'), int(z'0437'), int(z'0417'), int(z'0438'), int(z'0418'), int(z'0439'), int(z'0419'), int(z'043A'), int(z'041A'), int(z'043B'), int(z'041B'), int(z'043C'), int(z'041C'), int(z'043D'), int(z'041D'), int(z'043E'), int(z'041E'), int(z'043F'), int(z'041F'), int(z'0440'), int(z'0420'), int(z'0441'), int(z'0421'), int(z'0442'), int(z'0422'), int(z'0443'), int(z'0423'), int(z'0444'), int(z'0424'), int(z'0445'), int(z'0425'), int(z'0446'), int(z'0426'), int(z'0447'), int(z'0427'), int(z'0448'), int(z'0428'), int(z'0449'), int(z'0429'), int(z'044A'), int(z'042A'), int(z'044B'), int(z'042B'), int(z'044C'), int(z'042C'), int(z'044D'), int(z'042D'), int(z'044E'), int(z'042E'), int(z'044F'), int(z'042F'), int(z'0451'), int(z'0401'), int(z'0452'), int(z'0402'), int(z'0453'), int(z'0403'), int(z'0454'), int(z'0404'), int(z'0455'), int(z'0405'), int(z'0456'), int(z'0406'), int(z'0457'), int(z'0407'), int(z'0458'), int(z'0408'), int(z'0459'), int(z'0409'), int(z'045A'), int(z'040A'), int(z'045B'), int(z'040B'), int(z'045C'), int(z'040C'), int(z'045E'), int(z'040E'), int(z'045F'), int(z'040F'), int(z'0461'), int(z'0460'), int(z'0463'), int(z'0462'), int(z'0465'), int(z'0464'), int(z'0467'), int(z'0466'), int(z'0469'), int(z'0468'), int(z'046B'), int(z'046A'), int(z'046D'), int(z'046C'), int(z'046F'), int(z'046E'), int(z'0471'), int(z'0470'), int(z'0473'), int(z'0472'), int(z'0475'), int(z'0474'), int(z'0477'), int(z'0476'), int(z'0479'), int(z'0478'), int(z'047B'), int(z'047A'), int(z'047D'), int(z'047C'), int(z'047F'), int(z'047E'), int(z'0481'), int(z'0480'), int(z'0491'), int(z'0490'), int(z'0493'), int(z'0492'), int(z'0495'), int(z'0494'), int(z'0497'), int(z'0496'), int(z'0499'), int(z'0498'), int(z'049B'), int(z'049A'), int(z'049D'), int(z'049C'), int(z'049F'), int(z'049E'), int(z'04A1'), int(z'04A0'), int(z'04A3'), int(z'04A2'), int(z'04A5'), int(z'04A4'), int(z'04A7'), int(z'04A6'), int(z'04A9'), int(z'04A8'), int(z'04AB'), int(z'04AA'), int(z'04AD'), int(z'04AC'), int(z'04AF'), int(z'04AE'), int(z'04B1'), int(z'04B0'), int(z'04B3'), int(z'04B2'), int(z'04B5'), int(z'04B4'), int(z'04B7'), int(z'04B6'), int(z'04B9'), int(z'04B8'), int(z'04BB'), int(z'04BA'), int(z'04BD'), int(z'04BC'), int(z'04BF'), int(z'04BE'), int(z'04C2'), int(z'04C1'), int(z'04C4'), int(z'04C3'), int(z'04C8'), int(z'04C7'), int(z'04CC'), int(z'04CB'), int(z'04D1'), int(z'04D0'), int(z'04D3'), int(z'04D2'), int(z'04D5'), int(z'04D4'), int(z'04D7'), int(z'04D6'), int(z'04D9'), int(z'04D8'), int(z'04DB'), int(z'04DA'), int(z'04DD'), int(z'04DC'), int(z'04DF'), int(z'04DE'), int(z'04E1'), int(z'04E0'), int(z'04E3'), int(z'04E2'), int(z'04E5'), int(z'04E4'), int(z'04E7'), int(z'04E6'), int(z'04E9'), int(z'04E8'), int(z'04EB'), int(z'04EA'), int(z'04EF'), int(z'04EE'), int(z'04F1'), int(z'04F0'), int(z'04F3'), int(z'04F2'), int(z'04F5'), int(z'04F4'), int(z'04F9'), int(z'04F8'), int(z'0561'), int(z'0531'), int(z'0562'), int(z'0532'), int(z'0563'), int(z'0533'), int(z'0564'), int(z'0534'), int(z'0565'), int(z'0535'), int(z'0566'), int(z'0536'), int(z'0567'), int(z'0537'), int(z'0568'), int(z'0538'), int(z'0569'), int(z'0539'), int(z'056A'), int(z'053A'), int(z'056B'), int(z'053B'), int(z'056C'), int(z'053C'), int(z'056D'), int(z'053D'), int(z'056E'), int(z'053E'), int(z'056F'), int(z'053F'), int(z'0570'), int(z'0540'), int(z'0571'), int(z'0541'), int(z'0572'), int(z'0542'), int(z'0573'), int(z'0543'), int(z'0574'), int(z'0544'), int(z'0575'), int(z'0545'), int(z'0576'), int(z'0546'), int(z'0577'), int(z'0547'), int(z'0578'), int(z'0548'), int(z'0579'), int(z'0549'), int(z'057A'), int(z'054A'), int(z'057B'), int(z'054B'), int(z'057C'), int(z'054C'), int(z'057D'), int(z'054D'), int(z'057E'), int(z'054E'), int(z'057F'), int(z'054F'), int(z'0580'), int(z'0550'), int(z'0581'), int(z'0551'), int(z'0582'), int(z'0552'), int(z'0583'), int(z'0553'), int(z'0584'), int(z'0554'), int(z'0585'), int(z'0555'), int(z'0586'), int(z'0556'), int(z'10D0'), int(z'10A0'), int(z'10D1'), int(z'10A1'), int(z'10D2'), int(z'10A2'), int(z'10D3'), int(z'10A3'), int(z'10D4'), int(z'10A4'), int(z'10D5'), int(z'10A5'), int(z'10D6'), int(z'10A6'), int(z'10D7'), int(z'10A7'), int(z'10D8'), int(z'10A8'), int(z'10D9'), int(z'10A9'), int(z'10DA'), int(z'10AA'), int(z'10DB'), int(z'10AB'), int(z'10DC'), int(z'10AC'), int(z'10DD'), int(z'10AD'), int(z'10DE'), int(z'10AE'), int(z'10DF'), int(z'10AF'), int(z'10E0'), int(z'10B0'), int(z'10E1'), int(z'10B1'), int(z'10E2'), int(z'10B2'), int(z'10E3'), int(z'10B3'), int(z'10E4'), int(z'10B4'), int(z'10E5'), int(z'10B5'), int(z'10E6'), int(z'10B6'), int(z'10E7'), int(z'10B7'), int(z'10E8'), int(z'10B8'), int(z'10E9'), int(z'10B9'), int(z'10EA'), int(z'10BA'), int(z'10EB'), int(z'10BB'), int(z'10EC'), int(z'10BC'), int(z'10ED'), int(z'10BD'), int(z'10EE'), int(z'10BE'), int(z'10EF'), int(z'10BF'), int(z'10F0'), int(z'10C0'), int(z'10F1'), int(z'10C1'), int(z'10F2'), int(z'10C2'), int(z'10F3'), int(z'10C3'), int(z'10F4'), int(z'10C4'), int(z'10F5'), int(z'10C5'), int(z'1E01'), int(z'1E00'), int(z'1E03'), int(z'1E02'), int(z'1E05'), int(z'1E04'), int(z'1E07'), int(z'1E06'), int(z'1E09'), int(z'1E08'), int(z'1E0B'), int(z'1E0A'), int(z'1E0D'), int(z'1E0C'), int(z'1E0F'), int(z'1E0E'), int(z'1E11'), int(z'1E10'), int(z'1E13'), int(z'1E12'), int(z'1E15'), int(z'1E14'), int(z'1E17'), int(z'1E16'), int(z'1E19'), int(z'1E18'), int(z'1E1B'), int(z'1E1A'), int(z'1E1D'), int(z'1E1C'), int(z'1E1F'), int(z'1E1E'), int(z'1E21'), int(z'1E20'), int(z'1E23'), int(z'1E22'), int(z'1E25'), int(z'1E24'), int(z'1E27'), int(z'1E26'), int(z'1E29'), int(z'1E28'), int(z'1E2B'), int(z'1E2A'), int(z'1E2D'), int(z'1E2C'), int(z'1E2F'), int(z'1E2E'), int(z'1E31'), int(z'1E30'), int(z'1E33'), int(z'1E32'), int(z'1E35'), int(z'1E34'), int(z'1E37'), int(z'1E36'), int(z'1E39'), int(z'1E38'), int(z'1E3B'), int(z'1E3A'), int(z'1E3D'), int(z'1E3C'), int(z'1E3F'), int(z'1E3E'), int(z'1E41'), int(z'1E40'), int(z'1E43'), int(z'1E42'), int(z'1E45'), int(z'1E44'), int(z'1E47'), int(z'1E46'), int(z'1E49'), int(z'1E48'), int(z'1E4B'), int(z'1E4A'), int(z'1E4D'), int(z'1E4C'), int(z'1E4F'), int(z'1E4E'), int(z'1E51'), int(z'1E50'), int(z'1E53'), int(z'1E52'), int(z'1E55'), int(z'1E54'), int(z'1E57'), int(z'1E56'), int(z'1E59'), int(z'1E58'), int(z'1E5B'), int(z'1E5A'), int(z'1E5D'), int(z'1E5C'), int(z'1E5F'), int(z'1E5E'), int(z'1E61'), int(z'1E60'), int(z'1E63'), int(z'1E62'), int(z'1E65'), int(z'1E64'), int(z'1E67'), int(z'1E66'), int(z'1E69'), int(z'1E68'), int(z'1E6B'), int(z'1E6A'), int(z'1E6D'), int(z'1E6C'), int(z'1E6F'), int(z'1E6E'), int(z'1E71'), int(z'1E70'), int(z'1E73'), int(z'1E72'), int(z'1E75'), int(z'1E74'), int(z'1E77'), int(z'1E76'), int(z'1E79'), int(z'1E78'), int(z'1E7B'), int(z'1E7A'), int(z'1E7D'), int(z'1E7C'), int(z'1E7F'), int(z'1E7E'), int(z'1E81'), int(z'1E80'), int(z'1E83'), int(z'1E82'), int(z'1E85'), int(z'1E84'), int(z'1E87'), int(z'1E86'), int(z'1E89'), int(z'1E88'), int(z'1E8B'), int(z'1E8A'), int(z'1E8D'), int(z'1E8C'), int(z'1E8F'), int(z'1E8E'), int(z'1E91'), int(z'1E90'), int(z'1E93'), int(z'1E92'), int(z'1E95'), int(z'1E94'), int(z'1EA1'), int(z'1EA0'), int(z'1EA3'), int(z'1EA2'), int(z'1EA5'), int(z'1EA4'), int(z'1EA7'), int(z'1EA6'), int(z'1EA9'), int(z'1EA8'), int(z'1EAB'), int(z'1EAA'), int(z'1EAD'), int(z'1EAC'), int(z'1EAF'), int(z'1EAE'), int(z'1EB1'), int(z'1EB0'), int(z'1EB3'), int(z'1EB2'), int(z'1EB5'), int(z'1EB4'), int(z'1EB7'), int(z'1EB6'), int(z'1EB9'), int(z'1EB8'), int(z'1EBB'), int(z'1EBA'), int(z'1EBD'), int(z'1EBC'), int(z'1EBF'), int(z'1EBE'), int(z'1EC1'), int(z'1EC0'), int(z'1EC3'), int(z'1EC2'), int(z'1EC5'), int(z'1EC4'), int(z'1EC7'), int(z'1EC6'), int(z'1EC9'), int(z'1EC8'), int(z'1ECB'), int(z'1ECA'), int(z'1ECD'), int(z'1ECC'), int(z'1ECF'), int(z'1ECE'), int(z'1ED1'), int(z'1ED0'), int(z'1ED3'), int(z'1ED2'), int(z'1ED5'), int(z'1ED4'), int(z'1ED7'), int(z'1ED6'), int(z'1ED9'), int(z'1ED8'), int(z'1EDB'), int(z'1EDA'), int(z'1EDD'), int(z'1EDC'), int(z'1EDF'), int(z'1EDE'), int(z'1EE1'), int(z'1EE0'), int(z'1EE3'), int(z'1EE2'), int(z'1EE5'), int(z'1EE4'), int(z'1EE7'), int(z'1EE6'), int(z'1EE9'), int(z'1EE8'), int(z'1EEB'), int(z'1EEA'), int(z'1EED'), int(z'1EEC'), int(z'1EEF'), int(z'1EEE'), int(z'1EF1'), int(z'1EF0'), int(z'1EF3'), int(z'1EF2'), int(z'1EF5'), int(z'1EF4'), int(z'1EF7'), int(z'1EF6'), int(z'1EF9'), int(z'1EF8'), int(z'1F00'), int(z'1F08'), int(z'1F01'), int(z'1F09'), int(z'1F02'), int(z'1F0A'), int(z'1F03'), int(z'1F0B'), int(z'1F04'), int(z'1F0C'), int(z'1F05'), int(z'1F0D'), int(z'1F06'), int(z'1F0E'), int(z'1F07'), int(z'1F0F'), int(z'1F10'), int(z'1F18'), int(z'1F11'), int(z'1F19'), int(z'1F12'), int(z'1F1A'), int(z'1F13'), int(z'1F1B'), int(z'1F14'), int(z'1F1C'), int(z'1F15'), int(z'1F1D'), int(z'1F20'), int(z'1F28'), int(z'1F21'), int(z'1F29'), int(z'1F22'), int(z'1F2A'), int(z'1F23'), int(z'1F2B'), int(z'1F24'), int(z'1F2C'), int(z'1F25'), int(z'1F2D'), int(z'1F26'), int(z'1F2E'), int(z'1F27'), int(z'1F2F'), int(z'1F30'), int(z'1F38'), int(z'1F31'), int(z'1F39'), int(z'1F32'), int(z'1F3A'), int(z'1F33'), int(z'1F3B'), int(z'1F34'), int(z'1F3C'), int(z'1F35'), int(z'1F3D'), int(z'1F36'), int(z'1F3E'), int(z'1F37'), int(z'1F3F'), int(z'1F40'), int(z'1F48'), int(z'1F41'), int(z'1F49'), int(z'1F42'), int(z'1F4A'), int(z'1F43'), int(z'1F4B'), int(z'1F44'), int(z'1F4C'), int(z'1F45'), int(z'1F4D'), int(z'1F51'), int(z'1F59'), int(z'1F53'), int(z'1F5B'), int(z'1F55'), int(z'1F5D'), int(z'1F57'), int(z'1F5F'), int(z'1F60'), int(z'1F68'), int(z'1F61'), int(z'1F69'), int(z'1F62'), int(z'1F6A'), int(z'1F63'), int(z'1F6B'), int(z'1F64'), int(z'1F6C'), int(z'1F65'), int(z'1F6D'), int(z'1F66'), int(z'1F6E'), int(z'1F67'), int(z'1F6F'), int(z'1F80'), int(z'1F88'), int(z'1F81'), int(z'1F89'), int(z'1F82'), int(z'1F8A'), int(z'1F83'), int(z'1F8B'), int(z'1F84'), int(z'1F8C'), int(z'1F85'), int(z'1F8D'), int(z'1F86'), int(z'1F8E'), int(z'1F87'), int(z'1F8F'), int(z'1F90'), int(z'1F98'), int(z'1F91'), int(z'1F99'), int(z'1F92'), int(z'1F9A'), int(z'1F93'), int(z'1F9B'), int(z'1F94'), int(z'1F9C'), int(z'1F95'), int(z'1F9D'), int(z'1F96'), int(z'1F9E'), int(z'1F97'), int(z'1F9F'), int(z'1FA0'), int(z'1FA8'), int(z'1FA1'), int(z'1FA9'), int(z'1FA2'), int(z'1FAA'), int(z'1FA3'), int(z'1FAB'), int(z'1FA4'), int(z'1FAC'), int(z'1FA5'), int(z'1FAD'), int(z'1FA6'), int(z'1FAE'), int(z'1FA7'), int(z'1FAF'), int(z'1FB0'), int(z'1FB8'), int(z'1FB1'), int(z'1FB9'), int(z'1FD0'), int(z'1FD8'), int(z'1FD1'), int(z'1FD9'), int(z'1FE0'), int(z'1FE8'), int(z'1FE1'), int(z'1FE9'), int(z'24D0'), int(z'24B6'), int(z'24D1'), int(z'24B7'), int(z'24D2'), int(z'24B8'), int(z'24D3'), int(z'24B9'), int(z'24D4'), int(z'24BA'), int(z'24D5'), int(z'24BB'), int(z'24D6'), int(z'24BC'), int(z'24D7'), int(z'24BD'), int(z'24D8'), int(z'24BE'), int(z'24D9'), int(z'24BF'), int(z'24DA'), int(z'24C0'), int(z'24DB'), int(z'24C1'), int(z'24DC'), int(z'24C2'), int(z'24DD'), int(z'24C3'), int(z'24DE'), int(z'24C4'), int(z'24DF'), int(z'24C5'), int(z'24E0'), int(z'24C6'), int(z'24E1'), int(z'24C7'), int(z'24E2'), int(z'24C8'), int(z'24E3'), int(z'24C9'), int(z'24E4'), int(z'24CA'), int(z'24E5'), int(z'24CB'), int(z'24E6'), int(z'24CC'), int(z'24E7'), int(z'24CD'), int(z'24E8'), int(z'24CE'), int(z'24E9'), int(z'24CF'), int(z'FF41'), int(z'FF21'), int(z'FF42'), int(z'FF22'), int(z'FF43'), int(z'FF23'), int(z'FF44'), int(z'FF24'), int(z'FF45'), int(z'FF25'), int(z'FF46'), int(z'FF26'), int(z'FF47'), int(z'FF27'), int(z'FF48'), int(z'FF28'), int(z'FF49'), int(z'FF29'), int(z'FF4A'), int(z'FF2A'), int(z'FF4B'), int(z'FF2B'), int(z'FF4C'), int(z'FF2C'), int(z'FF4D'), int(z'FF2D'), int(z'FF4E'), int(z'FF2E'), int(z'FF4F'), int(z'FF2F'), int(z'FF50'), int(z'FF30'), int(z'FF51'), int(z'FF31'), int(z'FF52'), int(z'FF32'), int(z'FF53'), int(z'FF33'), int(z'FF54'), int(z'FF34'), int(z'FF55'), int(z'FF35'), int(z'FF56'), int(z'FF36'), int(z'FF57'), int(z'FF37'), int(z'FF58'), int(z'FF38'), int(z'FF59'), int(z'FF39'), int(z'FF5A'), int(z'FF3A')], shape(lowup), order=[2, 1]) type( unicode_type ) :: upp Source Code program testit !use M_unicode, only : assignment(=), unicode_type use M_unicode ! Unicode lowercase to uppercase conversion mapping table integer , parameter :: lowhigh = 666 integer , parameter :: lowup ( lowhigh , 2 ) = reshape ([ & int ( z '0061' ), int ( z '0041' ), & ! LATIN SMALL LETTER A => LATIN CAPITAL LETTER A int ( z '0062' ), int ( z '0042' ), & ! LATIN SMALL LETTER B => LATIN CAPITAL LETTER B int ( z '0063' ), int ( z '0043' ), & ! LATIN SMALL LETTER C => LATIN CAPITAL LETTER C int ( z '0064' ), int ( z '0044' ), & ! LATIN SMALL LETTER D => LATIN CAPITAL LETTER D int ( z '0065' ), int ( z '0045' ), & ! LATIN SMALL LETTER E => LATIN CAPITAL LETTER E int ( z '0066' ), int ( z '0046' ), & ! LATIN SMALL LETTER F => LATIN CAPITAL LETTER F int ( z '0067' ), int ( z '0047' ), & ! LATIN SMALL LETTER G => LATIN CAPITAL LETTER G int ( z '0068' ), int ( z '0048' ), & ! LATIN SMALL LETTER H => LATIN CAPITAL LETTER H int ( z '0069' ), int ( z '0049' ), & ! LATIN SMALL LETTER I => LATIN CAPITAL LETTER I int ( z '006A' ), int ( z '004A' ), & ! LATIN SMALL LETTER J => LATIN CAPITAL LETTER J int ( z '006B' ), int ( z '004B' ), & ! LATIN SMALL LETTER K => LATIN CAPITAL LETTER K int ( z '006C' ), int ( z '004C' ), & ! LATIN SMALL LETTER L => LATIN CAPITAL LETTER L int ( z '006D' ), int ( z '004D' ), & ! LATIN SMALL LETTER M => LATIN CAPITAL LETTER M int ( z '006E' ), int ( z '004E' ), & ! LATIN SMALL LETTER N => LATIN CAPITAL LETTER N int ( z '006F' ), int ( z '004F' ), & ! LATIN SMALL LETTER O => LATIN CAPITAL LETTER O int ( z '0070' ), int ( z '0050' ), & ! LATIN SMALL LETTER P => LATIN CAPITAL LETTER P int ( z '0071' ), int ( z '0051' ), & ! LATIN SMALL LETTER Q => LATIN CAPITAL LETTER Q int ( z '0072' ), int ( z '0052' ), & ! LATIN SMALL LETTER R => LATIN CAPITAL LETTER R int ( z '0073' ), int ( z '0053' ), & ! LATIN SMALL LETTER S => LATIN CAPITAL LETTER S int ( z '0074' ), int ( z '0054' ), & ! LATIN SMALL LETTER T => LATIN CAPITAL LETTER T int ( z '0075' ), int ( z '0055' ), & ! LATIN SMALL LETTER U => LATIN CAPITAL LETTER U int ( z '0076' ), int ( z '0056' ), & ! LATIN SMALL LETTER V => LATIN CAPITAL LETTER V int ( z '0077' ), int ( z '0057' ), & ! LATIN SMALL LETTER W => LATIN CAPITAL LETTER W int ( z '0078' ), int ( z '0058' ), & ! LATIN SMALL LETTER X => LATIN CAPITAL LETTER X int ( z '0079' ), int ( z '0059' ), & ! LATIN SMALL LETTER Y => LATIN CAPITAL LETTER Y int ( z '007A' ), int ( z '005A' ), & ! LATIN SMALL LETTER Z => LATIN CAPITAL LETTER Z int ( z '00E0' ), int ( z '00C0' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A GRAVE int ( z '00E1' ), int ( z '00C1' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A ACUTE int ( z '00E2' ), int ( z '00C2' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A CIRCUMFLEX int ( z '00E3' ), int ( z '00C3' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A TILDE int ( z '00E4' ), int ( z '00C4' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A DIAERESIS int ( z '00E5' ), int ( z '00C5' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A RING int ( z '00E6' ), int ( z '00C6' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A E int ( z '00E7' ), int ( z '00C7' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER C CEDILLA int ( z '00E8' ), int ( z '00C8' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER E GRAVE int ( z '00E9' ), int ( z '00C9' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER E ACUTE int ( z '00EA' ), int ( z '00CA' ), & ! LATIN SMALL LETTER E CIRCUMFLEX => LATIN CAPITAL LETTER E CIRCUMFLEX int ( z '00EB' ), int ( z '00CB' ), & ! LATIN SMALL LETTER E DIAERESIS => LATIN CAPITAL LETTER E DIAERESIS int ( z '00EC' ), int ( z '00CC' ), & ! LATIN SMALL LETTER I GRAVE => LATIN CAPITAL LETTER I GRAVE int ( z '00ED' ), int ( z '00CD' ), & ! LATIN SMALL LETTER I ACUTE => LATIN CAPITAL LETTER I ACUTE int ( z '00EE' ), int ( z '00CE' ), & ! LATIN SMALL LETTER I CIRCUMFLEX => LATIN CAPITAL LETTER I CIRCUMFLEX int ( z '00EF' ), int ( z '00CF' ), & ! LATIN SMALL LETTER I DIAERESIS => LATIN CAPITAL LETTER I DIAERESIS int ( z '00F0' ), int ( z '00D0' ), & ! LATIN SMALL LETTER ETH => LATIN CAPITAL LETTER ETH int ( z '00F1' ), int ( z '00D1' ), & ! LATIN SMALL LETTER N TILDE => LATIN CAPITAL LETTER N TILDE int ( z '00F2' ), int ( z '00D2' ), & ! LATIN SMALL LETTER O GRAVE => LATIN CAPITAL LETTER O GRAVE int ( z '00F3' ), int ( z '00D3' ), & ! LATIN SMALL LETTER O ACUTE => LATIN CAPITAL LETTER O ACUTE int ( z '00F4' ), int ( z '00D4' ), & ! LATIN SMALL LETTER O CIRCUMFLEX => LATIN CAPITAL LETTER O CIRCUMFLEX int ( z '00F5' ), int ( z '00D5' ), & ! LATIN SMALL LETTER O TILDE => LATIN CAPITAL LETTER O TILDE int ( z '00F6' ), int ( z '00D6' ), & ! LATIN SMALL LETTER O DIAERESIS => LATIN CAPITAL LETTER O DIAERESIS int ( z '00F8' ), int ( z '00D8' ), & ! LATIN SMALL LETTER O SLASH => LATIN CAPITAL LETTER O SLASH int ( z '00F9' ), int ( z '00D9' ), & ! LATIN SMALL LETTER U GRAVE => LATIN CAPITAL LETTER U GRAVE int ( z '00FA' ), int ( z '00DA' ), & ! LATIN SMALL LETTER U ACUTE => LATIN CAPITAL LETTER U ACUTE int ( z '00FB' ), int ( z '00DB' ), & ! LATIN SMALL LETTER U CIRCUMFLEX => LATIN CAPITAL LETTER U CIRCUMFLEX int ( z '00FC' ), int ( z '00DC' ), & ! LATIN SMALL LETTER U DIAERESIS => LATIN CAPITAL LETTER U DIAERESIS int ( z '00FD' ), int ( z '00DD' ), & ! LATIN SMALL LETTER Y ACUTE => LATIN CAPITAL LETTER Y ACUTE int ( z '00FE' ), int ( z '00DE' ), & ! LATIN SMALL LETTER THORN => LATIN CAPITAL LETTER THORN int ( z '00FF' ), int ( z '0178' ), & ! LATIN SMALL LETTER Y DIAERESIS => LATIN CAPITAL LETTER Y WITH DIAERESIS int ( z '0101' ), int ( z '0100' ), & ! LATIN SMALL LETTER A WITH MACRON => LATIN CAPITAL LETTER A WITH MACRON int ( z '0103' ), int ( z '0102' ), & ! LATIN SMALL LETTER A WITH BREVE => LATIN CAPITAL LETTER A WITH BREVE int ( z '0105' ), int ( z '0104' ), & ! LATIN SMALL LETTER A WITH OGONEK => LATIN CAPITAL LETTER A WITH OGONEK int ( z '0107' ), int ( z '0106' ), & ! LATIN SMALL LETTER C WITH ACUTE => LATIN CAPITAL LETTER C WITH ACUTE int ( z '0109' ), int ( z '0108' ), & ! LATIN SMALL LETTER C WITH CIRCUMFLEX => LATIN CAPITAL LETTER C WITH CIRCUMFLEX int ( z '010B' ), int ( z '010A' ), & ! LATIN SMALL LETTER C WITH DOT ABOVE => LATIN CAPITAL LETTER C WITH DOT ABOVE int ( z '010D' ), int ( z '010C' ), & ! LATIN SMALL LETTER C WITH CARON => LATIN CAPITAL LETTER C WITH CARON int ( z '010F' ), int ( z '010E' ), & ! LATIN SMALL LETTER D WITH CARON => LATIN CAPITAL LETTER D WITH CARON int ( z '0111' ), int ( z '0110' ), & ! LATIN SMALL LETTER D WITH STROKE => LATIN CAPITAL LETTER D WITH STROKE int ( z '0113' ), int ( z '0112' ), & ! LATIN SMALL LETTER E WITH MACRON => LATIN CAPITAL LETTER E WITH MACRON int ( z '0115' ), int ( z '0114' ), & ! LATIN SMALL LETTER E WITH BREVE => LATIN CAPITAL LETTER E WITH BREVE int ( z '0117' ), int ( z '0116' ), & ! LATIN SMALL LETTER E WITH DOT ABOVE => LATIN CAPITAL LETTER E WITH DOT ABOVE int ( z '0119' ), int ( z '0118' ), & ! LATIN SMALL LETTER E WITH OGONEK => LATIN CAPITAL LETTER E WITH OGONEK int ( z '011B' ), int ( z '011A' ), & ! LATIN SMALL LETTER E WITH CARON => LATIN CAPITAL LETTER E WITH CARON int ( z '011D' ), int ( z '011C' ), & ! LATIN SMALL LETTER G WITH CIRCUMFLEX => LATIN CAPITAL LETTER G WITH CIRCUMFLEX int ( z '011F' ), int ( z '011E' ), & ! LATIN SMALL LETTER G WITH BREVE => LATIN CAPITAL LETTER G WITH BREVE int ( z '0121' ), int ( z '0120' ), & ! LATIN SMALL LETTER G WITH DOT ABOVE => LATIN CAPITAL LETTER G WITH DOT ABOVE int ( z '0123' ), int ( z '0122' ), & ! LATIN SMALL LETTER G WITH CEDILLA => LATIN CAPITAL LETTER G WITH CEDILLA int ( z '0125' ), int ( z '0124' ), & ! LATIN SMALL LETTER H WITH CIRCUMFLEX => LATIN CAPITAL LETTER H WITH CIRCUMFLEX int ( z '0127' ), int ( z '0126' ), & ! LATIN SMALL LETTER H WITH STROKE => LATIN CAPITAL LETTER H WITH STROKE int ( z '0129' ), int ( z '0128' ), & ! LATIN SMALL LETTER I WITH TILDE => LATIN CAPITAL LETTER I WITH TILDE int ( z '012B' ), int ( z '012A' ), & ! LATIN SMALL LETTER I WITH MACRON => LATIN CAPITAL LETTER I WITH MACRON int ( z '012D' ), int ( z '012C' ), & ! LATIN SMALL LETTER I WITH BREVE => LATIN CAPITAL LETTER I WITH BREVE int ( z '012F' ), int ( z '012E' ), & ! LATIN SMALL LETTER I WITH OGONEK => LATIN CAPITAL LETTER I WITH OGONEK int ( z '0131' ), int ( z '0049' ), & ! LATIN SMALL LETTER DOTLESS I => LATIN CAPITAL LETTER I int ( z '0133' ), int ( z '0132' ), & ! LATIN SMALL LIGATURE IJ => LATIN CAPITAL LIGATURE IJ int ( z '0135' ), int ( z '0134' ), & ! LATIN SMALL LETTER J WITH CIRCUMFLEX => LATIN CAPITAL LETTER J WITH CIRCUMFLEX int ( z '0137' ), int ( z '0136' ), & ! LATIN SMALL LETTER K WITH CEDILLA => LATIN CAPITAL LETTER K WITH CEDILLA int ( z '013A' ), int ( z '0139' ), & ! LATIN SMALL LETTER L WITH ACUTE => LATIN CAPITAL LETTER L WITH ACUTE int ( z '013C' ), int ( z '013B' ), & ! LATIN SMALL LETTER L WITH CEDILLA => LATIN CAPITAL LETTER L WITH CEDILLA int ( z '013E' ), int ( z '013D' ), & ! LATIN SMALL LETTER L WITH CARON => LATIN CAPITAL LETTER L WITH CARON int ( z '0140' ), int ( z '013F' ), & ! LATIN SMALL LETTER L WITH MIDDLE DOT => LATIN CAPITAL LETTER L WITH MIDDLE DOT int ( z '0142' ), int ( z '0141' ), & ! LATIN SMALL LETTER L WITH STROKE => LATIN CAPITAL LETTER L WITH STROKE int ( z '0144' ), int ( z '0143' ), & ! LATIN SMALL LETTER N WITH ACUTE => LATIN CAPITAL LETTER N WITH ACUTE int ( z '0146' ), int ( z '0145' ), & ! LATIN SMALL LETTER N WITH CEDILLA => LATIN CAPITAL LETTER N WITH CEDILLA int ( z '0148' ), int ( z '0147' ), & ! LATIN SMALL LETTER N WITH CARON => LATIN CAPITAL LETTER N WITH CARON int ( z '014B' ), int ( z '014A' ), & ! LATIN SMALL LETTER ENG (SAMI) => LATIN CAPITAL LETTER ENG (SAMI) int ( z '014D' ), int ( z '014C' ), & ! LATIN SMALL LETTER O WITH MACRON => LATIN CAPITAL LETTER O WITH MACRON int ( z '014F' ), int ( z '014E' ), & ! LATIN SMALL LETTER O WITH BREVE => LATIN CAPITAL LETTER O WITH BREVE int ( z '0151' ), int ( z '0150' ), & ! LATIN SMALL LETTER O WITH DOUBLE ACUTE => LATIN CAPITAL LETTER O WITH DOUBLE ACUTE int ( z '0153' ), int ( z '0152' ), & ! LATIN SMALL LIGATURE OE => LATIN CAPITAL LIGATURE OE int ( z '0155' ), int ( z '0154' ), & ! LATIN SMALL LETTER R WITH ACUTE => LATIN CAPITAL LETTER R WITH ACUTE int ( z '0157' ), int ( z '0156' ), & ! LATIN SMALL LETTER R WITH CEDILLA => LATIN CAPITAL LETTER R WITH CEDILLA int ( z '0159' ), int ( z '0158' ), & ! LATIN SMALL LETTER R WITH CARON => LATIN CAPITAL LETTER R WITH CARON int ( z '015B' ), int ( z '015A' ), & ! LATIN SMALL LETTER S WITH ACUTE => LATIN CAPITAL LETTER S WITH ACUTE int ( z '015D' ), int ( z '015C' ), & ! LATIN SMALL LETTER S WITH CIRCUMFLEX => LATIN CAPITAL LETTER S WITH CIRCUMFLEX int ( z '015F' ), int ( z '015E' ), & ! LATIN SMALL LETTER S WITH CEDILLA => LATIN CAPITAL LETTER S WITH CEDILLA int ( z '0161' ), int ( z '0160' ), & ! LATIN SMALL LETTER S WITH CARON => LATIN CAPITAL LETTER S WITH CARON int ( z '0163' ), int ( z '0162' ), & ! LATIN SMALL LETTER T WITH CEDILLA => LATIN CAPITAL LETTER T WITH CEDILLA int ( z '0165' ), int ( z '0164' ), & ! LATIN SMALL LETTER T WITH CARON => LATIN CAPITAL LETTER T WITH CARON int ( z '0167' ), int ( z '0166' ), & ! LATIN SMALL LETTER T WITH STROKE => LATIN CAPITAL LETTER T WITH STROKE int ( z '0169' ), int ( z '0168' ), & ! LATIN SMALL LETTER U WITH TILDE => LATIN CAPITAL LETTER U WITH TILDE int ( z '016B' ), int ( z '016A' ), & ! LATIN SMALL LETTER U WITH MACRON => LATIN CAPITAL LETTER U WITH MACRON int ( z '016D' ), int ( z '016C' ), & ! LATIN SMALL LETTER U WITH BREVE => LATIN CAPITAL LETTER U WITH BREVE int ( z '016F' ), int ( z '016E' ), & ! LATIN SMALL LETTER U WITH RING ABOVE => LATIN CAPITAL LETTER U WITH RING ABOVE int ( z '0171' ), int ( z '0170' ), & ! LATIN SMALL LETTER U WITH DOUBLE ACUTE => LATIN CAPITAL LETTER U WITH DOUBLE ACUTE int ( z '0173' ), int ( z '0172' ), & ! LATIN SMALL LETTER U WITH OGONEK => LATIN CAPITAL LETTER U WITH OGONEK int ( z '0175' ), int ( z '0174' ), & ! LATIN SMALL LETTER W WITH CIRCUMFLEX => LATIN CAPITAL LETTER W WITH CIRCUMFLEX int ( z '0177' ), int ( z '0176' ), & ! LATIN SMALL LETTER Y WITH CIRCUMFLEX => LATIN CAPITAL LETTER Y WITH CIRCUMFLEX int ( z '017A' ), int ( z '0179' ), & ! LATIN SMALL LETTER Z WITH ACUTE => LATIN CAPITAL LETTER Z WITH ACUTE int ( z '017C' ), int ( z '017B' ), & ! LATIN SMALL LETTER Z WITH DOT ABOVE => LATIN CAPITAL LETTER Z WITH DOT ABOVE int ( z '017E' ), int ( z '017D' ), & ! LATIN SMALL LETTER Z WITH CARON => LATIN CAPITAL LETTER Z WITH CARON int ( z '0183' ), int ( z '0182' ), & ! LATIN SMALL LETTER B WITH TOPBAR => LATIN CAPITAL LETTER B WITH TOPBAR int ( z '0185' ), int ( z '0184' ), & ! LATIN SMALL LETTER TONE SIX => LATIN CAPITAL LETTER TONE SIX int ( z '0188' ), int ( z '0187' ), & ! LATIN SMALL LETTER C WITH HOOK => LATIN CAPITAL LETTER C WITH HOOK int ( z '018C' ), int ( z '018B' ), & ! LATIN SMALL LETTER D WITH TOPBAR => LATIN CAPITAL LETTER D WITH TOPBAR int ( z '0192' ), int ( z '0191' ), & ! LATIN SMALL LETTER F WITH HOOK => LATIN CAPITAL LETTER F WITH HOOK int ( z '0199' ), int ( z '0198' ), & ! LATIN SMALL LETTER K WITH HOOK => LATIN CAPITAL LETTER K WITH HOOK int ( z '01A1' ), int ( z '01A0' ), & ! LATIN SMALL LETTER O WITH HORN => LATIN CAPITAL LETTER O WITH HORN int ( z '01A3' ), int ( z '01A2' ), & ! LATIN SMALL LETTER OI => LATIN CAPITAL LETTER OI int ( z '01A5' ), int ( z '01A4' ), & ! LATIN SMALL LETTER P WITH HOOK => LATIN CAPITAL LETTER P WITH HOOK int ( z '01A8' ), int ( z '01A7' ), & ! LATIN SMALL LETTER TONE TWO => LATIN CAPITAL LETTER TONE TWO int ( z '01AD' ), int ( z '01AC' ), & ! LATIN SMALL LETTER T WITH HOOK => LATIN CAPITAL LETTER T WITH HOOK int ( z '01B0' ), int ( z '01AF' ), & ! LATIN SMALL LETTER U WITH HORN => LATIN CAPITAL LETTER U WITH HORN int ( z '01B4' ), int ( z '01B3' ), & ! LATIN SMALL LETTER Y WITH HOOK => LATIN CAPITAL LETTER Y WITH HOOK int ( z '01B6' ), int ( z '01B5' ), & ! LATIN SMALL LETTER Z WITH STROKE => LATIN CAPITAL LETTER Z WITH STROKE int ( z '01B9' ), int ( z '01B8' ), & ! LATIN SMALL LETTER EZH REVERSED => LATIN CAPITAL LETTER EZH REVERSED int ( z '01BD' ), int ( z '01BC' ), & ! LATIN SMALL LETTER TONE FIVE => LATIN CAPITAL LETTER TONE FIVE int ( z '01C6' ), int ( z '01C4' ), & ! LATIN SMALL LETTER DZ WITH CARON => LATIN CAPITAL LETTER DZ WITH CARON int ( z '01C9' ), int ( z '01C7' ), & ! LATIN SMALL LETTER LJ => LATIN CAPITAL LETTER LJ int ( z '01CC' ), int ( z '01CA' ), & ! LATIN SMALL LETTER NJ => LATIN CAPITAL LETTER NJ int ( z '01CE' ), int ( z '01CD' ), & ! LATIN SMALL LETTER A WITH CARON => LATIN CAPITAL LETTER A WITH CARON int ( z '01D0' ), int ( z '01CF' ), & ! LATIN SMALL LETTER I WITH CARON => LATIN CAPITAL LETTER I WITH CARON int ( z '01D2' ), int ( z '01D1' ), & ! LATIN SMALL LETTER O WITH CARON => LATIN CAPITAL LETTER O WITH CARON int ( z '01D4' ), int ( z '01D3' ), & ! LATIN SMALL LETTER U WITH CARON => LATIN CAPITAL LETTER U WITH CARON int ( z '01D6' ), int ( z '01D5' ), & ! LATIN SMALL LETTER U WITH DIAERESIS AND MACRON => LATIN CAPITAL LETTER U WITH DIAERESIS AND MACRON int ( z '01D8' ), int ( z '01D7' ), & ! LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE => LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE int ( z '01DA' ), int ( z '01D9' ), & ! LATIN SMALL LETTER U WITH DIAERESIS AND CARON => LATIN CAPITAL LETTER U WITH DIAERESIS AND CARON int ( z '01DC' ), int ( z '01DB' ), & ! LATIN SMALL LETTER U WITH DIAERESIS AND GRAVE => LATIN CAPITAL LETTER U WITH DIAERESIS AND GRAVE int ( z '01DF' ), int ( z '01DE' ), & ! LATIN SMALL LETTER A WITH DIAERESIS AND MACRON => LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON int ( z '01E1' ), int ( z '01E0' ), & ! LATIN SMALL LETTER A WITH DOT ABOVE AND MACRON => LATIN CAPITAL LETTER A WITH DOT ABOVE AND MACRON int ( z '01E3' ), int ( z '01E2' ), & ! LATIN SMALL LIGATURE AE WITH MACRON => LATIN CAPITAL LIGATURE AE MTH MACRON int ( z '01E5' ), int ( z '01E4' ), & ! LATIN SMALL LETTER G WITH STROKE => LATIN CAPITAL LETTER G WITH STROKE int ( z '01E7' ), int ( z '01E6' ), & ! LATIN SMALL LETTER G WITH CARON => LATIN CAPITAL LETTER G WITH CARON int ( z '01E9' ), int ( z '01E8' ), & ! LATIN SMALL LETTER K WITH CARON => LATIN CAPITAL LETTER K WITH CARON int ( z '01EB' ), int ( z '01EA' ), & ! LATIN SMALL LETTER O WITH OGONEK => LATIN CAPITAL LETTER O WITH OGONEK int ( z '01ED' ), int ( z '01EC' ), & ! LATIN SMALL LETTER O WITH OGONEK AND MACRON => LATIN CAPITAL LETTER O WITH OGONEK AND MACRON int ( z '01EF' ), int ( z '01EE' ), & ! LATIN SMALL LETTER EZH WITH CARON => LATIN CAPITAL LETTER EZH WITH CARON int ( z '01F3' ), int ( z '01F1' ), & ! LATIN SMALL LETTER DZ => LATIN CAPITAL LETTER DZ int ( z '01F5' ), int ( z '01F4' ), & ! LATIN SMALL LETTER G WITH ACUTE => LATIN CAPITAL LETTER G WITH ACUTE int ( z '01FB' ), int ( z '01FA' ), & ! LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE => LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE int ( z '01FD' ), int ( z '01FC' ), & ! LATIN SMALL LIGATURE AE WITH ACUTE => LATIN CAPITAL LIGATURE AE WITH ACUTE int ( z '01FF' ), int ( z '01FE' ), & ! LATIN SMALL LETTER O WITH STROKE AND ACUTE => LATIN CAPITAL LETTER O WITH STROKE AND ACUTE int ( z '0201' ), int ( z '0200' ), & ! LATIN SMALL LETTER A WITH DOUBLE GRAVE => LATIN CAPITAL LETTER A WITH DOUBLE GRAVE int ( z '0203' ), int ( z '0202' ), & ! LATIN SMALL LETTER A WITH INVERTED BREVE => LATIN CAPITAL LETTER A WITH INVERTED BREVE int ( z '0205' ), int ( z '0204' ), & ! LATIN SMALL LETTER E WITH DOUBLE GRAVE => LATIN CAPITAL LETTER E WITH DOUBLE GRAVE int ( z '0207' ), int ( z '0206' ), & ! LATIN SMALL LETTER E WITH INVERTED BREVE => LATIN CAPITAL LETTER E WITH INVERTED BREVE int ( z '0209' ), int ( z '0208' ), & ! LATIN SMALL LETTER I WITH DOUBLE GRAVE => LATIN CAPITAL LETTER I WITH DOUBLE GRAVE int ( z '020B' ), int ( z '020A' ), & ! LATIN SMALL LETTER I WITH INVERTED BREVE => LATIN CAPITAL LETTER I WITH INVERTED BREVE int ( z '020D' ), int ( z '020C' ), & ! LATIN SMALL LETTER O WITH DOUBLE GRAVE => LATIN CAPITAL LETTER O WITH DOUBLE GRAVE int ( z '020F' ), int ( z '020E' ), & ! LATIN SMALL LETTER O WITH INVERTED BREVE => LATIN CAPITAL LETTER O WITH INVERTED BREVE int ( z '0211' ), int ( z '0210' ), & ! LATIN SMALL LETTER R WITH DOUBLE GRAVE => LATIN CAPITAL LETTER R WITH DOUBLE GRAVE int ( z '0213' ), int ( z '0212' ), & ! LATIN SMALL LETTER R WITH INVERTED BREVE => LATIN CAPITAL LETTER R WITH INVERTED BREVE int ( z '0215' ), int ( z '0214' ), & ! LATIN SMALL LETTER U WITH DOUBLE GRAVE => LATIN CAPITAL LETTER U WITH DOUBLE GRAVE int ( z '0217' ), int ( z '0216' ), & ! LATIN SMALL LETTER U WITH INVERTED BREVE => LATIN CAPITAL LETTER U WITH INVERTED BREVE int ( z '0253' ), int ( z '0181' ), & ! LATIN SMALL LETTER B WITH HOOK => LATIN CAPITAL LETTER B WITH HOOK int ( z '0254' ), int ( z '0186' ), & ! LATIN SMALL LETTER OPEN O => LATIN CAPITAL LETTER OPEN O int ( z '0257' ), int ( z '018A' ), & ! LATIN SMALL LETTER D WITH HOOK => LATIN CAPITAL LETTER D WITH HOOK int ( z '0258' ), int ( z '018E' ), & ! LATIN SMALL LETTER REVERSED E => LATIN CAPITAL LETTER REVERSED E int ( z '0259' ), int ( z '018F' ), & ! LATIN SMALL LETTER SCHWA => LATIN CAPITAL LETTER SCHWA int ( z '025B' ), int ( z '0190' ), & ! LATIN SMALL LETTER OPEN E => LATIN CAPITAL LETTER OPEN E int ( z '0260' ), int ( z '0193' ), & ! LATIN SMALL LETTER G WITH HOOK => LATIN CAPITAL LETTER G WITH HOOK int ( z '0263' ), int ( z '0194' ), & ! LATIN SMALL LETTER GAMMA => LATIN CAPITAL LETTER GAMMA int ( z '0268' ), int ( z '0197' ), & ! LATIN SMALL LETTER I WITH STROKE => LATIN CAPITAL LETTER I WITH STROKE int ( z '0269' ), int ( z '0196' ), & ! LATIN SMALL LETTER IOTA => LATIN CAPITAL LETTER IOTA int ( z '026F' ), int ( z '019C' ), & ! LATIN SMALL LETTER TURNED M => LATIN CAPITAL LETTER TURNED M int ( z '0272' ), int ( z '019D' ), & ! LATIN SMALL LETTER N WITH LEFT HOOK => LATIN CAPITAL LETTER N WITH LEFT HOOK int ( z '0275' ), int ( z '019F' ), & ! LATIN SMALL LETTER BARRED O => LATIN CAPITAL LETTER O WITH MIDDLE TILDE int ( z '0283' ), int ( z '01A9' ), & ! LATIN SMALL LETTER ESH => LATIN CAPITAL LETTER ESH int ( z '0288' ), int ( z '01AE' ), & ! LATIN SMALL LETTER T WITH RETROFLEX HOOK => LATIN CAPITAL LETTER T WITH RETROFLEX HOOK int ( z '028A' ), int ( z '01B1' ), & ! LATIN SMALL LETTER UPSILON => LATIN CAPITAL LETTER UPSILON int ( z '028B' ), int ( z '01B2' ), & ! LATIN SMALL LETTER V WITH HOOK => LATIN CAPITAL LETTER V WITH HOOK int ( z '0292' ), int ( z '01B7' ), & ! LATIN SMALL LETTER EZH => LATIN CAPITAL LETTER EZH int ( z '03AC' ), int ( z '0386' ), & ! GREEK SMALL LETTER ALPHA WITH TONOS => GREEK CAPITAL LETTER ALPHA WITH TONOS int ( z '03AD' ), int ( z '0388' ), & ! GREEK SMALL LETTER EPSILON WITH TONOS => GREEK CAPITAL LETTER EPSILON WITH TONOS int ( z '03AE' ), int ( z '0389' ), & ! GREEK SMALL LETTER ETA WITH TONOS => GREEK CAPITAL LETTER ETA WITH TONOS int ( z '03AF' ), int ( z '038A' ), & ! GREEK SMALL LETTER IOTA WITH TONOS => GREEK CAPITAL LETTER IOTA WITH TONOS int ( z '03B1' ), int ( z '0391' ), & ! GREEK SMALL LETTER ALPHA => GREEK CAPITAL LETTER ALPHA int ( z '03B2' ), int ( z '0392' ), & ! GREEK SMALL LETTER BETA => GREEK CAPITAL LETTER BETA int ( z '03B3' ), int ( z '0393' ), & ! GREEK SMALL LETTER GAMMA => GREEK CAPITAL LETTER GAMMA int ( z '03B4' ), int ( z '0394' ), & ! GREEK SMALL LETTER DELTA => GREEK CAPITAL LETTER DELTA int ( z '03B5' ), int ( z '0395' ), & ! GREEK SMALL LETTER EPSILON => GREEK CAPITAL LETTER EPSILON int ( z '03B6' ), int ( z '0396' ), & ! GREEK SMALL LETTER ZETA => GREEK CAPITAL LETTER ZETA int ( z '03B7' ), int ( z '0397' ), & ! GREEK SMALL LETTER ETA => GREEK CAPITAL LETTER ETA int ( z '03B8' ), int ( z '0398' ), & ! GREEK SMALL LETTER THETA => GREEK CAPITAL LETTER THETA int ( z '03B9' ), int ( z '0399' ), & ! GREEK SMALL LETTER IOTA => GREEK CAPITAL LETTER IOTA int ( z '03BA' ), int ( z '039A' ), & ! GREEK SMALL LETTER KAPPA => GREEK CAPITAL LETTER KAPPA int ( z '03BB' ), int ( z '039B' ), & ! GREEK SMALL LETTER LAMDA => GREEK CAPITAL LETTER LAMDA int ( z '03BC' ), int ( z '039C' ), & ! GREEK SMALL LETTER MU => GREEK CAPITAL LETTER MU int ( z '03BD' ), int ( z '039D' ), & ! GREEK SMALL LETTER NU => GREEK CAPITAL LETTER NU int ( z '03BE' ), int ( z '039E' ), & ! GREEK SMALL LETTER XI => GREEK CAPITAL LETTER XI int ( z '03BF' ), int ( z '039F' ), & ! GREEK SMALL LETTER OMICRON => GREEK CAPITAL LETTER OMICRON int ( z '03C0' ), int ( z '03A0' ), & ! GREEK SMALL LETTER PI => GREEK CAPITAL LETTER PI int ( z '03C1' ), int ( z '03A1' ), & ! GREEK SMALL LETTER RHO => GREEK CAPITAL LETTER RHO int ( z '03C3' ), int ( z '03A3' ), & ! GREEK SMALL LETTER SIGMA => GREEK CAPITAL LETTER SIGMA int ( z '03C4' ), int ( z '03A4' ), & ! GREEK SMALL LETTER TAU => GREEK CAPITAL LETTER TAU int ( z '03C5' ), int ( z '03A5' ), & ! GREEK SMALL LETTER UPSILON => GREEK CAPITAL LETTER UPSILON int ( z '03C6' ), int ( z '03A6' ), & ! GREEK SMALL LETTER PHI => GREEK CAPITAL LETTER PHI int ( z '03C7' ), int ( z '03A7' ), & ! GREEK SMALL LETTER CHI => GREEK CAPITAL LETTER CHI int ( z '03C8' ), int ( z '03A8' ), & ! GREEK SMALL LETTER PSI => GREEK CAPITAL LETTER PSI int ( z '03C9' ), int ( z '03A9' ), & ! GREEK SMALL LETTER OMEGA => GREEK CAPITAL LETTER OMEGA int ( z '03CA' ), int ( z '03AA' ), & ! GREEK SMALL LETTER IOTA WITH DIALYTIKA => GREEK CAPITAL LETTER IOTA WITH DIALYTIKA int ( z '03CB' ), int ( z '03AB' ), & ! GREEK SMALL LETTER UPSILON WITH DIALYTIKA => GREEK CAPITAL LETTER UPSILON WITH DIALYTIKA int ( z '03CC' ), int ( z '038C' ), & ! GREEK SMALL LETTER OMICRON WITH TONOS => GREEK CAPITAL LETTER OMICRON WITH TONOS int ( z '03CD' ), int ( z '038E' ), & ! GREEK SMALL LETTER UPSILON WITH TONOS => GREEK CAPITAL LETTER UPSILON WITH TONOS int ( z '03CE' ), int ( z '038F' ), & ! GREEK SMALL LETTER OMEGA WITH TONOS => GREEK CAPITAL LETTER OMEGA WITH TONOS int ( z '03E3' ), int ( z '03E2' ), & ! COPTIC SMALL LETTER SHEI => COPTIC CAPITAL LETTER SHEI int ( z '03E5' ), int ( z '03E4' ), & ! COPTIC SMALL LETTER FEI => COPTIC CAPITAL LETTER FEI int ( z '03E7' ), int ( z '03E6' ), & ! COPTIC SMALL LETTER KHEI => COPTIC CAPITAL LETTER KHEI int ( z '03E9' ), int ( z '03E8' ), & ! COPTIC SMALL LETTER HORI => COPTIC CAPITAL LETTER HORI int ( z '03EB' ), int ( z '03EA' ), & ! COPTIC SMALL LETTER GANGIA => COPTIC CAPITAL LETTER GANGIA int ( z '03ED' ), int ( z '03EC' ), & ! COPTIC SMALL LETTER SHIMA => COPTIC CAPITAL LETTER SHIMA int ( z '03EF' ), int ( z '03EE' ), & ! COPTIC SMALL LETTER DEI => COPTIC CAPITAL LETTER DEI int ( z '0430' ), int ( z '0410' ), & ! CYRILLIC SMALL LETTER A => CYRILLIC CAPITAL LETTER A int ( z '0431' ), int ( z '0411' ), & ! CYRILLIC SMALL LETTER BE => CYRILLIC CAPITAL LETTER BE int ( z '0432' ), int ( z '0412' ), & ! CYRILLIC SMALL LETTER VE => CYRILLIC CAPITAL LETTER VE int ( z '0433' ), int ( z '0413' ), & ! CYRILLIC SMALL LETTER GHE => CYRILLIC CAPITAL LETTER GHE int ( z '0434' ), int ( z '0414' ), & ! CYRILLIC SMALL LETTER DE => CYRILLIC CAPITAL LETTER DE int ( z '0435' ), int ( z '0415' ), & ! CYRILLIC SMALL LETTER IE => CYRILLIC CAPITAL LETTER IE int ( z '0436' ), int ( z '0416' ), & ! CYRILLIC SMALL LETTER ZHE => CYRILLIC CAPITAL LETTER ZHE int ( z '0437' ), int ( z '0417' ), & ! CYRILLIC SMALL LETTER ZE => CYRILLIC CAPITAL LETTER ZE int ( z '0438' ), int ( z '0418' ), & ! CYRILLIC SMALL LETTER I => CYRILLIC CAPITAL LETTER I int ( z '0439' ), int ( z '0419' ), & ! CYRILLIC SMALL LETTER SHORT I => CYRILLIC CAPITAL LETTER SHORT I int ( z '043A' ), int ( z '041A' ), & ! CYRILLIC SMALL LETTER KA => CYRILLIC CAPITAL LETTER KA int ( z '043B' ), int ( z '041B' ), & ! CYRILLIC SMALL LETTER EL => CYRILLIC CAPITAL LETTER EL int ( z '043C' ), int ( z '041C' ), & ! CYRILLIC SMALL LETTER EM => CYRILLIC CAPITAL LETTER EM int ( z '043D' ), int ( z '041D' ), & ! CYRILLIC SMALL LETTER EN => CYRILLIC CAPITAL LETTER EN int ( z '043E' ), int ( z '041E' ), & ! CYRILLIC SMALL LETTER O => CYRILLIC CAPITAL LETTER O int ( z '043F' ), int ( z '041F' ), & ! CYRILLIC SMALL LETTER PE => CYRILLIC CAPITAL LETTER PE int ( z '0440' ), int ( z '0420' ), & ! CYRILLIC SMALL LETTER ER => CYRILLIC CAPITAL LETTER ER int ( z '0441' ), int ( z '0421' ), & ! CYRILLIC SMALL LETTER ES => CYRILLIC CAPITAL LETTER ES int ( z '0442' ), int ( z '0422' ), & ! CYRILLIC SMALL LETTER TE => CYRILLIC CAPITAL LETTER TE int ( z '0443' ), int ( z '0423' ), & ! CYRILLIC SMALL LETTER U => CYRILLIC CAPITAL LETTER U int ( z '0444' ), int ( z '0424' ), & ! CYRILLIC SMALL LETTER EF => CYRILLIC CAPITAL LETTER EF int ( z '0445' ), int ( z '0425' ), & ! CYRILLIC SMALL LETTER HA => CYRILLIC CAPITAL LETTER HA int ( z '0446' ), int ( z '0426' ), & ! CYRILLIC SMALL LETTER TSE => CYRILLIC CAPITAL LETTER TSE int ( z '0447' ), int ( z '0427' ), & ! CYRILLIC SMALL LETTER CHE => CYRILLIC CAPITAL LETTER CHE int ( z '0448' ), int ( z '0428' ), & ! CYRILLIC SMALL LETTER SHA => CYRILLIC CAPITAL LETTER SHA int ( z '0449' ), int ( z '0429' ), & ! CYRILLIC SMALL LETTER SHCHA => CYRILLIC CAPITAL LETTER SHCHA int ( z '044A' ), int ( z '042A' ), & ! CYRILLIC SMALL LETTER HARD SIGN => CYRILLIC CAPITAL LETTER HARD SIGN int ( z '044B' ), int ( z '042B' ), & ! CYRILLIC SMALL LETTER YERU => CYRILLIC CAPITAL LETTER YERU int ( z '044C' ), int ( z '042C' ), & ! CYRILLIC SMALL LETTER SOFT SIGN => CYRILLIC CAPITAL LETTER SOFT SIGN int ( z '044D' ), int ( z '042D' ), & ! CYRILLIC SMALL LETTER E => CYRILLIC CAPITAL LETTER E int ( z '044E' ), int ( z '042E' ), & ! CYRILLIC SMALL LETTER YU => CYRILLIC CAPITAL LETTER YU int ( z '044F' ), int ( z '042F' ), & ! CYRILLIC SMALL LETTER YA => CYRILLIC CAPITAL LETTER YA int ( z '0451' ), int ( z '0401' ), & ! CYRILLIC SMALL LETTER IO => CYRILLIC CAPITAL LETTER IO int ( z '0452' ), int ( z '0402' ), & ! CYRILLIC SMALL LETTER DJE (SERBOCROATIAN) => CYRILLIC CAPITAL LETTER DJE (SERBOCROATIAN) int ( z '0453' ), int ( z '0403' ), & ! CYRILLIC SMALL LETTER GJE => CYRILLIC CAPITAL LETTER GJE int ( z '0454' ), int ( z '0404' ), & ! CYRILLIC SMALL LETTER UKRAINIAN IE => CYRILLIC CAPITAL LETTER UKRAINIAN IE int ( z '0455' ), int ( z '0405' ), & ! CYRILLIC SMALL LETTER DZE => CYRILLIC CAPITAL LETTER DZE int ( z '0456' ), int ( z '0406' ), & ! CYRILLIC SMALL LETTER BYELORUSSIAN-UKRAINIAN I => CYRILLIC CAPITAL LETTER BYELORUSSIAN_UKRAINIAN I int ( z '0457' ), int ( z '0407' ), & ! CYRILLIC SMALL LETTER YI (UKRAINIAN) => CYRILLIC CAPITAL LETTER YI (UKRAINIAN) int ( z '0458' ), int ( z '0408' ), & ! CYRILLIC SMALL LETTER JE => CYRILLIC CAPITAL LETTER JE int ( z '0459' ), int ( z '0409' ), & ! CYRILLIC SMALL LETTER LJE => CYRILLIC CAPITAL LETTER LJE int ( z '045A' ), int ( z '040A' ), & ! CYRILLIC SMALL LETTER NJE => CYRILLIC CAPITAL LETTER NJE int ( z '045B' ), int ( z '040B' ), & ! CYRILLIC SMALL LETTER TSHE (SERBOCROATIAN) => CYRILLIC CAPITAL LETTER TSHE (SERBOCROATIAN) int ( z '045C' ), int ( z '040C' ), & ! CYRILLIC SMALL LETTER KJE => CYRILLIC CAPITAL LETTER KJE int ( z '045E' ), int ( z '040E' ), & ! CYRILLIC SMALL LETTER SHORT U (BYELORUSSIAN) => CYRILLIC CAPITAL LETTER SHORT U (BYELORUSSIAN) int ( z '045F' ), int ( z '040F' ), & ! CYRILLIC SMALL LETTER DZHE => CYRILLIC CAPITAL LETTER DZHE int ( z '0461' ), int ( z '0460' ), & ! CYRILLIC SMALL LETTER OMEGA => CYRILLIC CAPITAL LETTER OMEGA int ( z '0463' ), int ( z '0462' ), & ! CYRILLIC SMALL LETTER YAT => CYRILLIC CAPITAL LETTER YAT int ( z '0465' ), int ( z '0464' ), & ! CYRILLIC SMALL LETTER IOTIFIED E => CYRILLIC CAPITAL LETTER IOTIFIED E int ( z '0467' ), int ( z '0466' ), & ! CYRILLIC SMALL LETTER LITTLE YUS => CYRILLIC CAPITAL LETTER LITTLE YUS int ( z '0469' ), int ( z '0468' ), & ! CYRILLIC SMALL LETTER IOTIFIED LITTLE YUS => CYRILLIC CAPITAL LETTER IOTIFIED LITTLE YUS int ( z '046B' ), int ( z '046A' ), & ! CYRILLIC SMALL LETTER BIG YUS => CYRILLIC CAPITAL LETTER BIG YUS int ( z '046D' ), int ( z '046C' ), & ! CYRILLIC SMALL LETTER IOTIFIED BIG YUS => CYRILLIC CAPITAL LETTER IOTIFIED BIG YUS int ( z '046F' ), int ( z '046E' ), & ! CYRILLIC SMALL LETTER KSI => CYRILLIC CAPITAL LETTER KSI int ( z '0471' ), int ( z '0470' ), & ! CYRILLIC SMALL LETTER PSI => CYRILLIC CAPITAL LETTER PSI int ( z '0473' ), int ( z '0472' ), & ! CYRILLIC SMALL LETTER FITA => CYRILLIC CAPITAL LETTER FITA int ( z '0475' ), int ( z '0474' ), & ! CYRILLIC SMALL LETTER IZHITSA => CYRILLIC CAPITAL LETTER IZHITSA int ( z '0477' ), int ( z '0476' ), & ! CYRILLIC SMALL LETTER IZHITSA WITH DOUBLE GRAVE ACCENT => CYRILLIC CAPITAL LETTER IZHITSA WITH DOUBLE GRAVE ACCENT int ( z '0479' ), int ( z '0478' ), & ! CYRILLIC SMALL LETTER UK => CYRILLIC CAPITAL LETTER UK int ( z '047B' ), int ( z '047A' ), & ! CYRILLIC SMALL LETTER ROUND OMEGA => CYRILLIC CAPITAL LETTER ROUND OMEGA int ( z '047D' ), int ( z '047C' ), & ! CYRILLIC SMALL LETTER OMEGA WITH TITLO => CYRILLIC CAPITAL LETTER OMEGA WITH TITLO int ( z '047F' ), int ( z '047E' ), & ! CYRILLIC SMALL LETTER OT => CYRILLIC CAPITAL LETTER OT int ( z '0481' ), int ( z '0480' ), & ! CYRILLIC SMALL LETTER KOPPA => CYRILLIC CAPITAL LETTER KOPPA int ( z '0491' ), int ( z '0490' ), & ! CYRILLIC SMALL LETTER GHE WITH UPTURN => CYRILLIC CAPITAL LETTER GHE WITH UPTURN int ( z '0493' ), int ( z '0492' ), & ! CYRILLIC SMALL LETTER GHE WITH STROKE => CYRILLIC CAPITAL LETTER GHE WITH STROKE int ( z '0495' ), int ( z '0494' ), & ! CYRILLIC SMALL LETTER GHE WITH MIDDLE HOOK => CYRILLIC CAPITAL LETTER GHE WITH MIDDLE HOOK int ( z '0497' ), int ( z '0496' ), & ! CYRILLIC SMALL LETTER ZHE WITH DESCENDER => CYRILLIC CAPITAL LETTER ZHE WITH DESCENDER int ( z '0499' ), int ( z '0498' ), & ! CYRILLIC SMALL LETTER ZE WITH DESCENDER => CYRILLIC CAPITAL LETTER ZE WITH DESCENDER int ( z '049B' ), int ( z '049A' ), & ! CYRILLIC SMALL LETTER KA WITH DESCENDER => CYRILLIC CAPITAL LETTER KA WITH DESCENDER int ( z '049D' ), int ( z '049C' ), & ! CYRILLIC SMALL LETTER KA WITH VERTICAL STROKE => CYRILLIC CAPITAL LETTER KA WITH VERTICAL STROKE int ( z '049F' ), int ( z '049E' ), & ! CYRILLIC SMALL LETTER KA WITH STROKE => CYRILLIC CAPITAL LETTER KA WITH STROKE int ( z '04A1' ), int ( z '04A0' ), & ! CYRILLIC SMALL LETTER EASHKIR KA => CYRILLIC CAPITAL LETTER BASHKIR KA int ( z '04A3' ), int ( z '04A2' ), & ! CYRILLIC SMALL LETTER EN WITH DESCENOER => CYRILLIC CAPITAL LETTER EN WITH DESCENDER int ( z '04A5' ), int ( z '04A4' ), & ! CYRILLIC SMALL LIGATURE EN GHE => CYRILLIC CAPITAL LIGATURE EN GHF int ( z '04A7' ), int ( z '04A6' ), & ! CYRILLIC SMALL LETTER PE WITH MIDDLE HOOK (ABKHASIAN) => CYRILLIC CAPITAL LETTER PE WITH MIDDLE HOOK (ABKHASIAN) int ( z '04A9' ), int ( z '04A8' ), & ! CYRILLIC SMALL LETTER ABKHASIAN HA => CYRILLIC CAPITAL LETTER ABKHASIAN HA int ( z '04AB' ), int ( z '04AA' ), & ! CYRILLIC SMALL LETTER ES WITH DESCENDER => CYRILLIC CAPITAL LETTER ES WITH DESCENDER int ( z '04AD' ), int ( z '04AC' ), & ! CYRILLIC SMALL LETTER TE WITH DESCENDER => CYRILLIC CAPITAL LETTER TE WITH DESCENDER int ( z '04AF' ), int ( z '04AE' ), & ! CYRILLIC SMALL LETTER STRAIGHT U => CYRILLIC CAPITAL LETTER STRAIGHT U int ( z '04B1' ), int ( z '04B0' ), & ! CYRILLIC SMALL LETTER STRAIGHT U WITH STROKE => CYRILLIC CAPITAL LETTER STRAIGHT U WITH STROKE int ( z '04B3' ), int ( z '04B2' ), & ! CYRILLIC SMALL LETTER HA WITH DESCENDER => CYRILLIC CAPITAL LETTER HA WITH DESCENDER int ( z '04B5' ), int ( z '04B4' ), & ! CYRILLIC SMALL LIGATURE TE TSE (ABKHASIAN) => CYRILLIC CAPITAL LIGATURE TE TSE (ABKHASIAN) int ( z '04B7' ), int ( z '04B6' ), & ! CYRILLIC SMALL LETTER CHE WITH DESCENDER => CYRILLIC CAPITAL LETTER CHE WITH DESCENDER int ( z '04B9' ), int ( z '04B8' ), & ! CYRILLIC SMALL LETTER CHE WITH VERTICAL STROKE => CYRILLIC CAPITAL LETTER CHE WITH VERTICAL STROKE int ( z '04BB' ), int ( z '04BA' ), & ! CYRILLIC SMALL LETTER SHHA => CYRILLIC CAPITAL LETTER SHHA int ( z '04BD' ), int ( z '04BC' ), & ! CYRILLIC SMALL LETTER ABKHASIAN CHE => CYRILLIC CAPITAL LETTER ABKHASIAN CHE int ( z '04BF' ), int ( z '04BE' ), & ! CYRILLIC SMALL LETTER ABKHASIAN CHE WITH DESCENDER => CYRILLIC CAPITAL LETTER ABKHASIAN CHE WITH DESCENDER int ( z '04C2' ), int ( z '04C1' ), & ! CYRILLIC SMALL LETTER ZHE WITH BREVE => CYRILLIC CAPITAL LETTER ZHE WITH BREVE int ( z '04C4' ), int ( z '04C3' ), & ! CYRILLIC SMALL LETTER KA WITH HOOK => CYRILLIC CAPITAL LETTER KA WITH HOOK int ( z '04C8' ), int ( z '04C7' ), & ! CYRILLIC SMALL LETTER EN WITH HOOK => CYRILLIC CAPITAL LETTER EN WITH HOOK int ( z '04CC' ), int ( z '04CB' ), & ! CYRILLIC SMALL LETTER KHAKASSIAN CHE => CYRILLIC CAPITAL LETTER KHAKASSIAN CHE int ( z '04D1' ), int ( z '04D0' ), & ! CYRILLIC SMALL LETTER A WITH BREVE => CYRILLIC CAPITAL LETTER A WITH BREVE int ( z '04D3' ), int ( z '04D2' ), & ! CYRILLIC SMALL LETTER A WITH DIAERESIS => CYRILLIC CAPITAL LETTER A WITH DIAERESIS int ( z '04D5' ), int ( z '04D4' ), & ! CYRILLIC SMALL LIGATURE A IE => CYRILLIC CAPITAL LIGATURE A IE int ( z '04D7' ), int ( z '04D6' ), & ! CYRILLIC SMALL LETTER IE WITH BREVE => CYRILLIC CAPITAL LETTER IE WITH BREVE int ( z '04D9' ), int ( z '04D8' ), & ! CYRILLIC SMALL LETTER SCHWA => CYRILLIC CAPITAL LETTER SCHWA int ( z '04DB' ), int ( z '04DA' ), & ! CYRILLIC SMALL LETTER SCHWA WITH DIAERESIS => CYRILLIC CAPITAL LETTER SCHWA WITH DIAERESIS int ( z '04DD' ), int ( z '04DC' ), & ! CYRILLIC SMALL LETTER ZHE WITH DIAERESIS => CYRILLIC CAPITAL LETTER ZHE WITH DIAERESIS int ( z '04DF' ), int ( z '04DE' ), & ! CYRILLIC SMALL LETTER ZE WITH DIAERESIS => CYRILLIC CAPITAL LETTER ZE WITH DIAERESIS int ( z '04E1' ), int ( z '04E0' ), & ! CYRILLIC SMALL LETTER ABKHASIAN DZE => CYRILLIC CAPITAL LETTER ABKHASIAN DZE int ( z '04E3' ), int ( z '04E2' ), & ! CYRILLIC SMALL LETTER I WITH MACRON => CYRILLIC CAPITAL LETTER I WITH MACRON int ( z '04E5' ), int ( z '04E4' ), & ! CYRILLIC SMALL LETTER I WITH DIAERESIS => CYRILLIC CAPITAL LETTER I WITH DIAERESIS int ( z '04E7' ), int ( z '04E6' ), & ! CYRILLIC SMALL LETTER O WITH DIAERESIS => CYRILLIC CAPITAL LETTER O WITH DIAERESIS int ( z '04E9' ), int ( z '04E8' ), & ! CYRILLIC SMALL LETTER BARRED O => CYRILLIC CAPITAL LETTER BARRED O int ( z '04EB' ), int ( z '04EA' ), & ! CYRILLIC SMALL LETTER BARRED O WITH DIAERESIS => CYRILLIC CAPITAL LETTER BARRED O WITH DIAERESIS int ( z '04EF' ), int ( z '04EE' ), & ! CYRILLIC SMALL LETTER U WITH MACRON => CYRILLIC CAPITAL LETTER U WITH MACRON int ( z '04F1' ), int ( z '04F0' ), & ! CYRILLIC SMALL LETTER U WITH DIAERESIS => CYRILLIC CAPITAL LETTER U WITH DIAERESIS int ( z '04F3' ), int ( z '04F2' ), & ! CYRILLIC SMALL LETTER U WITH DOUBLE ACUTE => CYRILLIC CAPITAL LETTER U WITH DOUBLE ACUTE int ( z '04F5' ), int ( z '04F4' ), & ! CYRILLIC SMALL LETTER CHE AITH DIAERESIS => CYRILLIC CAPITAL LETTER CHE WITH DIAERESIS int ( z '04F9' ), int ( z '04F8' ), & ! CYRILLIC SMALL LETTER YERU WITH DIAERESIS => CYRILLIC CAPITAL LETTER YERU WITH DIAERESIS int ( z '0561' ), int ( z '0531' ), & ! ARMENIAN SMALL LETTER AYB => ARMENIAN CAPITAL LETTER AYB int ( z '0562' ), int ( z '0532' ), & ! ARMENIAN SMALL LETTER BEN => ARMENIAN CAPITAL LETTER BEN int ( z '0563' ), int ( z '0533' ), & ! ARMENIAN SMALL LETTER GIM => ARMENIAN CAPITAL LETTER GIM int ( z '0564' ), int ( z '0534' ), & ! ARMENIAN SMALL LETTER DA => ARMENIAN CAPITAL LETTER DA int ( z '0565' ), int ( z '0535' ), & ! ARMENIAN SMALL LETTER ECH => ARMENIAN CAPITAL LETTER ECH int ( z '0566' ), int ( z '0536' ), & ! ARMENIAN SMALL LETTER ZA => ARMENIAN CAPITAL LETTER ZA int ( z '0567' ), int ( z '0537' ), & ! ARMENIAN SMALL LETTER EH => ARMENIAN CAPITAL LETTER EH int ( z '0568' ), int ( z '0538' ), & ! ARMENIAN SMALL LETTER ET => ARMENIAN CAPITAL LETTER ET int ( z '0569' ), int ( z '0539' ), & ! ARMENIAN SMALL LETTER TO => ARMENIAN CAPITAL LETTER TO int ( z '056A' ), int ( z '053A' ), & ! ARMENIAN SMALL LETTER ZHE => ARMENIAN CAPITAL LETTER ZHE int ( z '056B' ), int ( z '053B' ), & ! ARMENIAN SMALL LETTER INI => ARMENIAN CAPITAL LETTER INI int ( z '056C' ), int ( z '053C' ), & ! ARMENIAN SMALL LETTER LIWN => ARMENIAN CAPITAL LETTER LIWN int ( z '056D' ), int ( z '053D' ), & ! ARMENIAN SMALL LETTER XEH => ARMENIAN CAPITAL LETTER XEH int ( z '056E' ), int ( z '053E' ), & ! ARMENIAN SMALL LETTER CA => ARMENIAN CAPITAL LETTER CA int ( z '056F' ), int ( z '053F' ), & ! ARMENIAN SMALL LETTER KEN => ARMENIAN CAPITAL LETTER KEN int ( z '0570' ), int ( z '0540' ), & ! ARMENIAN SMALL LETTER HO => ARMENIAN CAPITAL LETTER HO int ( z '0571' ), int ( z '0541' ), & ! ARMENIAN SMALL LETTER JA => ARMENIAN CAPITAL LETTER JA int ( z '0572' ), int ( z '0542' ), & ! ARMENIAN SMALL LETTER GHAD => ARMENIAN CAPITAL LETTER GHAD int ( z '0573' ), int ( z '0543' ), & ! ARMENIAN SMALL LETTER CHEH => ARMENIAN CAPITAL LETTER CHEH int ( z '0574' ), int ( z '0544' ), & ! ARMENIAN SMALL LETTER MEN => ARMENIAN CAPITAL LETTER MEN int ( z '0575' ), int ( z '0545' ), & ! ARMENIAN SMALL LETTER YI => ARMENIAN CAPITAL LETTER YI int ( z '0576' ), int ( z '0546' ), & ! ARMENIAN SMALL LETTER NOW => ARMENIAN CAPITAL LETTER NOW int ( z '0577' ), int ( z '0547' ), & ! ARMENIAN SMALL LETTER SNA => ARMENIAN CAPITAL LETTER SHA int ( z '0578' ), int ( z '0548' ), & ! ARMENIAN SMALL LETTER VO => ARMENIAN CAPITAL LETTER VO int ( z '0579' ), int ( z '0549' ), & ! ARMENIAN SMALL LETTER CHA => ARMENIAN CAPITAL LETTER CHA int ( z '057A' ), int ( z '054A' ), & ! ARMENIAN SMALL LETTER PEH => ARMENIAN CAPITAL LETTER PEH int ( z '057B' ), int ( z '054B' ), & ! ARMENIAN SMALL LETTER JHEH => ARMENIAN CAPITAL LETTER JHEH int ( z '057C' ), int ( z '054C' ), & ! ARMENIAN SMALL LETTER RA => ARMENIAN CAPITAL LETTER RA int ( z '057D' ), int ( z '054D' ), & ! ARMENIAN SMALL LETTER SEH => ARMENIAN CAPITAL LETTER SEH int ( z '057E' ), int ( z '054E' ), & ! ARMENIAN SMALL LETTER VEW => ARMENIAN CAPITAL LETTER VEW int ( z '057F' ), int ( z '054F' ), & ! ARMENIAN SMALL LETTER TIWN => ARMENIAN CAPITAL LETTER TIWN int ( z '0580' ), int ( z '0550' ), & ! ARMENIAN SMALL LETTER REH => ARMENIAN CAPITAL LETTER REH int ( z '0581' ), int ( z '0551' ), & ! ARMENIAN SMALL LETTER CO => ARMENIAN CAPITAL LETTER CO int ( z '0582' ), int ( z '0552' ), & ! ARMENIAN SMALL LETTER YIWN => ARMENIAN CAPITAL LETTER YIWN int ( z '0583' ), int ( z '0553' ), & ! ARMENIAN SMALL LETTER PIWP => ARMENIAN CAPITAL LETTER PIWR int ( z '0584' ), int ( z '0554' ), & ! ARMENIAN SMALL LETTER KEH => ARMENIAN CAPITAL LETTER KEH int ( z '0585' ), int ( z '0555' ), & ! ARMENIAN SMALL LETTER OH => ARMENIAN CAPITAL LETTER OH int ( z '0586' ), int ( z '0556' ), & ! ARMENIAN SMALL LETTER FEH => ARMENIAN CAPITAL LETTER FEH int ( z '10D0' ), int ( z '10A0' ), & ! GEORGIAN LETTER AN => GEORGIAN CAPITAL LETTER AN (KHUTSURI) int ( z '10D1' ), int ( z '10A1' ), & ! GEORGIAN LETTER BAN => GEORGIAN CAPITAL LETTER BAN (KHUTSURI) int ( z '10D2' ), int ( z '10A2' ), & ! GEORGIAN LETTER GAN => GEORGIAN CAPITAL LETTER GAN (KHUTSURI) int ( z '10D3' ), int ( z '10A3' ), & ! GEORGIAN LETTER DON => GEORGIAN CAPITAL LETTER DON (KHUTSURI) int ( z '10D4' ), int ( z '10A4' ), & ! GEORGIAN LETTER EN => GEORGIAN CAPITAL LETTER EN (KHUTSURI) int ( z '10D5' ), int ( z '10A5' ), & ! GEORGIAN LETTER VIN => GEORGIAN CAPITAL LETTER VIN (KHUTSURI) int ( z '10D6' ), int ( z '10A6' ), & ! GEORGIAN LETTER ZEN => GEORGIAN CAPITAL LETTER ZEN (KHUTSURI) int ( z '10D7' ), int ( z '10A7' ), & ! GEORGIAN LETTER TAN => GEORGIAN CAPITAL LETTER TAN (KHUTSURI) int ( z '10D8' ), int ( z '10A8' ), & ! GEORGIAN LETTER IN => GEORGIAN CAPITAL LETTER IN (KHUTSURI) int ( z '10D9' ), int ( z '10A9' ), & ! GEORGIAN LETTER KAN => GEORGIAN CAPITAL LETTER KAN (KHUTSURI) int ( z '10DA' ), int ( z '10AA' ), & ! GEORGIAN LETTER LAS => GEORGIAN CAPITAL LETTER LAS (KHUTSURI) int ( z '10DB' ), int ( z '10AB' ), & ! GEORGIAN LETTER MAN => GEORGIAN CAPITAL LETTER MAN (KHUTSURI) int ( z '10DC' ), int ( z '10AC' ), & ! GEORGIAN LETTER NAR => GEORGIAN CAPITAL LETTER NAR (KHUTSURI) int ( z '10DD' ), int ( z '10AD' ), & ! GEORGIAN LETTER ON => GEORGIAN CAPITAL LETTER ON (KHUTSURI) int ( z '10DE' ), int ( z '10AE' ), & ! GEORGIAN LETTER PAR => GEORGIAN CAPITAL LETTER PAR (KHUTSURI) int ( z '10DF' ), int ( z '10AF' ), & ! GEORGIAN LETTER ZHAR => GEORGIAN CAPITAL LETTER ZHAR (KHUTSURI) int ( z '10E0' ), int ( z '10B0' ), & ! GEORGIAN LETTER RAE => GEORGIAN CAPITAL LETTER RAE (KHUTSURI) int ( z '10E1' ), int ( z '10B1' ), & ! GEORGIAN LETTER SAN => GEORGIAN CAPITAL LETTER SAN (KHUTSURI) int ( z '10E2' ), int ( z '10B2' ), & ! GEORGIAN LETTER TAR => GEORGIAN CAPITAL LETTER TAR (KHUTSURI) int ( z '10E3' ), int ( z '10B3' ), & ! GEORGIAN LETTER UN => GEORGIAN CAPITAL LETTER UN (KHUTSURI) int ( z '10E4' ), int ( z '10B4' ), & ! GEORGIAN LETTER PHAR => GEORGIAN CAPITAL LETTER PHAR (KHUTSURI) int ( z '10E5' ), int ( z '10B5' ), & ! GEORGIAN LETTER KHAR => GEORGIAN CAPITAL LETTER KHAR (KHUTSURI) int ( z '10E6' ), int ( z '10B6' ), & ! GEORGIAN LETTER GHAN => GEORGIAN CAPITAL LETTER GHAN (KHUTSURI) int ( z '10E7' ), int ( z '10B7' ), & ! GEORGIAN LETTER QAR => GEORGIAN CAPITAL LETTER QAR (KHUTSURI) int ( z '10E8' ), int ( z '10B8' ), & ! GEORGIAN LETTER SHIN => GEORGIAN CAPITAL LETTER SHIN (KHUTSURI) int ( z '10E9' ), int ( z '10B9' ), & ! GEORGIAN LETTER CHIN => GEORGIAN CAPITAL LETTER CHIN (KHUTSURI) int ( z '10EA' ), int ( z '10BA' ), & ! GEORGIAN LETTER CAN => GEORGIAN CAPITAL LETTER CAN (KHUTSURI) int ( z '10EB' ), int ( z '10BB' ), & ! GEORGIAN LETTER JIL => GEORGIAN CAPITAL LETTER JIL (KHUTSURI) int ( z '10EC' ), int ( z '10BC' ), & ! GEORGIAN LETTER CIL => GEORGIAN CAPITAL LETTER CIL (KHUTSURI) int ( z '10ED' ), int ( z '10BD' ), & ! GEORGIAN LETTER CHAR => GEORGIAN CAPITAL LETTER CHAR (KHUTSURI) int ( z '10EE' ), int ( z '10BE' ), & ! GEORGIAN LETTER XAN => GEORGIAN CAPITAL LETTER XAN (KHUTSURI) int ( z '10EF' ), int ( z '10BF' ), & ! GEORGIAN LETTER JHAN => GEORGIAN CAPITAL LETTER JHAN (KHUTSURI) int ( z '10F0' ), int ( z '10C0' ), & ! GEORGIAN LETTER HAE => GEORGIAN CAPITAL LETTER HAE (KHUTSURI) int ( z '10F1' ), int ( z '10C1' ), & ! GEORGIAN LETTER HE => GEORGIAN CAPITAL LETTER HE (KHUTSURI) int ( z '10F2' ), int ( z '10C2' ), & ! GEORGIAN LETTER HIE => GEORGIAN CAPITAL LETTER HIE (KHUTSURI) int ( z '10F3' ), int ( z '10C3' ), & ! GEORGIAN LETTER WE => GEORGIAN CAPITAL LETTER WE (KHUTSURI) int ( z '10F4' ), int ( z '10C4' ), & ! GEORGIAN LETTER HAR => GEORGIAN CAPITAL LETTER HAR (KHUTSURI) int ( z '10F5' ), int ( z '10C5' ), & ! GEORGIAN LETTER HOE => GEORGIAN CAPITAL LETTER HOE (KHUTSURI) int ( z '1E01' ), int ( z '1E00' ), & ! LATIN SMALL LETTER A WITH RING BELOW => LATIN CAPITAL LETTER A WITH RING BELOW int ( z '1E03' ), int ( z '1E02' ), & ! LATIN SMALL LETTER B WITH DOT ABOVE => LATIN CAPITAL LETTER B WITH DOT ABOVE int ( z '1E05' ), int ( z '1E04' ), & ! LATIN SMALL LETTER B WITH DOT BELOW => LATIN CAPITAL LETTER B WITH DOT BELOW int ( z '1E07' ), int ( z '1E06' ), & ! LATIN SMALL LETTER B WITH LINE BELOW => LATIN CAPITAL LETTER B WITH LINE BELOW int ( z '1E09' ), int ( z '1E08' ), & ! LATIN SMALL LETTER C WITH CEDILLA AND ACUTE => LATIN CAPITAL LETTER C WITH CEDILLA AND ACUTE int ( z '1E0B' ), int ( z '1E0A' ), & ! LATIN SMALL LETTER D WITH DOT ABOVE => LATIN CAPITAL LETTER D WITH DOT ABOVE int ( z '1E0D' ), int ( z '1E0C' ), & ! LATIN SMALL LETTER D WITH DOT BELOW => LATIN CAPITAL LETTER D WITH DOT BELOW int ( z '1E0F' ), int ( z '1E0E' ), & ! LATIN SMALL LETTER D WITH LINE BELOW => LATIN CAPITAL LETTER D WITH LINE BELOW int ( z '1E11' ), int ( z '1E10' ), & ! LATIN SMALL LETTER D WITH CEDILLA => LATIN CAPITAL LETTER D WITH CEDILLA int ( z '1E13' ), int ( z '1E12' ), & ! LATIN SMALL LETTER D WITH CIRCUMFLEX BELOW => LATIN CAPITAL LETTER D WITH CIRCUMFLEX BELOW int ( z '1E15' ), int ( z '1E14' ), & ! LATIN SMALL LETTER E WITH MACRON AND GRAVE => LATIN CAPITAL LETTER E WITH MACRON AND GRAVE int ( z '1E17' ), int ( z '1E16' ), & ! LATIN SMALL LETTER E WITH MACRON AND ACUTE => LATIN CAPITAL LETTER E WITH MACRON AND ACUTE int ( z '1E19' ), int ( z '1E18' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX BELOW => LATIN CAPITAL LETTER E WITH CIRCUMFLEX BELOW int ( z '1E1B' ), int ( z '1E1A' ), & ! LATIN SMALL LETTER E WITH TILDE BELOW => LATIN CAPITAL LETTER E WITH TILDE BELOW int ( z '1E1D' ), int ( z '1E1C' ), & ! LATIN SMALL LETTER E WITH CEDILLA AND BREVE => LATIN CAPITAL LETTER E WITH CEDILLA AND BREVE int ( z '1E1F' ), int ( z '1E1E' ), & ! LATIN SMALL LETTER F WITH DOT ABOVE => LATIN CAPITAL LETTER F WITH DOT ABOVE int ( z '1E21' ), int ( z '1E20' ), & ! LATIN SMALL LETTER G WITH MACRON => LATIN CAPITAL LETTER G WITH MACRON int ( z '1E23' ), int ( z '1E22' ), & ! LATIN SMALL LETTER H WITH DOT ABOVE => LATIN CAPITAL LETTER H WITH DOT ABOVE int ( z '1E25' ), int ( z '1E24' ), & ! LATIN SMALL LETTER H WITH DOT BELOW => LATIN CAPITAL LETTER H WITH DOT BELOW int ( z '1E27' ), int ( z '1E26' ), & ! LATIN SMALL LETTER H WITH DIAERESIS => LATIN CAPITAL LETTER H WITH DIAERESIS int ( z '1E29' ), int ( z '1E28' ), & ! LATIN SMALL LETTER H WITH CEDILLA => LATIN CAPITAL LETTER H WITH CEDILLA int ( z '1E2B' ), int ( z '1E2A' ), & ! LATIN SMALL LETTER H WITH BREVE BELOW => LATIN CAPITAL LETTER H WITH BREVE BELOW int ( z '1E2D' ), int ( z '1E2C' ), & ! LATIN SMALL LETTER I WITH TILDE BELOW => LATIN CAPITAL LETTER I WITH TILDE BELOW int ( z '1E2F' ), int ( z '1E2E' ), & ! LATIN SMALL LETTER I WITH DIAERESIS AND ACUTE => LATIN CAPITAL LETTER I WITH DIAERESIS AND ACUTE int ( z '1E31' ), int ( z '1E30' ), & ! LATIN SMALL LETTER K WITH ACUTE => LATIN CAPITAL LETTER K WITH ACUTE int ( z '1E33' ), int ( z '1E32' ), & ! LATIN SMALL LETTER K WITH DOT BELOW => LATIN CAPITAL LETTER K WITH DOT BELOW int ( z '1E35' ), int ( z '1E34' ), & ! LATIN SMALL LETTER K WITH LINE BELOW => LATIN CAPITAL LETTER K WITH LINE BELOW int ( z '1E37' ), int ( z '1E36' ), & ! LATIN SMALL LETTER L WITH DOT BELOW => LATIN CAPITAL LETTER L WITH DOT BELOW int ( z '1E39' ), int ( z '1E38' ), & ! LATIN SMALL LETTER L WITH DOT BELOW AND MACRON => LATIN CAPITAL LETTER L WITH DOT BELOW AND MACRON int ( z '1E3B' ), int ( z '1E3A' ), & ! LATIN SMALL LETTER L WITH LINE BELOW => LATIN CAPITAL LETTER L WITH LINE BELOW int ( z '1E3D' ), int ( z '1E3C' ), & ! LATIN SMALL LETTER L WITH CIRCUMFLEX BELOW => LATIN CAPITAL LETTER L WITH CIRCUMFLEX BELOW int ( z '1E3F' ), int ( z '1E3E' ), & ! LATIN SMALL LETTER M WITH ACUTE => LATIN CAPITAL LETTER M WITH ACUTE int ( z '1E41' ), int ( z '1E40' ), & ! LATIN SMALL LETTER M WITH DOT ABOVE => LATIN CAPITAL LETTER M WITH DOT ABOVE int ( z '1E43' ), int ( z '1E42' ), & ! LATIN SMALL LETTER M WITH DOT BELOW => LATIN CAPITAL LETTER M WITH DOT BELOW int ( z '1E45' ), int ( z '1E44' ), & ! LATIN SMALL LETTER N WITH DOT ABOVE => LATIN CAPITAL LETTER N WITH DOT ABOVE int ( z '1E47' ), int ( z '1E46' ), & ! LATIN SMALL LETTER N WITH DOT BELOW => LATIN CAPITAL LETTER N WITH DOT BELOW int ( z '1E49' ), int ( z '1E48' ), & ! LATIN SMALL LETTER N WITH LINE BELOW => LATIN CAPITAL LETTER N WITH LINE BELOW int ( z '1E4B' ), int ( z '1E4A' ), & ! LATIN SMALL LETTER N WITH CIRCUMFLEX BELOW => LATIN CAPITAL LETTER N WITH CIRCUMFLEX BELOW int ( z '1E4D' ), int ( z '1E4C' ), & ! LATIN SMALL LETTER O WITH TILDE AND ACUTE => LATIN CAPITAL LETTER O WITH TILDE AND ACUTE int ( z '1E4F' ), int ( z '1E4E' ), & ! LATIN SMALL LETTER O WITH TlLDE AND DIAERESIS => LATIN CAPITAL LETTER O WITH TILDE AND DIAERESIS int ( z '1E51' ), int ( z '1E50' ), & ! LATIN SMALL LETTER O WITH MACRON AND GRAVE => LATIN CAPITAL LETTER O WITH MACRON AND GRAVE int ( z '1E53' ), int ( z '1E52' ), & ! LATIN SMALL LETTER O WITH MACRON AND ACUTE => LATIN CAPITAL LETTER O WITH MACRON AND ACUTE int ( z '1E55' ), int ( z '1E54' ), & ! LATIN SMALL LETTER P WITH ACUTE => LATIN CAPITAL LETTER P WITH ACUTE int ( z '1E57' ), int ( z '1E56' ), & ! LATIN SMALL LETTER P WITH DOT ABOVE => LATIN CAPITAL LETTER P WITH DOT ABOVE int ( z '1E59' ), int ( z '1E58' ), & ! LATIN SMALL LETTER R WITH DOT ABOVE => LATIN CAPITAL LETTER R WITH DOT ABOVE int ( z '1E5B' ), int ( z '1E5A' ), & ! LATIN SMALL LETTER R WITH DOT BELOW => LATIN CAPITAL LETTER R WITH DOT BELOW int ( z '1E5D' ), int ( z '1E5C' ), & ! LATIN SMALL LETTER R WITH DOT BELOW AND MACRON => LATIN CAPITAL LETTER R WITH DOT BELOW AND MACRON int ( z '1E5F' ), int ( z '1E5E' ), & ! LATIN SMALL LETTER R WITH LINE BELOW => LATIN CAPITAL LETTER R WITH LINE BELOW int ( z '1E61' ), int ( z '1E60' ), & ! LATIN SMALL LETTER S WITH DOT ABOVE => LATIN CAPITAL LETTER S WITH DOT ABOVE int ( z '1E63' ), int ( z '1E62' ), & ! LATIN SMALL LETTER S WITH DOT BELOW => LATIN CAPITAL LETTER S WITH DOT BELOW int ( z '1E65' ), int ( z '1E64' ), & ! LATIN SMALL LETTER S WITH ACUTE AND DOT ABOVE => LATIN CAPITAL LETTER S WITH ACUTE AND DOT ABOVE int ( z '1E67' ), int ( z '1E66' ), & ! LATIN SMALL LETTER S WITH CARON AND DOT ABOVE => LATIN CAPITAL LETTER S WITH CARON AND DOT ABOVE int ( z '1E69' ), int ( z '1E68' ), & ! LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE => LATIN CAPITAL LETTER S WITH DOT BELOW AND DOT ABOVE int ( z '1E6B' ), int ( z '1E6A' ), & ! LATIN SMALL LETTER T WITH DOT ABOVE => LATIN CAPITAL LETTER T WITH DOT ABOVE int ( z '1E6D' ), int ( z '1E6C' ), & ! LATIN SMALL LETTER T WITH DOT BELOW => LATIN CAPITAL LETTER T WITH DOT BELOW int ( z '1E6F' ), int ( z '1E6E' ), & ! LATIN SMALL LETTER T WITH LINE BELOW => LATIN CAPITAL LETTER T WITH LINE BELOW int ( z '1E71' ), int ( z '1E70' ), & ! LATIN SMALL LETTER T WITH CIRCUMFLEX BELOW => LATIN CAPITAL LETTER T WITH CIRCUMFLEX BELOW int ( z '1E73' ), int ( z '1E72' ), & ! LATIN SMALL LETTER U WITH DIAERESIS BELOW => LATIN CAPITAL LETTER U WITH DIAERESIS BELOW int ( z '1E75' ), int ( z '1E74' ), & ! LATIN SMALL LETTER U WITH TILDE BELOW => LATIN CAPITAL LETTER U WITH TILDE BELOW int ( z '1E77' ), int ( z '1E76' ), & ! LATIN SMALL LETTER U WITH CIRCUMFLEX BELOW => LATIN CAPITAL LETTER U WITH CIRCUMFLEX BELOW int ( z '1E79' ), int ( z '1E78' ), & ! LATIN SMALL LETTER U WITH TILDE AND ACUTE => LATIN CAPITAL LETTER U WITH TILDE AND ACUTE int ( z '1E7B' ), int ( z '1E7A' ), & ! LATIN SMALL LETTER U WITH MACRON AND DIAERESIS => LATIN CAPITAL LETTER U WITH MACRON AND DIAERESIS int ( z '1E7D' ), int ( z '1E7C' ), & ! LATIN SMALL LETTER V WITH TILDE => LATIN CAPITAL LETTER V WITH TILDE int ( z '1E7F' ), int ( z '1E7E' ), & ! LATIN SMALL LETTER V WITH DOT BELOW => LATIN CAPITAL LETTER V WITH DOT BELOW int ( z '1E81' ), int ( z '1E80' ), & ! LATIN SMALL LETTER W WITH GRAVE => LATIN CAPITAL LETTER W WITH GRAVE int ( z '1E83' ), int ( z '1E82' ), & ! LATIN SMALL LETTER W WITH ACUTE => LATIN CAPITAL LETTER W WITH ACUTE int ( z '1E85' ), int ( z '1E84' ), & ! LATIN SMALL LETTER W WITH DIAERESIS => LATIN CAPITAL LETTER W WITH DIAERESIS int ( z '1E87' ), int ( z '1E86' ), & ! LATIN SMALL LETTER W WITH DOT ABOVE => LATIN CAPITAL LETTER W WITH DOT ABOVE int ( z '1E89' ), int ( z '1E88' ), & ! LATIN SMALL LETTER W WITH DOT BELOW => LATIN CAPITAL LETTER W WITH DOT BELOW int ( z '1E8B' ), int ( z '1E8A' ), & ! LATIN SMALL LETTER X WITH DOT ABOVE => LATIN CAPITAL LETTER X WITH DOT ABOVE int ( z '1E8D' ), int ( z '1E8C' ), & ! LATIN SMALL LETTER X WITH DIAERESIS => LATIN CAPITAL LETTER X5 WITH DIAERESIS int ( z '1E8F' ), int ( z '1E8E' ), & ! LATIN SMALL LETTER Y WITH DOT ABOVE => LATIN CAPITAL LETTER Y WITH DOT ABOVE int ( z '1E91' ), int ( z '1E90' ), & ! LATIN SMALL LETTER Z WITH CIRCUMFLEX => LATIN CAPITAL LETTER Z WITH CIRCUMFLEX int ( z '1E93' ), int ( z '1E92' ), & ! LATIN SMALL LETTER Z WITH DOT BELOW => LATIN CAPITAL LETTER Z WITH DOT BELOW int ( z '1E95' ), int ( z '1E94' ), & ! LATIN SMALL LETTER Z WITH LINE BELOW => LATIN CAPITAL LETTER Z WITH LINE BELOW int ( z '1EA1' ), int ( z '1EA0' ), & ! LATIN SMALL LETTER A WITH DOT BELOW => LATIN CAPITAL LETTER A WITH DOT BELOW int ( z '1EA3' ), int ( z '1EA2' ), & ! LATIN SMALL LETTER A WITH HOOK ABOVE => LATIN CAPITAL LETTER A WITH HOOK ABOVE int ( z '1EA5' ), int ( z '1EA4' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE => LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE int ( z '1EA7' ), int ( z '1EA6' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND GRAVE => LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND GRAVE int ( z '1EA9' ), int ( z '1EA8' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE => LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE int ( z '1EAB' ), int ( z '1EAA' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND TILDE => LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND TILDE int ( z '1EAD' ), int ( z '1EAC' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND DOT BELOW => LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND DOT BELOW int ( z '1EAF' ), int ( z '1EAE' ), & ! LATIN SMALL LETTER A WITH BREVE AND ACUTE => LATIN CAPITAL LETTER A WITH BREVE AND ACUTE int ( z '1EB1' ), int ( z '1EB0' ), & ! LATIN SMALL LETTER A WITH BREVE AND GRAVE => LATIN CAPITAL LETTER A WITH BREVE AND GRAVE int ( z '1EB3' ), int ( z '1EB2' ), & ! LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE => LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE int ( z '1EB5' ), int ( z '1EB4' ), & ! LATIN SMALL LETTER A WITH BREVE AND TILDE => LATIN CAPITAL LETTER A WITH BREVE AND TILDE int ( z '1EB7' ), int ( z '1EB6' ), & ! LATIN SMALL LETTER A WITH BREVE AND DOT BELOW => LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW int ( z '1EB9' ), int ( z '1EB8' ), & ! LATIN SMALL LETTER E WITH DOT BELOW => LATIN CAPITAL LETTER E WITH DOT BELOW int ( z '1EBB' ), int ( z '1EBA' ), & ! LATIN SMALL LETTER E WITH HOOK ABOVE => LATIN CAPITAL LETTER E WITH HOOK ABOVE int ( z '1EBD' ), int ( z '1EBC' ), & ! LATIN SMALL LETTER E WITH TILDE => LATIN CAPITAL LETTER E WITH TILDE int ( z '1EBF' ), int ( z '1EBE' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE => LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE int ( z '1EC1' ), int ( z '1EC0' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND GRAVE => LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE int ( z '1EC3' ), int ( z '1EC2' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE => LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE int ( z '1EC5' ), int ( z '1EC4' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND TILDE => LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND TILDE int ( z '1EC7' ), int ( z '1EC6' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW => LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND DOT BELOW int ( z '1EC9' ), int ( z '1EC8' ), & ! LATIN SMALL LETTER I WITH HOOK ABOVE => LATIN CAPITAL LETTER I WITH HOOK ABOVE int ( z '1ECB' ), int ( z '1ECA' ), & ! LATIN SMALL LETTER I WITH DOT BELOW => LATIN CAPITAL LETTER I WITH DOT BELOW int ( z '1ECD' ), int ( z '1ECC' ), & ! LATIN SMALL LETTER O WITH DOT BELOW => LATIN CAPITAL LETTER O WITH DOT BELOW int ( z '1ECF' ), int ( z '1ECE' ), & ! LATIN SMALL LETTER O WITH HOOK ABOVE => LATIN CAPITAL LETTER O WITH HOOK ABOVE int ( z '1ED1' ), int ( z '1ED0' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE => LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE int ( z '1ED3' ), int ( z '1ED2' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND GRAVE => LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND GRAVE int ( z '1ED5' ), int ( z '1ED4' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE => LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE int ( z '1ED7' ), int ( z '1ED6' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND TILDE => LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND TILDE int ( z '1ED9' ), int ( z '1ED8' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW => LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND DOT BELOW int ( z '1EDB' ), int ( z '1EDA' ), & ! LATIN SMALL LETTER O WITH HORN AND ACUTE => LATIN CAPITAL LETTER O WITH HORN AND ACUTE int ( z '1EDD' ), int ( z '1EDC' ), & ! LATIN SMALL LETTER O WITH HORN AND GRAVE => LATIN CAPITAL LETTER O WITH HORN AND GRAVE int ( z '1EDF' ), int ( z '1EDE' ), & ! LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE => LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE int ( z '1EE1' ), int ( z '1EE0' ), & ! LATIN SMALL LETTER O WITH HORN AND TILDE => LATIN CAPITAL LETTER O WITH HORN AND TILDE int ( z '1EE3' ), int ( z '1EE2' ), & ! LATIN SMALL LETTER O WITH HORN AND DOT BELOW => LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW int ( z '1EE5' ), int ( z '1EE4' ), & ! LATIN SMALL LETTER U WITH DOT BELOW => LATIN CAPITAL LETTER U WITH DOT BELOW int ( z '1EE7' ), int ( z '1EE6' ), & ! LATIN SMALL LETTER U WITH HOOK ABOVE => LATIN CAPITAL LETTER U WITH HOOK ABOVE int ( z '1EE9' ), int ( z '1EE8' ), & ! LATIN SMALL LETTER U WITH HORN AND ACUTE => LATIN CAPITAL LETTER U WITH HORN AND ACUTE int ( z '1EEB' ), int ( z '1EEA' ), & ! LATIN SMALL LETTER U WITH HORN AND GRAVE => LATIN CAPITAL LETTER U WITH HORN AND GRAVE int ( z '1EED' ), int ( z '1EEC' ), & ! LATIN SMALL LETTER U WITH HORN AND HOCK ABOVE => LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE int ( z '1EEF' ), int ( z '1EEE' ), & ! LATIN SMALL LETTER U WITH HORN AND TILDE => LATIN CAPITAL LETTER U WITH HORN AND TILDE int ( z '1EF1' ), int ( z '1EF0' ), & ! LATIN SMALL LETTER U WITH HORN AND DOT BELOW => LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW int ( z '1EF3' ), int ( z '1EF2' ), & ! LATIN SMALL LETTER Y WITH GRAVE => LATIN CAPITAL LETTER Y WITH GRAVE int ( z '1EF5' ), int ( z '1EF4' ), & ! LATIN SMALL LETTER Y WITH DOT BELOW => LATIN CAPITAL LETTER Y WITH DOT BELOW int ( z '1EF7' ), int ( z '1EF6' ), & ! LATIN SMALL LETTER Y WITH HOOK ABOVE => LATIN CAPITAL LETTER Y WITH HOOK ABOVE int ( z '1EF9' ), int ( z '1EF8' ), & ! LATIN SMALL LETTER Y WITH TILDE => LATIN CAPITAL LETTER Y WITH TILDE int ( z '1F00' ), int ( z '1F08' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI => GREEK CAPITAL LETTER ALPHA WITH PSILI int ( z '1F01' ), int ( z '1F09' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA => GREEK CAPITAL LETTER ALPHA WITH DASIA int ( z '1F02' ), int ( z '1F0A' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA => GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA int ( z '1F03' ), int ( z '1F0B' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA => GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA int ( z '1F04' ), int ( z '1F0C' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA => GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA int ( z '1F05' ), int ( z '1F0D' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA => GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA int ( z '1F06' ), int ( z '1F0E' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI => GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI int ( z '1F07' ), int ( z '1F0F' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI => GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI int ( z '1F10' ), int ( z '1F18' ), & ! GREEK SMALL LETTER EPSILON WITH PSILI => GREEK CAPITAL LETTER EPSILON WITH PSILI int ( z '1F11' ), int ( z '1F19' ), & ! GREEK SMALL LETTER EPSILON WITH DASIA => GREEK CAPITAL LETTER EPSILON WITH DASIA int ( z '1F12' ), int ( z '1F1A' ), & ! GREEK SMALL LETTER EPSILON WITH PSILI AND VARIA => GREEK CAPITAL LETTER EPSILON WITH PSILI AND VARIA int ( z '1F13' ), int ( z '1F1B' ), & ! GREEK SMALL LETTER EPSILON WITH DASIA AND VARIA => GREEK CAPITAL LETTER EPSILON WITH DASIA AND VARIA int ( z '1F14' ), int ( z '1F1C' ), & ! GREEK SMALL LETTER EPSILON WITH PSILI AND OXIA => GREEK CAPITAL LETTER EPSILON WITH PSILI AND OXIA int ( z '1F15' ), int ( z '1F1D' ), & ! GREEK SMALL LETTER EPSILON WITH DASIA AND OXIA => GREEK CAPITAL LETTER EPSILON WITH DASIA AND OXIA int ( z '1F20' ), int ( z '1F28' ), & ! GREEK SMALL LETTER ETA WITH PSILI => GREEK CAPITAL LETTER ETA WITH PSILI int ( z '1F21' ), int ( z '1F29' ), & ! GREEK SMALL LETTER ETA WITH DASIA => GREEK CAPITAL LETTER ETA WITH DASIA int ( z '1F22' ), int ( z '1F2A' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND VARIA => GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA int ( z '1F23' ), int ( z '1F2B' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND VARIA => GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA int ( z '1F24' ), int ( z '1F2C' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND OXIA => GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA int ( z '1F25' ), int ( z '1F2D' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND OXIA => GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA int ( z '1F26' ), int ( z '1F2E' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI => GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI int ( z '1F27' ), int ( z '1F2F' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI => GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI int ( z '1F30' ), int ( z '1F38' ), & ! GREEK SMALL LETTER IOTA WITH PSILI => GREEK CAPITAL LETTER IOTA WITH PSILI int ( z '1F31' ), int ( z '1F39' ), & ! GREEK SMALL LETTER IOTA WITH DASIA => GREEK CAPITAL LETTER IOTA WITH DASIA int ( z '1F32' ), int ( z '1F3A' ), & ! GREEK SMALL LETTER IOTA WITH PSILI AND VARIA => GREEK CAPITAL LETTER IOTA WITH PSILI AND VARIA int ( z '1F33' ), int ( z '1F3B' ), & ! GREEK SMALL LETTER IOTA WITH DASIA AND VARIA => GREEK CAPITAL LETTER IOTA WITH DASIA AND VARIA int ( z '1F34' ), int ( z '1F3C' ), & ! GREEK SMALL LETTER IOTA WITH PSILI AND OXIA => GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA int ( z '1F35' ), int ( z '1F3D' ), & ! GREEK SMALL LETTER IOTA WITH DASIA AND OXIA => GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA int ( z '1F36' ), int ( z '1F3E' ), & ! GREEK SMALL LETTER IOTA WITH PSILI AND PERISPOMENI => GREEK CAPITAL LETTER IOTA WITH PSILI AND PERISPOMENI int ( z '1F37' ), int ( z '1F3F' ), & ! GREEK SMALL LETTER IOTA WITH DASIA AND PERISPOMENI => GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI int ( z '1F40' ), int ( z '1F48' ), & ! GREEK SMALL LETTER OMICRON WITH PSILI => GREEK CAPITAL LETTER OMICRON WITH PSILI int ( z '1F41' ), int ( z '1F49' ), & ! GREEK SMALL LETTER OMICRON WITH DASIA => GREEK CAPITAL LETTER OMICRON WITH DASIA int ( z '1F42' ), int ( z '1F4A' ), & ! GREEK SMALL LETTER OMICRON WITH PSILI AND VARIA => GREEK CAPITAL LETTER OMICRON WITH PSILI AND VARIA int ( z '1F43' ), int ( z '1F4B' ), & ! GREEK SMALL LETTER OMICRON WITH DASIA AND VARIA => GREEK CAPITAL LETTER OMICRON WITH DASIA AND VARIA int ( z '1F44' ), int ( z '1F4C' ), & ! GREEK SMALL LETTER OMICRON WITH PSILI AND OXIA => GREEK CAPITAL LETTER OMICRON WITH PSILI AND OXIA int ( z '1F45' ), int ( z '1F4D' ), & ! GREEK SMALL LETTER OMICRON WITH DASIA AND OXIA => GREEK CAPITAL LETTER OMICRON WITH DASIA AND OXIA int ( z '1F51' ), int ( z '1F59' ), & ! GREEK SMALL LETTER UPSILON WITH DASIA => GREEK CAPITAL LETTER UPSILON WITH OASIS int ( z '1F53' ), int ( z '1F5B' ), & ! GREEK SMALL LETTER UPSILON WITH DASIA AND VARIA => GREEK CAPITAL LETTER UPSILON WITH DASIA AND VARIA int ( z '1F55' ), int ( z '1F5D' ), & ! GREEK SMALL LETTER UPSILON WITH DASIA AND OXIA => GREEK CAPITAL LETTER UPSILON WITH DASIA AND OXIA int ( z '1F57' ), int ( z '1F5F' ), & ! GREEK SMALL LETTER UPSILON WITH DASIA AND PERISPOMENI => GREEK CAPITAL LETTER UPSILON WITH DASIA AND PERISPOMENI int ( z '1F60' ), int ( z '1F68' ), & ! GREEK SMALL LETTER OMEGA WITh PSILI => GREEK CAPITAL LETTER OMEGA WITH PSILI int ( z '1F61' ), int ( z '1F69' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA => GREEK CAPITAL LETTER OMEGA WITH DASIA int ( z '1F62' ), int ( z '1F6A' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA => GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA int ( z '1F63' ), int ( z '1F6B' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA => GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA int ( z '1F64' ), int ( z '1F6C' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA => GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA int ( z '1F65' ), int ( z '1F6D' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA => GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA int ( z '1F66' ), int ( z '1F6E' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI => GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI int ( z '1F67' ), int ( z '1F6F' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI => GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI int ( z '1F80' ), int ( z '1F88' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITh PSILI AND PROSGEGRAMMENI int ( z '1F81' ), int ( z '1F89' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH DASIA AND PROSGEGRAMMENI int ( z '1F82' ), int ( z '1F8A' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI int ( z '1F83' ), int ( z '1F8B' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI int ( z '1F84' ), int ( z '1F8C' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMEN int ( z '1F85' ), int ( z '1F8D' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMEN int ( z '1F86' ), int ( z '1F8E' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1F87' ), int ( z '1F8F' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1F90' ), int ( z '1F98' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH PSILI AND PROSGEGRAMMENI int ( z '1F91' ), int ( z '1F99' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH DASIA AND PROSGEGRAMMENI int ( z '1F92' ), int ( z '1F9A' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI int ( z '1F93' ), int ( z '1F9B' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI int ( z '1F94' ), int ( z '1F9C' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI int ( z '1F95' ), int ( z '1F9D' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI int ( z '1F96' ), int ( z '1F9E' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1F97' ), int ( z '1F9F' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1FA0' ), int ( z '1FA8' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH PSILI AND PROSGEGRAMMENI int ( z '1FA1' ), int ( z '1FA9' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH DASIA AND PROSGEGRAMMENI int ( z '1FA2' ), int ( z '1FAA' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI int ( z '1FA3' ), int ( z '1FAB' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI int ( z '1FA4' ), int ( z '1FAC' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI int ( z '1FA5' ), int ( z '1FAD' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI int ( z '1FA6' ), int ( z '1FAE' ), & ! GREEK SMALL LETTER OMEGA WITh PSILI AND PERISPOMENI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1FA7' ), int ( z '1FAF' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND PEPISPOMENI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMECA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1FB0' ), int ( z '1FB8' ), & ! GREEK SMALL LETTER ALPHA WITH VRACHY => GREEK CAPITAL LETTER ALPHA WITH VRACHY int ( z '1FB1' ), int ( z '1FB9' ), & ! GREEK SMALL LETTER ALPHA WITH MACRON => GREEK CAPITAL LETTER ALPHA WITH MACRON int ( z '1FD0' ), int ( z '1FD8' ), & ! GREEK SMALL LETTER IOTA WITH VRACHY => GREEK CAPITAL LETTER IOTA WITH VRACHY int ( z '1FD1' ), int ( z '1FD9' ), & ! GREEK SMALL LETTER IOTA WITH MACRON => GREEK CAPITAL LETTER IOTA WITH MACRON int ( z '1FE0' ), int ( z '1FE8' ), & ! GREEK SMALL LETTER UPSILON WITH VRACHY => GREEK CAPITAL LETTER UPSILON WITH VRACHY int ( z '1FE1' ), int ( z '1FE9' ), & ! GREEK SMALL LETTER UPSILON WITH MACRON => GREEK CAPITAL LETTER UPSILON WITH MACRON int ( z '24D0' ), int ( z '24B6' ), & ! CIRCLED LATIN SMALL LETTER A => CIRCLED LATIN CAPITAL LETTER A int ( z '24D1' ), int ( z '24B7' ), & ! CIRCLED LATIN SMALL LETTER B => CIRCLED LATIN CAPITAL LETTER B int ( z '24D2' ), int ( z '24B8' ), & ! CIRCLED LATIN SMALL LETTER C => CIRCLED LATIN CAPITAL LETTER C int ( z '24D3' ), int ( z '24B9' ), & ! CIRCLED LATIN SMALL LETTER D => CIRCLED LATIN CAPITAL LETTER D int ( z '24D4' ), int ( z '24BA' ), & ! CIRCLED LATIN SMALL LETTER E => CIRCLED LATIN CAPITAL LETTER E int ( z '24D5' ), int ( z '24BB' ), & ! CIRCLED LATIN SMALL LETTER F => CIRCLED LATIN CAPITAL LETTER F int ( z '24D6' ), int ( z '24BC' ), & ! CIRCLED LATIN SMALL LETTER G => CIRCLED LATIN CAPITAL LETTER G int ( z '24D7' ), int ( z '24BD' ), & ! CIRCLED LATIN SMALL LETTER H => CIRCLED LATIN CAPITAL LETTER H int ( z '24D8' ), int ( z '24BE' ), & ! CIRCLED LATIN SMALL LETTER I => CIRCLED LATIN CAPITAL LETTER I int ( z '24D9' ), int ( z '24BF' ), & ! CIRCLED LATIN SMALL LETTER J => CIRCLED LATIN CAPITAL LETTER J int ( z '24DA' ), int ( z '24C0' ), & ! CIRCLED LATIN SMALL LETTER K => CIRCLED LATIN CAPITAL LETTER K int ( z '24DB' ), int ( z '24C1' ), & ! CIRCLED LATIN SMALL LETTER L => CIRCLED LATIN CAPITAL LETTER L int ( z '24DC' ), int ( z '24C2' ), & ! CIRCLED LATIN SMALL LETTER M => CIRCLED LATIN CAPITAL LETTER M int ( z '24DD' ), int ( z '24C3' ), & ! CIRCLED LATIN SMALL LETTER N => CIRCLED LATIN CAPITAL LETTER N int ( z '24DE' ), int ( z '24C4' ), & ! CIRCLED LATIN SMALL LETTER O => CIRCLED LATIN CAPITAL LETTER O int ( z '24DF' ), int ( z '24C5' ), & ! CIRCLED LATIN SMALL LETTER P => CIRCLED LATIN CAPITAL LETTER P int ( z '24E0' ), int ( z '24C6' ), & ! CIRCLED LATIN SMALL LETTER Q => CIRCLED LATIN CAPITAL LETTER Q int ( z '24E1' ), int ( z '24C7' ), & ! CIRCLED LATIN SMALL LETTER R => CIRCLED LATIN CAPITAL LETTER R int ( z '24E2' ), int ( z '24C8' ), & ! CIRCLED LATIN SMALL LETTER S => CIRCLED LATIN CAPITAL LETTER S int ( z '24E3' ), int ( z '24C9' ), & ! CIRCLED LATIN SMALL LETTER T => CIRCLED LATIN CAPITAL LETTER T int ( z '24E4' ), int ( z '24CA' ), & ! CIRCLED LATIN SMALL LETTER U => CIRCLED LATIN CAPITAL LETTER U int ( z '24E5' ), int ( z '24CB' ), & ! CIRCLED LATIN SMALL LETTER V => CIRCLED LATIN CAPITAL LETTER V int ( z '24E6' ), int ( z '24CC' ), & ! CIRCLED LATIN SMALL LETTER W => CIRCLED LATIN CAPITAL LETTER W int ( z '24E7' ), int ( z '24CD' ), & ! CIRCLED LATIN SMALL LETTER X => CIRCLED LATIN CAPITAL LETTER X int ( z '24E8' ), int ( z '24CE' ), & ! CIRCLED LATIN SMALL LETTER Y => CIRCLED LATIN CAPITAL LETTER Y int ( z '24E9' ), int ( z '24CF' ), & ! CIRCLED LATIN SMALL LETTER Z => CIRCLED LATIN CAPITAL LETTER Z int ( z 'FF41' ), int ( z 'FF21' ), & ! FULLWIDTH LATIN SMALL LETTER A => FULLWIDTH LATIN CAPITAL LETTER A int ( z 'FF42' ), int ( z 'FF22' ), & ! FULLWIDTH LATIN SMALL LETTER B => FULLWIDTH LATIN CAPITAL LETTER B int ( z 'FF43' ), int ( z 'FF23' ), & ! FULLWIDTH LATIN SMALL LETTER C => FULLWIDTH LATIN CAPITAL LETTER C int ( z 'FF44' ), int ( z 'FF24' ), & ! FULLWIDTH LATIN SMALL LETTER D => FULLWIDTH LATIN CAPITAL LETTER D int ( z 'FF45' ), int ( z 'FF25' ), & ! FULLWIDTH LATIN SMALL LETTER E => FULLWIDTH LATIN CAPITAL LETTER E int ( z 'FF46' ), int ( z 'FF26' ), & ! FULLWIDTH LATIN SMALL LETTER F => FULLWIDTH LATIN CAPITAL LETTER F int ( z 'FF47' ), int ( z 'FF27' ), & ! FULLWIDTH LATIN SMALL LETTER G => FULLWIDTH LATIN CAPITAL LETTER G int ( z 'FF48' ), int ( z 'FF28' ), & ! FULLWIDTH LATIN SMALL LETTER H => FULLWIDTH LATIN CAPITAL LETTER H int ( z 'FF49' ), int ( z 'FF29' ), & ! FULLWIDTH LATIN SMALL LETTER I => FULLWIDTH LATIN CAPITAL LETTER I int ( z 'FF4A' ), int ( z 'FF2A' ), & ! FULLWIDTH LATIN SMALL LETTER J => FULLWIDTH LATIN CAPITAL LETTER J int ( z 'FF4B' ), int ( z 'FF2B' ), & ! FULLWIDTH LATIN SMALL LETTER K => FULLWIDTH LATIN CAPITAL LETTER K int ( z 'FF4C' ), int ( z 'FF2C' ), & ! FULLWIDTH LATIN SMALL LETTER L => FULLWIDTH LATIN CAPITAL LETTER L int ( z 'FF4D' ), int ( z 'FF2D' ), & ! FULLWIDTH LATIN SMALL LETTER M => FULLWIDTH LATIN CAPITAL LETTER M int ( z 'FF4E' ), int ( z 'FF2E' ), & ! FULLWIDTH LATIN SMALL LETTER N => FULLWIDTH LATIN CAPITAL LETTER N int ( z 'FF4F' ), int ( z 'FF2F' ), & ! FULLWIDTH LATIN SMALL LETTER O => FULLWIDTH LATIN CAPITAL LETTER O int ( z 'FF50' ), int ( z 'FF30' ), & ! FULLWIDTH LATIN SMALL LETTER P => FULLWIDTH LATIN CAPITAL LETTER P int ( z 'FF51' ), int ( z 'FF31' ), & ! FULLWIDTH LATIN SMALL LETTER Q => FULLWIDTH LATIN CAPITAL LETTER Q int ( z 'FF52' ), int ( z 'FF32' ), & ! FULLWIDTH LATIN SMALL LETTER R => FULLWIDTH LATIN CAPITAL LETTER R int ( z 'FF53' ), int ( z 'FF33' ), & ! FULLWIDTH LATIN SMALL LETTER S => FULLWIDTH LATIN CAPITAL LETTER S int ( z 'FF54' ), int ( z 'FF34' ), & ! FULLWIDTH LATIN SMALL LETTER T => FULLWIDTH LATIN CAPITAL LETTER T int ( z 'FF55' ), int ( z 'FF35' ), & ! FULLWIDTH LATIN SMALL LETTER U => FULLWIDTH LATIN CAPITAL LETTER U int ( z 'FF56' ), int ( z 'FF36' ), & ! FULLWIDTH LATIN SMALL LETTER V => FULLWIDTH LATIN CAPITAL LETTER V int ( z 'FF57' ), int ( z 'FF37' ), & ! FULLWIDTH LATIN SMALL LETTER W => FULLWIDTH LATIN CAPITAL LETTER W int ( z 'FF58' ), int ( z 'FF38' ), & ! FULLWIDTH LATIN SMALL LETTER X => FULLWIDTH LATIN CAPITAL LETTER X int ( z 'FF59' ), int ( z 'FF39' ), & ! FULLWIDTH LATIN SMALL LETTER Y => FULLWIDTH LATIN CAPITAL LETTER Y int ( z 'FF5A' ), int ( z 'FF3A' )] & ! FULLWIDTH LATIN SMALL LETTER Z => FULLWIDTH LATIN CAPITAL LETTER Z , shape ( lowup ), order = [ 2 , 1 ]) type ( unicode_type ) :: low type ( unicode_type ) :: upp low = lowup (:, 1 ) upp = lowup (:, 2 ) write ( * , '(g0)' ) low % character () write ( * , '(g0)' ) character ( low % upper ()) write ( * , '(g0)' ) upp % character () write ( * , '(g0)' ) character ( upp % lower ()) end program testit","tags":"","url":"program/testit~2.html"},{"title":"checkform – M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial type( unicode_type ) :: chars character(len=*), parameter :: g = '(*(g0,1x))' character(len=*), parameter :: hex = 'abcdefABCDEF0123456789' character(len=*), parameter :: int = '1234567890' logical :: lout type( unicode_type ) :: str Source Code program checkform ! check if string is of form NN‐HHHHH use M_unicode , only : verify , unicode_type , assignment ( = ) use M_unicode , only : ut => unicode_type implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' character ( len =* ), parameter :: int = '1234567890' character ( len =* ), parameter :: hex = 'abcdefABCDEF0123456789' logical :: lout type ( unicode_type ) :: chars type ( unicode_type ) :: str chars = '32‐af43d' lout = . true . ! are the first two characters integer characters? str = chars % character ( 1 , 2 ) lout = ( verify ( str , ut ( int ) ) == 0 ) . and . lout ! is the third character a dash? str = chars % character ( 3 , 3 ) lout = ( verify ( str , ut ( '‐-' ) ) == 0 ) . and . lout ! is remaining string a valid representation of a hex value? str = chars % character ( 4 , 8 ) lout = ( verify ( str , ut ( hex ) ) == 0 ) . and . lout if ( lout ) then write ( * , g ) trim ( chars % character ()), ' passed' else write ( * , g ) trim ( chars % character ()), ' failed' endif end program checkform","tags":"","url":"program/checkform.html"},{"title":"count_glyphs – M_unicode","text":"Uses M_unicode iso_fortran_env Variables Type Attributes Name Initial character(len=1024) :: aline character(len=*), parameter :: g = '(*(g0))' character(len=255) :: iomsg integer :: iostat integer :: length type( unicode_type ) :: uline Source Code program count_glyphs ! @(#) read a utf-8 file and write it out with lines prefixed with glyph count of the line use , intrinsic :: iso_fortran_env , only : output_unit , input_unit use M_unicode implicit none intrinsic is_iostat_end character ( len =* ), parameter :: g = '(*(g0))' integer :: length integer :: iostat character ( len = 1024 ) :: aline type ( unicode_type ) :: uline character ( len = 255 ) :: iomsg do read ( input_unit , '(a)' , iostat = iostat , iomsg = iomsg ) aline if ( iostat . eq . 0 ) then uline = trim ( aline ) length = len_trim ( uline ) write ( output_unit , '(i9,\": \",a)' ) length , uline % character ( 1 , length ) elseif ( is_iostat_end ( iostat )) then exit else write ( output_unit , g ) '<ERROR>' , trim ( iomsg ) exit endif enddo end program count_glyphs","tags":"","url":"program/count_glyphs.html"},{"title":"demo_lower – M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0))' type( unicode_type ) :: lower_pangram type( unicode_type ) :: pangram Source Code program demo_lower use M_unicode , only : lower , unicode_type , assignment ( = ) implicit none character ( len =* ), parameter :: g = '(*(g0))' type ( unicode_type ) :: pangram type ( unicode_type ) :: lower_pangram ! a sentence containing every letter of the English alphabet pangram = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\" write ( * , g ) pangram % character () lower_pangram = lower ( pangram ) write ( * , g ) lower_pangram % character () end program demo_lower","tags":"","url":"program/demo_lower.html"},{"title":"demo_tokenize – M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial integer, allocatable, dimension(:) :: begins type( unicode_type ) :: delims integer, allocatable, dimension(:) :: ends character(len=*), parameter :: g0 = '(*(g0))' character(len=*), parameter :: g1 = '(*(g0,1x))' type( unicode_type ) :: herbs integer :: i type( unicode_type ), allocatable :: separators (:) type( unicode_type ), allocatable :: tokens (:) Source Code program demo_tokenize use M_unicode , only : assignment ( = ), unicode_type , tokenize , len , character character ( len =* ), parameter :: g0 = '(*(g0))' character ( len =* ), parameter :: g1 = '(*(g0,1x))' type ( unicode_type ), allocatable :: tokens (:) type ( unicode_type ), allocatable :: separators (:) type ( unicode_type ) :: delims type ( unicode_type ) :: herbs integer , allocatable , dimension (:) :: begins integer , allocatable , dimension (:) :: ends integer :: i delims = ',&' herbs = 'parsley,sage,rosemary,&thyme' write ( * , * ) herbs % character () write ( * , g0 ) write ( * , g0 ) 'expecting' write ( * , g0 ) ' tokens    =[parsley][sage][rosemary][][thyme]' write ( * , g0 ) ' separators=,,,&' CALL TOKENIZE ( herbs , delims , tokens , separators ) write ( * , g0 ) 'got' write ( * , g0 ) \" tokens    =\" ,( '[' // tokens ( i )% character (), ']' , i = 1 , size ( tokens )) write ( * , g0 ) \" separators=\" ,( separators ( i )% character (), i = 1 , size ( separators )) write ( * , g0 ) write ( * , g0 ) 'expecting' write ( * , * ) 'begins=' ,[ 1 , 9 , 14 , 23 , 24 ] write ( * , * ) 'ends=  ' ,[ 7 , 12 , 21 , 22 , 28 ] CALL TOKENIZE ( herbs , delims , begins , ends ) write ( * , g0 ) 'got' write ( * , * ) 'begins=' , begins write ( * , * ) 'ends=  ' , ends write ( * , g0 ) write ( * , g0 ) 'OOP' tokens = herbs % tokenize ( delims ) write ( * , g0 ) \" tokens    =\" ,( '[' // tokens ( i )% character (), ']' , i = 1 , size ( tokens )) herbs = 'parsley/sage/rosemary//thyme' delims = '/' tokens = herbs % tokenize ( delims ) write ( * , g0 ) \" tokens    =\" ,( '[' // tokens ( i )% character (), ']' , i = 1 , size ( tokens )) herbs = 'parsley😃sage😃rosemary😃😃thyme' delims = '😃' write ( * , g0 ) ' ' , delims % character () write ( * , g1 ) ' ' , delims % codepoint () tokens = herbs % tokenize ( delims ) write ( * , g0 ) \" tokens    =\" ,( '[' // tokens ( i )% character (), ']' , i = 1 , size ( tokens )) end program demo_tokenize","tags":"","url":"program/demo_tokenize.html"},{"title":"uni_to_ftn – M_unicode","text":"Uses iso_fortran_env Variables Type Attributes Name Initial character(len=:), allocatable :: command_line character(len=*), parameter :: form = '(\"char(int(z''\",z0,\"''))\":,\"// &\")' character(len=*), parameter :: g = '(*(g0))' integer :: i Functions function getargs () result(command_line) Arguments None Return Value character(len=:), allocatable Source Code program uni_to_ftn ! @(#) take command line argument utf-8 text and generate Fortran statement that represents the string use , intrinsic :: iso_fortran_env , only : output_unit implicit none character ( len =* ), parameter :: form = '(\"char(int(z''\",z0,\"''))\":,\"// &\")' character ( len =* ), parameter :: g = '(*(g0))' integer :: i character ( len = :), allocatable :: command_line command_line = getargs () ! get string containing all command arguments as CHARACTER bytes ! write the command line out as a Fortran variable expression using the CHAR() function open ( output_unit , encoding = 'UTF-8' ) write ( * , g ) '! ENCODING:[' , command_line // ']' write ( * , g ) 'character(len=*),parameter :: variable= &' write ( * , form )( command_line ( i : i ), i = 1 , len ( command_line )) contains function getargs () result ( command_line ) integer :: length character ( len = :), allocatable :: command_line call get_command ( length = length ) ! get command line length allocate ( character ( len = length ) :: command_line ) ! allocate string big enough to hold command line call get_command ( command = command_line ) ! get command line as a string call get_command_argument ( 0 , length = length ) ! remove argument 0 command_line = command_line ( length + 2 :) end function getargs end program uni_to_ftn","tags":"","url":"program/uni_to_ftn.html"},{"title":"test_for_iso_10646 – M_unicode","text":"Uses M_unicode iso_fortran_env Variables Type Attributes Name Initial type( unicode_type ) :: smiley Source Code program test_for_iso_10646 use M_unicode use iso_fortran_env , only : output_unit implicit none type ( unicode_type ) :: smiley smiley = [ int ( z '1F603' )] open ( output_unit , encoding = 'utf-8' ) write ( * , * ) 'Smiling face with open mouth' , smiley % character () ! 😃 end program test_for_iso_10646","tags":"","url":"program/test_for_iso_10646.html"},{"title":"multi_line – M_unicode","text":"Uses M_unicode iso_fortran_env Variables Type Attributes Name Initial integer :: i integer :: longest type( unicode_type ), allocatable :: upagain (:) Source Code program multi_line use iso_fortran_env , only : output_unit use M_unicode use M_unicode , only : ut => unicode_type implicit none integer :: i , longest type ( ut ), allocatable :: upagain (:) upagain = [ & ! ROMANIZATION                         ! ENGLISH ut ( \"七転び八起き。\" ), & ! Nanakorobi yaoki.                    ! Fall seven times, stand up eight. ut ( \"転んでもまた立ち上がる。\" ), & ! Koronde mo mata tachiagaru.          ! Even if you fall down, you will get up again. ut ( \"くじけずに前を向いて歩いていこう。\" )] ! Kujikezu ni mae o muite aruite ikou. ! Don't be discouraged, just keep walking forward. ! open ( output_unit , encoding = 'UTF-8' ) longest = 0 ! get longest trimmed line do i = 1 , size ( upagain ) longest = max ( longest , len_trim ( upagain ( i ))) write ( * , * ) 'LEN=' , len_trim ( upagain ( i )) enddo write ( output_unit , * ) 'longest=' , longest write ( output_unit , * ) do i = 1 , size ( upagain ) write ( output_unit , '(g0)' ) character ( upagain ( i )), len_trim ( upagain ( i )) enddo end program multi_line","tags":"","url":"program/multi_line.html"},{"title":"test_M_unicode – M_unicode","text":"Uses M_unicode iso_fortran_env Variables Type Attributes Name Initial logical, parameter :: F = .false. logical, parameter :: T = .true. character(len=:), allocatable :: astr character(len=*), parameter :: g0 = '(*(g0))' integer :: i type( unicode_type ) :: lhs type( unicode_type ) :: rhs type( unicode_type ) :: smiley type( unicode_type ) :: string type( unicode_type ) :: substring integer :: total character(len=*), parameter :: upagain = \"七転び八起き。転んでもまた立ち上がる。くじけずに前を向いて歩いていこう。\" type( unicode_type ) :: ut_str Subroutines subroutine check (label, test) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label logical, intent(in) :: test subroutine checkit (label, aline, answer, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label character(len=*), intent(in) :: aline character(len=*), intent(in) :: answer character(len=*), intent(in) :: expected subroutine checkits (label, aline, answer, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label character(len=*), intent(in) :: aline character(len=*), intent(in) :: answer (:) character(len=*), intent(in) :: expected (:) subroutine checkits_l (label, aline, answer, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label character(len=*), intent(in) :: aline logical, intent(in) :: answer (:) logical, intent(in) :: expected (:) Source Code program test_M_unicode use iso_fortran_env , only : output_unit use M_unicode , only : adjustl , adjustr , index use M_unicode , only : trim , len , len_trim use M_unicode , only : character use M_unicode , only : assignment ( = ), unicode_type , operator ( // ) use M_unicode , only : operator ( <= ), lle use M_unicode , only : operator ( < ), llt use M_unicode , only : operator ( /= ), lne use M_unicode , only : operator ( == ), leq use M_unicode , only : operator ( > ), lgt use M_unicode , only : operator ( >= ), lge use M_unicode , only : utf8_to_codepoints , codepoints_to_utf8 use M_unicode , only : scan , verify use M_unicode , only : split , tokenize use M_unicode , only : repeat use M_unicode , only : upper , lower use M_unicode , only : sort implicit none character ( len =* ), parameter :: g0 = '(*(g0))' logical , parameter :: T = . true . logical , parameter :: F = . false . ! character ( len =* ), parameter :: upagain = \"七転び八起き。転んでもまた立ち上がる。くじけずに前を向いて歩いていこう。\" ! Romanization: ! Nanakorobi yaoki. Koronde mo mata tachiagaru. Kujikezu ni mae o muite aruite ikou. ! or English translation ! \"Fall seven times, stand up eight. Even if you fall down, you will get up again. Don't be discouraged, just keep walking forward.\" ! character ( len = :), allocatable :: astr type ( unicode_type ) :: ut_str type ( unicode_type ) :: smiley integer :: total integer :: i type ( unicode_type ) :: lhs , rhs type ( unicode_type ) :: string , substring smiley = '😃' total = 0 write ( * , g0 ) 'encoding can be altered on an open file' open ( output_unit , encoding = 'UTF-8' ) write ( * , g0 ) astr = 'Hello World and Ni Hao -- 你好' ut_str = astr call checkits ( 'convert to ASCII bytes' , astr , ut_str % bytes (), transfer ( 'Hello World and Ni Hao -- 你好' ,[ 'A' ])) astr = \"  this is a string    \" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), 'this is a string      ' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '      this is a string' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '  this is a string' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 18 ) call check ( 'len_trim' , len_trim ( ut_str ). eq . 18 ) call check ( 'len' , ut_str % len (). eq . 22 ) call check ( 'len' , len ( ut_str ). eq . 22 ) astr = \"  \" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), '  ' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '  ' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 0 ) call check ( 'len' , ut_str % len (). eq . 2 ) astr = \"\" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), '' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 0 ) call check ( 'len' , ut_str % len (). eq . 0 ) astr = \"ALLFULL\" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), 'ALLFULL' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), 'ALLFULL' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), 'ALLFULL' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 7 ) call check ( 'len' , ut_str % len (). eq . 7 ) ut_str = [ 32 , 32 , int ( z '1F603' ), 32 , 32 , 32 ] astr = character ( ut_str ) call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), '😃     ' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '     😃' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '  😃' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 3 ) call check ( 'len' , ut_str % len (). eq . 6 ) if ( total . ne . 0 ) then write ( * , g0 ) total , 'failures' stop 1 endif ut_str = smiley // ' and ' // smiley // 'and' // smiley // smiley // 'is it' astr = '😃 and 😃and😃😃is it' call checkit ( 'concatenation' , astr , character ( ut_str ), '😃 and 😃and😃😃is it' ) lhs = 'this is the left' rhs = 'this is the right' call checkits_l ( 'LLE' , ' ' , [ lle ( lhs , rhs ), lhs <= rhs , lle ( rhs , lhs ), rhs <= lhs ] , [ T , T , F , F ] ) call checkits_l ( 'LLT' , ' ' , [ llt ( lhs , rhs ), lhs < rhs , llt ( rhs , lhs ), rhs < lhs ] , [ T , T , F , F ] ) call checkits_l ( 'LNE' , ' ' , [ lne ( lhs , rhs ), lhs /= rhs , lne ( rhs , lhs ), rhs /= lhs ] , [ T , T , T , T ] ) call checkits_l ( 'LEQ' , ' ' , [ leq ( lhs , rhs ), lhs == rhs , leq ( rhs , lhs ), rhs == lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LGT' , ' ' , [ lgt ( lhs , rhs ), lhs > rhs , lgt ( rhs , lhs ), rhs > lhs ] , [ F , F , T , T ] ) call checkits_l ( 'LGE' , ' ' , [ lge ( lhs , rhs ), lhs >= rhs , lge ( rhs , lhs ), rhs >= lhs ] , [ F , F , T , T ] ) lhs = 'abc' rhs = 'abc ' call checkits_l ( 'LLE' , ' ' , [ lle ( lhs , rhs ), lhs <= rhs , lle ( rhs , lhs ), rhs <= lhs ] , [ T , T , T , T ] ) call checkits_l ( 'LLT' , ' ' , [ llt ( lhs , rhs ), lhs < rhs , llt ( rhs , lhs ), rhs < lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LNE' , ' ' , [ lne ( lhs , rhs ), lhs /= rhs , lne ( rhs , lhs ), rhs /= lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LEQ' , ' ' , [ leq ( lhs , rhs ), lhs == rhs , leq ( rhs , lhs ), rhs == lhs ] , [ T , T , T , T ] ) call checkits_l ( 'LGT' , ' ' , [ lgt ( lhs , rhs ), lhs > rhs , lgt ( rhs , lhs ), rhs > lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LGE' , ' ' , [ lge ( lhs , rhs ), lhs >= rhs , lge ( rhs , lhs ), rhs >= lhs ] , [ T , T , T , T ] ) string = \" can you find me here? \" substring = \"find me\" astr = character ( substring ) call check ( 'index ' // string % character () // ':' // substring % character (), index ( string , substring ). eq . 10 ) call check ( 'index ' // string % character () // ':' // astr , index ( string , astr ). eq . 10 ) string = \" can you find me here? \" substring = \"not there\" astr = character ( substring ) call check ( 'index ' // string % character () // ':' // substring % character (), index ( string , substring ). eq . 0 ) call check ( 'index ' // string % character () // ':' // astr , index ( string , astr ). eq . 0 ) string = \"short\" substring = \"shortnot\" astr = character ( substring ) call check ( 'index ' // string % character () // ':' // substring % character (), index ( string , substring ). eq . 0 ) call check ( 'index ' // string % character () // ':' // astr , index ( string , astr ). eq . 0 ) string = upagain write ( * , g0 ) 'original bytes  :' , upagain write ( * , g0 ) 'bytes reversed  :' , ( upagain ( i : i ), i = len ( upagain ), 1 , - 1 ) write ( * , g0 ) 'original string :' , string % character () write ( * , g0 ) 'string reversed :' , string % character ( string % len (), 1 , - 1 ) contains subroutine checkit ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline character ( len =* ), intent ( in ) :: answer character ( len =* ), intent ( in ) :: expected write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , answer . eq . expected ), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( answer . ne . expected ) total = total + 1 end subroutine checkit subroutine checkits ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline character ( len =* ), intent ( in ) :: answer (:) character ( len =* ), intent ( in ) :: expected (:) write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , all ( answer . eq . expected )), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( all ( answer . ne . expected )) total = total + 1 end subroutine checkits subroutine checkits_l ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline logical , intent ( in ) :: answer (:) logical , intent ( in ) :: expected (:) write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , all ( answer . eqv . expected )), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( all ( answer . neqv . expected )) total = total + 1 end subroutine checkits_l subroutine check ( label , test ) character ( len =* ), intent ( in ) :: label logical , intent ( in ) :: test write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , test ), ' ' , label if (. not . test ) total = total + 1 end subroutine check end program test_M_unicode","tags":"","url":"program/test_m_unicode.html"},{"title":"bom_exe – M_unicode","text":"Uses M_unicode iso_fortran_env Variables Type Attributes Name Initial type( unicode_type ) :: U_BOM Source Code program bom_exe ! ! create a Fortran source file starting with a utf-8 BOM to see if your ! compiler will compile it or fail because a character is not in the ! Fortran character set outside of a comment or literal string ! use iso_fortran_env , only : stdout => output_unit use M_unicode implicit none type ( unicode_type ) :: U_BOM U_bom = [ int ( z 'FEFF' )] write ( stdout , '(a)' , advance = 'no' ) U_bom % character () write ( stdout , '(a)' ) & 'program testit ! Unicode BOM encoded to utf-8 bytes by Fortran' ,& '   write(*,*)\"File starts with BOM from UCS-4 write!\"' ,& 'end program testit' end program bom_exe","tags":"","url":"program/bom_exe.html"},{"title":"demo_scan – M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0,1x))' type( unicode_type ) :: line type( unicode_type ) :: set Source Code program demo_scan use M_unicode , only : scan , unicode_type , assignment ( = ) use M_unicode , only : ut => unicode_type implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' type ( ut ) :: line type ( ut ) :: set line = 'parsley😃sage😃rosemary😃😃thyme' set = '😃' write ( * , g ) '123456789012345678901234567890123456789012345678901234567890' write ( * , g ) line % character () write ( * , g ) scan ( line , set ) write ( * , g ) scan ( line , set , back = . true .) write ( * , g ) scan ( line , set , back = . false .) write ( * , g ) scan ( line , unicode_type ( \"NOT\" )) write ( * , g ) 'OOP' write ( * , g ) line % scan ( set ) write ( * , g ) line % scan ( ut ( \"o\" )) end program demo_scan","tags":"","url":"program/demo_scan.html"},{"title":"demo_sort – M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0))' integer :: i integer :: ii (isz) integer, parameter :: isz = 4 type( unicode_type ) :: rr (isz) Source Code program demo_sort use M_unicode , only : sort , unicode_type , assignment ( = ) use M_unicode , only : ut => unicode_type implicit none character ( len =* ), parameter :: g = '(*(g0))' integer , parameter :: isz = 4 type ( unicode_type ) :: rr ( isz ) integer :: ii ( isz ) integer :: i write ( * , g ) 'sort array with sort(3f)' rr = [ & ut ( \"the\" ), & ut ( \"quick\" ), & ut ( \"brown\" ), & ut ( \"fox\" ) ] call sort ( rr , ii ) write ( * , g ) 'original order' do i = 1 , size ( rr ) write ( * , g ) rr ( i )% character () enddo write ( * , g ) 'sorted order' do i = 1 , size ( rr ) write ( * , g ) rr ( ii ( i ))% character () enddo end program demo_sort","tags":"","url":"program/demo_sort.html"},{"title":"testit – M_unicode","text":"Uses M_unicode iso_fortran_env Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0))' type( unicode_type ) :: ustr Source Code program testit use iso_fortran_env , only : stdout => output_unit ! user-defined type to hold Unicode text use M_unicode , only : unicode_type ! convert unicode_type to CHARACTER variables use M_unicode , only : character ! intrinsic overloads use M_unicode , only : adjustl , adjustr use M_unicode , only : trim , len , len_trim use M_unicode , only : index , scan , verify use M_unicode , only : split , tokenize use M_unicode , only : repeat use M_unicode , only : upper , lower use M_unicode , only : sort ! operators (and overloads) and assignment use M_unicode , only : assignment ( = ) use M_unicode , only : operator ( <= ), lle use M_unicode , only : operator ( < ), llt use M_unicode , only : operator ( /= ), lne use M_unicode , only : operator ( == ), leq use M_unicode , only : operator ( > ), lgt use M_unicode , only : operator ( >= ), lge use M_unicode , only : operator ( // ) ! low-level text conversion to integer codepoint arrays: use M_unicode , only : utf8_to_codepoints , codepoints_to_utf8 implicit none type ( unicode_type ) :: ustr character ( len =* ), parameter :: g = '(*(g0))' !open (stdout, encoding='UTF-8') ! preferred, but not required if not supported ! Constructors ! UNICODE_VARIABLE= UNICODE_VARIABLE|CHARACTER(LEN=*)|INTEGER_ARRAY ! VARiABLE%CHARACTER(start,end,step) returns a CHARACTER string ! VARiABLE%BYTES() returns an array of CHARACTER(len=1) values ustr = 'Hello World and Ni Hao -- 你好  ' write ( stdout , g ) character ( ustr ) ! convert to intrinsic CHARACTER variable write ( stdout , g ) len ( ustr ) write ( stdout , g ) len_trim ( ustr ) write ( stdout , g ) ustr % character ( 27 , 28 ) ! similiar to LINE(27:28) write ( stdout , g ) index ( ustr , '你' ) ! OOPS write ( stdout , g ) ustr % character ( len ( ustr ), 1 , - 1 ) ! reverse string write ( stdout , g ) ustr % codepoint () ! Unicode codepoint values end program testit","tags":"","url":"program/testit~3.html"},{"title":"crow_and_fox – M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial integer :: i type(unicode_type), allocatable :: poem (:) Source Code program crow_and_fox use M_unicode , only : unicode_type , ut => unicode_type , character , len ! “The Crow and the Fox” by Jean de la Fontaine type ( unicode_type ), allocatable :: poem (:) integer :: i poem = [& ut ( 'Maître Corbeau, sur un arbre perché,' ), & ut ( 'Tenait en son bec un fromage.' ), & ut ( 'Maître Renard, par l’odeur alléché,' ), & ut ( 'Lui tint à peu près ce langage :' ), & ut ( '«Hé ! bonjour, Monsieur du Corbeau.' ), & ut ( 'Que vous êtes joli ! que vous me semblez beau !' ), & ut ( 'Sans mentir, si votre ramage' ), & ut ( 'Se rapporte à votre plumage,' ), & ut ( 'Vous êtes le Phénix des hôtes de ces bois.»' ), & ut ( 'A ces mots le Corbeau ne se sent pas de joie ;' ), & ut ( 'Et pour montrer sa belle voix,' ), & ut ( 'Il ouvre un large bec, laisse tomber sa proie.' ), & ut ( 'Le Renard s’en saisit, et dit : «Mon bon Monsieur,' ), & ut ( 'Apprenez que tout flatteur' ), & ut ( 'Vit aux dépens de celui qui l’écoute :' ), & ut ( 'Cette leçon vaut bien un fromage, sans doute.»' ), & ut ( 'Le Corbeau, honteux et confus,' ), & ut ( 'Jura, mais un peu tard, qu’on ne l’y prendrait plus.' ), & ut ( ' -- Jean de la Fontaine' )] write ( * , '(g0)' )( character ( poem ( i )), i = 1 , size ( poem )) write ( * , '(a)' ) write ( * , '(*(a))' )( poem ( i )% codepoint (), new_line ( 'a' ), i = 1 , size ( poem )) write ( * , '(a)' ) write ( * , '(*(g0))' )( character ( poem ( i )), len ( poem ( i )), ' ' , len ( poem ( i )% character ()), new_line ( 'a' ), i = 1 , size ( poem )) end program crow_and_fox","tags":"","url":"program/crow_and_fox.html"},{"title":"uplow_utf8.f90 – M_unicode","text":"Source Code program testit use M_unicode type ( unicode_type ) :: upp , low ! ! remember unicode characters are multi-byte so be careful ! with older compilers to not exceed 132 bytes per line ! low = '& &abcdefghijklmnopqrstuvwxyzàáâãäåæçèéêëì& &íîïðñòóôõöøùúûüýþÿāăąćĉċčďđēĕėęěĝğġģĥħĩīĭ& &įıĳĵķĺļľŀłńņňŋōŏőœŕŗřśŝşšţťŧũūŭůűųŵŷźżž& &ƃƅƈƌƒƙơƣƥƨƭưƴƶƹƽǆǉǌǎǐǒǔǖǘǚǜǟǡǣǥǧǩǫǭǯǳǵǻǽǿ& &ȁȃȅȇȉȋȍȏȑȓȕȗɓɔɗɘəɛɠɣɨɩɯɲɵʃʈʊʋʒάέήί& &αβγδεζηθικλμνξοπρστυφχψωϊϋόύώϣϥϧϩϫϭϯабвгдежзий& &клмнопрстуфхцчшщъыьэюяёђѓєѕіїјљњћќўџ& &ѡѣѥѧѩѫѭѯѱѳѵѷѹѻѽѿҁґғҕҗҙқҝҟҡңҥҧҩҫҭүұҳҵҷҹһҽҿӂӄӈ& &ӌӑӓӕӗәӛӝӟӡӣӥӧөӫӯӱӳӵӹաբգդեզէըթժիլխծկհձղ& &ճմյնշոչպջռսվտրցւփքօֆაბგდევზთიკლმნოპჟრსტუფქ& &ღყშჩცძწჭხჯჰჱჲჳჴჵḁḃḅḇḉḋḍḏḑḓḕḗḙḛḝḟḡḣḥḧ& &ḩḫḭḯḱḳḵḷḹḻḽḿṁṃṅṇṉṋṍṏṑṓṕṗṙ& &ṛṝṟṡṣṥṧṩṫṭṯṱṳṵṷṹṻṽṿ& &ẁẃẅẇẉẋẍẏẑẓẕạảấầẩẫậắằẳẵặẹẻẽếềểễệỉịọỏốồổỗ& &ộớờởỡợụủứừửữựỳỵỷỹἀἁἂἃἄἅἆἇἐἑἒἓἔἕἠἡἢἣἤἥἦἧἰἱ& &ἲἳἴἵἶἷὀὁὂὃὄὅὑὓὕὗὠὡὢὣὤὥὦὧᾀᾁᾂᾃᾄᾅᾆᾇᾐᾑᾒᾓᾔᾕᾖᾗ& &ᾠᾡᾢᾣᾤᾥᾦᾧᾰᾱῐῑῠῡⓐⓑⓒⓓⓔⓕⓖⓗⓘⓙⓚⓛⓜⓝⓞⓟⓠⓡⓢⓣⓤⓥⓦⓧⓨⓩ& &ａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚ' upp = '& &ABCDEFGHIJKLMNOPQRSTUVWXYZÀÁÂÃÄÅÆÇÈÉÊË& &ÌÍÎÏÐÑÒÓÔÕÖØÙÚÛÜÝÞŸĀĂĄĆĈĊČĎĐĒĔĖĘĚĜĞĠĢĤĦĨĪĬ& &ĮIĲĴĶĹĻĽĿŁŃŅŇŊŌŎŐŒŔŖŘŚŜŞŠŢŤŦŨŪŬŮŰŲŴŶŹŻ& &ŽƂƄƇƋƑƘƠƢƤƧƬƯƳƵƸƼǄǇǊǍǏǑǓǕǗǙǛǞǠǢǤǦǨǪǬǮǱǴǺǼǾ& &ȀȂȄȆȈȊȌȎȐȒȔȖƁƆƊƎƏƐƓƔƗƖƜƝƟƩƮƱƲƷΆΈΉΊΑΒΓΔΕΖΗΘ& &ΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩΪΫΌΎΏϢϤϦϨϪϬϮАБВГДЕЖЗИЙ& &КЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯЁЂЃЄЅІЇЈЉЊЋЌЎЏѠѢѤѦѨѪѬ& &ѮѰѲѴѶѸѺѼѾҀҐҒҔҖҘҚҜҞҠҢҤҦҨҪҬҮҰҲҴҶҸҺҼҾӁӃӇ& &ӋӐӒӔӖӘӚӜӞӠӢӤӦӨӪӮӰӲӴӸԱԲԳԴԵԶԷԸԹԺԻԼԽԾԿՀՁՂՃՄ& &ՅՆՇՈՉՊՋՌՍՎՏՐՑՒՓՔՕՖႠႡႢႣႤႥႦႧႨႩႪႫႬႭႮႯႰႱႲႳႴႵ& &ႶႷႸႹႺႻႼႽႾႿჀჁჂჃჄჅḀḂḄḆḈḊḌḎḐḒḔḖḘḚḜḞḠḢḤḦḨḪḬḮ& &ḰḲḴḶḸḺḼḾṀṂṄṆṈṊṌṎṐṒṔṖṘṚṜṞṠṢṤṦṨṪṬṮṰṲṴṶṸṺṼṾ& &ẀẂẄẆẈẊẌẎẐẒẔẠẢẤẦẨẪẬẮẰẲẴẶẸẺẼẾỀỂỄỆỈỊ& &ỌỎỐỒỔỖỘỚỜỞỠỢỤỦỨỪỬỮỰỲỴỶỸ& &ἈἉἊἋἌἍἎἏἘἙἚἛἜἝἨἩἪἫἬἭἮἯἸἹ& &ἺἻἼἽἾἿὈὉὊὋὌὍὙὛὝὟὨὩὪὫὬὭὮὯ& &ᾈᾉᾊᾋᾌᾍᾎᾏᾘᾙᾚᾛᾜᾝᾞᾟᾨᾩᾪᾫᾬᾭᾮᾯᾸᾹ& &ῘῙῨῩⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ& &ＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺ' write ( * , '(g0)' ) low % character () write ( * , '(g0)' ) character ( upper ( low )) write ( * , '(g0)' ) character ( upp ) write ( * , '(g0)' ) character ( upp % lower ()) end program testit","tags":"","url":"sourcefile/uplow_utf8.f90.html"},{"title":"demo_split.f90 – M_unicode","text":"Source Code program demo_split use M_unicode , only : split , unicode_type , assignment ( = ), len , character use M_unicode , only : ut => unicode_type implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' type ( ut ) :: proverb type ( ut ) :: delims type ( ut ), allocatable :: array (:) integer :: first integer :: last integer :: pos integer :: i delims = '=|; ' proverb = \"Más vale pájaro en mano, que ciento volando.\" call printwords ( proverb ) ! there really are not spaces between these glyphs array = [ & ut ( \"七転び八起き。\" ), & ut ( \"転んでもまた立ち上がる。\" ), & ut ( \"くじけずに前を向いて歩いていこう。\" )] call printwords ( array ) write ( * , g ) 'OOP' array = proverb % split ( ut ( ' ' )) write ( * , '(*(:\"[\",a,\"]\"))' )( character ( array ( i )), i = 1 , size ( array )) contains impure elemental subroutine printwords ( line ) type ( ut ), intent ( in ) :: line pos = 0 write ( * , g ) line % character (), len ( line ) do while ( pos < len ( line )) first = pos + 1 call split ( line , delims , pos ) last = pos - 1 print g , line % character ( first , last ), first , last , pos end do end subroutine printwords end program demo_split","tags":"","url":"sourcefile/demo_split.f90.html"},{"title":"demo_upper.f90 – M_unicode","text":"Source Code program demo_upper use M_unicode , only : upper , unicode_type , assignment ( = ) implicit none character ( len =* ), parameter :: g = '(*(g0))' type ( unicode_type ) :: pangram type ( unicode_type ) :: upper_pangram ! a sentence containing every letter of the English alphabet pangram = \"The quick brown fox jumps over the lazy dog.\" write ( * , g ) pangram % character () upper_pangram = upper ( pangram ) write ( * , g ) upper_pangram % character () end program demo_upper","tags":"","url":"sourcefile/demo_upper.f90.html"},{"title":"sample.f90 – M_unicode","text":"Source Code program assign_exe use M_unicode , only : len , len_trim , repeat , trim , adjustr , adjustl use M_unicode , only : character use M_unicode , only : assignment ( = ), unicode_type character ( len =* ), parameter :: g = '(*(g0))' character ( len = :), allocatable :: aline type ( unicode_type ) :: uline , substring character ( len =* ), parameter :: smiley = '😃' aline = \"Доки не впріти, доти не вміти.\" write ( * , g ) '123456789012345678901234567890' write ( * , g ) aline write ( * , g ) 'length in bytes is: ' , len ( aline ) uline = aline write ( * , g ) 'length in glyphs is: ' , len ( uline ) write ( * , g ) 'string is: ' , character ( uline ) write ( * , g ) 'third word is: ' , character ( uline , 9 , 14 ) ! substring substring = character ( uline , 17 , 29 ) write ( * , g ) 'string is: ' , character ( substring ) uline = repeat ( smiley , 30 ) write ( * , g ) character ( uline ) write ( * , g ) len_trim ( uline ) uline = aline // '      ' write ( * , g ) len_trim ( uline ) uline = [ 32 , 160 , 8192 , 8193 , 8194 , 8195 , 8196 , 8197 , 8198 , 8199 , 8200 , 8201 , 8202 , 8239 , 8287 , 12288 ] write ( * , g ) 'spaces:' , character ( uline ), len ( uline ), len_trim ( uline ) uline = [ 32 , 160 , 8192 , 8193 , 8194 , 8195 , 8196 , 8197 , 8198 , 8199 , 8200 , 8201 , 8202 , 8239 , 8287 , 12288 ] uline = trim ( uline ) write ( * , g ) 'trim:' , '[' , character ( uline ), ']' uline = '    this  is just a    string        ' write ( * , g ) 'adjustr:' , '[' , character ( uline ), '] ==> [' , character ( adjustr ( uline )), ']' uline = '    this  is just a    string        ' write ( * , g ) 'adjustl:' , '[' , character ( uline ), '] ==> [' , character ( adjustl ( uline )), ']' !write(*,g)uline end program assign_exe","tags":"","url":"sourcefile/sample.f90.html"},{"title":"fid.f90 – M_unicode","text":"Source Code program test_id use , intrinsic :: iso_fortran_env , only : compiler_version use , intrinsic :: iso_fortran_env , only : compiler_options implicit none character ( len = :), allocatable :: version , options character ( len =* ), parameter :: nl = new_line ( 'a' ) integer :: where , start , break version = compiler_version () options = ' ' // compiler_options () start = 1 do where = index ( options ( start :), ' -' ) if ( where . eq . 0 ) exit break = where + start - 1 options ( break : break ) = nl start = where enddo if ( start . eq . 1 ) then do where = index ( options ( start :), ' /' ) if ( where . eq . 0 ) exit break = where + start - 1 options ( break : break ) = nl start = where enddo endif print '(*(1x,a))' , & 'This file was compiled by ' , & version , nl , & 'using the options ' , & options end program test_id","tags":"","url":"sourcefile/fid.f90.html"},{"title":"note.f90 – M_unicode","text":"Source Code program note use M_unicode implicit none integer , parameter :: pointer ( * ) = [ int ( z '1FBC1' ), int ( z '1FBC2' ), int ( z '1FBC3' )] type ( unicode_type ) :: uline uline = pointer write ( * , '(*(g0))' ) uline % character () end program note","tags":"","url":"sourcefile/note.f90.html"},{"title":"M_unicode.f90 – M_unicode","text":"Source Code ! TODO: !  o globbing !  o regex !  o elemental functions? module M_unicode ! Unicode-related procedures not requiring compiler support of ISO-10646 ! first presented in https://fortran-lang.discourse.group/t/how-to-use-utf-8-in-gfortran/9949 ! including enhancements and latin support from Francois Jacq, 2025-08 ! use , intrinsic :: iso_fortran_env , only : error_unit , stderr => error_unit use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none private public :: utf8_to_codepoints , codepoints_to_utf8 public :: adjustl , adjustr , index , len , len_trim , repeat , trim public :: sort public :: split , tokenize public :: upper , lower public :: scan , verify public :: unicode_type public :: assignment ( = ) public :: character public :: lle , llt , lne , leq , lgt , lge public :: operator ( <= ), operator ( < ), operator ( /= ), operator ( == ), operator ( > ), operator ( >= ), operator ( // ) private :: a2s , s2a private :: binary_search interface utf8_to_codepoints module procedure utf8_to_codepoints_str , utf8_to_codepoints_chars end interface utf8_to_codepoints interface codepoints_to_utf8 module procedure codepoints_to_utf8_str , codepoints_to_utf8_chars end interface codepoints_to_utf8 interface sort module procedure :: sort_quick_rx end interface sort interface verify module procedure :: uverify end interface verify interface scan module procedure :: uscan end interface scan interface tokenize module procedure :: split_first_last , split_pos , split_tokens end interface tokenize interface split module procedure :: split_first_last , split_pos , split_tokens end interface split ! Assign a character sequence to a string. interface assignment ( = ) module procedure :: assign_str_char module procedure :: assign_str_codes end interface assignment ( = ) interface character module procedure :: char_str , char_strs module procedure :: char_str_range , char_strs_range module procedure :: char_str_range_step , char_strs_range_step end interface character ! INTRINSIC COMPATIBILITY interface adjustl ; module procedure :: adjustl_str ; end interface adjustl interface adjustr ; module procedure :: adjustr_str ; end interface adjustr interface len ; module procedure :: len_str ; end interface len interface len_trim ; module procedure :: len_trim_str ; end interface len_trim interface repeat ; module procedure :: repeat_str ; end interface repeat interface trim ; module procedure :: trim_str ; end interface trim interface index ; module procedure :: index_str_str , index_str_char , index_char_str ; end interface index interface lle ; module procedure :: lle_str_str , lle_str_char , lle_char_str ; end interface lle interface llt ; module procedure :: llt_str_str , llt_str_char , llt_char_str ; end interface llt interface lne ; module procedure :: lne_char_str , lne_str_char , lne_str_str ; end interface lne interface leq ; module procedure :: leq_char_str , leq_str_char , leq_str_str ; end interface leq interface lgt ; module procedure :: lgt_str_str , lgt_str_char , lgt_char_str ; end interface lgt interface lge ; module procedure :: lge_str_str , lge_str_char , lge_char_str ; end interface lge interface operator ( <= ); module procedure :: lle_str_str , lle_str_char , lle_char_str ; end interface operator ( <= ) interface operator ( < ); module procedure :: llt_str_str , llt_str_char , llt_char_str ; end interface operator ( < ) interface operator ( /= ); module procedure :: lne_char_str , lne_str_char , lne_str_str ; end interface operator ( /= ) interface operator ( == ); module procedure :: leq_char_str , leq_str_char , leq_str_str ; end interface operator ( == ) interface operator ( > ); module procedure :: lgt_str_str , lgt_str_char , lgt_char_str ; end interface operator ( > ) interface operator ( >= ); module procedure :: lge_str_str , lge_str_char , lge_char_str ; end interface operator ( >= ) interface operator ( // ); module procedure :: concat_str_str , concat_str_char , concat_char_str ; end interface operator ( // ) type :: unicode_type ! Unicode string type holding an arbitrary sequence of integer codes. !sequence ! not used for storage association; a kludge to prevent extending this type. private integer , allocatable :: codes (:) contains ! METHODS: procedure :: character => oop_character procedure :: codepoint => oop_codepoint procedure :: bytes => oop_bytes procedure :: adjustl => oop_adjustl procedure :: adjustr => oop_adjustr procedure :: index => oop_index procedure :: len => oop_len procedure :: len_trim => oop_len_trim procedure :: trim => oop_trim procedure :: split => oop_split procedure :: tokenize => oop_tokenize procedure :: scan => oop_scan procedure :: verify => oop_verify procedure :: upper => oop_upper procedure :: lower => oop_lower !DECLARATION OF OVERLOADED OPERATORS FOR TYPE(UNICODE_TYPE) procedure , private :: eq => oop_eq !   generic           :: operator(==) => eq !   procedure,private :: ge => oop_ge !   generic           :: operator(>=) => oop_ge !   procedure,private :: lt => oop_lt !   generic           :: operator(<)  => oop_lt !   procedure,private :: gt => oop_gt !   generic           :: operator(>)  => oop_gt !   procedure,private :: le => oop_le !   generic           :: operator(<=) => oop_le !   procedure,private :: ne => oop_ne !   generic           :: operator(/=) => oop_ne !   procedure,private :: string_append_value !   generic           :: operator(//) => string_append_value end type unicode_type ! Constructor for new string instances interface unicode_type elemental module function new_str ( string ) result ( new ) character ( len =* ), intent ( in ), optional :: string type ( unicode_type ) :: new end function new_str module function new_codes ( codes ) result ( new ) integer , intent ( in ) :: codes (:) type ( unicode_type ) :: new end function new_codes end interface unicode_type ! space U+0020 32 Common Basic Latin Separator, Most common (normal ! ASCII space) ! ! no-break space U+00A0 160 Common Latin-1 Supplement Separator, ! Non-breaking space: identical to U+0020, but not a point at which a line ! may be broken. ! ! en quad U+2000 8192 General Punctuation Separator, Width of one en. U+2002 ! is canonically equivalent to this character; U+2002 is preferred. ! ! em quad U+2001 8193   Common General Punctuation Separator, ! Also known as \"mutton quad\". Width of one em. U+2003 is ! canonically equivalent to this character; U+2003 is preferred. ! ! en space U+2002 8194   Common General Punctuation Separator, ! space Also known as \"nut\". Width of one en. U+2000 En Quad is ! canonically equivalent to this character; U+2002 is preferred. ! ! em space U+2003 8195  Common General Punctuation Separator, ! space Also known as \"mutton\". Width of one em. U+2001 Em Quad is ! canonically equivalent to this character; U+2003 is preferred. ! ! three-per-em space U+2004 8196 Common General Punctuation Separator, ! Also known as \"thick space\". One third of an em wide. ! ! four-per-em space U+2005 8197 Common General Punctuation Separator, ! space Also known as \"mid space\". One fourth of an em wide. ! ! six-per-em space U+2006 8198 Common General Punctuation Separator, ! space One sixth of an em wide. In computer typography, sometimes equated ! to U+2009. ! ! figure space U+2007 8199 Common General Punctuation Separator, In fonts ! with monospaced digits, equal to the width of one digit. ! ! punctuation space U+2008 8200 Common General Punctuation Separator, ! As wide as the narrow punctuation in a font, i.e. the advance width of ! the period or comma. ! ! thin space U+2009 8201 Common General Punctuation Separator, one-fifth ! (sometimes one-sixth) of an em wide.  Recommended for use as a thousands ! separator for measures made with SI units. Unlike U+2002 to U+2008, ! its width may get adjusted in typesetting. ! ! hair space U+200A 8202 Common General Punctuation Separator, space ! Thinner than a thin space. ! ! narrow no-break space U+202F 8239 Common General Punctuation Separator, ! Similar in function to U+00A0 ! ! No-Break Space. When used with Mongolian, its width is usually one third ! of the normal space; in other context, its width sometimes resembles ! that of the Thin Space (U+2009). ! ! medium mathematical space U+205F 8287   Common General Punctuation ! Separator, space MMSP. Used in mathematical formulae. Four-eighteenths ! of an em. In mathematical typography, the widths of spaces are usually ! given in integral multiples of an eighteenth of an em, and 4/18 em ! may be used in several situations, for example between the a and the + ! and between the + and the b in the expression a + b. ! ! ideographic space U+3000 12288 　 Yes No Common CJK Symbols and ! Punctuation Separator, As wide as a CJK character cell (fullwidth). Used, ! for example, in tai tou. integer , parameter :: G_SPACE = 32 integer , parameter :: G_SPACES ( * ) = [ 32 , 160 , 8192 , 8193 , 8194 , 8195 , 8196 , 8197 , 8198 , 8199 , 8200 , 8201 , 8202 , 8239 , 8287 , 12288 ] ! Unicode lowercase to uppercase conversion mapping table ! The standard English lowercase \"i\" (U+0069) has a dot, which is called a \"tittle\". ! The uppercase dotted \"İ\" (U+0130) is a separate Unicode character that functions as the uppercase dotted \"i\". ! * U+0049 I LATIN CAPITAL LETTER I. ! * U+0130 İ LATIN CAPITAL LETTER I WITH DOT ABOVE. ! * U+0069 i LATIN SMALL LETTER I. (dotted) ! * U+0131 ı LATIN SMALL LETTER I DOTLESS ! So the problem is both \"LATIN SMALL LETTER I DOTLESS\" and \"LATIN SMALL LETTER I\" typically have uppercase \"LATIN CAPITAL LETTER I\" ! so a round trip will not put I back to a dotless I. Because doing ASCII outside of the table could have dotted as one set and ! undotted as another in the table but the routine would still have the same issue. integer , parameter :: lowhigh = 666 integer , parameter :: lowup ( lowhigh , 2 ) = reshape ([ & int ( z '0061' ), int ( z '0041' ), & ! LATIN SMALL LETTER A => LATIN CAPITAL LETTER A int ( z '0062' ), int ( z '0042' ), & ! LATIN SMALL LETTER B => LATIN CAPITAL LETTER B int ( z '0063' ), int ( z '0043' ), & ! LATIN SMALL LETTER C => LATIN CAPITAL LETTER C int ( z '0064' ), int ( z '0044' ), & ! LATIN SMALL LETTER D => LATIN CAPITAL LETTER D int ( z '0065' ), int ( z '0045' ), & ! LATIN SMALL LETTER E => LATIN CAPITAL LETTER E int ( z '0066' ), int ( z '0046' ), & ! LATIN SMALL LETTER F => LATIN CAPITAL LETTER F int ( z '0067' ), int ( z '0047' ), & ! LATIN SMALL LETTER G => LATIN CAPITAL LETTER G int ( z '0068' ), int ( z '0048' ), & ! LATIN SMALL LETTER H => LATIN CAPITAL LETTER H int ( z '0069' ), int ( z '0049' ), & ! LATIN SMALL LETTER I => LATIN CAPITAL LETTER I int ( z '006A' ), int ( z '004A' ), & ! LATIN SMALL LETTER J => LATIN CAPITAL LETTER J int ( z '006B' ), int ( z '004B' ), & ! LATIN SMALL LETTER K => LATIN CAPITAL LETTER K int ( z '006C' ), int ( z '004C' ), & ! LATIN SMALL LETTER L => LATIN CAPITAL LETTER L int ( z '006D' ), int ( z '004D' ), & ! LATIN SMALL LETTER M => LATIN CAPITAL LETTER M int ( z '006E' ), int ( z '004E' ), & ! LATIN SMALL LETTER N => LATIN CAPITAL LETTER N int ( z '006F' ), int ( z '004F' ), & ! LATIN SMALL LETTER O => LATIN CAPITAL LETTER O int ( z '0070' ), int ( z '0050' ), & ! LATIN SMALL LETTER P => LATIN CAPITAL LETTER P int ( z '0071' ), int ( z '0051' ), & ! LATIN SMALL LETTER Q => LATIN CAPITAL LETTER Q int ( z '0072' ), int ( z '0052' ), & ! LATIN SMALL LETTER R => LATIN CAPITAL LETTER R int ( z '0073' ), int ( z '0053' ), & ! LATIN SMALL LETTER S => LATIN CAPITAL LETTER S int ( z '0074' ), int ( z '0054' ), & ! LATIN SMALL LETTER T => LATIN CAPITAL LETTER T int ( z '0075' ), int ( z '0055' ), & ! LATIN SMALL LETTER U => LATIN CAPITAL LETTER U int ( z '0076' ), int ( z '0056' ), & ! LATIN SMALL LETTER V => LATIN CAPITAL LETTER V int ( z '0077' ), int ( z '0057' ), & ! LATIN SMALL LETTER W => LATIN CAPITAL LETTER W int ( z '0078' ), int ( z '0058' ), & ! LATIN SMALL LETTER X => LATIN CAPITAL LETTER X int ( z '0079' ), int ( z '0059' ), & ! LATIN SMALL LETTER Y => LATIN CAPITAL LETTER Y int ( z '007A' ), int ( z '005A' ), & ! LATIN SMALL LETTER Z => LATIN CAPITAL LETTER Z int ( z '00E0' ), int ( z '00C0' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A GRAVE int ( z '00E1' ), int ( z '00C1' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A ACUTE int ( z '00E2' ), int ( z '00C2' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A CIRCUMFLEX int ( z '00E3' ), int ( z '00C3' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A TILDE int ( z '00E4' ), int ( z '00C4' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A DIAERESIS int ( z '00E5' ), int ( z '00C5' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A RING int ( z '00E6' ), int ( z '00C6' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A E int ( z '00E7' ), int ( z '00C7' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER C CEDILLA int ( z '00E8' ), int ( z '00C8' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER E GRAVE int ( z '00E9' ), int ( z '00C9' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER E ACUTE int ( z '00EA' ), int ( z '00CA' ), & ! LATIN SMALL LETTER E CIRCUMFLEX => LATIN CAPITAL LETTER E CIRCUMFLEX int ( z '00EB' ), int ( z '00CB' ), & ! LATIN SMALL LETTER E DIAERESIS => LATIN CAPITAL LETTER E DIAERESIS int ( z '00EC' ), int ( z '00CC' ), & ! LATIN SMALL LETTER I GRAVE => LATIN CAPITAL LETTER I GRAVE int ( z '00ED' ), int ( z '00CD' ), & ! LATIN SMALL LETTER I ACUTE => LATIN CAPITAL LETTER I ACUTE int ( z '00EE' ), int ( z '00CE' ), & ! LATIN SMALL LETTER I CIRCUMFLEX => LATIN CAPITAL LETTER I CIRCUMFLEX int ( z '00EF' ), int ( z '00CF' ), & ! LATIN SMALL LETTER I DIAERESIS => LATIN CAPITAL LETTER I DIAERESIS int ( z '00F0' ), int ( z '00D0' ), & ! LATIN SMALL LETTER ETH => LATIN CAPITAL LETTER ETH int ( z '00F1' ), int ( z '00D1' ), & ! LATIN SMALL LETTER N TILDE => LATIN CAPITAL LETTER N TILDE int ( z '00F2' ), int ( z '00D2' ), & ! LATIN SMALL LETTER O GRAVE => LATIN CAPITAL LETTER O GRAVE int ( z '00F3' ), int ( z '00D3' ), & ! LATIN SMALL LETTER O ACUTE => LATIN CAPITAL LETTER O ACUTE int ( z '00F4' ), int ( z '00D4' ), & ! LATIN SMALL LETTER O CIRCUMFLEX => LATIN CAPITAL LETTER O CIRCUMFLEX int ( z '00F5' ), int ( z '00D5' ), & ! LATIN SMALL LETTER O TILDE => LATIN CAPITAL LETTER O TILDE int ( z '00F6' ), int ( z '00D6' ), & ! LATIN SMALL LETTER O DIAERESIS => LATIN CAPITAL LETTER O DIAERESIS int ( z '00F8' ), int ( z '00D8' ), & ! LATIN SMALL LETTER O SLASH => LATIN CAPITAL LETTER O SLASH int ( z '00F9' ), int ( z '00D9' ), & ! LATIN SMALL LETTER U GRAVE => LATIN CAPITAL LETTER U GRAVE int ( z '00FA' ), int ( z '00DA' ), & ! LATIN SMALL LETTER U ACUTE => LATIN CAPITAL LETTER U ACUTE int ( z '00FB' ), int ( z '00DB' ), & ! LATIN SMALL LETTER U CIRCUMFLEX => LATIN CAPITAL LETTER U CIRCUMFLEX int ( z '00FC' ), int ( z '00DC' ), & ! LATIN SMALL LETTER U DIAERESIS => LATIN CAPITAL LETTER U DIAERESIS int ( z '00FD' ), int ( z '00DD' ), & ! LATIN SMALL LETTER Y ACUTE => LATIN CAPITAL LETTER Y ACUTE int ( z '00FE' ), int ( z '00DE' ), & ! LATIN SMALL LETTER THORN => LATIN CAPITAL LETTER THORN int ( z '00FF' ), int ( z '0178' ), & ! LATIN SMALL LETTER Y DIAERESIS => LATIN CAPITAL LETTER Y WITH DIAERESIS int ( z '0101' ), int ( z '0100' ), & ! LATIN SMALL LETTER A WITH MACRON => LATIN CAPITAL LETTER A WITH MACRON int ( z '0103' ), int ( z '0102' ), & ! LATIN SMALL LETTER A WITH BREVE => LATIN CAPITAL LETTER A WITH BREVE int ( z '0105' ), int ( z '0104' ), & ! LATIN SMALL LETTER A WITH OGONEK => LATIN CAPITAL LETTER A WITH OGONEK int ( z '0107' ), int ( z '0106' ), & ! LATIN SMALL LETTER C WITH ACUTE => LATIN CAPITAL LETTER C WITH ACUTE int ( z '0109' ), int ( z '0108' ), & ! LATIN SMALL LETTER C WITH CIRCUMFLEX => LATIN CAPITAL LETTER C WITH CIRCUMFLEX int ( z '010B' ), int ( z '010A' ), & ! LATIN SMALL LETTER C WITH DOT ABOVE => LATIN CAPITAL LETTER C WITH DOT ABOVE int ( z '010D' ), int ( z '010C' ), & ! LATIN SMALL LETTER C WITH CARON => LATIN CAPITAL LETTER C WITH CARON int ( z '010F' ), int ( z '010E' ), & ! LATIN SMALL LETTER D WITH CARON => LATIN CAPITAL LETTER D WITH CARON int ( z '0111' ), int ( z '0110' ), & ! LATIN SMALL LETTER D WITH STROKE => LATIN CAPITAL LETTER D WITH STROKE int ( z '0113' ), int ( z '0112' ), & ! LATIN SMALL LETTER E WITH MACRON => LATIN CAPITAL LETTER E WITH MACRON int ( z '0115' ), int ( z '0114' ), & ! LATIN SMALL LETTER E WITH BREVE => LATIN CAPITAL LETTER E WITH BREVE int ( z '0117' ), int ( z '0116' ), & ! LATIN SMALL LETTER E WITH DOT ABOVE => LATIN CAPITAL LETTER E WITH DOT ABOVE int ( z '0119' ), int ( z '0118' ), & ! LATIN SMALL LETTER E WITH OGONEK => LATIN CAPITAL LETTER E WITH OGONEK int ( z '011B' ), int ( z '011A' ), & ! LATIN SMALL LETTER E WITH CARON => LATIN CAPITAL LETTER E WITH CARON int ( z '011D' ), int ( z '011C' ), & ! LATIN SMALL LETTER G WITH CIRCUMFLEX => LATIN CAPITAL LETTER G WITH CIRCUMFLEX int ( z '011F' ), int ( z '011E' ), & ! LATIN SMALL LETTER G WITH BREVE => LATIN CAPITAL LETTER G WITH BREVE int ( z '0121' ), int ( z '0120' ), & ! LATIN SMALL LETTER G WITH DOT ABOVE => LATIN CAPITAL LETTER G WITH DOT ABOVE int ( z '0123' ), int ( z '0122' ), & ! LATIN SMALL LETTER G WITH CEDILLA => LATIN CAPITAL LETTER G WITH CEDILLA int ( z '0125' ), int ( z '0124' ), & ! LATIN SMALL LETTER H WITH CIRCUMFLEX => LATIN CAPITAL LETTER H WITH CIRCUMFLEX int ( z '0127' ), int ( z '0126' ), & ! LATIN SMALL LETTER H WITH STROKE => LATIN CAPITAL LETTER H WITH STROKE int ( z '0129' ), int ( z '0128' ), & ! LATIN SMALL LETTER I WITH TILDE => LATIN CAPITAL LETTER I WITH TILDE int ( z '012B' ), int ( z '012A' ), & ! LATIN SMALL LETTER I WITH MACRON => LATIN CAPITAL LETTER I WITH MACRON int ( z '012D' ), int ( z '012C' ), & ! LATIN SMALL LETTER I WITH BREVE => LATIN CAPITAL LETTER I WITH BREVE int ( z '012F' ), int ( z '012E' ), & ! LATIN SMALL LETTER I WITH OGONEK => LATIN CAPITAL LETTER I WITH OGONEK int ( z '0131' ), int ( z '0049' ), & ! LATIN SMALL LETTER DOTLESS I => LATIN CAPITAL LETTER I int ( z '0133' ), int ( z '0132' ), & ! LATIN SMALL LIGATURE IJ => LATIN CAPITAL LIGATURE IJ int ( z '0135' ), int ( z '0134' ), & ! LATIN SMALL LETTER J WITH CIRCUMFLEX => LATIN CAPITAL LETTER J WITH CIRCUMFLEX int ( z '0137' ), int ( z '0136' ), & ! LATIN SMALL LETTER K WITH CEDILLA => LATIN CAPITAL LETTER K WITH CEDILLA int ( z '013A' ), int ( z '0139' ), & ! LATIN SMALL LETTER L WITH ACUTE => LATIN CAPITAL LETTER L WITH ACUTE int ( z '013C' ), int ( z '013B' ), & ! LATIN SMALL LETTER L WITH CEDILLA => LATIN CAPITAL LETTER L WITH CEDILLA int ( z '013E' ), int ( z '013D' ), & ! LATIN SMALL LETTER L WITH CARON => LATIN CAPITAL LETTER L WITH CARON int ( z '0140' ), int ( z '013F' ), & ! LATIN SMALL LETTER L WITH MIDDLE DOT => LATIN CAPITAL LETTER L WITH MIDDLE DOT int ( z '0142' ), int ( z '0141' ), & ! LATIN SMALL LETTER L WITH STROKE => LATIN CAPITAL LETTER L WITH STROKE int ( z '0144' ), int ( z '0143' ), & ! LATIN SMALL LETTER N WITH ACUTE => LATIN CAPITAL LETTER N WITH ACUTE int ( z '0146' ), int ( z '0145' ), & ! LATIN SMALL LETTER N WITH CEDILLA => LATIN CAPITAL LETTER N WITH CEDILLA int ( z '0148' ), int ( z '0147' ), & ! LATIN SMALL LETTER N WITH CARON => LATIN CAPITAL LETTER N WITH CARON int ( z '014B' ), int ( z '014A' ), & ! LATIN SMALL LETTER ENG (SAMI) => LATIN CAPITAL LETTER ENG (SAMI) int ( z '014D' ), int ( z '014C' ), & ! LATIN SMALL LETTER O WITH MACRON => LATIN CAPITAL LETTER O WITH MACRON int ( z '014F' ), int ( z '014E' ), & ! LATIN SMALL LETTER O WITH BREVE => LATIN CAPITAL LETTER O WITH BREVE int ( z '0151' ), int ( z '0150' ), & ! LATIN SMALL LETTER O WITH DOUBLE ACUTE => LATIN CAPITAL LETTER O WITH DOUBLE ACUTE int ( z '0153' ), int ( z '0152' ), & ! LATIN SMALL LIGATURE OE => LATIN CAPITAL LIGATURE OE int ( z '0155' ), int ( z '0154' ), & ! LATIN SMALL LETTER R WITH ACUTE => LATIN CAPITAL LETTER R WITH ACUTE int ( z '0157' ), int ( z '0156' ), & ! LATIN SMALL LETTER R WITH CEDILLA => LATIN CAPITAL LETTER R WITH CEDILLA int ( z '0159' ), int ( z '0158' ), & ! LATIN SMALL LETTER R WITH CARON => LATIN CAPITAL LETTER R WITH CARON int ( z '015B' ), int ( z '015A' ), & ! LATIN SMALL LETTER S WITH ACUTE => LATIN CAPITAL LETTER S WITH ACUTE int ( z '015D' ), int ( z '015C' ), & ! LATIN SMALL LETTER S WITH CIRCUMFLEX => LATIN CAPITAL LETTER S WITH CIRCUMFLEX int ( z '015F' ), int ( z '015E' ), & ! LATIN SMALL LETTER S WITH CEDILLA => LATIN CAPITAL LETTER S WITH CEDILLA int ( z '0161' ), int ( z '0160' ), & ! LATIN SMALL LETTER S WITH CARON => LATIN CAPITAL LETTER S WITH CARON int ( z '0163' ), int ( z '0162' ), & ! LATIN SMALL LETTER T WITH CEDILLA => LATIN CAPITAL LETTER T WITH CEDILLA int ( z '0165' ), int ( z '0164' ), & ! LATIN SMALL LETTER T WITH CARON => LATIN CAPITAL LETTER T WITH CARON int ( z '0167' ), int ( z '0166' ), & ! LATIN SMALL LETTER T WITH STROKE => LATIN CAPITAL LETTER T WITH STROKE int ( z '0169' ), int ( z '0168' ), & ! LATIN SMALL LETTER U WITH TILDE => LATIN CAPITAL LETTER U WITH TILDE int ( z '016B' ), int ( z '016A' ), & ! LATIN SMALL LETTER U WITH MACRON => LATIN CAPITAL LETTER U WITH MACRON int ( z '016D' ), int ( z '016C' ), & ! LATIN SMALL LETTER U WITH BREVE => LATIN CAPITAL LETTER U WITH BREVE int ( z '016F' ), int ( z '016E' ), & ! LATIN SMALL LETTER U WITH RING ABOVE => LATIN CAPITAL LETTER U WITH RING ABOVE int ( z '0171' ), int ( z '0170' ), & ! LATIN SMALL LETTER U WITH DOUBLE ACUTE => LATIN CAPITAL LETTER U WITH DOUBLE ACUTE int ( z '0173' ), int ( z '0172' ), & ! LATIN SMALL LETTER U WITH OGONEK => LATIN CAPITAL LETTER U WITH OGONEK int ( z '0175' ), int ( z '0174' ), & ! LATIN SMALL LETTER W WITH CIRCUMFLEX => LATIN CAPITAL LETTER W WITH CIRCUMFLEX int ( z '0177' ), int ( z '0176' ), & ! LATIN SMALL LETTER Y WITH CIRCUMFLEX => LATIN CAPITAL LETTER Y WITH CIRCUMFLEX int ( z '017A' ), int ( z '0179' ), & ! LATIN SMALL LETTER Z WITH ACUTE => LATIN CAPITAL LETTER Z WITH ACUTE int ( z '017C' ), int ( z '017B' ), & ! LATIN SMALL LETTER Z WITH DOT ABOVE => LATIN CAPITAL LETTER Z WITH DOT ABOVE int ( z '017E' ), int ( z '017D' ), & ! LATIN SMALL LETTER Z WITH CARON => LATIN CAPITAL LETTER Z WITH CARON int ( z '0183' ), int ( z '0182' ), & ! LATIN SMALL LETTER B WITH TOPBAR => LATIN CAPITAL LETTER B WITH TOPBAR int ( z '0185' ), int ( z '0184' ), & ! LATIN SMALL LETTER TONE SIX => LATIN CAPITAL LETTER TONE SIX int ( z '0188' ), int ( z '0187' ), & ! LATIN SMALL LETTER C WITH HOOK => LATIN CAPITAL LETTER C WITH HOOK int ( z '018C' ), int ( z '018B' ), & ! LATIN SMALL LETTER D WITH TOPBAR => LATIN CAPITAL LETTER D WITH TOPBAR int ( z '0192' ), int ( z '0191' ), & ! LATIN SMALL LETTER F WITH HOOK => LATIN CAPITAL LETTER F WITH HOOK int ( z '0199' ), int ( z '0198' ), & ! LATIN SMALL LETTER K WITH HOOK => LATIN CAPITAL LETTER K WITH HOOK int ( z '01A1' ), int ( z '01A0' ), & ! LATIN SMALL LETTER O WITH HORN => LATIN CAPITAL LETTER O WITH HORN int ( z '01A3' ), int ( z '01A2' ), & ! LATIN SMALL LETTER OI => LATIN CAPITAL LETTER OI int ( z '01A5' ), int ( z '01A4' ), & ! LATIN SMALL LETTER P WITH HOOK => LATIN CAPITAL LETTER P WITH HOOK int ( z '01A8' ), int ( z '01A7' ), & ! LATIN SMALL LETTER TONE TWO => LATIN CAPITAL LETTER TONE TWO int ( z '01AD' ), int ( z '01AC' ), & ! LATIN SMALL LETTER T WITH HOOK => LATIN CAPITAL LETTER T WITH HOOK int ( z '01B0' ), int ( z '01AF' ), & ! LATIN SMALL LETTER U WITH HORN => LATIN CAPITAL LETTER U WITH HORN int ( z '01B4' ), int ( z '01B3' ), & ! LATIN SMALL LETTER Y WITH HOOK => LATIN CAPITAL LETTER Y WITH HOOK int ( z '01B6' ), int ( z '01B5' ), & ! LATIN SMALL LETTER Z WITH STROKE => LATIN CAPITAL LETTER Z WITH STROKE int ( z '01B9' ), int ( z '01B8' ), & ! LATIN SMALL LETTER EZH REVERSED => LATIN CAPITAL LETTER EZH REVERSED int ( z '01BD' ), int ( z '01BC' ), & ! LATIN SMALL LETTER TONE FIVE => LATIN CAPITAL LETTER TONE FIVE int ( z '01C6' ), int ( z '01C4' ), & ! LATIN SMALL LETTER DZ WITH CARON => LATIN CAPITAL LETTER DZ WITH CARON int ( z '01C9' ), int ( z '01C7' ), & ! LATIN SMALL LETTER LJ => LATIN CAPITAL LETTER LJ int ( z '01CC' ), int ( z '01CA' ), & ! LATIN SMALL LETTER NJ => LATIN CAPITAL LETTER NJ int ( z '01CE' ), int ( z '01CD' ), & ! LATIN SMALL LETTER A WITH CARON => LATIN CAPITAL LETTER A WITH CARON int ( z '01D0' ), int ( z '01CF' ), & ! LATIN SMALL LETTER I WITH CARON => LATIN CAPITAL LETTER I WITH CARON int ( z '01D2' ), int ( z '01D1' ), & ! LATIN SMALL LETTER O WITH CARON => LATIN CAPITAL LETTER O WITH CARON int ( z '01D4' ), int ( z '01D3' ), & ! LATIN SMALL LETTER U WITH CARON => LATIN CAPITAL LETTER U WITH CARON int ( z '01D6' ), int ( z '01D5' ), & ! LATIN SMALL LETTER U WITH DIAERESIS AND MACRON => LATIN CAPITAL LETTER U WITH DIAERESIS AND MACRON int ( z '01D8' ), int ( z '01D7' ), & ! LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE => LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE int ( z '01DA' ), int ( z '01D9' ), & ! LATIN SMALL LETTER U WITH DIAERESIS AND CARON => LATIN CAPITAL LETTER U WITH DIAERESIS AND CARON int ( z '01DC' ), int ( z '01DB' ), & ! LATIN SMALL LETTER U WITH DIAERESIS AND GRAVE => LATIN CAPITAL LETTER U WITH DIAERESIS AND GRAVE int ( z '01DF' ), int ( z '01DE' ), & ! LATIN SMALL LETTER A WITH DIAERESIS AND MACRON => LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON int ( z '01E1' ), int ( z '01E0' ), & ! LATIN SMALL LETTER A WITH DOT ABOVE AND MACRON => LATIN CAPITAL LETTER A WITH DOT ABOVE AND MACRON int ( z '01E3' ), int ( z '01E2' ), & ! LATIN SMALL LIGATURE AE WITH MACRON => LATIN CAPITAL LIGATURE AE MTH MACRON int ( z '01E5' ), int ( z '01E4' ), & ! LATIN SMALL LETTER G WITH STROKE => LATIN CAPITAL LETTER G WITH STROKE int ( z '01E7' ), int ( z '01E6' ), & ! LATIN SMALL LETTER G WITH CARON => LATIN CAPITAL LETTER G WITH CARON int ( z '01E9' ), int ( z '01E8' ), & ! LATIN SMALL LETTER K WITH CARON => LATIN CAPITAL LETTER K WITH CARON int ( z '01EB' ), int ( z '01EA' ), & ! LATIN SMALL LETTER O WITH OGONEK => LATIN CAPITAL LETTER O WITH OGONEK int ( z '01ED' ), int ( z '01EC' ), & ! LATIN SMALL LETTER O WITH OGONEK AND MACRON => LATIN CAPITAL LETTER O WITH OGONEK AND MACRON int ( z '01EF' ), int ( z '01EE' ), & ! LATIN SMALL LETTER EZH WITH CARON => LATIN CAPITAL LETTER EZH WITH CARON int ( z '01F3' ), int ( z '01F1' ), & ! LATIN SMALL LETTER DZ => LATIN CAPITAL LETTER DZ int ( z '01F5' ), int ( z '01F4' ), & ! LATIN SMALL LETTER G WITH ACUTE => LATIN CAPITAL LETTER G WITH ACUTE int ( z '01FB' ), int ( z '01FA' ), & ! LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE => LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE int ( z '01FD' ), int ( z '01FC' ), & ! LATIN SMALL LIGATURE AE WITH ACUTE => LATIN CAPITAL LIGATURE AE WITH ACUTE int ( z '01FF' ), int ( z '01FE' ), & ! LATIN SMALL LETTER O WITH STROKE AND ACUTE => LATIN CAPITAL LETTER O WITH STROKE AND ACUTE int ( z '0201' ), int ( z '0200' ), & ! LATIN SMALL LETTER A WITH DOUBLE GRAVE => LATIN CAPITAL LETTER A WITH DOUBLE GRAVE int ( z '0203' ), int ( z '0202' ), & ! LATIN SMALL LETTER A WITH INVERTED BREVE => LATIN CAPITAL LETTER A WITH INVERTED BREVE int ( z '0205' ), int ( z '0204' ), & ! LATIN SMALL LETTER E WITH DOUBLE GRAVE => LATIN CAPITAL LETTER E WITH DOUBLE GRAVE int ( z '0207' ), int ( z '0206' ), & ! LATIN SMALL LETTER E WITH INVERTED BREVE => LATIN CAPITAL LETTER E WITH INVERTED BREVE int ( z '0209' ), int ( z '0208' ), & ! LATIN SMALL LETTER I WITH DOUBLE GRAVE => LATIN CAPITAL LETTER I WITH DOUBLE GRAVE int ( z '020B' ), int ( z '020A' ), & ! LATIN SMALL LETTER I WITH INVERTED BREVE => LATIN CAPITAL LETTER I WITH INVERTED BREVE int ( z '020D' ), int ( z '020C' ), & ! LATIN SMALL LETTER O WITH DOUBLE GRAVE => LATIN CAPITAL LETTER O WITH DOUBLE GRAVE int ( z '020F' ), int ( z '020E' ), & ! LATIN SMALL LETTER O WITH INVERTED BREVE => LATIN CAPITAL LETTER O WITH INVERTED BREVE int ( z '0211' ), int ( z '0210' ), & ! LATIN SMALL LETTER R WITH DOUBLE GRAVE => LATIN CAPITAL LETTER R WITH DOUBLE GRAVE int ( z '0213' ), int ( z '0212' ), & ! LATIN SMALL LETTER R WITH INVERTED BREVE => LATIN CAPITAL LETTER R WITH INVERTED BREVE int ( z '0215' ), int ( z '0214' ), & ! LATIN SMALL LETTER U WITH DOUBLE GRAVE => LATIN CAPITAL LETTER U WITH DOUBLE GRAVE int ( z '0217' ), int ( z '0216' ), & ! LATIN SMALL LETTER U WITH INVERTED BREVE => LATIN CAPITAL LETTER U WITH INVERTED BREVE int ( z '0253' ), int ( z '0181' ), & ! LATIN SMALL LETTER B WITH HOOK => LATIN CAPITAL LETTER B WITH HOOK int ( z '0254' ), int ( z '0186' ), & ! LATIN SMALL LETTER OPEN O => LATIN CAPITAL LETTER OPEN O int ( z '0257' ), int ( z '018A' ), & ! LATIN SMALL LETTER D WITH HOOK => LATIN CAPITAL LETTER D WITH HOOK int ( z '0258' ), int ( z '018E' ), & ! LATIN SMALL LETTER REVERSED E => LATIN CAPITAL LETTER REVERSED E int ( z '0259' ), int ( z '018F' ), & ! LATIN SMALL LETTER SCHWA => LATIN CAPITAL LETTER SCHWA int ( z '025B' ), int ( z '0190' ), & ! LATIN SMALL LETTER OPEN E => LATIN CAPITAL LETTER OPEN E int ( z '0260' ), int ( z '0193' ), & ! LATIN SMALL LETTER G WITH HOOK => LATIN CAPITAL LETTER G WITH HOOK int ( z '0263' ), int ( z '0194' ), & ! LATIN SMALL LETTER GAMMA => LATIN CAPITAL LETTER GAMMA int ( z '0268' ), int ( z '0197' ), & ! LATIN SMALL LETTER I WITH STROKE => LATIN CAPITAL LETTER I WITH STROKE int ( z '0269' ), int ( z '0196' ), & ! LATIN SMALL LETTER IOTA => LATIN CAPITAL LETTER IOTA int ( z '026F' ), int ( z '019C' ), & ! LATIN SMALL LETTER TURNED M => LATIN CAPITAL LETTER TURNED M int ( z '0272' ), int ( z '019D' ), & ! LATIN SMALL LETTER N WITH LEFT HOOK => LATIN CAPITAL LETTER N WITH LEFT HOOK int ( z '0275' ), int ( z '019F' ), & ! LATIN SMALL LETTER BARRED O => LATIN CAPITAL LETTER O WITH MIDDLE TILDE int ( z '0283' ), int ( z '01A9' ), & ! LATIN SMALL LETTER ESH => LATIN CAPITAL LETTER ESH int ( z '0288' ), int ( z '01AE' ), & ! LATIN SMALL LETTER T WITH RETROFLEX HOOK => LATIN CAPITAL LETTER T WITH RETROFLEX HOOK int ( z '028A' ), int ( z '01B1' ), & ! LATIN SMALL LETTER UPSILON => LATIN CAPITAL LETTER UPSILON int ( z '028B' ), int ( z '01B2' ), & ! LATIN SMALL LETTER V WITH HOOK => LATIN CAPITAL LETTER V WITH HOOK int ( z '0292' ), int ( z '01B7' ), & ! LATIN SMALL LETTER EZH => LATIN CAPITAL LETTER EZH int ( z '03AC' ), int ( z '0386' ), & ! GREEK SMALL LETTER ALPHA WITH TONOS => GREEK CAPITAL LETTER ALPHA WITH TONOS int ( z '03AD' ), int ( z '0388' ), & ! GREEK SMALL LETTER EPSILON WITH TONOS => GREEK CAPITAL LETTER EPSILON WITH TONOS int ( z '03AE' ), int ( z '0389' ), & ! GREEK SMALL LETTER ETA WITH TONOS => GREEK CAPITAL LETTER ETA WITH TONOS int ( z '03AF' ), int ( z '038A' ), & ! GREEK SMALL LETTER IOTA WITH TONOS => GREEK CAPITAL LETTER IOTA WITH TONOS int ( z '03B1' ), int ( z '0391' ), & ! GREEK SMALL LETTER ALPHA => GREEK CAPITAL LETTER ALPHA int ( z '03B2' ), int ( z '0392' ), & ! GREEK SMALL LETTER BETA => GREEK CAPITAL LETTER BETA int ( z '03B3' ), int ( z '0393' ), & ! GREEK SMALL LETTER GAMMA => GREEK CAPITAL LETTER GAMMA int ( z '03B4' ), int ( z '0394' ), & ! GREEK SMALL LETTER DELTA => GREEK CAPITAL LETTER DELTA int ( z '03B5' ), int ( z '0395' ), & ! GREEK SMALL LETTER EPSILON => GREEK CAPITAL LETTER EPSILON int ( z '03B6' ), int ( z '0396' ), & ! GREEK SMALL LETTER ZETA => GREEK CAPITAL LETTER ZETA int ( z '03B7' ), int ( z '0397' ), & ! GREEK SMALL LETTER ETA => GREEK CAPITAL LETTER ETA int ( z '03B8' ), int ( z '0398' ), & ! GREEK SMALL LETTER THETA => GREEK CAPITAL LETTER THETA int ( z '03B9' ), int ( z '0399' ), & ! GREEK SMALL LETTER IOTA => GREEK CAPITAL LETTER IOTA int ( z '03BA' ), int ( z '039A' ), & ! GREEK SMALL LETTER KAPPA => GREEK CAPITAL LETTER KAPPA int ( z '03BB' ), int ( z '039B' ), & ! GREEK SMALL LETTER LAMDA => GREEK CAPITAL LETTER LAMDA int ( z '03BC' ), int ( z '039C' ), & ! GREEK SMALL LETTER MU => GREEK CAPITAL LETTER MU int ( z '03BD' ), int ( z '039D' ), & ! GREEK SMALL LETTER NU => GREEK CAPITAL LETTER NU int ( z '03BE' ), int ( z '039E' ), & ! GREEK SMALL LETTER XI => GREEK CAPITAL LETTER XI int ( z '03BF' ), int ( z '039F' ), & ! GREEK SMALL LETTER OMICRON => GREEK CAPITAL LETTER OMICRON int ( z '03C0' ), int ( z '03A0' ), & ! GREEK SMALL LETTER PI => GREEK CAPITAL LETTER PI int ( z '03C1' ), int ( z '03A1' ), & ! GREEK SMALL LETTER RHO => GREEK CAPITAL LETTER RHO int ( z '03C3' ), int ( z '03A3' ), & ! GREEK SMALL LETTER SIGMA => GREEK CAPITAL LETTER SIGMA int ( z '03C4' ), int ( z '03A4' ), & ! GREEK SMALL LETTER TAU => GREEK CAPITAL LETTER TAU int ( z '03C5' ), int ( z '03A5' ), & ! GREEK SMALL LETTER UPSILON => GREEK CAPITAL LETTER UPSILON int ( z '03C6' ), int ( z '03A6' ), & ! GREEK SMALL LETTER PHI => GREEK CAPITAL LETTER PHI int ( z '03C7' ), int ( z '03A7' ), & ! GREEK SMALL LETTER CHI => GREEK CAPITAL LETTER CHI int ( z '03C8' ), int ( z '03A8' ), & ! GREEK SMALL LETTER PSI => GREEK CAPITAL LETTER PSI int ( z '03C9' ), int ( z '03A9' ), & ! GREEK SMALL LETTER OMEGA => GREEK CAPITAL LETTER OMEGA int ( z '03CA' ), int ( z '03AA' ), & ! GREEK SMALL LETTER IOTA WITH DIALYTIKA => GREEK CAPITAL LETTER IOTA WITH DIALYTIKA int ( z '03CB' ), int ( z '03AB' ), & ! GREEK SMALL LETTER UPSILON WITH DIALYTIKA => GREEK CAPITAL LETTER UPSILON WITH DIALYTIKA int ( z '03CC' ), int ( z '038C' ), & ! GREEK SMALL LETTER OMICRON WITH TONOS => GREEK CAPITAL LETTER OMICRON WITH TONOS int ( z '03CD' ), int ( z '038E' ), & ! GREEK SMALL LETTER UPSILON WITH TONOS => GREEK CAPITAL LETTER UPSILON WITH TONOS int ( z '03CE' ), int ( z '038F' ), & ! GREEK SMALL LETTER OMEGA WITH TONOS => GREEK CAPITAL LETTER OMEGA WITH TONOS int ( z '03E3' ), int ( z '03E2' ), & ! COPTIC SMALL LETTER SHEI => COPTIC CAPITAL LETTER SHEI int ( z '03E5' ), int ( z '03E4' ), & ! COPTIC SMALL LETTER FEI => COPTIC CAPITAL LETTER FEI int ( z '03E7' ), int ( z '03E6' ), & ! COPTIC SMALL LETTER KHEI => COPTIC CAPITAL LETTER KHEI int ( z '03E9' ), int ( z '03E8' ), & ! COPTIC SMALL LETTER HORI => COPTIC CAPITAL LETTER HORI int ( z '03EB' ), int ( z '03EA' ), & ! COPTIC SMALL LETTER GANGIA => COPTIC CAPITAL LETTER GANGIA int ( z '03ED' ), int ( z '03EC' ), & ! COPTIC SMALL LETTER SHIMA => COPTIC CAPITAL LETTER SHIMA int ( z '03EF' ), int ( z '03EE' ), & ! COPTIC SMALL LETTER DEI => COPTIC CAPITAL LETTER DEI int ( z '0430' ), int ( z '0410' ), & ! CYRILLIC SMALL LETTER A => CYRILLIC CAPITAL LETTER A int ( z '0431' ), int ( z '0411' ), & ! CYRILLIC SMALL LETTER BE => CYRILLIC CAPITAL LETTER BE int ( z '0432' ), int ( z '0412' ), & ! CYRILLIC SMALL LETTER VE => CYRILLIC CAPITAL LETTER VE int ( z '0433' ), int ( z '0413' ), & ! CYRILLIC SMALL LETTER GHE => CYRILLIC CAPITAL LETTER GHE int ( z '0434' ), int ( z '0414' ), & ! CYRILLIC SMALL LETTER DE => CYRILLIC CAPITAL LETTER DE int ( z '0435' ), int ( z '0415' ), & ! CYRILLIC SMALL LETTER IE => CYRILLIC CAPITAL LETTER IE int ( z '0436' ), int ( z '0416' ), & ! CYRILLIC SMALL LETTER ZHE => CYRILLIC CAPITAL LETTER ZHE int ( z '0437' ), int ( z '0417' ), & ! CYRILLIC SMALL LETTER ZE => CYRILLIC CAPITAL LETTER ZE int ( z '0438' ), int ( z '0418' ), & ! CYRILLIC SMALL LETTER I => CYRILLIC CAPITAL LETTER I int ( z '0439' ), int ( z '0419' ), & ! CYRILLIC SMALL LETTER SHORT I => CYRILLIC CAPITAL LETTER SHORT I int ( z '043A' ), int ( z '041A' ), & ! CYRILLIC SMALL LETTER KA => CYRILLIC CAPITAL LETTER KA int ( z '043B' ), int ( z '041B' ), & ! CYRILLIC SMALL LETTER EL => CYRILLIC CAPITAL LETTER EL int ( z '043C' ), int ( z '041C' ), & ! CYRILLIC SMALL LETTER EM => CYRILLIC CAPITAL LETTER EM int ( z '043D' ), int ( z '041D' ), & ! CYRILLIC SMALL LETTER EN => CYRILLIC CAPITAL LETTER EN int ( z '043E' ), int ( z '041E' ), & ! CYRILLIC SMALL LETTER O => CYRILLIC CAPITAL LETTER O int ( z '043F' ), int ( z '041F' ), & ! CYRILLIC SMALL LETTER PE => CYRILLIC CAPITAL LETTER PE int ( z '0440' ), int ( z '0420' ), & ! CYRILLIC SMALL LETTER ER => CYRILLIC CAPITAL LETTER ER int ( z '0441' ), int ( z '0421' ), & ! CYRILLIC SMALL LETTER ES => CYRILLIC CAPITAL LETTER ES int ( z '0442' ), int ( z '0422' ), & ! CYRILLIC SMALL LETTER TE => CYRILLIC CAPITAL LETTER TE int ( z '0443' ), int ( z '0423' ), & ! CYRILLIC SMALL LETTER U => CYRILLIC CAPITAL LETTER U int ( z '0444' ), int ( z '0424' ), & ! CYRILLIC SMALL LETTER EF => CYRILLIC CAPITAL LETTER EF int ( z '0445' ), int ( z '0425' ), & ! CYRILLIC SMALL LETTER HA => CYRILLIC CAPITAL LETTER HA int ( z '0446' ), int ( z '0426' ), & ! CYRILLIC SMALL LETTER TSE => CYRILLIC CAPITAL LETTER TSE int ( z '0447' ), int ( z '0427' ), & ! CYRILLIC SMALL LETTER CHE => CYRILLIC CAPITAL LETTER CHE int ( z '0448' ), int ( z '0428' ), & ! CYRILLIC SMALL LETTER SHA => CYRILLIC CAPITAL LETTER SHA int ( z '0449' ), int ( z '0429' ), & ! CYRILLIC SMALL LETTER SHCHA => CYRILLIC CAPITAL LETTER SHCHA int ( z '044A' ), int ( z '042A' ), & ! CYRILLIC SMALL LETTER HARD SIGN => CYRILLIC CAPITAL LETTER HARD SIGN int ( z '044B' ), int ( z '042B' ), & ! CYRILLIC SMALL LETTER YERU => CYRILLIC CAPITAL LETTER YERU int ( z '044C' ), int ( z '042C' ), & ! CYRILLIC SMALL LETTER SOFT SIGN => CYRILLIC CAPITAL LETTER SOFT SIGN int ( z '044D' ), int ( z '042D' ), & ! CYRILLIC SMALL LETTER E => CYRILLIC CAPITAL LETTER E int ( z '044E' ), int ( z '042E' ), & ! CYRILLIC SMALL LETTER YU => CYRILLIC CAPITAL LETTER YU int ( z '044F' ), int ( z '042F' ), & ! CYRILLIC SMALL LETTER YA => CYRILLIC CAPITAL LETTER YA int ( z '0451' ), int ( z '0401' ), & ! CYRILLIC SMALL LETTER IO => CYRILLIC CAPITAL LETTER IO int ( z '0452' ), int ( z '0402' ), & ! CYRILLIC SMALL LETTER DJE (SERBOCROATIAN) => CYRILLIC CAPITAL LETTER DJE (SERBOCROATIAN) int ( z '0453' ), int ( z '0403' ), & ! CYRILLIC SMALL LETTER GJE => CYRILLIC CAPITAL LETTER GJE int ( z '0454' ), int ( z '0404' ), & ! CYRILLIC SMALL LETTER UKRAINIAN IE => CYRILLIC CAPITAL LETTER UKRAINIAN IE int ( z '0455' ), int ( z '0405' ), & ! CYRILLIC SMALL LETTER DZE => CYRILLIC CAPITAL LETTER DZE int ( z '0456' ), int ( z '0406' ), & ! CYRILLIC SMALL LETTER BYELORUSSIAN-UKRAINIAN I => CYRILLIC CAPITAL LETTER BYELORUSSIAN_UKRAINIAN I int ( z '0457' ), int ( z '0407' ), & ! CYRILLIC SMALL LETTER YI (UKRAINIAN) => CYRILLIC CAPITAL LETTER YI (UKRAINIAN) int ( z '0458' ), int ( z '0408' ), & ! CYRILLIC SMALL LETTER JE => CYRILLIC CAPITAL LETTER JE int ( z '0459' ), int ( z '0409' ), & ! CYRILLIC SMALL LETTER LJE => CYRILLIC CAPITAL LETTER LJE int ( z '045A' ), int ( z '040A' ), & ! CYRILLIC SMALL LETTER NJE => CYRILLIC CAPITAL LETTER NJE int ( z '045B' ), int ( z '040B' ), & ! CYRILLIC SMALL LETTER TSHE (SERBOCROATIAN) => CYRILLIC CAPITAL LETTER TSHE (SERBOCROATIAN) int ( z '045C' ), int ( z '040C' ), & ! CYRILLIC SMALL LETTER KJE => CYRILLIC CAPITAL LETTER KJE int ( z '045E' ), int ( z '040E' ), & ! CYRILLIC SMALL LETTER SHORT U (BYELORUSSIAN) => CYRILLIC CAPITAL LETTER SHORT U (BYELORUSSIAN) int ( z '045F' ), int ( z '040F' ), & ! CYRILLIC SMALL LETTER DZHE => CYRILLIC CAPITAL LETTER DZHE int ( z '0461' ), int ( z '0460' ), & ! CYRILLIC SMALL LETTER OMEGA => CYRILLIC CAPITAL LETTER OMEGA int ( z '0463' ), int ( z '0462' ), & ! CYRILLIC SMALL LETTER YAT => CYRILLIC CAPITAL LETTER YAT int ( z '0465' ), int ( z '0464' ), & ! CYRILLIC SMALL LETTER IOTIFIED E => CYRILLIC CAPITAL LETTER IOTIFIED E int ( z '0467' ), int ( z '0466' ), & ! CYRILLIC SMALL LETTER LITTLE YUS => CYRILLIC CAPITAL LETTER LITTLE YUS int ( z '0469' ), int ( z '0468' ), & ! CYRILLIC SMALL LETTER IOTIFIED LITTLE YUS => CYRILLIC CAPITAL LETTER IOTIFIED LITTLE YUS int ( z '046B' ), int ( z '046A' ), & ! CYRILLIC SMALL LETTER BIG YUS => CYRILLIC CAPITAL LETTER BIG YUS int ( z '046D' ), int ( z '046C' ), & ! CYRILLIC SMALL LETTER IOTIFIED BIG YUS => CYRILLIC CAPITAL LETTER IOTIFIED BIG YUS int ( z '046F' ), int ( z '046E' ), & ! CYRILLIC SMALL LETTER KSI => CYRILLIC CAPITAL LETTER KSI int ( z '0471' ), int ( z '0470' ), & ! CYRILLIC SMALL LETTER PSI => CYRILLIC CAPITAL LETTER PSI int ( z '0473' ), int ( z '0472' ), & ! CYRILLIC SMALL LETTER FITA => CYRILLIC CAPITAL LETTER FITA int ( z '0475' ), int ( z '0474' ), & ! CYRILLIC SMALL LETTER IZHITSA => CYRILLIC CAPITAL LETTER IZHITSA int ( z '0477' ), int ( z '0476' ), & ! CYRILLIC SMALL LETTER IZHITSA WITH DOUBLE GRAVE ACCENT => CYRILLIC CAPITAL LETTER IZHITSA WITH DOUBLE GRAVE ACCENT int ( z '0479' ), int ( z '0478' ), & ! CYRILLIC SMALL LETTER UK => CYRILLIC CAPITAL LETTER UK int ( z '047B' ), int ( z '047A' ), & ! CYRILLIC SMALL LETTER ROUND OMEGA => CYRILLIC CAPITAL LETTER ROUND OMEGA int ( z '047D' ), int ( z '047C' ), & ! CYRILLIC SMALL LETTER OMEGA WITH TITLO => CYRILLIC CAPITAL LETTER OMEGA WITH TITLO int ( z '047F' ), int ( z '047E' ), & ! CYRILLIC SMALL LETTER OT => CYRILLIC CAPITAL LETTER OT int ( z '0481' ), int ( z '0480' ), & ! CYRILLIC SMALL LETTER KOPPA => CYRILLIC CAPITAL LETTER KOPPA int ( z '0491' ), int ( z '0490' ), & ! CYRILLIC SMALL LETTER GHE WITH UPTURN => CYRILLIC CAPITAL LETTER GHE WITH UPTURN int ( z '0493' ), int ( z '0492' ), & ! CYRILLIC SMALL LETTER GHE WITH STROKE => CYRILLIC CAPITAL LETTER GHE WITH STROKE int ( z '0495' ), int ( z '0494' ), & ! CYRILLIC SMALL LETTER GHE WITH MIDDLE HOOK => CYRILLIC CAPITAL LETTER GHE WITH MIDDLE HOOK int ( z '0497' ), int ( z '0496' ), & ! CYRILLIC SMALL LETTER ZHE WITH DESCENDER => CYRILLIC CAPITAL LETTER ZHE WITH DESCENDER int ( z '0499' ), int ( z '0498' ), & ! CYRILLIC SMALL LETTER ZE WITH DESCENDER => CYRILLIC CAPITAL LETTER ZE WITH DESCENDER int ( z '049B' ), int ( z '049A' ), & ! CYRILLIC SMALL LETTER KA WITH DESCENDER => CYRILLIC CAPITAL LETTER KA WITH DESCENDER int ( z '049D' ), int ( z '049C' ), & ! CYRILLIC SMALL LETTER KA WITH VERTICAL STROKE => CYRILLIC CAPITAL LETTER KA WITH VERTICAL STROKE int ( z '049F' ), int ( z '049E' ), & ! CYRILLIC SMALL LETTER KA WITH STROKE => CYRILLIC CAPITAL LETTER KA WITH STROKE int ( z '04A1' ), int ( z '04A0' ), & ! CYRILLIC SMALL LETTER EASHKIR KA => CYRILLIC CAPITAL LETTER BASHKIR KA int ( z '04A3' ), int ( z '04A2' ), & ! CYRILLIC SMALL LETTER EN WITH DESCENOER => CYRILLIC CAPITAL LETTER EN WITH DESCENDER int ( z '04A5' ), int ( z '04A4' ), & ! CYRILLIC SMALL LIGATURE EN GHE => CYRILLIC CAPITAL LIGATURE EN GHF int ( z '04A7' ), int ( z '04A6' ), & ! CYRILLIC SMALL LETTER PE WITH MIDDLE HOOK (ABKHASIAN) => CYRILLIC CAPITAL LETTER PE WITH MIDDLE HOOK (ABKHASIAN) int ( z '04A9' ), int ( z '04A8' ), & ! CYRILLIC SMALL LETTER ABKHASIAN HA => CYRILLIC CAPITAL LETTER ABKHASIAN HA int ( z '04AB' ), int ( z '04AA' ), & ! CYRILLIC SMALL LETTER ES WITH DESCENDER => CYRILLIC CAPITAL LETTER ES WITH DESCENDER int ( z '04AD' ), int ( z '04AC' ), & ! CYRILLIC SMALL LETTER TE WITH DESCENDER => CYRILLIC CAPITAL LETTER TE WITH DESCENDER int ( z '04AF' ), int ( z '04AE' ), & ! CYRILLIC SMALL LETTER STRAIGHT U => CYRILLIC CAPITAL LETTER STRAIGHT U int ( z '04B1' ), int ( z '04B0' ), & ! CYRILLIC SMALL LETTER STRAIGHT U WITH STROKE => CYRILLIC CAPITAL LETTER STRAIGHT U WITH STROKE int ( z '04B3' ), int ( z '04B2' ), & ! CYRILLIC SMALL LETTER HA WITH DESCENDER => CYRILLIC CAPITAL LETTER HA WITH DESCENDER int ( z '04B5' ), int ( z '04B4' ), & ! CYRILLIC SMALL LIGATURE TE TSE (ABKHASIAN) => CYRILLIC CAPITAL LIGATURE TE TSE (ABKHASIAN) int ( z '04B7' ), int ( z '04B6' ), & ! CYRILLIC SMALL LETTER CHE WITH DESCENDER => CYRILLIC CAPITAL LETTER CHE WITH DESCENDER int ( z '04B9' ), int ( z '04B8' ), & ! CYRILLIC SMALL LETTER CHE WITH VERTICAL STROKE => CYRILLIC CAPITAL LETTER CHE WITH VERTICAL STROKE int ( z '04BB' ), int ( z '04BA' ), & ! CYRILLIC SMALL LETTER SHHA => CYRILLIC CAPITAL LETTER SHHA int ( z '04BD' ), int ( z '04BC' ), & ! CYRILLIC SMALL LETTER ABKHASIAN CHE => CYRILLIC CAPITAL LETTER ABKHASIAN CHE int ( z '04BF' ), int ( z '04BE' ), & ! CYRILLIC SMALL LETTER ABKHASIAN CHE WITH DESCENDER => CYRILLIC CAPITAL LETTER ABKHASIAN CHE WITH DESCENDER int ( z '04C2' ), int ( z '04C1' ), & ! CYRILLIC SMALL LETTER ZHE WITH BREVE => CYRILLIC CAPITAL LETTER ZHE WITH BREVE int ( z '04C4' ), int ( z '04C3' ), & ! CYRILLIC SMALL LETTER KA WITH HOOK => CYRILLIC CAPITAL LETTER KA WITH HOOK int ( z '04C8' ), int ( z '04C7' ), & ! CYRILLIC SMALL LETTER EN WITH HOOK => CYRILLIC CAPITAL LETTER EN WITH HOOK int ( z '04CC' ), int ( z '04CB' ), & ! CYRILLIC SMALL LETTER KHAKASSIAN CHE => CYRILLIC CAPITAL LETTER KHAKASSIAN CHE int ( z '04D1' ), int ( z '04D0' ), & ! CYRILLIC SMALL LETTER A WITH BREVE => CYRILLIC CAPITAL LETTER A WITH BREVE int ( z '04D3' ), int ( z '04D2' ), & ! CYRILLIC SMALL LETTER A WITH DIAERESIS => CYRILLIC CAPITAL LETTER A WITH DIAERESIS int ( z '04D5' ), int ( z '04D4' ), & ! CYRILLIC SMALL LIGATURE A IE => CYRILLIC CAPITAL LIGATURE A IE int ( z '04D7' ), int ( z '04D6' ), & ! CYRILLIC SMALL LETTER IE WITH BREVE => CYRILLIC CAPITAL LETTER IE WITH BREVE int ( z '04D9' ), int ( z '04D8' ), & ! CYRILLIC SMALL LETTER SCHWA => CYRILLIC CAPITAL LETTER SCHWA int ( z '04DB' ), int ( z '04DA' ), & ! CYRILLIC SMALL LETTER SCHWA WITH DIAERESIS => CYRILLIC CAPITAL LETTER SCHWA WITH DIAERESIS int ( z '04DD' ), int ( z '04DC' ), & ! CYRILLIC SMALL LETTER ZHE WITH DIAERESIS => CYRILLIC CAPITAL LETTER ZHE WITH DIAERESIS int ( z '04DF' ), int ( z '04DE' ), & ! CYRILLIC SMALL LETTER ZE WITH DIAERESIS => CYRILLIC CAPITAL LETTER ZE WITH DIAERESIS int ( z '04E1' ), int ( z '04E0' ), & ! CYRILLIC SMALL LETTER ABKHASIAN DZE => CYRILLIC CAPITAL LETTER ABKHASIAN DZE int ( z '04E3' ), int ( z '04E2' ), & ! CYRILLIC SMALL LETTER I WITH MACRON => CYRILLIC CAPITAL LETTER I WITH MACRON int ( z '04E5' ), int ( z '04E4' ), & ! CYRILLIC SMALL LETTER I WITH DIAERESIS => CYRILLIC CAPITAL LETTER I WITH DIAERESIS int ( z '04E7' ), int ( z '04E6' ), & ! CYRILLIC SMALL LETTER O WITH DIAERESIS => CYRILLIC CAPITAL LETTER O WITH DIAERESIS int ( z '04E9' ), int ( z '04E8' ), & ! CYRILLIC SMALL LETTER BARRED O => CYRILLIC CAPITAL LETTER BARRED O int ( z '04EB' ), int ( z '04EA' ), & ! CYRILLIC SMALL LETTER BARRED O WITH DIAERESIS => CYRILLIC CAPITAL LETTER BARRED O WITH DIAERESIS int ( z '04EF' ), int ( z '04EE' ), & ! CYRILLIC SMALL LETTER U WITH MACRON => CYRILLIC CAPITAL LETTER U WITH MACRON int ( z '04F1' ), int ( z '04F0' ), & ! CYRILLIC SMALL LETTER U WITH DIAERESIS => CYRILLIC CAPITAL LETTER U WITH DIAERESIS int ( z '04F3' ), int ( z '04F2' ), & ! CYRILLIC SMALL LETTER U WITH DOUBLE ACUTE => CYRILLIC CAPITAL LETTER U WITH DOUBLE ACUTE int ( z '04F5' ), int ( z '04F4' ), & ! CYRILLIC SMALL LETTER CHE AITH DIAERESIS => CYRILLIC CAPITAL LETTER CHE WITH DIAERESIS int ( z '04F9' ), int ( z '04F8' ), & ! CYRILLIC SMALL LETTER YERU WITH DIAERESIS => CYRILLIC CAPITAL LETTER YERU WITH DIAERESIS int ( z '0561' ), int ( z '0531' ), & ! ARMENIAN SMALL LETTER AYB => ARMENIAN CAPITAL LETTER AYB int ( z '0562' ), int ( z '0532' ), & ! ARMENIAN SMALL LETTER BEN => ARMENIAN CAPITAL LETTER BEN int ( z '0563' ), int ( z '0533' ), & ! ARMENIAN SMALL LETTER GIM => ARMENIAN CAPITAL LETTER GIM int ( z '0564' ), int ( z '0534' ), & ! ARMENIAN SMALL LETTER DA => ARMENIAN CAPITAL LETTER DA int ( z '0565' ), int ( z '0535' ), & ! ARMENIAN SMALL LETTER ECH => ARMENIAN CAPITAL LETTER ECH int ( z '0566' ), int ( z '0536' ), & ! ARMENIAN SMALL LETTER ZA => ARMENIAN CAPITAL LETTER ZA int ( z '0567' ), int ( z '0537' ), & ! ARMENIAN SMALL LETTER EH => ARMENIAN CAPITAL LETTER EH int ( z '0568' ), int ( z '0538' ), & ! ARMENIAN SMALL LETTER ET => ARMENIAN CAPITAL LETTER ET int ( z '0569' ), int ( z '0539' ), & ! ARMENIAN SMALL LETTER TO => ARMENIAN CAPITAL LETTER TO int ( z '056A' ), int ( z '053A' ), & ! ARMENIAN SMALL LETTER ZHE => ARMENIAN CAPITAL LETTER ZHE int ( z '056B' ), int ( z '053B' ), & ! ARMENIAN SMALL LETTER INI => ARMENIAN CAPITAL LETTER INI int ( z '056C' ), int ( z '053C' ), & ! ARMENIAN SMALL LETTER LIWN => ARMENIAN CAPITAL LETTER LIWN int ( z '056D' ), int ( z '053D' ), & ! ARMENIAN SMALL LETTER XEH => ARMENIAN CAPITAL LETTER XEH int ( z '056E' ), int ( z '053E' ), & ! ARMENIAN SMALL LETTER CA => ARMENIAN CAPITAL LETTER CA int ( z '056F' ), int ( z '053F' ), & ! ARMENIAN SMALL LETTER KEN => ARMENIAN CAPITAL LETTER KEN int ( z '0570' ), int ( z '0540' ), & ! ARMENIAN SMALL LETTER HO => ARMENIAN CAPITAL LETTER HO int ( z '0571' ), int ( z '0541' ), & ! ARMENIAN SMALL LETTER JA => ARMENIAN CAPITAL LETTER JA int ( z '0572' ), int ( z '0542' ), & ! ARMENIAN SMALL LETTER GHAD => ARMENIAN CAPITAL LETTER GHAD int ( z '0573' ), int ( z '0543' ), & ! ARMENIAN SMALL LETTER CHEH => ARMENIAN CAPITAL LETTER CHEH int ( z '0574' ), int ( z '0544' ), & ! ARMENIAN SMALL LETTER MEN => ARMENIAN CAPITAL LETTER MEN int ( z '0575' ), int ( z '0545' ), & ! ARMENIAN SMALL LETTER YI => ARMENIAN CAPITAL LETTER YI int ( z '0576' ), int ( z '0546' ), & ! ARMENIAN SMALL LETTER NOW => ARMENIAN CAPITAL LETTER NOW int ( z '0577' ), int ( z '0547' ), & ! ARMENIAN SMALL LETTER SNA => ARMENIAN CAPITAL LETTER SHA int ( z '0578' ), int ( z '0548' ), & ! ARMENIAN SMALL LETTER VO => ARMENIAN CAPITAL LETTER VO int ( z '0579' ), int ( z '0549' ), & ! ARMENIAN SMALL LETTER CHA => ARMENIAN CAPITAL LETTER CHA int ( z '057A' ), int ( z '054A' ), & ! ARMENIAN SMALL LETTER PEH => ARMENIAN CAPITAL LETTER PEH int ( z '057B' ), int ( z '054B' ), & ! ARMENIAN SMALL LETTER JHEH => ARMENIAN CAPITAL LETTER JHEH int ( z '057C' ), int ( z '054C' ), & ! ARMENIAN SMALL LETTER RA => ARMENIAN CAPITAL LETTER RA int ( z '057D' ), int ( z '054D' ), & ! ARMENIAN SMALL LETTER SEH => ARMENIAN CAPITAL LETTER SEH int ( z '057E' ), int ( z '054E' ), & ! ARMENIAN SMALL LETTER VEW => ARMENIAN CAPITAL LETTER VEW int ( z '057F' ), int ( z '054F' ), & ! ARMENIAN SMALL LETTER TIWN => ARMENIAN CAPITAL LETTER TIWN int ( z '0580' ), int ( z '0550' ), & ! ARMENIAN SMALL LETTER REH => ARMENIAN CAPITAL LETTER REH int ( z '0581' ), int ( z '0551' ), & ! ARMENIAN SMALL LETTER CO => ARMENIAN CAPITAL LETTER CO int ( z '0582' ), int ( z '0552' ), & ! ARMENIAN SMALL LETTER YIWN => ARMENIAN CAPITAL LETTER YIWN int ( z '0583' ), int ( z '0553' ), & ! ARMENIAN SMALL LETTER PIWP => ARMENIAN CAPITAL LETTER PIWR int ( z '0584' ), int ( z '0554' ), & ! ARMENIAN SMALL LETTER KEH => ARMENIAN CAPITAL LETTER KEH int ( z '0585' ), int ( z '0555' ), & ! ARMENIAN SMALL LETTER OH => ARMENIAN CAPITAL LETTER OH int ( z '0586' ), int ( z '0556' ), & ! ARMENIAN SMALL LETTER FEH => ARMENIAN CAPITAL LETTER FEH int ( z '10D0' ), int ( z '10A0' ), & ! GEORGIAN LETTER AN => GEORGIAN CAPITAL LETTER AN (KHUTSURI) int ( z '10D1' ), int ( z '10A1' ), & ! GEORGIAN LETTER BAN => GEORGIAN CAPITAL LETTER BAN (KHUTSURI) int ( z '10D2' ), int ( z '10A2' ), & ! GEORGIAN LETTER GAN => GEORGIAN CAPITAL LETTER GAN (KHUTSURI) int ( z '10D3' ), int ( z '10A3' ), & ! GEORGIAN LETTER DON => GEORGIAN CAPITAL LETTER DON (KHUTSURI) int ( z '10D4' ), int ( z '10A4' ), & ! GEORGIAN LETTER EN => GEORGIAN CAPITAL LETTER EN (KHUTSURI) int ( z '10D5' ), int ( z '10A5' ), & ! GEORGIAN LETTER VIN => GEORGIAN CAPITAL LETTER VIN (KHUTSURI) int ( z '10D6' ), int ( z '10A6' ), & ! GEORGIAN LETTER ZEN => GEORGIAN CAPITAL LETTER ZEN (KHUTSURI) int ( z '10D7' ), int ( z '10A7' ), & ! GEORGIAN LETTER TAN => GEORGIAN CAPITAL LETTER TAN (KHUTSURI) int ( z '10D8' ), int ( z '10A8' ), & ! GEORGIAN LETTER IN => GEORGIAN CAPITAL LETTER IN (KHUTSURI) int ( z '10D9' ), int ( z '10A9' ), & ! GEORGIAN LETTER KAN => GEORGIAN CAPITAL LETTER KAN (KHUTSURI) int ( z '10DA' ), int ( z '10AA' ), & ! GEORGIAN LETTER LAS => GEORGIAN CAPITAL LETTER LAS (KHUTSURI) int ( z '10DB' ), int ( z '10AB' ), & ! GEORGIAN LETTER MAN => GEORGIAN CAPITAL LETTER MAN (KHUTSURI) int ( z '10DC' ), int ( z '10AC' ), & ! GEORGIAN LETTER NAR => GEORGIAN CAPITAL LETTER NAR (KHUTSURI) int ( z '10DD' ), int ( z '10AD' ), & ! GEORGIAN LETTER ON => GEORGIAN CAPITAL LETTER ON (KHUTSURI) int ( z '10DE' ), int ( z '10AE' ), & ! GEORGIAN LETTER PAR => GEORGIAN CAPITAL LETTER PAR (KHUTSURI) int ( z '10DF' ), int ( z '10AF' ), & ! GEORGIAN LETTER ZHAR => GEORGIAN CAPITAL LETTER ZHAR (KHUTSURI) int ( z '10E0' ), int ( z '10B0' ), & ! GEORGIAN LETTER RAE => GEORGIAN CAPITAL LETTER RAE (KHUTSURI) int ( z '10E1' ), int ( z '10B1' ), & ! GEORGIAN LETTER SAN => GEORGIAN CAPITAL LETTER SAN (KHUTSURI) int ( z '10E2' ), int ( z '10B2' ), & ! GEORGIAN LETTER TAR => GEORGIAN CAPITAL LETTER TAR (KHUTSURI) int ( z '10E3' ), int ( z '10B3' ), & ! GEORGIAN LETTER UN => GEORGIAN CAPITAL LETTER UN (KHUTSURI) int ( z '10E4' ), int ( z '10B4' ), & ! GEORGIAN LETTER PHAR => GEORGIAN CAPITAL LETTER PHAR (KHUTSURI) int ( z '10E5' ), int ( z '10B5' ), & ! GEORGIAN LETTER KHAR => GEORGIAN CAPITAL LETTER KHAR (KHUTSURI) int ( z '10E6' ), int ( z '10B6' ), & ! GEORGIAN LETTER GHAN => GEORGIAN CAPITAL LETTER GHAN (KHUTSURI) int ( z '10E7' ), int ( z '10B7' ), & ! GEORGIAN LETTER QAR => GEORGIAN CAPITAL LETTER QAR (KHUTSURI) int ( z '10E8' ), int ( z '10B8' ), & ! GEORGIAN LETTER SHIN => GEORGIAN CAPITAL LETTER SHIN (KHUTSURI) int ( z '10E9' ), int ( z '10B9' ), & ! GEORGIAN LETTER CHIN => GEORGIAN CAPITAL LETTER CHIN (KHUTSURI) int ( z '10EA' ), int ( z '10BA' ), & ! GEORGIAN LETTER CAN => GEORGIAN CAPITAL LETTER CAN (KHUTSURI) int ( z '10EB' ), int ( z '10BB' ), & ! GEORGIAN LETTER JIL => GEORGIAN CAPITAL LETTER JIL (KHUTSURI) int ( z '10EC' ), int ( z '10BC' ), & ! GEORGIAN LETTER CIL => GEORGIAN CAPITAL LETTER CIL (KHUTSURI) int ( z '10ED' ), int ( z '10BD' ), & ! GEORGIAN LETTER CHAR => GEORGIAN CAPITAL LETTER CHAR (KHUTSURI) int ( z '10EE' ), int ( z '10BE' ), & ! GEORGIAN LETTER XAN => GEORGIAN CAPITAL LETTER XAN (KHUTSURI) int ( z '10EF' ), int ( z '10BF' ), & ! GEORGIAN LETTER JHAN => GEORGIAN CAPITAL LETTER JHAN (KHUTSURI) int ( z '10F0' ), int ( z '10C0' ), & ! GEORGIAN LETTER HAE => GEORGIAN CAPITAL LETTER HAE (KHUTSURI) int ( z '10F1' ), int ( z '10C1' ), & ! GEORGIAN LETTER HE => GEORGIAN CAPITAL LETTER HE (KHUTSURI) int ( z '10F2' ), int ( z '10C2' ), & ! GEORGIAN LETTER HIE => GEORGIAN CAPITAL LETTER HIE (KHUTSURI) int ( z '10F3' ), int ( z '10C3' ), & ! GEORGIAN LETTER WE => GEORGIAN CAPITAL LETTER WE (KHUTSURI) int ( z '10F4' ), int ( z '10C4' ), & ! GEORGIAN LETTER HAR => GEORGIAN CAPITAL LETTER HAR (KHUTSURI) int ( z '10F5' ), int ( z '10C5' ), & ! GEORGIAN LETTER HOE => GEORGIAN CAPITAL LETTER HOE (KHUTSURI) int ( z '1E01' ), int ( z '1E00' ), & ! LATIN SMALL LETTER A WITH RING BELOW => LATIN CAPITAL LETTER A WITH RING BELOW int ( z '1E03' ), int ( z '1E02' ), & ! LATIN SMALL LETTER B WITH DOT ABOVE => LATIN CAPITAL LETTER B WITH DOT ABOVE int ( z '1E05' ), int ( z '1E04' ), & ! LATIN SMALL LETTER B WITH DOT BELOW => LATIN CAPITAL LETTER B WITH DOT BELOW int ( z '1E07' ), int ( z '1E06' ), & ! LATIN SMALL LETTER B WITH LINE BELOW => LATIN CAPITAL LETTER B WITH LINE BELOW int ( z '1E09' ), int ( z '1E08' ), & ! LATIN SMALL LETTER C WITH CEDILLA AND ACUTE => LATIN CAPITAL LETTER C WITH CEDILLA AND ACUTE int ( z '1E0B' ), int ( z '1E0A' ), & ! LATIN SMALL LETTER D WITH DOT ABOVE => LATIN CAPITAL LETTER D WITH DOT ABOVE int ( z '1E0D' ), int ( z '1E0C' ), & ! LATIN SMALL LETTER D WITH DOT BELOW => LATIN CAPITAL LETTER D WITH DOT BELOW int ( z '1E0F' ), int ( z '1E0E' ), & ! LATIN SMALL LETTER D WITH LINE BELOW => LATIN CAPITAL LETTER D WITH LINE BELOW int ( z '1E11' ), int ( z '1E10' ), & ! LATIN SMALL LETTER D WITH CEDILLA => LATIN CAPITAL LETTER D WITH CEDILLA int ( z '1E13' ), int ( z '1E12' ), & ! LATIN SMALL LETTER D WITH CIRCUMFLEX BELOW => LATIN CAPITAL LETTER D WITH CIRCUMFLEX BELOW int ( z '1E15' ), int ( z '1E14' ), & ! LATIN SMALL LETTER E WITH MACRON AND GRAVE => LATIN CAPITAL LETTER E WITH MACRON AND GRAVE int ( z '1E17' ), int ( z '1E16' ), & ! LATIN SMALL LETTER E WITH MACRON AND ACUTE => LATIN CAPITAL LETTER E WITH MACRON AND ACUTE int ( z '1E19' ), int ( z '1E18' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX BELOW => LATIN CAPITAL LETTER E WITH CIRCUMFLEX BELOW int ( z '1E1B' ), int ( z '1E1A' ), & ! LATIN SMALL LETTER E WITH TILDE BELOW => LATIN CAPITAL LETTER E WITH TILDE BELOW int ( z '1E1D' ), int ( z '1E1C' ), & ! LATIN SMALL LETTER E WITH CEDILLA AND BREVE => LATIN CAPITAL LETTER E WITH CEDILLA AND BREVE int ( z '1E1F' ), int ( z '1E1E' ), & ! LATIN SMALL LETTER F WITH DOT ABOVE => LATIN CAPITAL LETTER F WITH DOT ABOVE int ( z '1E21' ), int ( z '1E20' ), & ! LATIN SMALL LETTER G WITH MACRON => LATIN CAPITAL LETTER G WITH MACRON int ( z '1E23' ), int ( z '1E22' ), & ! LATIN SMALL LETTER H WITH DOT ABOVE => LATIN CAPITAL LETTER H WITH DOT ABOVE int ( z '1E25' ), int ( z '1E24' ), & ! LATIN SMALL LETTER H WITH DOT BELOW => LATIN CAPITAL LETTER H WITH DOT BELOW int ( z '1E27' ), int ( z '1E26' ), & ! LATIN SMALL LETTER H WITH DIAERESIS => LATIN CAPITAL LETTER H WITH DIAERESIS int ( z '1E29' ), int ( z '1E28' ), & ! LATIN SMALL LETTER H WITH CEDILLA => LATIN CAPITAL LETTER H WITH CEDILLA int ( z '1E2B' ), int ( z '1E2A' ), & ! LATIN SMALL LETTER H WITH BREVE BELOW => LATIN CAPITAL LETTER H WITH BREVE BELOW int ( z '1E2D' ), int ( z '1E2C' ), & ! LATIN SMALL LETTER I WITH TILDE BELOW => LATIN CAPITAL LETTER I WITH TILDE BELOW int ( z '1E2F' ), int ( z '1E2E' ), & ! LATIN SMALL LETTER I WITH DIAERESIS AND ACUTE => LATIN CAPITAL LETTER I WITH DIAERESIS AND ACUTE int ( z '1E31' ), int ( z '1E30' ), & ! LATIN SMALL LETTER K WITH ACUTE => LATIN CAPITAL LETTER K WITH ACUTE int ( z '1E33' ), int ( z '1E32' ), & ! LATIN SMALL LETTER K WITH DOT BELOW => LATIN CAPITAL LETTER K WITH DOT BELOW int ( z '1E35' ), int ( z '1E34' ), & ! LATIN SMALL LETTER K WITH LINE BELOW => LATIN CAPITAL LETTER K WITH LINE BELOW int ( z '1E37' ), int ( z '1E36' ), & ! LATIN SMALL LETTER L WITH DOT BELOW => LATIN CAPITAL LETTER L WITH DOT BELOW int ( z '1E39' ), int ( z '1E38' ), & ! LATIN SMALL LETTER L WITH DOT BELOW AND MACRON => LATIN CAPITAL LETTER L WITH DOT BELOW AND MACRON int ( z '1E3B' ), int ( z '1E3A' ), & ! LATIN SMALL LETTER L WITH LINE BELOW => LATIN CAPITAL LETTER L WITH LINE BELOW int ( z '1E3D' ), int ( z '1E3C' ), & ! LATIN SMALL LETTER L WITH CIRCUMFLEX BELOW => LATIN CAPITAL LETTER L WITH CIRCUMFLEX BELOW int ( z '1E3F' ), int ( z '1E3E' ), & ! LATIN SMALL LETTER M WITH ACUTE => LATIN CAPITAL LETTER M WITH ACUTE int ( z '1E41' ), int ( z '1E40' ), & ! LATIN SMALL LETTER M WITH DOT ABOVE => LATIN CAPITAL LETTER M WITH DOT ABOVE int ( z '1E43' ), int ( z '1E42' ), & ! LATIN SMALL LETTER M WITH DOT BELOW => LATIN CAPITAL LETTER M WITH DOT BELOW int ( z '1E45' ), int ( z '1E44' ), & ! LATIN SMALL LETTER N WITH DOT ABOVE => LATIN CAPITAL LETTER N WITH DOT ABOVE int ( z '1E47' ), int ( z '1E46' ), & ! LATIN SMALL LETTER N WITH DOT BELOW => LATIN CAPITAL LETTER N WITH DOT BELOW int ( z '1E49' ), int ( z '1E48' ), & ! LATIN SMALL LETTER N WITH LINE BELOW => LATIN CAPITAL LETTER N WITH LINE BELOW int ( z '1E4B' ), int ( z '1E4A' ), & ! LATIN SMALL LETTER N WITH CIRCUMFLEX BELOW => LATIN CAPITAL LETTER N WITH CIRCUMFLEX BELOW int ( z '1E4D' ), int ( z '1E4C' ), & ! LATIN SMALL LETTER O WITH TILDE AND ACUTE => LATIN CAPITAL LETTER O WITH TILDE AND ACUTE int ( z '1E4F' ), int ( z '1E4E' ), & ! LATIN SMALL LETTER O WITH TlLDE AND DIAERESIS => LATIN CAPITAL LETTER O WITH TILDE AND DIAERESIS int ( z '1E51' ), int ( z '1E50' ), & ! LATIN SMALL LETTER O WITH MACRON AND GRAVE => LATIN CAPITAL LETTER O WITH MACRON AND GRAVE int ( z '1E53' ), int ( z '1E52' ), & ! LATIN SMALL LETTER O WITH MACRON AND ACUTE => LATIN CAPITAL LETTER O WITH MACRON AND ACUTE int ( z '1E55' ), int ( z '1E54' ), & ! LATIN SMALL LETTER P WITH ACUTE => LATIN CAPITAL LETTER P WITH ACUTE int ( z '1E57' ), int ( z '1E56' ), & ! LATIN SMALL LETTER P WITH DOT ABOVE => LATIN CAPITAL LETTER P WITH DOT ABOVE int ( z '1E59' ), int ( z '1E58' ), & ! LATIN SMALL LETTER R WITH DOT ABOVE => LATIN CAPITAL LETTER R WITH DOT ABOVE int ( z '1E5B' ), int ( z '1E5A' ), & ! LATIN SMALL LETTER R WITH DOT BELOW => LATIN CAPITAL LETTER R WITH DOT BELOW int ( z '1E5D' ), int ( z '1E5C' ), & ! LATIN SMALL LETTER R WITH DOT BELOW AND MACRON => LATIN CAPITAL LETTER R WITH DOT BELOW AND MACRON int ( z '1E5F' ), int ( z '1E5E' ), & ! LATIN SMALL LETTER R WITH LINE BELOW => LATIN CAPITAL LETTER R WITH LINE BELOW int ( z '1E61' ), int ( z '1E60' ), & ! LATIN SMALL LETTER S WITH DOT ABOVE => LATIN CAPITAL LETTER S WITH DOT ABOVE int ( z '1E63' ), int ( z '1E62' ), & ! LATIN SMALL LETTER S WITH DOT BELOW => LATIN CAPITAL LETTER S WITH DOT BELOW int ( z '1E65' ), int ( z '1E64' ), & ! LATIN SMALL LETTER S WITH ACUTE AND DOT ABOVE => LATIN CAPITAL LETTER S WITH ACUTE AND DOT ABOVE int ( z '1E67' ), int ( z '1E66' ), & ! LATIN SMALL LETTER S WITH CARON AND DOT ABOVE => LATIN CAPITAL LETTER S WITH CARON AND DOT ABOVE int ( z '1E69' ), int ( z '1E68' ), & ! LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE => LATIN CAPITAL LETTER S WITH DOT BELOW AND DOT ABOVE int ( z '1E6B' ), int ( z '1E6A' ), & ! LATIN SMALL LETTER T WITH DOT ABOVE => LATIN CAPITAL LETTER T WITH DOT ABOVE int ( z '1E6D' ), int ( z '1E6C' ), & ! LATIN SMALL LETTER T WITH DOT BELOW => LATIN CAPITAL LETTER T WITH DOT BELOW int ( z '1E6F' ), int ( z '1E6E' ), & ! LATIN SMALL LETTER T WITH LINE BELOW => LATIN CAPITAL LETTER T WITH LINE BELOW int ( z '1E71' ), int ( z '1E70' ), & ! LATIN SMALL LETTER T WITH CIRCUMFLEX BELOW => LATIN CAPITAL LETTER T WITH CIRCUMFLEX BELOW int ( z '1E73' ), int ( z '1E72' ), & ! LATIN SMALL LETTER U WITH DIAERESIS BELOW => LATIN CAPITAL LETTER U WITH DIAERESIS BELOW int ( z '1E75' ), int ( z '1E74' ), & ! LATIN SMALL LETTER U WITH TILDE BELOW => LATIN CAPITAL LETTER U WITH TILDE BELOW int ( z '1E77' ), int ( z '1E76' ), & ! LATIN SMALL LETTER U WITH CIRCUMFLEX BELOW => LATIN CAPITAL LETTER U WITH CIRCUMFLEX BELOW int ( z '1E79' ), int ( z '1E78' ), & ! LATIN SMALL LETTER U WITH TILDE AND ACUTE => LATIN CAPITAL LETTER U WITH TILDE AND ACUTE int ( z '1E7B' ), int ( z '1E7A' ), & ! LATIN SMALL LETTER U WITH MACRON AND DIAERESIS => LATIN CAPITAL LETTER U WITH MACRON AND DIAERESIS int ( z '1E7D' ), int ( z '1E7C' ), & ! LATIN SMALL LETTER V WITH TILDE => LATIN CAPITAL LETTER V WITH TILDE int ( z '1E7F' ), int ( z '1E7E' ), & ! LATIN SMALL LETTER V WITH DOT BELOW => LATIN CAPITAL LETTER V WITH DOT BELOW int ( z '1E81' ), int ( z '1E80' ), & ! LATIN SMALL LETTER W WITH GRAVE => LATIN CAPITAL LETTER W WITH GRAVE int ( z '1E83' ), int ( z '1E82' ), & ! LATIN SMALL LETTER W WITH ACUTE => LATIN CAPITAL LETTER W WITH ACUTE int ( z '1E85' ), int ( z '1E84' ), & ! LATIN SMALL LETTER W WITH DIAERESIS => LATIN CAPITAL LETTER W WITH DIAERESIS int ( z '1E87' ), int ( z '1E86' ), & ! LATIN SMALL LETTER W WITH DOT ABOVE => LATIN CAPITAL LETTER W WITH DOT ABOVE int ( z '1E89' ), int ( z '1E88' ), & ! LATIN SMALL LETTER W WITH DOT BELOW => LATIN CAPITAL LETTER W WITH DOT BELOW int ( z '1E8B' ), int ( z '1E8A' ), & ! LATIN SMALL LETTER X WITH DOT ABOVE => LATIN CAPITAL LETTER X WITH DOT ABOVE int ( z '1E8D' ), int ( z '1E8C' ), & ! LATIN SMALL LETTER X WITH DIAERESIS => LATIN CAPITAL LETTER X5 WITH DIAERESIS int ( z '1E8F' ), int ( z '1E8E' ), & ! LATIN SMALL LETTER Y WITH DOT ABOVE => LATIN CAPITAL LETTER Y WITH DOT ABOVE int ( z '1E91' ), int ( z '1E90' ), & ! LATIN SMALL LETTER Z WITH CIRCUMFLEX => LATIN CAPITAL LETTER Z WITH CIRCUMFLEX int ( z '1E93' ), int ( z '1E92' ), & ! LATIN SMALL LETTER Z WITH DOT BELOW => LATIN CAPITAL LETTER Z WITH DOT BELOW int ( z '1E95' ), int ( z '1E94' ), & ! LATIN SMALL LETTER Z WITH LINE BELOW => LATIN CAPITAL LETTER Z WITH LINE BELOW int ( z '1EA1' ), int ( z '1EA0' ), & ! LATIN SMALL LETTER A WITH DOT BELOW => LATIN CAPITAL LETTER A WITH DOT BELOW int ( z '1EA3' ), int ( z '1EA2' ), & ! LATIN SMALL LETTER A WITH HOOK ABOVE => LATIN CAPITAL LETTER A WITH HOOK ABOVE int ( z '1EA5' ), int ( z '1EA4' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE => LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE int ( z '1EA7' ), int ( z '1EA6' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND GRAVE => LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND GRAVE int ( z '1EA9' ), int ( z '1EA8' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE => LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE int ( z '1EAB' ), int ( z '1EAA' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND TILDE => LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND TILDE int ( z '1EAD' ), int ( z '1EAC' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND DOT BELOW => LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND DOT BELOW int ( z '1EAF' ), int ( z '1EAE' ), & ! LATIN SMALL LETTER A WITH BREVE AND ACUTE => LATIN CAPITAL LETTER A WITH BREVE AND ACUTE int ( z '1EB1' ), int ( z '1EB0' ), & ! LATIN SMALL LETTER A WITH BREVE AND GRAVE => LATIN CAPITAL LETTER A WITH BREVE AND GRAVE int ( z '1EB3' ), int ( z '1EB2' ), & ! LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE => LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE int ( z '1EB5' ), int ( z '1EB4' ), & ! LATIN SMALL LETTER A WITH BREVE AND TILDE => LATIN CAPITAL LETTER A WITH BREVE AND TILDE int ( z '1EB7' ), int ( z '1EB6' ), & ! LATIN SMALL LETTER A WITH BREVE AND DOT BELOW => LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW int ( z '1EB9' ), int ( z '1EB8' ), & ! LATIN SMALL LETTER E WITH DOT BELOW => LATIN CAPITAL LETTER E WITH DOT BELOW int ( z '1EBB' ), int ( z '1EBA' ), & ! LATIN SMALL LETTER E WITH HOOK ABOVE => LATIN CAPITAL LETTER E WITH HOOK ABOVE int ( z '1EBD' ), int ( z '1EBC' ), & ! LATIN SMALL LETTER E WITH TILDE => LATIN CAPITAL LETTER E WITH TILDE int ( z '1EBF' ), int ( z '1EBE' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE => LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE int ( z '1EC1' ), int ( z '1EC0' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND GRAVE => LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE int ( z '1EC3' ), int ( z '1EC2' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE => LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE int ( z '1EC5' ), int ( z '1EC4' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND TILDE => LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND TILDE int ( z '1EC7' ), int ( z '1EC6' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW => LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND DOT BELOW int ( z '1EC9' ), int ( z '1EC8' ), & ! LATIN SMALL LETTER I WITH HOOK ABOVE => LATIN CAPITAL LETTER I WITH HOOK ABOVE int ( z '1ECB' ), int ( z '1ECA' ), & ! LATIN SMALL LETTER I WITH DOT BELOW => LATIN CAPITAL LETTER I WITH DOT BELOW int ( z '1ECD' ), int ( z '1ECC' ), & ! LATIN SMALL LETTER O WITH DOT BELOW => LATIN CAPITAL LETTER O WITH DOT BELOW int ( z '1ECF' ), int ( z '1ECE' ), & ! LATIN SMALL LETTER O WITH HOOK ABOVE => LATIN CAPITAL LETTER O WITH HOOK ABOVE int ( z '1ED1' ), int ( z '1ED0' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE => LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE int ( z '1ED3' ), int ( z '1ED2' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND GRAVE => LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND GRAVE int ( z '1ED5' ), int ( z '1ED4' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE => LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE int ( z '1ED7' ), int ( z '1ED6' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND TILDE => LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND TILDE int ( z '1ED9' ), int ( z '1ED8' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW => LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND DOT BELOW int ( z '1EDB' ), int ( z '1EDA' ), & ! LATIN SMALL LETTER O WITH HORN AND ACUTE => LATIN CAPITAL LETTER O WITH HORN AND ACUTE int ( z '1EDD' ), int ( z '1EDC' ), & ! LATIN SMALL LETTER O WITH HORN AND GRAVE => LATIN CAPITAL LETTER O WITH HORN AND GRAVE int ( z '1EDF' ), int ( z '1EDE' ), & ! LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE => LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE int ( z '1EE1' ), int ( z '1EE0' ), & ! LATIN SMALL LETTER O WITH HORN AND TILDE => LATIN CAPITAL LETTER O WITH HORN AND TILDE int ( z '1EE3' ), int ( z '1EE2' ), & ! LATIN SMALL LETTER O WITH HORN AND DOT BELOW => LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW int ( z '1EE5' ), int ( z '1EE4' ), & ! LATIN SMALL LETTER U WITH DOT BELOW => LATIN CAPITAL LETTER U WITH DOT BELOW int ( z '1EE7' ), int ( z '1EE6' ), & ! LATIN SMALL LETTER U WITH HOOK ABOVE => LATIN CAPITAL LETTER U WITH HOOK ABOVE int ( z '1EE9' ), int ( z '1EE8' ), & ! LATIN SMALL LETTER U WITH HORN AND ACUTE => LATIN CAPITAL LETTER U WITH HORN AND ACUTE int ( z '1EEB' ), int ( z '1EEA' ), & ! LATIN SMALL LETTER U WITH HORN AND GRAVE => LATIN CAPITAL LETTER U WITH HORN AND GRAVE int ( z '1EED' ), int ( z '1EEC' ), & ! LATIN SMALL LETTER U WITH HORN AND HOCK ABOVE => LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE int ( z '1EEF' ), int ( z '1EEE' ), & ! LATIN SMALL LETTER U WITH HORN AND TILDE => LATIN CAPITAL LETTER U WITH HORN AND TILDE int ( z '1EF1' ), int ( z '1EF0' ), & ! LATIN SMALL LETTER U WITH HORN AND DOT BELOW => LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW int ( z '1EF3' ), int ( z '1EF2' ), & ! LATIN SMALL LETTER Y WITH GRAVE => LATIN CAPITAL LETTER Y WITH GRAVE int ( z '1EF5' ), int ( z '1EF4' ), & ! LATIN SMALL LETTER Y WITH DOT BELOW => LATIN CAPITAL LETTER Y WITH DOT BELOW int ( z '1EF7' ), int ( z '1EF6' ), & ! LATIN SMALL LETTER Y WITH HOOK ABOVE => LATIN CAPITAL LETTER Y WITH HOOK ABOVE int ( z '1EF9' ), int ( z '1EF8' ), & ! LATIN SMALL LETTER Y WITH TILDE => LATIN CAPITAL LETTER Y WITH TILDE int ( z '1F00' ), int ( z '1F08' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI => GREEK CAPITAL LETTER ALPHA WITH PSILI int ( z '1F01' ), int ( z '1F09' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA => GREEK CAPITAL LETTER ALPHA WITH DASIA int ( z '1F02' ), int ( z '1F0A' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA => GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA int ( z '1F03' ), int ( z '1F0B' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA => GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA int ( z '1F04' ), int ( z '1F0C' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA => GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA int ( z '1F05' ), int ( z '1F0D' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA => GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA int ( z '1F06' ), int ( z '1F0E' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI => GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI int ( z '1F07' ), int ( z '1F0F' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI => GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI int ( z '1F10' ), int ( z '1F18' ), & ! GREEK SMALL LETTER EPSILON WITH PSILI => GREEK CAPITAL LETTER EPSILON WITH PSILI int ( z '1F11' ), int ( z '1F19' ), & ! GREEK SMALL LETTER EPSILON WITH DASIA => GREEK CAPITAL LETTER EPSILON WITH DASIA int ( z '1F12' ), int ( z '1F1A' ), & ! GREEK SMALL LETTER EPSILON WITH PSILI AND VARIA => GREEK CAPITAL LETTER EPSILON WITH PSILI AND VARIA int ( z '1F13' ), int ( z '1F1B' ), & ! GREEK SMALL LETTER EPSILON WITH DASIA AND VARIA => GREEK CAPITAL LETTER EPSILON WITH DASIA AND VARIA int ( z '1F14' ), int ( z '1F1C' ), & ! GREEK SMALL LETTER EPSILON WITH PSILI AND OXIA => GREEK CAPITAL LETTER EPSILON WITH PSILI AND OXIA int ( z '1F15' ), int ( z '1F1D' ), & ! GREEK SMALL LETTER EPSILON WITH DASIA AND OXIA => GREEK CAPITAL LETTER EPSILON WITH DASIA AND OXIA int ( z '1F20' ), int ( z '1F28' ), & ! GREEK SMALL LETTER ETA WITH PSILI => GREEK CAPITAL LETTER ETA WITH PSILI int ( z '1F21' ), int ( z '1F29' ), & ! GREEK SMALL LETTER ETA WITH DASIA => GREEK CAPITAL LETTER ETA WITH DASIA int ( z '1F22' ), int ( z '1F2A' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND VARIA => GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA int ( z '1F23' ), int ( z '1F2B' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND VARIA => GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA int ( z '1F24' ), int ( z '1F2C' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND OXIA => GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA int ( z '1F25' ), int ( z '1F2D' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND OXIA => GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA int ( z '1F26' ), int ( z '1F2E' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI => GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI int ( z '1F27' ), int ( z '1F2F' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI => GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI int ( z '1F30' ), int ( z '1F38' ), & ! GREEK SMALL LETTER IOTA WITH PSILI => GREEK CAPITAL LETTER IOTA WITH PSILI int ( z '1F31' ), int ( z '1F39' ), & ! GREEK SMALL LETTER IOTA WITH DASIA => GREEK CAPITAL LETTER IOTA WITH DASIA int ( z '1F32' ), int ( z '1F3A' ), & ! GREEK SMALL LETTER IOTA WITH PSILI AND VARIA => GREEK CAPITAL LETTER IOTA WITH PSILI AND VARIA int ( z '1F33' ), int ( z '1F3B' ), & ! GREEK SMALL LETTER IOTA WITH DASIA AND VARIA => GREEK CAPITAL LETTER IOTA WITH DASIA AND VARIA int ( z '1F34' ), int ( z '1F3C' ), & ! GREEK SMALL LETTER IOTA WITH PSILI AND OXIA => GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA int ( z '1F35' ), int ( z '1F3D' ), & ! GREEK SMALL LETTER IOTA WITH DASIA AND OXIA => GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA int ( z '1F36' ), int ( z '1F3E' ), & ! GREEK SMALL LETTER IOTA WITH PSILI AND PERISPOMENI => GREEK CAPITAL LETTER IOTA WITH PSILI AND PERISPOMENI int ( z '1F37' ), int ( z '1F3F' ), & ! GREEK SMALL LETTER IOTA WITH DASIA AND PERISPOMENI => GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI int ( z '1F40' ), int ( z '1F48' ), & ! GREEK SMALL LETTER OMICRON WITH PSILI => GREEK CAPITAL LETTER OMICRON WITH PSILI int ( z '1F41' ), int ( z '1F49' ), & ! GREEK SMALL LETTER OMICRON WITH DASIA => GREEK CAPITAL LETTER OMICRON WITH DASIA int ( z '1F42' ), int ( z '1F4A' ), & ! GREEK SMALL LETTER OMICRON WITH PSILI AND VARIA => GREEK CAPITAL LETTER OMICRON WITH PSILI AND VARIA int ( z '1F43' ), int ( z '1F4B' ), & ! GREEK SMALL LETTER OMICRON WITH DASIA AND VARIA => GREEK CAPITAL LETTER OMICRON WITH DASIA AND VARIA int ( z '1F44' ), int ( z '1F4C' ), & ! GREEK SMALL LETTER OMICRON WITH PSILI AND OXIA => GREEK CAPITAL LETTER OMICRON WITH PSILI AND OXIA int ( z '1F45' ), int ( z '1F4D' ), & ! GREEK SMALL LETTER OMICRON WITH DASIA AND OXIA => GREEK CAPITAL LETTER OMICRON WITH DASIA AND OXIA int ( z '1F51' ), int ( z '1F59' ), & ! GREEK SMALL LETTER UPSILON WITH DASIA => GREEK CAPITAL LETTER UPSILON WITH OASIS int ( z '1F53' ), int ( z '1F5B' ), & ! GREEK SMALL LETTER UPSILON WITH DASIA AND VARIA => GREEK CAPITAL LETTER UPSILON WITH DASIA AND VARIA int ( z '1F55' ), int ( z '1F5D' ), & ! GREEK SMALL LETTER UPSILON WITH DASIA AND OXIA => GREEK CAPITAL LETTER UPSILON WITH DASIA AND OXIA int ( z '1F57' ), int ( z '1F5F' ), & ! GREEK SMALL LETTER UPSILON WITH DASIA AND PERISPOMENI => GREEK CAPITAL LETTER UPSILON WITH DASIA AND PERISPOMENI int ( z '1F60' ), int ( z '1F68' ), & ! GREEK SMALL LETTER OMEGA WITh PSILI => GREEK CAPITAL LETTER OMEGA WITH PSILI int ( z '1F61' ), int ( z '1F69' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA => GREEK CAPITAL LETTER OMEGA WITH DASIA int ( z '1F62' ), int ( z '1F6A' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA => GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA int ( z '1F63' ), int ( z '1F6B' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA => GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA int ( z '1F64' ), int ( z '1F6C' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA => GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA int ( z '1F65' ), int ( z '1F6D' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA => GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA int ( z '1F66' ), int ( z '1F6E' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI => GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI int ( z '1F67' ), int ( z '1F6F' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI => GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI int ( z '1F80' ), int ( z '1F88' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITh PSILI AND PROSGEGRAMMENI int ( z '1F81' ), int ( z '1F89' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH DASIA AND PROSGEGRAMMENI int ( z '1F82' ), int ( z '1F8A' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI int ( z '1F83' ), int ( z '1F8B' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI int ( z '1F84' ), int ( z '1F8C' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMEN int ( z '1F85' ), int ( z '1F8D' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMEN int ( z '1F86' ), int ( z '1F8E' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1F87' ), int ( z '1F8F' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1F90' ), int ( z '1F98' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH PSILI AND PROSGEGRAMMENI int ( z '1F91' ), int ( z '1F99' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH DASIA AND PROSGEGRAMMENI int ( z '1F92' ), int ( z '1F9A' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI int ( z '1F93' ), int ( z '1F9B' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI int ( z '1F94' ), int ( z '1F9C' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI int ( z '1F95' ), int ( z '1F9D' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI int ( z '1F96' ), int ( z '1F9E' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1F97' ), int ( z '1F9F' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1FA0' ), int ( z '1FA8' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH PSILI AND PROSGEGRAMMENI int ( z '1FA1' ), int ( z '1FA9' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH DASIA AND PROSGEGRAMMENI int ( z '1FA2' ), int ( z '1FAA' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI int ( z '1FA3' ), int ( z '1FAB' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI int ( z '1FA4' ), int ( z '1FAC' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI int ( z '1FA5' ), int ( z '1FAD' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI int ( z '1FA6' ), int ( z '1FAE' ), & ! GREEK SMALL LETTER OMEGA WITh PSILI AND PERISPOMENI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1FA7' ), int ( z '1FAF' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND PEPISPOMENI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMECA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1FB0' ), int ( z '1FB8' ), & ! GREEK SMALL LETTER ALPHA WITH VRACHY => GREEK CAPITAL LETTER ALPHA WITH VRACHY int ( z '1FB1' ), int ( z '1FB9' ), & ! GREEK SMALL LETTER ALPHA WITH MACRON => GREEK CAPITAL LETTER ALPHA WITH MACRON int ( z '1FD0' ), int ( z '1FD8' ), & ! GREEK SMALL LETTER IOTA WITH VRACHY => GREEK CAPITAL LETTER IOTA WITH VRACHY int ( z '1FD1' ), int ( z '1FD9' ), & ! GREEK SMALL LETTER IOTA WITH MACRON => GREEK CAPITAL LETTER IOTA WITH MACRON int ( z '1FE0' ), int ( z '1FE8' ), & ! GREEK SMALL LETTER UPSILON WITH VRACHY => GREEK CAPITAL LETTER UPSILON WITH VRACHY int ( z '1FE1' ), int ( z '1FE9' ), & ! GREEK SMALL LETTER UPSILON WITH MACRON => GREEK CAPITAL LETTER UPSILON WITH MACRON int ( z '24D0' ), int ( z '24B6' ), & ! CIRCLED LATIN SMALL LETTER A => CIRCLED LATIN CAPITAL LETTER A int ( z '24D1' ), int ( z '24B7' ), & ! CIRCLED LATIN SMALL LETTER B => CIRCLED LATIN CAPITAL LETTER B int ( z '24D2' ), int ( z '24B8' ), & ! CIRCLED LATIN SMALL LETTER C => CIRCLED LATIN CAPITAL LETTER C int ( z '24D3' ), int ( z '24B9' ), & ! CIRCLED LATIN SMALL LETTER D => CIRCLED LATIN CAPITAL LETTER D int ( z '24D4' ), int ( z '24BA' ), & ! CIRCLED LATIN SMALL LETTER E => CIRCLED LATIN CAPITAL LETTER E int ( z '24D5' ), int ( z '24BB' ), & ! CIRCLED LATIN SMALL LETTER F => CIRCLED LATIN CAPITAL LETTER F int ( z '24D6' ), int ( z '24BC' ), & ! CIRCLED LATIN SMALL LETTER G => CIRCLED LATIN CAPITAL LETTER G int ( z '24D7' ), int ( z '24BD' ), & ! CIRCLED LATIN SMALL LETTER H => CIRCLED LATIN CAPITAL LETTER H int ( z '24D8' ), int ( z '24BE' ), & ! CIRCLED LATIN SMALL LETTER I => CIRCLED LATIN CAPITAL LETTER I int ( z '24D9' ), int ( z '24BF' ), & ! CIRCLED LATIN SMALL LETTER J => CIRCLED LATIN CAPITAL LETTER J int ( z '24DA' ), int ( z '24C0' ), & ! CIRCLED LATIN SMALL LETTER K => CIRCLED LATIN CAPITAL LETTER K int ( z '24DB' ), int ( z '24C1' ), & ! CIRCLED LATIN SMALL LETTER L => CIRCLED LATIN CAPITAL LETTER L int ( z '24DC' ), int ( z '24C2' ), & ! CIRCLED LATIN SMALL LETTER M => CIRCLED LATIN CAPITAL LETTER M int ( z '24DD' ), int ( z '24C3' ), & ! CIRCLED LATIN SMALL LETTER N => CIRCLED LATIN CAPITAL LETTER N int ( z '24DE' ), int ( z '24C4' ), & ! CIRCLED LATIN SMALL LETTER O => CIRCLED LATIN CAPITAL LETTER O int ( z '24DF' ), int ( z '24C5' ), & ! CIRCLED LATIN SMALL LETTER P => CIRCLED LATIN CAPITAL LETTER P int ( z '24E0' ), int ( z '24C6' ), & ! CIRCLED LATIN SMALL LETTER Q => CIRCLED LATIN CAPITAL LETTER Q int ( z '24E1' ), int ( z '24C7' ), & ! CIRCLED LATIN SMALL LETTER R => CIRCLED LATIN CAPITAL LETTER R int ( z '24E2' ), int ( z '24C8' ), & ! CIRCLED LATIN SMALL LETTER S => CIRCLED LATIN CAPITAL LETTER S int ( z '24E3' ), int ( z '24C9' ), & ! CIRCLED LATIN SMALL LETTER T => CIRCLED LATIN CAPITAL LETTER T int ( z '24E4' ), int ( z '24CA' ), & ! CIRCLED LATIN SMALL LETTER U => CIRCLED LATIN CAPITAL LETTER U int ( z '24E5' ), int ( z '24CB' ), & ! CIRCLED LATIN SMALL LETTER V => CIRCLED LATIN CAPITAL LETTER V int ( z '24E6' ), int ( z '24CC' ), & ! CIRCLED LATIN SMALL LETTER W => CIRCLED LATIN CAPITAL LETTER W int ( z '24E7' ), int ( z '24CD' ), & ! CIRCLED LATIN SMALL LETTER X => CIRCLED LATIN CAPITAL LETTER X int ( z '24E8' ), int ( z '24CE' ), & ! CIRCLED LATIN SMALL LETTER Y => CIRCLED LATIN CAPITAL LETTER Y int ( z '24E9' ), int ( z '24CF' ), & ! CIRCLED LATIN SMALL LETTER Z => CIRCLED LATIN CAPITAL LETTER Z int ( z 'FF41' ), int ( z 'FF21' ), & ! FULLWIDTH LATIN SMALL LETTER A => FULLWIDTH LATIN CAPITAL LETTER A int ( z 'FF42' ), int ( z 'FF22' ), & ! FULLWIDTH LATIN SMALL LETTER B => FULLWIDTH LATIN CAPITAL LETTER B int ( z 'FF43' ), int ( z 'FF23' ), & ! FULLWIDTH LATIN SMALL LETTER C => FULLWIDTH LATIN CAPITAL LETTER C int ( z 'FF44' ), int ( z 'FF24' ), & ! FULLWIDTH LATIN SMALL LETTER D => FULLWIDTH LATIN CAPITAL LETTER D int ( z 'FF45' ), int ( z 'FF25' ), & ! FULLWIDTH LATIN SMALL LETTER E => FULLWIDTH LATIN CAPITAL LETTER E int ( z 'FF46' ), int ( z 'FF26' ), & ! FULLWIDTH LATIN SMALL LETTER F => FULLWIDTH LATIN CAPITAL LETTER F int ( z 'FF47' ), int ( z 'FF27' ), & ! FULLWIDTH LATIN SMALL LETTER G => FULLWIDTH LATIN CAPITAL LETTER G int ( z 'FF48' ), int ( z 'FF28' ), & ! FULLWIDTH LATIN SMALL LETTER H => FULLWIDTH LATIN CAPITAL LETTER H int ( z 'FF49' ), int ( z 'FF29' ), & ! FULLWIDTH LATIN SMALL LETTER I => FULLWIDTH LATIN CAPITAL LETTER I int ( z 'FF4A' ), int ( z 'FF2A' ), & ! FULLWIDTH LATIN SMALL LETTER J => FULLWIDTH LATIN CAPITAL LETTER J int ( z 'FF4B' ), int ( z 'FF2B' ), & ! FULLWIDTH LATIN SMALL LETTER K => FULLWIDTH LATIN CAPITAL LETTER K int ( z 'FF4C' ), int ( z 'FF2C' ), & ! FULLWIDTH LATIN SMALL LETTER L => FULLWIDTH LATIN CAPITAL LETTER L int ( z 'FF4D' ), int ( z 'FF2D' ), & ! FULLWIDTH LATIN SMALL LETTER M => FULLWIDTH LATIN CAPITAL LETTER M int ( z 'FF4E' ), int ( z 'FF2E' ), & ! FULLWIDTH LATIN SMALL LETTER N => FULLWIDTH LATIN CAPITAL LETTER N int ( z 'FF4F' ), int ( z 'FF2F' ), & ! FULLWIDTH LATIN SMALL LETTER O => FULLWIDTH LATIN CAPITAL LETTER O int ( z 'FF50' ), int ( z 'FF30' ), & ! FULLWIDTH LATIN SMALL LETTER P => FULLWIDTH LATIN CAPITAL LETTER P int ( z 'FF51' ), int ( z 'FF31' ), & ! FULLWIDTH LATIN SMALL LETTER Q => FULLWIDTH LATIN CAPITAL LETTER Q int ( z 'FF52' ), int ( z 'FF32' ), & ! FULLWIDTH LATIN SMALL LETTER R => FULLWIDTH LATIN CAPITAL LETTER R int ( z 'FF53' ), int ( z 'FF33' ), & ! FULLWIDTH LATIN SMALL LETTER S => FULLWIDTH LATIN CAPITAL LETTER S int ( z 'FF54' ), int ( z 'FF34' ), & ! FULLWIDTH LATIN SMALL LETTER T => FULLWIDTH LATIN CAPITAL LETTER T int ( z 'FF55' ), int ( z 'FF35' ), & ! FULLWIDTH LATIN SMALL LETTER U => FULLWIDTH LATIN CAPITAL LETTER U int ( z 'FF56' ), int ( z 'FF36' ), & ! FULLWIDTH LATIN SMALL LETTER V => FULLWIDTH LATIN CAPITAL LETTER V int ( z 'FF57' ), int ( z 'FF37' ), & ! FULLWIDTH LATIN SMALL LETTER W => FULLWIDTH LATIN CAPITAL LETTER W int ( z 'FF58' ), int ( z 'FF38' ), & ! FULLWIDTH LATIN SMALL LETTER X => FULLWIDTH LATIN CAPITAL LETTER X int ( z 'FF59' ), int ( z 'FF39' ), & ! FULLWIDTH LATIN SMALL LETTER Y => FULLWIDTH LATIN CAPITAL LETTER Y int ( z 'FF5A' ), int ( z 'FF3A' )] & ! FULLWIDTH LATIN SMALL LETTER Z => FULLWIDTH LATIN CAPITAL LETTER Z , shape ( lowup ), order = [ 2 , 1 ]) integer , parameter :: highlow = 667 integer , parameter :: uplow ( highlow , 2 ) = reshape ([ & int ( z '0041' ), int ( z '0061' ), & ! LATIN SMALL LETTER A <= LATIN CAPITAL LETTER A int ( z '0042' ), int ( z '0062' ), & ! LATIN SMALL LETTER B <= LATIN CAPITAL LETTER B int ( z '0043' ), int ( z '0063' ), & ! LATIN SMALL LETTER C <= LATIN CAPITAL LETTER C int ( z '0044' ), int ( z '0064' ), & ! LATIN SMALL LETTER D <= LATIN CAPITAL LETTER D int ( z '0045' ), int ( z '0065' ), & ! LATIN SMALL LETTER E <= LATIN CAPITAL LETTER E int ( z '0046' ), int ( z '0066' ), & ! LATIN SMALL LETTER F <= LATIN CAPITAL LETTER F int ( z '0047' ), int ( z '0067' ), & ! LATIN SMALL LETTER G <= LATIN CAPITAL LETTER G int ( z '0048' ), int ( z '0068' ), & ! LATIN SMALL LETTER H <= LATIN CAPITAL LETTER H int ( z '0049' ), int ( z '0069' ), & ! LATIN SMALL LETTER I <= LATIN CAPITAL LETTER I int ( z '0049' ), int ( z '0131' ), & ! LATIN SMALL LETTER DOTLESS I <= LATIN CAPITAL LETTER I int ( z '004A' ), int ( z '006A' ), & ! LATIN SMALL LETTER J <= LATIN CAPITAL LETTER J int ( z '004B' ), int ( z '006B' ), & ! LATIN SMALL LETTER K <= LATIN CAPITAL LETTER K int ( z '004C' ), int ( z '006C' ), & ! LATIN SMALL LETTER L <= LATIN CAPITAL LETTER L int ( z '004D' ), int ( z '006D' ), & ! LATIN SMALL LETTER M <= LATIN CAPITAL LETTER M int ( z '004E' ), int ( z '006E' ), & ! LATIN SMALL LETTER N <= LATIN CAPITAL LETTER N int ( z '004F' ), int ( z '006F' ), & ! LATIN SMALL LETTER O <= LATIN CAPITAL LETTER O int ( z '0050' ), int ( z '0070' ), & ! LATIN SMALL LETTER P <= LATIN CAPITAL LETTER P int ( z '0051' ), int ( z '0071' ), & ! LATIN SMALL LETTER Q <= LATIN CAPITAL LETTER Q int ( z '0052' ), int ( z '0072' ), & ! LATIN SMALL LETTER R <= LATIN CAPITAL LETTER R int ( z '0053' ), int ( z '0073' ), & ! LATIN SMALL LETTER S <= LATIN CAPITAL LETTER S int ( z '0054' ), int ( z '0074' ), & ! LATIN SMALL LETTER T <= LATIN CAPITAL LETTER T int ( z '0055' ), int ( z '0075' ), & ! LATIN SMALL LETTER U <= LATIN CAPITAL LETTER U int ( z '0056' ), int ( z '0076' ), & ! LATIN SMALL LETTER V <= LATIN CAPITAL LETTER V int ( z '0057' ), int ( z '0077' ), & ! LATIN SMALL LETTER W <= LATIN CAPITAL LETTER W int ( z '0058' ), int ( z '0078' ), & ! LATIN SMALL LETTER X <= LATIN CAPITAL LETTER X int ( z '0059' ), int ( z '0079' ), & ! LATIN SMALL LETTER Y <= LATIN CAPITAL LETTER Y int ( z '005A' ), int ( z '007A' ), & ! LATIN SMALL LETTER Z <= LATIN CAPITAL LETTER Z int ( z '00C0' ), int ( z '00E0' ), & ! LATIN SMALL LETTER A GRAVE <= LATIN CAPITAL LETTER A GRAVE int ( z '00C1' ), int ( z '00E1' ), & ! LATIN SMALL LETTER A GRAVE <= LATIN CAPITAL LETTER A ACUTE int ( z '00C2' ), int ( z '00E2' ), & ! LATIN SMALL LETTER A GRAVE <= LATIN CAPITAL LETTER A CIRCUMFLEX int ( z '00C3' ), int ( z '00E3' ), & ! LATIN SMALL LETTER A GRAVE <= LATIN CAPITAL LETTER A TILDE int ( z '00C4' ), int ( z '00E4' ), & ! LATIN SMALL LETTER A GRAVE <= LATIN CAPITAL LETTER A DIAERESIS int ( z '00C5' ), int ( z '00E5' ), & ! LATIN SMALL LETTER A GRAVE <= LATIN CAPITAL LETTER A RING int ( z '00C6' ), int ( z '00E6' ), & ! LATIN SMALL LETTER A GRAVE <= LATIN CAPITAL LETTER A E int ( z '00C7' ), int ( z '00E7' ), & ! LATIN SMALL LETTER A GRAVE <= LATIN CAPITAL LETTER C CEDILLA int ( z '00C8' ), int ( z '00E8' ), & ! LATIN SMALL LETTER A GRAVE <= LATIN CAPITAL LETTER E GRAVE int ( z '00C9' ), int ( z '00E9' ), & ! LATIN SMALL LETTER A GRAVE <= LATIN CAPITAL LETTER E ACUTE int ( z '00CA' ), int ( z '00EA' ), & ! LATIN SMALL LETTER E CIRCUMFLEX <= LATIN CAPITAL LETTER E CIRCUMFLEX int ( z '00CB' ), int ( z '00EB' ), & ! LATIN SMALL LETTER E DIAERESIS <= LATIN CAPITAL LETTER E DIAERESIS int ( z '00CC' ), int ( z '00EC' ), & ! LATIN SMALL LETTER I GRAVE <= LATIN CAPITAL LETTER I GRAVE int ( z '00CD' ), int ( z '00ED' ), & ! LATIN SMALL LETTER I ACUTE <= LATIN CAPITAL LETTER I ACUTE int ( z '00CE' ), int ( z '00EE' ), & ! LATIN SMALL LETTER I CIRCUMFLEX <= LATIN CAPITAL LETTER I CIRCUMFLEX int ( z '00CF' ), int ( z '00EF' ), & ! LATIN SMALL LETTER I DIAERESIS <= LATIN CAPITAL LETTER I DIAERESIS int ( z '00D0' ), int ( z '00F0' ), & ! LATIN SMALL LETTER ETH <= LATIN CAPITAL LETTER ETH int ( z '00D1' ), int ( z '00F1' ), & ! LATIN SMALL LETTER N TILDE <= LATIN CAPITAL LETTER N TILDE int ( z '00D2' ), int ( z '00F2' ), & ! LATIN SMALL LETTER O GRAVE <= LATIN CAPITAL LETTER O GRAVE int ( z '00D3' ), int ( z '00F3' ), & ! LATIN SMALL LETTER O ACUTE <= LATIN CAPITAL LETTER O ACUTE int ( z '00D4' ), int ( z '00F4' ), & ! LATIN SMALL LETTER O CIRCUMFLEX <= LATIN CAPITAL LETTER O CIRCUMFLEX int ( z '00D5' ), int ( z '00F5' ), & ! LATIN SMALL LETTER O TILDE <= LATIN CAPITAL LETTER O TILDE int ( z '00D6' ), int ( z '00F6' ), & ! LATIN SMALL LETTER O DIAERESIS <= LATIN CAPITAL LETTER O DIAERESIS int ( z '00D8' ), int ( z '00F8' ), & ! LATIN SMALL LETTER O SLASH <= LATIN CAPITAL LETTER O SLASH int ( z '00D9' ), int ( z '00F9' ), & ! LATIN SMALL LETTER U GRAVE <= LATIN CAPITAL LETTER U GRAVE int ( z '00DA' ), int ( z '00FA' ), & ! LATIN SMALL LETTER U ACUTE <= LATIN CAPITAL LETTER U ACUTE int ( z '00DB' ), int ( z '00FB' ), & ! LATIN SMALL LETTER U CIRCUMFLEX <= LATIN CAPITAL LETTER U CIRCUMFLEX int ( z '00DC' ), int ( z '00FC' ), & ! LATIN SMALL LETTER U DIAERESIS <= LATIN CAPITAL LETTER U DIAERESIS int ( z '00DD' ), int ( z '00FD' ), & ! LATIN SMALL LETTER Y ACUTE <= LATIN CAPITAL LETTER Y ACUTE int ( z '00DE' ), int ( z '00FE' ), & ! LATIN SMALL LETTER THORN <= LATIN CAPITAL LETTER THORN int ( z '0100' ), int ( z '0101' ), & ! LATIN SMALL LETTER A WITH MACRON <= LATIN CAPITAL LETTER A WITH MACRON int ( z '0102' ), int ( z '0103' ), & ! LATIN SMALL LETTER A WITH BREVE <= LATIN CAPITAL LETTER A WITH BREVE int ( z '0104' ), int ( z '0105' ), & ! LATIN SMALL LETTER A WITH OGONEK <= LATIN CAPITAL LETTER A WITH OGONEK int ( z '0106' ), int ( z '0107' ), & ! LATIN SMALL LETTER C WITH ACUTE <= LATIN CAPITAL LETTER C WITH ACUTE int ( z '0108' ), int ( z '0109' ), & ! LATIN SMALL LETTER C WITH CIRCUMFLEX <= LATIN CAPITAL LETTER C WITH CIRCUMFLEX int ( z '010A' ), int ( z '010B' ), & ! LATIN SMALL LETTER C WITH DOT ABOVE <= LATIN CAPITAL LETTER C WITH DOT ABOVE int ( z '010C' ), int ( z '010D' ), & ! LATIN SMALL LETTER C WITH CARON <= LATIN CAPITAL LETTER C WITH CARON int ( z '010E' ), int ( z '010F' ), & ! LATIN SMALL LETTER D WITH CARON <= LATIN CAPITAL LETTER D WITH CARON int ( z '0110' ), int ( z '0111' ), & ! LATIN SMALL LETTER D WITH STROKE <= LATIN CAPITAL LETTER D WITH STROKE int ( z '0112' ), int ( z '0113' ), & ! LATIN SMALL LETTER E WITH MACRON <= LATIN CAPITAL LETTER E WITH MACRON int ( z '0114' ), int ( z '0115' ), & ! LATIN SMALL LETTER E WITH BREVE <= LATIN CAPITAL LETTER E WITH BREVE int ( z '0116' ), int ( z '0117' ), & ! LATIN SMALL LETTER E WITH DOT ABOVE <= LATIN CAPITAL LETTER E WITH DOT ABOVE int ( z '0118' ), int ( z '0119' ), & ! LATIN SMALL LETTER E WITH OGONEK <= LATIN CAPITAL LETTER E WITH OGONEK int ( z '011A' ), int ( z '011B' ), & ! LATIN SMALL LETTER E WITH CARON <= LATIN CAPITAL LETTER E WITH CARON int ( z '011C' ), int ( z '011D' ), & ! LATIN SMALL LETTER G WITH CIRCUMFLEX <= LATIN CAPITAL LETTER G WITH CIRCUMFLEX int ( z '011E' ), int ( z '011F' ), & ! LATIN SMALL LETTER G WITH BREVE <= LATIN CAPITAL LETTER G WITH BREVE int ( z '0120' ), int ( z '0121' ), & ! LATIN SMALL LETTER G WITH DOT ABOVE <= LATIN CAPITAL LETTER G WITH DOT ABOVE int ( z '0122' ), int ( z '0123' ), & ! LATIN SMALL LETTER G WITH CEDILLA <= LATIN CAPITAL LETTER G WITH CEDILLA int ( z '0124' ), int ( z '0125' ), & ! LATIN SMALL LETTER H WITH CIRCUMFLEX <= LATIN CAPITAL LETTER H WITH CIRCUMFLEX int ( z '0126' ), int ( z '0127' ), & ! LATIN SMALL LETTER H WITH STROKE <= LATIN CAPITAL LETTER H WITH STROKE int ( z '0128' ), int ( z '0129' ), & ! LATIN SMALL LETTER I WITH TILDE <= LATIN CAPITAL LETTER I WITH TILDE int ( z '012A' ), int ( z '012B' ), & ! LATIN SMALL LETTER I WITH MACRON <= LATIN CAPITAL LETTER I WITH MACRON int ( z '012C' ), int ( z '012D' ), & ! LATIN SMALL LETTER I WITH BREVE <= LATIN CAPITAL LETTER I WITH BREVE int ( z '012E' ), int ( z '012F' ), & ! LATIN SMALL LETTER I WITH OGONEK <= LATIN CAPITAL LETTER I WITH OGONEK int ( z '0130' ), int ( z '0069' ), & ! LATIN sMALL LETTER I <= CAPITAL LETTER I WITH DOT ABOVE int ( z '0132' ), int ( z '0133' ), & ! LATIN SMALL LIGATURE IJ <= LATIN CAPITAL LIGATURE IJ int ( z '0134' ), int ( z '0135' ), & ! LATIN SMALL LETTER J WITH CIRCUMFLEX <= LATIN CAPITAL LETTER J WITH CIRCUMFLEX int ( z '0136' ), int ( z '0137' ), & ! LATIN SMALL LETTER K WITH CEDILLA <= LATIN CAPITAL LETTER K WITH CEDILLA int ( z '0139' ), int ( z '013A' ), & ! LATIN SMALL LETTER L WITH ACUTE <= LATIN CAPITAL LETTER L WITH ACUTE int ( z '013B' ), int ( z '013C' ), & ! LATIN SMALL LETTER L WITH CEDILLA <= LATIN CAPITAL LETTER L WITH CEDILLA int ( z '013D' ), int ( z '013E' ), & ! LATIN SMALL LETTER L WITH CARON <= LATIN CAPITAL LETTER L WITH CARON int ( z '013F' ), int ( z '0140' ), & ! LATIN SMALL LETTER L WITH MIDDLE DOT <= LATIN CAPITAL LETTER L WITH MIDDLE DOT int ( z '0141' ), int ( z '0142' ), & ! LATIN SMALL LETTER L WITH STROKE <= LATIN CAPITAL LETTER L WITH STROKE int ( z '0143' ), int ( z '0144' ), & ! LATIN SMALL LETTER N WITH ACUTE <= LATIN CAPITAL LETTER N WITH ACUTE int ( z '0145' ), int ( z '0146' ), & ! LATIN SMALL LETTER N WITH CEDILLA <= LATIN CAPITAL LETTER N WITH CEDILLA int ( z '0147' ), int ( z '0148' ), & ! LATIN SMALL LETTER N WITH CARON <= LATIN CAPITAL LETTER N WITH CARON int ( z '014A' ), int ( z '014B' ), & ! LATIN SMALL LETTER ENG (SAMI) <= LATIN CAPITAL LETTER ENG (SAMI) int ( z '014C' ), int ( z '014D' ), & ! LATIN SMALL LETTER O WITH MACRON <= LATIN CAPITAL LETTER O WITH MACRON int ( z '014E' ), int ( z '014F' ), & ! LATIN SMALL LETTER O WITH BREVE <= LATIN CAPITAL LETTER O WITH BREVE int ( z '0150' ), int ( z '0151' ), & ! LATIN SMALL LETTER O WITH DOUBLE ACUTE <= LATIN CAPITAL LETTER O WITH DOUBLE ACUTE int ( z '0152' ), int ( z '0153' ), & ! LATIN SMALL LIGATURE OE <= LATIN CAPITAL LIGATURE OE int ( z '0154' ), int ( z '0155' ), & ! LATIN SMALL LETTER R WITH ACUTE <= LATIN CAPITAL LETTER R WITH ACUTE int ( z '0156' ), int ( z '0157' ), & ! LATIN SMALL LETTER R WITH CEDILLA <= LATIN CAPITAL LETTER R WITH CEDILLA int ( z '0158' ), int ( z '0159' ), & ! LATIN SMALL LETTER R WITH CARON <= LATIN CAPITAL LETTER R WITH CARON int ( z '015A' ), int ( z '015B' ), & ! LATIN SMALL LETTER S WITH ACUTE <= LATIN CAPITAL LETTER S WITH ACUTE int ( z '015C' ), int ( z '015D' ), & ! LATIN SMALL LETTER S WITH CIRCUMFLEX <= LATIN CAPITAL LETTER S WITH CIRCUMFLEX int ( z '015E' ), int ( z '015F' ), & ! LATIN SMALL LETTER S WITH CEDILLA <= LATIN CAPITAL LETTER S WITH CEDILLA int ( z '0160' ), int ( z '0161' ), & ! LATIN SMALL LETTER S WITH CARON <= LATIN CAPITAL LETTER S WITH CARON int ( z '0162' ), int ( z '0163' ), & ! LATIN SMALL LETTER T WITH CEDILLA <= LATIN CAPITAL LETTER T WITH CEDILLA int ( z '0164' ), int ( z '0165' ), & ! LATIN SMALL LETTER T WITH CARON <= LATIN CAPITAL LETTER T WITH CARON int ( z '0166' ), int ( z '0167' ), & ! LATIN SMALL LETTER T WITH STROKE <= LATIN CAPITAL LETTER T WITH STROKE int ( z '0168' ), int ( z '0169' ), & ! LATIN SMALL LETTER U WITH TILDE <= LATIN CAPITAL LETTER U WITH TILDE int ( z '016A' ), int ( z '016B' ), & ! LATIN SMALL LETTER U WITH MACRON <= LATIN CAPITAL LETTER U WITH MACRON int ( z '016C' ), int ( z '016D' ), & ! LATIN SMALL LETTER U WITH BREVE <= LATIN CAPITAL LETTER U WITH BREVE int ( z '016E' ), int ( z '016F' ), & ! LATIN SMALL LETTER U WITH RING ABOVE <= LATIN CAPITAL LETTER U WITH RING ABOVE int ( z '0170' ), int ( z '0171' ), & ! LATIN SMALL LETTER U WITH DOUBLE ACUTE <= LATIN CAPITAL LETTER U WITH DOUBLE ACUTE int ( z '0172' ), int ( z '0173' ), & ! LATIN SMALL LETTER U WITH OGONEK <= LATIN CAPITAL LETTER U WITH OGONEK int ( z '0174' ), int ( z '0175' ), & ! LATIN SMALL LETTER W WITH CIRCUMFLEX <= LATIN CAPITAL LETTER W WITH CIRCUMFLEX int ( z '0176' ), int ( z '0177' ), & ! LATIN SMALL LETTER Y WITH CIRCUMFLEX <= LATIN CAPITAL LETTER Y WITH CIRCUMFLEX int ( z '0178' ), int ( z '00FF' ), & ! LATIN SMALL LETTER Y DIAERESIS <= LATIN CAPITAL LETTER Y WITH DIAERESIS int ( z '0179' ), int ( z '017A' ), & ! LATIN SMALL LETTER Z WITH ACUTE <= LATIN CAPITAL LETTER Z WITH ACUTE int ( z '017B' ), int ( z '017C' ), & ! LATIN SMALL LETTER Z WITH DOT ABOVE <= LATIN CAPITAL LETTER Z WITH DOT ABOVE int ( z '017D' ), int ( z '017E' ), & ! LATIN SMALL LETTER Z WITH CARON <= LATIN CAPITAL LETTER Z WITH CARON int ( z '0181' ), int ( z '0253' ), & ! LATIN SMALL LETTER B WITH HOOK <= LATIN CAPITAL LETTER B WITH HOOK int ( z '0182' ), int ( z '0183' ), & ! LATIN SMALL LETTER B WITH TOPBAR <= LATIN CAPITAL LETTER B WITH TOPBAR int ( z '0184' ), int ( z '0185' ), & ! LATIN SMALL LETTER TONE SIX <= LATIN CAPITAL LETTER TONE SIX int ( z '0186' ), int ( z '0254' ), & ! LATIN SMALL LETTER OPEN O <= LATIN CAPITAL LETTER OPEN O int ( z '0187' ), int ( z '0188' ), & ! LATIN SMALL LETTER C WITH HOOK <= LATIN CAPITAL LETTER C WITH HOOK int ( z '018A' ), int ( z '0257' ), & ! LATIN SMALL LETTER D WITH HOOK <= LATIN CAPITAL LETTER D WITH HOOK int ( z '018B' ), int ( z '018C' ), & ! LATIN SMALL LETTER D WITH TOPBAR <= LATIN CAPITAL LETTER D WITH TOPBAR int ( z '018E' ), int ( z '0258' ), & ! LATIN SMALL LETTER REVERSED E <= LATIN CAPITAL LETTER REVERSED E int ( z '018F' ), int ( z '0259' ), & ! LATIN SMALL LETTER SCHWA <= LATIN CAPITAL LETTER SCHWA int ( z '0190' ), int ( z '025B' ), & ! LATIN SMALL LETTER OPEN E <= LATIN CAPITAL LETTER OPEN E int ( z '0191' ), int ( z '0192' ), & ! LATIN SMALL LETTER F WITH HOOK <= LATIN CAPITAL LETTER F WITH HOOK int ( z '0193' ), int ( z '0260' ), & ! LATIN SMALL LETTER G WITH HOOK <= LATIN CAPITAL LETTER G WITH HOOK int ( z '0194' ), int ( z '0263' ), & ! LATIN SMALL LETTER GAMMA <= LATIN CAPITAL LETTER GAMMA int ( z '0196' ), int ( z '0269' ), & ! LATIN SMALL LETTER IOTA <= LATIN CAPITAL LETTER IOTA int ( z '0197' ), int ( z '0268' ), & ! LATIN SMALL LETTER I WITH STROKE <= LATIN CAPITAL LETTER I WITH STROKE int ( z '0198' ), int ( z '0199' ), & ! LATIN SMALL LETTER K WITH HOOK <= LATIN CAPITAL LETTER K WITH HOOK int ( z '019C' ), int ( z '026F' ), & ! LATIN SMALL LETTER TURNED M <= LATIN CAPITAL LETTER TURNED M int ( z '019D' ), int ( z '0272' ), & ! LATIN SMALL LETTER N WITH LEFT HOOK <= LATIN CAPITAL LETTER N WITH LEFT HOOK int ( z '019F' ), int ( z '0275' ), & ! LATIN SMALL LETTER BARRED O <= LATIN CAPITAL LETTER O WITH MIDDLE TILDE int ( z '01A0' ), int ( z '01A1' ), & ! LATIN SMALL LETTER O WITH HORN <= LATIN CAPITAL LETTER O WITH HORN int ( z '01A2' ), int ( z '01A3' ), & ! LATIN SMALL LETTER OI <= LATIN CAPITAL LETTER OI int ( z '01A4' ), int ( z '01A5' ), & ! LATIN SMALL LETTER P WITH HOOK <= LATIN CAPITAL LETTER P WITH HOOK int ( z '01A7' ), int ( z '01A8' ), & ! LATIN SMALL LETTER TONE TWO <= LATIN CAPITAL LETTER TONE TWO int ( z '01A9' ), int ( z '0283' ), & ! LATIN SMALL LETTER ESH <= LATIN CAPITAL LETTER ESH int ( z '01AC' ), int ( z '01AD' ), & ! LATIN SMALL LETTER T WITH HOOK <= LATIN CAPITAL LETTER T WITH HOOK int ( z '01AE' ), int ( z '0288' ), & ! LATIN SMALL LETTER T WITH RETROFLEX HOOK <= LATIN CAPITAL LETTER T WITH RETROFLEX HOOK int ( z '01AF' ), int ( z '01B0' ), & ! LATIN SMALL LETTER U WITH HORN <= LATIN CAPITAL LETTER U WITH HORN int ( z '01B1' ), int ( z '028A' ), & ! LATIN SMALL LETTER UPSILON <= LATIN CAPITAL LETTER UPSILON int ( z '01B2' ), int ( z '028B' ), & ! LATIN SMALL LETTER V WITH HOOK <= LATIN CAPITAL LETTER V WITH HOOK int ( z '01B3' ), int ( z '01B4' ), & ! LATIN SMALL LETTER Y WITH HOOK <= LATIN CAPITAL LETTER Y WITH HOOK int ( z '01B5' ), int ( z '01B6' ), & ! LATIN SMALL LETTER Z WITH STROKE <= LATIN CAPITAL LETTER Z WITH STROKE int ( z '01B7' ), int ( z '0292' ), & ! LATIN SMALL LETTER EZH <= LATIN CAPITAL LETTER EZH int ( z '01B8' ), int ( z '01B9' ), & ! LATIN SMALL LETTER EZH REVERSED <= LATIN CAPITAL LETTER EZH REVERSED int ( z '01BC' ), int ( z '01BD' ), & ! LATIN SMALL LETTER TONE FIVE <= LATIN CAPITAL LETTER TONE FIVE int ( z '01C4' ), int ( z '01C6' ), & ! LATIN SMALL LETTER DZ WITH CARON <= LATIN CAPITAL LETTER DZ WITH CARON int ( z '01C7' ), int ( z '01C9' ), & ! LATIN SMALL LETTER LJ <= LATIN CAPITAL LETTER LJ int ( z '01CA' ), int ( z '01CC' ), & ! LATIN SMALL LETTER NJ <= LATIN CAPITAL LETTER NJ int ( z '01CD' ), int ( z '01CE' ), & ! LATIN SMALL LETTER A WITH CARON <= LATIN CAPITAL LETTER A WITH CARON int ( z '01CF' ), int ( z '01D0' ), & ! LATIN SMALL LETTER I WITH CARON <= LATIN CAPITAL LETTER I WITH CARON int ( z '01D1' ), int ( z '01D2' ), & ! LATIN SMALL LETTER O WITH CARON <= LATIN CAPITAL LETTER O WITH CARON int ( z '01D3' ), int ( z '01D4' ), & ! LATIN SMALL LETTER U WITH CARON <= LATIN CAPITAL LETTER U WITH CARON int ( z '01D5' ), int ( z '01D6' ), & ! LATIN SMALL LETTER U WITH DIAERESIS AND MACRON <= LATIN CAPITAL LETTER U WITH DIAERESIS AND MACRON int ( z '01D7' ), int ( z '01D8' ), & ! LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE <= LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE int ( z '01D9' ), int ( z '01DA' ), & ! LATIN SMALL LETTER U WITH DIAERESIS AND CARON <= LATIN CAPITAL LETTER U WITH DIAERESIS AND CARON int ( z '01DB' ), int ( z '01DC' ), & ! LATIN SMALL LETTER U WITH DIAERESIS AND GRAVE <= LATIN CAPITAL LETTER U WITH DIAERESIS AND GRAVE int ( z '01DE' ), int ( z '01DF' ), & ! LATIN SMALL LETTER A WITH DIAERESIS AND MACRON <= LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON int ( z '01E0' ), int ( z '01E1' ), & ! LATIN SMALL LETTER A WITH DOT ABOVE AND MACRON <= LATIN CAPITAL LETTER A WITH DOT ABOVE AND MACRON int ( z '01E2' ), int ( z '01E3' ), & ! LATIN SMALL LIGATURE AE WITH MACRON <= LATIN CAPITAL LIGATURE AE MTH MACRON int ( z '01E4' ), int ( z '01E5' ), & ! LATIN SMALL LETTER G WITH STROKE <= LATIN CAPITAL LETTER G WITH STROKE int ( z '01E6' ), int ( z '01E7' ), & ! LATIN SMALL LETTER G WITH CARON <= LATIN CAPITAL LETTER G WITH CARON int ( z '01E8' ), int ( z '01E9' ), & ! LATIN SMALL LETTER K WITH CARON <= LATIN CAPITAL LETTER K WITH CARON int ( z '01EA' ), int ( z '01EB' ), & ! LATIN SMALL LETTER O WITH OGONEK <= LATIN CAPITAL LETTER O WITH OGONEK int ( z '01EC' ), int ( z '01ED' ), & ! LATIN SMALL LETTER O WITH OGONEK AND MACRON <= LATIN CAPITAL LETTER O WITH OGONEK AND MACRON int ( z '01EE' ), int ( z '01EF' ), & ! LATIN SMALL LETTER EZH WITH CARON <= LATIN CAPITAL LETTER EZH WITH CARON int ( z '01F1' ), int ( z '01F3' ), & ! LATIN SMALL LETTER DZ <= LATIN CAPITAL LETTER DZ int ( z '01F4' ), int ( z '01F5' ), & ! LATIN SMALL LETTER G WITH ACUTE <= LATIN CAPITAL LETTER G WITH ACUTE int ( z '01FA' ), int ( z '01FB' ), & ! LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE <= LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE int ( z '01FC' ), int ( z '01FD' ), & ! LATIN SMALL LIGATURE AE WITH ACUTE <= LATIN CAPITAL LIGATURE AE WITH ACUTE int ( z '01FE' ), int ( z '01FF' ), & ! LATIN SMALL LETTER O WITH STROKE AND ACUTE <= LATIN CAPITAL LETTER O WITH STROKE AND ACUTE int ( z '0200' ), int ( z '0201' ), & ! LATIN SMALL LETTER A WITH DOUBLE GRAVE <= LATIN CAPITAL LETTER A WITH DOUBLE GRAVE int ( z '0202' ), int ( z '0203' ), & ! LATIN SMALL LETTER A WITH INVERTED BREVE <= LATIN CAPITAL LETTER A WITH INVERTED BREVE int ( z '0204' ), int ( z '0205' ), & ! LATIN SMALL LETTER E WITH DOUBLE GRAVE <= LATIN CAPITAL LETTER E WITH DOUBLE GRAVE int ( z '0206' ), int ( z '0207' ), & ! LATIN SMALL LETTER E WITH INVERTED BREVE <= LATIN CAPITAL LETTER E WITH INVERTED BREVE int ( z '0208' ), int ( z '0209' ), & ! LATIN SMALL LETTER I WITH DOUBLE GRAVE <= LATIN CAPITAL LETTER I WITH DOUBLE GRAVE int ( z '020A' ), int ( z '020B' ), & ! LATIN SMALL LETTER I WITH INVERTED BREVE <= LATIN CAPITAL LETTER I WITH INVERTED BREVE int ( z '020C' ), int ( z '020D' ), & ! LATIN SMALL LETTER O WITH DOUBLE GRAVE <= LATIN CAPITAL LETTER O WITH DOUBLE GRAVE int ( z '020E' ), int ( z '020F' ), & ! LATIN SMALL LETTER O WITH INVERTED BREVE <= LATIN CAPITAL LETTER O WITH INVERTED BREVE int ( z '0210' ), int ( z '0211' ), & ! LATIN SMALL LETTER R WITH DOUBLE GRAVE <= LATIN CAPITAL LETTER R WITH DOUBLE GRAVE int ( z '0212' ), int ( z '0213' ), & ! LATIN SMALL LETTER R WITH INVERTED BREVE <= LATIN CAPITAL LETTER R WITH INVERTED BREVE int ( z '0214' ), int ( z '0215' ), & ! LATIN SMALL LETTER U WITH DOUBLE GRAVE <= LATIN CAPITAL LETTER U WITH DOUBLE GRAVE int ( z '0216' ), int ( z '0217' ), & ! LATIN SMALL LETTER U WITH INVERTED BREVE <= LATIN CAPITAL LETTER U WITH INVERTED BREVE int ( z '0386' ), int ( z '03AC' ), & ! GREEK SMALL LETTER ALPHA WITH TONOS <= GREEK CAPITAL LETTER ALPHA WITH TONOS int ( z '0388' ), int ( z '03AD' ), & ! GREEK SMALL LETTER EPSILON WITH TONOS <= GREEK CAPITAL LETTER EPSILON WITH TONOS int ( z '0389' ), int ( z '03AE' ), & ! GREEK SMALL LETTER ETA WITH TONOS <= GREEK CAPITAL LETTER ETA WITH TONOS int ( z '038A' ), int ( z '03AF' ), & ! GREEK SMALL LETTER IOTA WITH TONOS <= GREEK CAPITAL LETTER IOTA WITH TONOS int ( z '038C' ), int ( z '03CC' ), & ! GREEK SMALL LETTER OMICRON WITH TONOS <= GREEK CAPITAL LETTER OMICRON WITH TONOS int ( z '038E' ), int ( z '03CD' ), & ! GREEK SMALL LETTER UPSILON WITH TONOS <= GREEK CAPITAL LETTER UPSILON WITH TONOS int ( z '038F' ), int ( z '03CE' ), & ! GREEK SMALL LETTER OMEGA WITH TONOS <= GREEK CAPITAL LETTER OMEGA WITH TONOS int ( z '0391' ), int ( z '03B1' ), & ! GREEK SMALL LETTER ALPHA <= GREEK CAPITAL LETTER ALPHA int ( z '0392' ), int ( z '03B2' ), & ! GREEK SMALL LETTER BETA <= GREEK CAPITAL LETTER BETA int ( z '0393' ), int ( z '03B3' ), & ! GREEK SMALL LETTER GAMMA <= GREEK CAPITAL LETTER GAMMA int ( z '0394' ), int ( z '03B4' ), & ! GREEK SMALL LETTER DELTA <= GREEK CAPITAL LETTER DELTA int ( z '0395' ), int ( z '03B5' ), & ! GREEK SMALL LETTER EPSILON <= GREEK CAPITAL LETTER EPSILON int ( z '0396' ), int ( z '03B6' ), & ! GREEK SMALL LETTER ZETA <= GREEK CAPITAL LETTER ZETA int ( z '0397' ), int ( z '03B7' ), & ! GREEK SMALL LETTER ETA <= GREEK CAPITAL LETTER ETA int ( z '0398' ), int ( z '03B8' ), & ! GREEK SMALL LETTER THETA <= GREEK CAPITAL LETTER THETA int ( z '0399' ), int ( z '03B9' ), & ! GREEK SMALL LETTER IOTA <= GREEK CAPITAL LETTER IOTA int ( z '039A' ), int ( z '03BA' ), & ! GREEK SMALL LETTER KAPPA <= GREEK CAPITAL LETTER KAPPA int ( z '039B' ), int ( z '03BB' ), & ! GREEK SMALL LETTER LAMDA <= GREEK CAPITAL LETTER LAMDA int ( z '039C' ), int ( z '03BC' ), & ! GREEK SMALL LETTER MU <= GREEK CAPITAL LETTER MU int ( z '039D' ), int ( z '03BD' ), & ! GREEK SMALL LETTER NU <= GREEK CAPITAL LETTER NU int ( z '039E' ), int ( z '03BE' ), & ! GREEK SMALL LETTER XI <= GREEK CAPITAL LETTER XI int ( z '039F' ), int ( z '03BF' ), & ! GREEK SMALL LETTER OMICRON <= GREEK CAPITAL LETTER OMICRON int ( z '03A0' ), int ( z '03C0' ), & ! GREEK SMALL LETTER PI <= GREEK CAPITAL LETTER PI int ( z '03A1' ), int ( z '03C1' ), & ! GREEK SMALL LETTER RHO <= GREEK CAPITAL LETTER RHO int ( z '03A3' ), int ( z '03C3' ), & ! GREEK SMALL LETTER SIGMA <= GREEK CAPITAL LETTER SIGMA int ( z '03A4' ), int ( z '03C4' ), & ! GREEK SMALL LETTER TAU <= GREEK CAPITAL LETTER TAU int ( z '03A5' ), int ( z '03C5' ), & ! GREEK SMALL LETTER UPSILON <= GREEK CAPITAL LETTER UPSILON int ( z '03A6' ), int ( z '03C6' ), & ! GREEK SMALL LETTER PHI <= GREEK CAPITAL LETTER PHI int ( z '03A7' ), int ( z '03C7' ), & ! GREEK SMALL LETTER CHI <= GREEK CAPITAL LETTER CHI int ( z '03A8' ), int ( z '03C8' ), & ! GREEK SMALL LETTER PSI <= GREEK CAPITAL LETTER PSI int ( z '03A9' ), int ( z '03C9' ), & ! GREEK SMALL LETTER OMEGA <= GREEK CAPITAL LETTER OMEGA int ( z '03AA' ), int ( z '03CA' ), & ! GREEK SMALL LETTER IOTA WITH DIALYTIKA <= GREEK CAPITAL LETTER IOTA WITH DIALYTIKA int ( z '03AB' ), int ( z '03CB' ), & ! GREEK SMALL LETTER UPSILON WITH DIALYTIKA <= GREEK CAPITAL LETTER UPSILON WITH DIALYTIKA int ( z '03E2' ), int ( z '03E3' ), & ! COPTIC SMALL LETTER SHEI <= COPTIC CAPITAL LETTER SHEI int ( z '03E4' ), int ( z '03E5' ), & ! COPTIC SMALL LETTER FEI <= COPTIC CAPITAL LETTER FEI int ( z '03E6' ), int ( z '03E7' ), & ! COPTIC SMALL LETTER KHEI <= COPTIC CAPITAL LETTER KHEI int ( z '03E8' ), int ( z '03E9' ), & ! COPTIC SMALL LETTER HORI <= COPTIC CAPITAL LETTER HORI int ( z '03EA' ), int ( z '03EB' ), & ! COPTIC SMALL LETTER GANGIA <= COPTIC CAPITAL LETTER GANGIA int ( z '03EC' ), int ( z '03ED' ), & ! COPTIC SMALL LETTER SHIMA <= COPTIC CAPITAL LETTER SHIMA int ( z '03EE' ), int ( z '03EF' ), & ! COPTIC SMALL LETTER DEI <= COPTIC CAPITAL LETTER DEI int ( z '0401' ), int ( z '0451' ), & ! CYRILLIC SMALL LETTER IO <= CYRILLIC CAPITAL LETTER IO int ( z '0402' ), int ( z '0452' ), & ! CYRILLIC SMALL LETTER DJE (SERBOCROATIAN) <= CYRILLIC CAPITAL LETTER DJE (SERBOCROATIAN) int ( z '0403' ), int ( z '0453' ), & ! CYRILLIC SMALL LETTER GJE <= CYRILLIC CAPITAL LETTER GJE int ( z '0404' ), int ( z '0454' ), & ! CYRILLIC SMALL LETTER UKRAINIAN IE <= CYRILLIC CAPITAL LETTER UKRAINIAN IE int ( z '0405' ), int ( z '0455' ), & ! CYRILLIC SMALL LETTER DZE <= CYRILLIC CAPITAL LETTER DZE int ( z '0406' ), int ( z '0456' ), & ! CYRILLIC SMALL LETTER BYELORUSSIAN-UKRAINIAN I <= CYRILLIC CAPITAL LETTER BYELORUSSIAN_UKRAINIAN I int ( z '0407' ), int ( z '0457' ), & ! CYRILLIC SMALL LETTER YI (UKRAINIAN) <= CYRILLIC CAPITAL LETTER YI (UKRAINIAN) int ( z '0408' ), int ( z '0458' ), & ! CYRILLIC SMALL LETTER JE <= CYRILLIC CAPITAL LETTER JE int ( z '0409' ), int ( z '0459' ), & ! CYRILLIC SMALL LETTER LJE <= CYRILLIC CAPITAL LETTER LJE int ( z '040A' ), int ( z '045A' ), & ! CYRILLIC SMALL LETTER NJE <= CYRILLIC CAPITAL LETTER NJE int ( z '040B' ), int ( z '045B' ), & ! CYRILLIC SMALL LETTER TSHE (SERBOCROATIAN) <= CYRILLIC CAPITAL LETTER TSHE (SERBOCROATIAN) int ( z '040C' ), int ( z '045C' ), & ! CYRILLIC SMALL LETTER KJE <= CYRILLIC CAPITAL LETTER KJE int ( z '040E' ), int ( z '045E' ), & ! CYRILLIC SMALL LETTER SHORT U (BYELORUSSIAN) <= CYRILLIC CAPITAL LETTER SHORT U (BYELORUSSIAN) int ( z '040F' ), int ( z '045F' ), & ! CYRILLIC SMALL LETTER DZHE <= CYRILLIC CAPITAL LETTER DZHE int ( z '0410' ), int ( z '0430' ), & ! CYRILLIC SMALL LETTER A <= CYRILLIC CAPITAL LETTER A int ( z '0411' ), int ( z '0431' ), & ! CYRILLIC SMALL LETTER BE <= CYRILLIC CAPITAL LETTER BE int ( z '0412' ), int ( z '0432' ), & ! CYRILLIC SMALL LETTER VE <= CYRILLIC CAPITAL LETTER VE int ( z '0413' ), int ( z '0433' ), & ! CYRILLIC SMALL LETTER GHE <= CYRILLIC CAPITAL LETTER GHE int ( z '0414' ), int ( z '0434' ), & ! CYRILLIC SMALL LETTER DE <= CYRILLIC CAPITAL LETTER DE int ( z '0415' ), int ( z '0435' ), & ! CYRILLIC SMALL LETTER IE <= CYRILLIC CAPITAL LETTER IE int ( z '0416' ), int ( z '0436' ), & ! CYRILLIC SMALL LETTER ZHE <= CYRILLIC CAPITAL LETTER ZHE int ( z '0417' ), int ( z '0437' ), & ! CYRILLIC SMALL LETTER ZE <= CYRILLIC CAPITAL LETTER ZE int ( z '0418' ), int ( z '0438' ), & ! CYRILLIC SMALL LETTER I <= CYRILLIC CAPITAL LETTER I int ( z '0419' ), int ( z '0439' ), & ! CYRILLIC SMALL LETTER SHORT I <= CYRILLIC CAPITAL LETTER SHORT I int ( z '041A' ), int ( z '043A' ), & ! CYRILLIC SMALL LETTER KA <= CYRILLIC CAPITAL LETTER KA int ( z '041B' ), int ( z '043B' ), & ! CYRILLIC SMALL LETTER EL <= CYRILLIC CAPITAL LETTER EL int ( z '041C' ), int ( z '043C' ), & ! CYRILLIC SMALL LETTER EM <= CYRILLIC CAPITAL LETTER EM int ( z '041D' ), int ( z '043D' ), & ! CYRILLIC SMALL LETTER EN <= CYRILLIC CAPITAL LETTER EN int ( z '041E' ), int ( z '043E' ), & ! CYRILLIC SMALL LETTER O <= CYRILLIC CAPITAL LETTER O int ( z '041F' ), int ( z '043F' ), & ! CYRILLIC SMALL LETTER PE <= CYRILLIC CAPITAL LETTER PE int ( z '0420' ), int ( z '0440' ), & ! CYRILLIC SMALL LETTER ER <= CYRILLIC CAPITAL LETTER ER int ( z '0421' ), int ( z '0441' ), & ! CYRILLIC SMALL LETTER ES <= CYRILLIC CAPITAL LETTER ES int ( z '0422' ), int ( z '0442' ), & ! CYRILLIC SMALL LETTER TE <= CYRILLIC CAPITAL LETTER TE int ( z '0423' ), int ( z '0443' ), & ! CYRILLIC SMALL LETTER U <= CYRILLIC CAPITAL LETTER U int ( z '0424' ), int ( z '0444' ), & ! CYRILLIC SMALL LETTER EF <= CYRILLIC CAPITAL LETTER EF int ( z '0425' ), int ( z '0445' ), & ! CYRILLIC SMALL LETTER HA <= CYRILLIC CAPITAL LETTER HA int ( z '0426' ), int ( z '0446' ), & ! CYRILLIC SMALL LETTER TSE <= CYRILLIC CAPITAL LETTER TSE int ( z '0427' ), int ( z '0447' ), & ! CYRILLIC SMALL LETTER CHE <= CYRILLIC CAPITAL LETTER CHE int ( z '0428' ), int ( z '0448' ), & ! CYRILLIC SMALL LETTER SHA <= CYRILLIC CAPITAL LETTER SHA int ( z '0429' ), int ( z '0449' ), & ! CYRILLIC SMALL LETTER SHCHA <= CYRILLIC CAPITAL LETTER SHCHA int ( z '042A' ), int ( z '044A' ), & ! CYRILLIC SMALL LETTER HARD SIGN <= CYRILLIC CAPITAL LETTER HARD SIGN int ( z '042B' ), int ( z '044B' ), & ! CYRILLIC SMALL LETTER YERU <= CYRILLIC CAPITAL LETTER YERU int ( z '042C' ), int ( z '044C' ), & ! CYRILLIC SMALL LETTER SOFT SIGN <= CYRILLIC CAPITAL LETTER SOFT SIGN int ( z '042D' ), int ( z '044D' ), & ! CYRILLIC SMALL LETTER E <= CYRILLIC CAPITAL LETTER E int ( z '042E' ), int ( z '044E' ), & ! CYRILLIC SMALL LETTER YU <= CYRILLIC CAPITAL LETTER YU int ( z '042F' ), int ( z '044F' ), & ! CYRILLIC SMALL LETTER YA <= CYRILLIC CAPITAL LETTER YA int ( z '0460' ), int ( z '0461' ), & ! CYRILLIC SMALL LETTER OMEGA <= CYRILLIC CAPITAL LETTER OMEGA int ( z '0462' ), int ( z '0463' ), & ! CYRILLIC SMALL LETTER YAT <= CYRILLIC CAPITAL LETTER YAT int ( z '0464' ), int ( z '0465' ), & ! CYRILLIC SMALL LETTER IOTIFIED E <= CYRILLIC CAPITAL LETTER IOTIFIED E int ( z '0466' ), int ( z '0467' ), & ! CYRILLIC SMALL LETTER LITTLE YUS <= CYRILLIC CAPITAL LETTER LITTLE YUS int ( z '0468' ), int ( z '0469' ), & ! CYRILLIC SMALL LETTER IOTIFIED LITTLE YUS <= CYRILLIC CAPITAL LETTER IOTIFIED LITTLE YUS int ( z '046A' ), int ( z '046B' ), & ! CYRILLIC SMALL LETTER BIG YUS <= CYRILLIC CAPITAL LETTER BIG YUS int ( z '046C' ), int ( z '046D' ), & ! CYRILLIC SMALL LETTER IOTIFIED BIG YUS <= CYRILLIC CAPITAL LETTER IOTIFIED BIG YUS int ( z '046E' ), int ( z '046F' ), & ! CYRILLIC SMALL LETTER KSI <= CYRILLIC CAPITAL LETTER KSI int ( z '0470' ), int ( z '0471' ), & ! CYRILLIC SMALL LETTER PSI <= CYRILLIC CAPITAL LETTER PSI int ( z '0472' ), int ( z '0473' ), & ! CYRILLIC SMALL LETTER FITA <= CYRILLIC CAPITAL LETTER FITA int ( z '0474' ), int ( z '0475' ), & ! CYRILLIC SMALL LETTER IZHITSA <= CYRILLIC CAPITAL LETTER IZHITSA int ( z '0476' ), int ( z '0477' ), & ! CYRILLIC SMALL LETTER IZHITSA WITH DOUBLE GRAVE ACCENT <= CYRILLIC CAPITAL LETTER IZHITSA WITH DOUBLE GRAVE ACCENT int ( z '0478' ), int ( z '0479' ), & ! CYRILLIC SMALL LETTER UK <= CYRILLIC CAPITAL LETTER UK int ( z '047A' ), int ( z '047B' ), & ! CYRILLIC SMALL LETTER ROUND OMEGA <= CYRILLIC CAPITAL LETTER ROUND OMEGA int ( z '047C' ), int ( z '047D' ), & ! CYRILLIC SMALL LETTER OMEGA WITH TITLO <= CYRILLIC CAPITAL LETTER OMEGA WITH TITLO int ( z '047E' ), int ( z '047F' ), & ! CYRILLIC SMALL LETTER OT <= CYRILLIC CAPITAL LETTER OT int ( z '0480' ), int ( z '0481' ), & ! CYRILLIC SMALL LETTER KOPPA <= CYRILLIC CAPITAL LETTER KOPPA int ( z '0490' ), int ( z '0491' ), & ! CYRILLIC SMALL LETTER GHE WITH UPTURN <= CYRILLIC CAPITAL LETTER GHE WITH UPTURN int ( z '0492' ), int ( z '0493' ), & ! CYRILLIC SMALL LETTER GHE WITH STROKE <= CYRILLIC CAPITAL LETTER GHE WITH STROKE int ( z '0494' ), int ( z '0495' ), & ! CYRILLIC SMALL LETTER GHE WITH MIDDLE HOOK <= CYRILLIC CAPITAL LETTER GHE WITH MIDDLE HOOK int ( z '0496' ), int ( z '0497' ), & ! CYRILLIC SMALL LETTER ZHE WITH DESCENDER <= CYRILLIC CAPITAL LETTER ZHE WITH DESCENDER int ( z '0498' ), int ( z '0499' ), & ! CYRILLIC SMALL LETTER ZE WITH DESCENDER <= CYRILLIC CAPITAL LETTER ZE WITH DESCENDER int ( z '049A' ), int ( z '049B' ), & ! CYRILLIC SMALL LETTER KA WITH DESCENDER <= CYRILLIC CAPITAL LETTER KA WITH DESCENDER int ( z '049C' ), int ( z '049D' ), & ! CYRILLIC SMALL LETTER KA WITH VERTICAL STROKE <= CYRILLIC CAPITAL LETTER KA WITH VERTICAL STROKE int ( z '049E' ), int ( z '049F' ), & ! CYRILLIC SMALL LETTER KA WITH STROKE <= CYRILLIC CAPITAL LETTER KA WITH STROKE int ( z '04A0' ), int ( z '04A1' ), & ! CYRILLIC SMALL LETTER EASHKIR KA <= CYRILLIC CAPITAL LETTER BASHKIR KA int ( z '04A2' ), int ( z '04A3' ), & ! CYRILLIC SMALL LETTER EN WITH DESCENOER <= CYRILLIC CAPITAL LETTER EN WITH DESCENDER int ( z '04A4' ), int ( z '04A5' ), & ! CYRILLIC SMALL LIGATURE EN GHE <= CYRILLIC CAPITAL LIGATURE EN GHF int ( z '04A6' ), int ( z '04A7' ), & ! CYRILLIC SMALL LETTER PE WITH MIDDLE HOOK (ABKHASIAN) <= CYRILLIC CAPITAL LETTER PE WITH MIDDLE HOOK (ABKHASIAN) int ( z '04A8' ), int ( z '04A9' ), & ! CYRILLIC SMALL LETTER ABKHASIAN HA <= CYRILLIC CAPITAL LETTER ABKHASIAN HA int ( z '04AA' ), int ( z '04AB' ), & ! CYRILLIC SMALL LETTER ES WITH DESCENDER <= CYRILLIC CAPITAL LETTER ES WITH DESCENDER int ( z '04AC' ), int ( z '04AD' ), & ! CYRILLIC SMALL LETTER TE WITH DESCENDER <= CYRILLIC CAPITAL LETTER TE WITH DESCENDER int ( z '04AE' ), int ( z '04AF' ), & ! CYRILLIC SMALL LETTER STRAIGHT U <= CYRILLIC CAPITAL LETTER STRAIGHT U int ( z '04B0' ), int ( z '04B1' ), & ! CYRILLIC SMALL LETTER STRAIGHT U WITH STROKE <= CYRILLIC CAPITAL LETTER STRAIGHT U WITH STROKE int ( z '04B2' ), int ( z '04B3' ), & ! CYRILLIC SMALL LETTER HA WITH DESCENDER <= CYRILLIC CAPITAL LETTER HA WITH DESCENDER int ( z '04B4' ), int ( z '04B5' ), & ! CYRILLIC SMALL LIGATURE TE TSE (ABKHASIAN) <= CYRILLIC CAPITAL LIGATURE TE TSE (ABKHASIAN) int ( z '04B6' ), int ( z '04B7' ), & ! CYRILLIC SMALL LETTER CHE WITH DESCENDER <= CYRILLIC CAPITAL LETTER CHE WITH DESCENDER int ( z '04B8' ), int ( z '04B9' ), & ! CYRILLIC SMALL LETTER CHE WITH VERTICAL STROKE <= CYRILLIC CAPITAL LETTER CHE WITH VERTICAL STROKE int ( z '04BA' ), int ( z '04BB' ), & ! CYRILLIC SMALL LETTER SHHA <= CYRILLIC CAPITAL LETTER SHHA int ( z '04BC' ), int ( z '04BD' ), & ! CYRILLIC SMALL LETTER ABKHASIAN CHE <= CYRILLIC CAPITAL LETTER ABKHASIAN CHE int ( z '04BE' ), int ( z '04BF' ), & ! CYRILLIC SMALL LETTER ABKHASIAN CHE WITH DESCENDER <= CYRILLIC CAPITAL LETTER ABKHASIAN CHE WITH DESCENDER int ( z '04C1' ), int ( z '04C2' ), & ! CYRILLIC SMALL LETTER ZHE WITH BREVE <= CYRILLIC CAPITAL LETTER ZHE WITH BREVE int ( z '04C3' ), int ( z '04C4' ), & ! CYRILLIC SMALL LETTER KA WITH HOOK <= CYRILLIC CAPITAL LETTER KA WITH HOOK int ( z '04C7' ), int ( z '04C8' ), & ! CYRILLIC SMALL LETTER EN WITH HOOK <= CYRILLIC CAPITAL LETTER EN WITH HOOK int ( z '04CB' ), int ( z '04CC' ), & ! CYRILLIC SMALL LETTER KHAKASSIAN CHE <= CYRILLIC CAPITAL LETTER KHAKASSIAN CHE int ( z '04D0' ), int ( z '04D1' ), & ! CYRILLIC SMALL LETTER A WITH BREVE <= CYRILLIC CAPITAL LETTER A WITH BREVE int ( z '04D2' ), int ( z '04D3' ), & ! CYRILLIC SMALL LETTER A WITH DIAERESIS <= CYRILLIC CAPITAL LETTER A WITH DIAERESIS int ( z '04D4' ), int ( z '04D5' ), & ! CYRILLIC SMALL LIGATURE A IE <= CYRILLIC CAPITAL LIGATURE A IE int ( z '04D6' ), int ( z '04D7' ), & ! CYRILLIC SMALL LETTER IE WITH BREVE <= CYRILLIC CAPITAL LETTER IE WITH BREVE int ( z '04D8' ), int ( z '04D9' ), & ! CYRILLIC SMALL LETTER SCHWA <= CYRILLIC CAPITAL LETTER SCHWA int ( z '04DA' ), int ( z '04DB' ), & ! CYRILLIC SMALL LETTER SCHWA WITH DIAERESIS <= CYRILLIC CAPITAL LETTER SCHWA WITH DIAERESIS int ( z '04DC' ), int ( z '04DD' ), & ! CYRILLIC SMALL LETTER ZHE WITH DIAERESIS <= CYRILLIC CAPITAL LETTER ZHE WITH DIAERESIS int ( z '04DE' ), int ( z '04DF' ), & ! CYRILLIC SMALL LETTER ZE WITH DIAERESIS <= CYRILLIC CAPITAL LETTER ZE WITH DIAERESIS int ( z '04E0' ), int ( z '04E1' ), & ! CYRILLIC SMALL LETTER ABKHASIAN DZE <= CYRILLIC CAPITAL LETTER ABKHASIAN DZE int ( z '04E2' ), int ( z '04E3' ), & ! CYRILLIC SMALL LETTER I WITH MACRON <= CYRILLIC CAPITAL LETTER I WITH MACRON int ( z '04E4' ), int ( z '04E5' ), & ! CYRILLIC SMALL LETTER I WITH DIAERESIS <= CYRILLIC CAPITAL LETTER I WITH DIAERESIS int ( z '04E6' ), int ( z '04E7' ), & ! CYRILLIC SMALL LETTER O WITH DIAERESIS <= CYRILLIC CAPITAL LETTER O WITH DIAERESIS int ( z '04E8' ), int ( z '04E9' ), & ! CYRILLIC SMALL LETTER BARRED O <= CYRILLIC CAPITAL LETTER BARRED O int ( z '04EA' ), int ( z '04EB' ), & ! CYRILLIC SMALL LETTER BARRED O WITH DIAERESIS <= CYRILLIC CAPITAL LETTER BARRED O WITH DIAERESIS int ( z '04EE' ), int ( z '04EF' ), & ! CYRILLIC SMALL LETTER U WITH MACRON <= CYRILLIC CAPITAL LETTER U WITH MACRON int ( z '04F0' ), int ( z '04F1' ), & ! CYRILLIC SMALL LETTER U WITH DIAERESIS <= CYRILLIC CAPITAL LETTER U WITH DIAERESIS int ( z '04F2' ), int ( z '04F3' ), & ! CYRILLIC SMALL LETTER U WITH DOUBLE ACUTE <= CYRILLIC CAPITAL LETTER U WITH DOUBLE ACUTE int ( z '04F4' ), int ( z '04F5' ), & ! CYRILLIC SMALL LETTER CHE AITH DIAERESIS <= CYRILLIC CAPITAL LETTER CHE WITH DIAERESIS int ( z '04F8' ), int ( z '04F9' ), & ! CYRILLIC SMALL LETTER YERU WITH DIAERESIS <= CYRILLIC CAPITAL LETTER YERU WITH DIAERESIS int ( z '0531' ), int ( z '0561' ), & ! ARMENIAN SMALL LETTER AYB <= ARMENIAN CAPITAL LETTER AYB int ( z '0532' ), int ( z '0562' ), & ! ARMENIAN SMALL LETTER BEN <= ARMENIAN CAPITAL LETTER BEN int ( z '0533' ), int ( z '0563' ), & ! ARMENIAN SMALL LETTER GIM <= ARMENIAN CAPITAL LETTER GIM int ( z '0534' ), int ( z '0564' ), & ! ARMENIAN SMALL LETTER DA <= ARMENIAN CAPITAL LETTER DA int ( z '0535' ), int ( z '0565' ), & ! ARMENIAN SMALL LETTER ECH <= ARMENIAN CAPITAL LETTER ECH int ( z '0536' ), int ( z '0566' ), & ! ARMENIAN SMALL LETTER ZA <= ARMENIAN CAPITAL LETTER ZA int ( z '0537' ), int ( z '0567' ), & ! ARMENIAN SMALL LETTER EH <= ARMENIAN CAPITAL LETTER EH int ( z '0538' ), int ( z '0568' ), & ! ARMENIAN SMALL LETTER ET <= ARMENIAN CAPITAL LETTER ET int ( z '0539' ), int ( z '0569' ), & ! ARMENIAN SMALL LETTER TO <= ARMENIAN CAPITAL LETTER TO int ( z '053A' ), int ( z '056A' ), & ! ARMENIAN SMALL LETTER ZHE <= ARMENIAN CAPITAL LETTER ZHE int ( z '053B' ), int ( z '056B' ), & ! ARMENIAN SMALL LETTER INI <= ARMENIAN CAPITAL LETTER INI int ( z '053C' ), int ( z '056C' ), & ! ARMENIAN SMALL LETTER LIWN <= ARMENIAN CAPITAL LETTER LIWN int ( z '053D' ), int ( z '056D' ), & ! ARMENIAN SMALL LETTER XEH <= ARMENIAN CAPITAL LETTER XEH int ( z '053E' ), int ( z '056E' ), & ! ARMENIAN SMALL LETTER CA <= ARMENIAN CAPITAL LETTER CA int ( z '053F' ), int ( z '056F' ), & ! ARMENIAN SMALL LETTER KEN <= ARMENIAN CAPITAL LETTER KEN int ( z '0540' ), int ( z '0570' ), & ! ARMENIAN SMALL LETTER HO <= ARMENIAN CAPITAL LETTER HO int ( z '0541' ), int ( z '0571' ), & ! ARMENIAN SMALL LETTER JA <= ARMENIAN CAPITAL LETTER JA int ( z '0542' ), int ( z '0572' ), & ! ARMENIAN SMALL LETTER GHAD <= ARMENIAN CAPITAL LETTER GHAD int ( z '0543' ), int ( z '0573' ), & ! ARMENIAN SMALL LETTER CHEH <= ARMENIAN CAPITAL LETTER CHEH int ( z '0544' ), int ( z '0574' ), & ! ARMENIAN SMALL LETTER MEN <= ARMENIAN CAPITAL LETTER MEN int ( z '0545' ), int ( z '0575' ), & ! ARMENIAN SMALL LETTER YI <= ARMENIAN CAPITAL LETTER YI int ( z '0546' ), int ( z '0576' ), & ! ARMENIAN SMALL LETTER NOW <= ARMENIAN CAPITAL LETTER NOW int ( z '0547' ), int ( z '0577' ), & ! ARMENIAN SMALL LETTER SNA <= ARMENIAN CAPITAL LETTER SHA int ( z '0548' ), int ( z '0578' ), & ! ARMENIAN SMALL LETTER VO <= ARMENIAN CAPITAL LETTER VO int ( z '0549' ), int ( z '0579' ), & ! ARMENIAN SMALL LETTER CHA <= ARMENIAN CAPITAL LETTER CHA int ( z '054A' ), int ( z '057A' ), & ! ARMENIAN SMALL LETTER PEH <= ARMENIAN CAPITAL LETTER PEH int ( z '054B' ), int ( z '057B' ), & ! ARMENIAN SMALL LETTER JHEH <= ARMENIAN CAPITAL LETTER JHEH int ( z '054C' ), int ( z '057C' ), & ! ARMENIAN SMALL LETTER RA <= ARMENIAN CAPITAL LETTER RA int ( z '054D' ), int ( z '057D' ), & ! ARMENIAN SMALL LETTER SEH <= ARMENIAN CAPITAL LETTER SEH int ( z '054E' ), int ( z '057E' ), & ! ARMENIAN SMALL LETTER VEW <= ARMENIAN CAPITAL LETTER VEW int ( z '054F' ), int ( z '057F' ), & ! ARMENIAN SMALL LETTER TIWN <= ARMENIAN CAPITAL LETTER TIWN int ( z '0550' ), int ( z '0580' ), & ! ARMENIAN SMALL LETTER REH <= ARMENIAN CAPITAL LETTER REH int ( z '0551' ), int ( z '0581' ), & ! ARMENIAN SMALL LETTER CO <= ARMENIAN CAPITAL LETTER CO int ( z '0552' ), int ( z '0582' ), & ! ARMENIAN SMALL LETTER YIWN <= ARMENIAN CAPITAL LETTER YIWN int ( z '0553' ), int ( z '0583' ), & ! ARMENIAN SMALL LETTER PIWP <= ARMENIAN CAPITAL LETTER PIWR int ( z '0554' ), int ( z '0584' ), & ! ARMENIAN SMALL LETTER KEH <= ARMENIAN CAPITAL LETTER KEH int ( z '0555' ), int ( z '0585' ), & ! ARMENIAN SMALL LETTER OH <= ARMENIAN CAPITAL LETTER OH int ( z '0556' ), int ( z '0586' ), & ! ARMENIAN SMALL LETTER FEH <= ARMENIAN CAPITAL LETTER FEH int ( z '10A0' ), int ( z '10D0' ), & ! GEORGIAN LETTER AN <= GEORGIAN CAPITAL LETTER AN (KHUTSURI) int ( z '10A1' ), int ( z '10D1' ), & ! GEORGIAN LETTER BAN <= GEORGIAN CAPITAL LETTER BAN (KHUTSURI) int ( z '10A2' ), int ( z '10D2' ), & ! GEORGIAN LETTER GAN <= GEORGIAN CAPITAL LETTER GAN (KHUTSURI) int ( z '10A3' ), int ( z '10D3' ), & ! GEORGIAN LETTER DON <= GEORGIAN CAPITAL LETTER DON (KHUTSURI) int ( z '10A4' ), int ( z '10D4' ), & ! GEORGIAN LETTER EN <= GEORGIAN CAPITAL LETTER EN (KHUTSURI) int ( z '10A5' ), int ( z '10D5' ), & ! GEORGIAN LETTER VIN <= GEORGIAN CAPITAL LETTER VIN (KHUTSURI) int ( z '10A6' ), int ( z '10D6' ), & ! GEORGIAN LETTER ZEN <= GEORGIAN CAPITAL LETTER ZEN (KHUTSURI) int ( z '10A7' ), int ( z '10D7' ), & ! GEORGIAN LETTER TAN <= GEORGIAN CAPITAL LETTER TAN (KHUTSURI) int ( z '10A8' ), int ( z '10D8' ), & ! GEORGIAN LETTER IN <= GEORGIAN CAPITAL LETTER IN (KHUTSURI) int ( z '10A9' ), int ( z '10D9' ), & ! GEORGIAN LETTER KAN <= GEORGIAN CAPITAL LETTER KAN (KHUTSURI) int ( z '10AA' ), int ( z '10DA' ), & ! GEORGIAN LETTER LAS <= GEORGIAN CAPITAL LETTER LAS (KHUTSURI) int ( z '10AB' ), int ( z '10DB' ), & ! GEORGIAN LETTER MAN <= GEORGIAN CAPITAL LETTER MAN (KHUTSURI) int ( z '10AC' ), int ( z '10DC' ), & ! GEORGIAN LETTER NAR <= GEORGIAN CAPITAL LETTER NAR (KHUTSURI) int ( z '10AD' ), int ( z '10DD' ), & ! GEORGIAN LETTER ON <= GEORGIAN CAPITAL LETTER ON (KHUTSURI) int ( z '10AE' ), int ( z '10DE' ), & ! GEORGIAN LETTER PAR <= GEORGIAN CAPITAL LETTER PAR (KHUTSURI) int ( z '10AF' ), int ( z '10DF' ), & ! GEORGIAN LETTER ZHAR <= GEORGIAN CAPITAL LETTER ZHAR (KHUTSURI) int ( z '10B0' ), int ( z '10E0' ), & ! GEORGIAN LETTER RAE <= GEORGIAN CAPITAL LETTER RAE (KHUTSURI) int ( z '10B1' ), int ( z '10E1' ), & ! GEORGIAN LETTER SAN <= GEORGIAN CAPITAL LETTER SAN (KHUTSURI) int ( z '10B2' ), int ( z '10E2' ), & ! GEORGIAN LETTER TAR <= GEORGIAN CAPITAL LETTER TAR (KHUTSURI) int ( z '10B3' ), int ( z '10E3' ), & ! GEORGIAN LETTER UN <= GEORGIAN CAPITAL LETTER UN (KHUTSURI) int ( z '10B4' ), int ( z '10E4' ), & ! GEORGIAN LETTER PHAR <= GEORGIAN CAPITAL LETTER PHAR (KHUTSURI) int ( z '10B5' ), int ( z '10E5' ), & ! GEORGIAN LETTER KHAR <= GEORGIAN CAPITAL LETTER KHAR (KHUTSURI) int ( z '10B6' ), int ( z '10E6' ), & ! GEORGIAN LETTER GHAN <= GEORGIAN CAPITAL LETTER GHAN (KHUTSURI) int ( z '10B7' ), int ( z '10E7' ), & ! GEORGIAN LETTER QAR <= GEORGIAN CAPITAL LETTER QAR (KHUTSURI) int ( z '10B8' ), int ( z '10E8' ), & ! GEORGIAN LETTER SHIN <= GEORGIAN CAPITAL LETTER SHIN (KHUTSURI) int ( z '10B9' ), int ( z '10E9' ), & ! GEORGIAN LETTER CHIN <= GEORGIAN CAPITAL LETTER CHIN (KHUTSURI) int ( z '10BA' ), int ( z '10EA' ), & ! GEORGIAN LETTER CAN <= GEORGIAN CAPITAL LETTER CAN (KHUTSURI) int ( z '10BB' ), int ( z '10EB' ), & ! GEORGIAN LETTER JIL <= GEORGIAN CAPITAL LETTER JIL (KHUTSURI) int ( z '10BC' ), int ( z '10EC' ), & ! GEORGIAN LETTER CIL <= GEORGIAN CAPITAL LETTER CIL (KHUTSURI) int ( z '10BD' ), int ( z '10ED' ), & ! GEORGIAN LETTER CHAR <= GEORGIAN CAPITAL LETTER CHAR (KHUTSURI) int ( z '10BE' ), int ( z '10EE' ), & ! GEORGIAN LETTER XAN <= GEORGIAN CAPITAL LETTER XAN (KHUTSURI) int ( z '10BF' ), int ( z '10EF' ), & ! GEORGIAN LETTER JHAN <= GEORGIAN CAPITAL LETTER JHAN (KHUTSURI) int ( z '10C0' ), int ( z '10F0' ), & ! GEORGIAN LETTER HAE <= GEORGIAN CAPITAL LETTER HAE (KHUTSURI) int ( z '10C1' ), int ( z '10F1' ), & ! GEORGIAN LETTER HE <= GEORGIAN CAPITAL LETTER HE (KHUTSURI) int ( z '10C2' ), int ( z '10F2' ), & ! GEORGIAN LETTER HIE <= GEORGIAN CAPITAL LETTER HIE (KHUTSURI) int ( z '10C3' ), int ( z '10F3' ), & ! GEORGIAN LETTER WE <= GEORGIAN CAPITAL LETTER WE (KHUTSURI) int ( z '10C4' ), int ( z '10F4' ), & ! GEORGIAN LETTER HAR <= GEORGIAN CAPITAL LETTER HAR (KHUTSURI) int ( z '10C5' ), int ( z '10F5' ), & ! GEORGIAN LETTER HOE <= GEORGIAN CAPITAL LETTER HOE (KHUTSURI) int ( z '1E00' ), int ( z '1E01' ), & ! LATIN SMALL LETTER A WITH RING BELOW <= LATIN CAPITAL LETTER A WITH RING BELOW int ( z '1E02' ), int ( z '1E03' ), & ! LATIN SMALL LETTER B WITH DOT ABOVE <= LATIN CAPITAL LETTER B WITH DOT ABOVE int ( z '1E04' ), int ( z '1E05' ), & ! LATIN SMALL LETTER B WITH DOT BELOW <= LATIN CAPITAL LETTER B WITH DOT BELOW int ( z '1E06' ), int ( z '1E07' ), & ! LATIN SMALL LETTER B WITH LINE BELOW <= LATIN CAPITAL LETTER B WITH LINE BELOW int ( z '1E08' ), int ( z '1E09' ), & ! LATIN SMALL LETTER C WITH CEDILLA AND ACUTE <= LATIN CAPITAL LETTER C WITH CEDILLA AND ACUTE int ( z '1E0A' ), int ( z '1E0B' ), & ! LATIN SMALL LETTER D WITH DOT ABOVE <= LATIN CAPITAL LETTER D WITH DOT ABOVE int ( z '1E0C' ), int ( z '1E0D' ), & ! LATIN SMALL LETTER D WITH DOT BELOW <= LATIN CAPITAL LETTER D WITH DOT BELOW int ( z '1E0E' ), int ( z '1E0F' ), & ! LATIN SMALL LETTER D WITH LINE BELOW <= LATIN CAPITAL LETTER D WITH LINE BELOW int ( z '1E10' ), int ( z '1E11' ), & ! LATIN SMALL LETTER D WITH CEDILLA <= LATIN CAPITAL LETTER D WITH CEDILLA int ( z '1E12' ), int ( z '1E13' ), & ! LATIN SMALL LETTER D WITH CIRCUMFLEX BELOW <= LATIN CAPITAL LETTER D WITH CIRCUMFLEX BELOW int ( z '1E14' ), int ( z '1E15' ), & ! LATIN SMALL LETTER E WITH MACRON AND GRAVE <= LATIN CAPITAL LETTER E WITH MACRON AND GRAVE int ( z '1E16' ), int ( z '1E17' ), & ! LATIN SMALL LETTER E WITH MACRON AND ACUTE <= LATIN CAPITAL LETTER E WITH MACRON AND ACUTE int ( z '1E18' ), int ( z '1E19' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX BELOW <= LATIN CAPITAL LETTER E WITH CIRCUMFLEX BELOW int ( z '1E1A' ), int ( z '1E1B' ), & ! LATIN SMALL LETTER E WITH TILDE BELOW <= LATIN CAPITAL LETTER E WITH TILDE BELOW int ( z '1E1C' ), int ( z '1E1D' ), & ! LATIN SMALL LETTER E WITH CEDILLA AND BREVE <= LATIN CAPITAL LETTER E WITH CEDILLA AND BREVE int ( z '1E1E' ), int ( z '1E1F' ), & ! LATIN SMALL LETTER F WITH DOT ABOVE <= LATIN CAPITAL LETTER F WITH DOT ABOVE int ( z '1E20' ), int ( z '1E21' ), & ! LATIN SMALL LETTER G WITH MACRON <= LATIN CAPITAL LETTER G WITH MACRON int ( z '1E22' ), int ( z '1E23' ), & ! LATIN SMALL LETTER H WITH DOT ABOVE <= LATIN CAPITAL LETTER H WITH DOT ABOVE int ( z '1E24' ), int ( z '1E25' ), & ! LATIN SMALL LETTER H WITH DOT BELOW <= LATIN CAPITAL LETTER H WITH DOT BELOW int ( z '1E26' ), int ( z '1E27' ), & ! LATIN SMALL LETTER H WITH DIAERESIS <= LATIN CAPITAL LETTER H WITH DIAERESIS int ( z '1E28' ), int ( z '1E29' ), & ! LATIN SMALL LETTER H WITH CEDILLA <= LATIN CAPITAL LETTER H WITH CEDILLA int ( z '1E2A' ), int ( z '1E2B' ), & ! LATIN SMALL LETTER H WITH BREVE BELOW <= LATIN CAPITAL LETTER H WITH BREVE BELOW int ( z '1E2C' ), int ( z '1E2D' ), & ! LATIN SMALL LETTER I WITH TILDE BELOW <= LATIN CAPITAL LETTER I WITH TILDE BELOW int ( z '1E2E' ), int ( z '1E2F' ), & ! LATIN SMALL LETTER I WITH DIAERESIS AND ACUTE <= LATIN CAPITAL LETTER I WITH DIAERESIS AND ACUTE int ( z '1E30' ), int ( z '1E31' ), & ! LATIN SMALL LETTER K WITH ACUTE <= LATIN CAPITAL LETTER K WITH ACUTE int ( z '1E32' ), int ( z '1E33' ), & ! LATIN SMALL LETTER K WITH DOT BELOW <= LATIN CAPITAL LETTER K WITH DOT BELOW int ( z '1E34' ), int ( z '1E35' ), & ! LATIN SMALL LETTER K WITH LINE BELOW <= LATIN CAPITAL LETTER K WITH LINE BELOW int ( z '1E36' ), int ( z '1E37' ), & ! LATIN SMALL LETTER L WITH DOT BELOW <= LATIN CAPITAL LETTER L WITH DOT BELOW int ( z '1E38' ), int ( z '1E39' ), & ! LATIN SMALL LETTER L WITH DOT BELOW AND MACRON <= LATIN CAPITAL LETTER L WITH DOT BELOW AND MACRON int ( z '1E3A' ), int ( z '1E3B' ), & ! LATIN SMALL LETTER L WITH LINE BELOW <= LATIN CAPITAL LETTER L WITH LINE BELOW int ( z '1E3C' ), int ( z '1E3D' ), & ! LATIN SMALL LETTER L WITH CIRCUMFLEX BELOW <= LATIN CAPITAL LETTER L WITH CIRCUMFLEX BELOW int ( z '1E3E' ), int ( z '1E3F' ), & ! LATIN SMALL LETTER M WITH ACUTE <= LATIN CAPITAL LETTER M WITH ACUTE int ( z '1E40' ), int ( z '1E41' ), & ! LATIN SMALL LETTER M WITH DOT ABOVE <= LATIN CAPITAL LETTER M WITH DOT ABOVE int ( z '1E42' ), int ( z '1E43' ), & ! LATIN SMALL LETTER M WITH DOT BELOW <= LATIN CAPITAL LETTER M WITH DOT BELOW int ( z '1E44' ), int ( z '1E45' ), & ! LATIN SMALL LETTER N WITH DOT ABOVE <= LATIN CAPITAL LETTER N WITH DOT ABOVE int ( z '1E46' ), int ( z '1E47' ), & ! LATIN SMALL LETTER N WITH DOT BELOW <= LATIN CAPITAL LETTER N WITH DOT BELOW int ( z '1E48' ), int ( z '1E49' ), & ! LATIN SMALL LETTER N WITH LINE BELOW <= LATIN CAPITAL LETTER N WITH LINE BELOW int ( z '1E4A' ), int ( z '1E4B' ), & ! LATIN SMALL LETTER N WITH CIRCUMFLEX BELOW <= LATIN CAPITAL LETTER N WITH CIRCUMFLEX BELOW int ( z '1E4C' ), int ( z '1E4D' ), & ! LATIN SMALL LETTER O WITH TILDE AND ACUTE <= LATIN CAPITAL LETTER O WITH TILDE AND ACUTE int ( z '1E4E' ), int ( z '1E4F' ), & ! LATIN SMALL LETTER O WITH TlLDE AND DIAERESIS <= LATIN CAPITAL LETTER O WITH TILDE AND DIAERESIS int ( z '1E50' ), int ( z '1E51' ), & ! LATIN SMALL LETTER O WITH MACRON AND GRAVE <= LATIN CAPITAL LETTER O WITH MACRON AND GRAVE int ( z '1E52' ), int ( z '1E53' ), & ! LATIN SMALL LETTER O WITH MACRON AND ACUTE <= LATIN CAPITAL LETTER O WITH MACRON AND ACUTE int ( z '1E54' ), int ( z '1E55' ), & ! LATIN SMALL LETTER P WITH ACUTE <= LATIN CAPITAL LETTER P WITH ACUTE int ( z '1E56' ), int ( z '1E57' ), & ! LATIN SMALL LETTER P WITH DOT ABOVE <= LATIN CAPITAL LETTER P WITH DOT ABOVE int ( z '1E58' ), int ( z '1E59' ), & ! LATIN SMALL LETTER R WITH DOT ABOVE <= LATIN CAPITAL LETTER R WITH DOT ABOVE int ( z '1E5A' ), int ( z '1E5B' ), & ! LATIN SMALL LETTER R WITH DOT BELOW <= LATIN CAPITAL LETTER R WITH DOT BELOW int ( z '1E5C' ), int ( z '1E5D' ), & ! LATIN SMALL LETTER R WITH DOT BELOW AND MACRON <= LATIN CAPITAL LETTER R WITH DOT BELOW AND MACRON int ( z '1E5E' ), int ( z '1E5F' ), & ! LATIN SMALL LETTER R WITH LINE BELOW <= LATIN CAPITAL LETTER R WITH LINE BELOW int ( z '1E60' ), int ( z '1E61' ), & ! LATIN SMALL LETTER S WITH DOT ABOVE <= LATIN CAPITAL LETTER S WITH DOT ABOVE int ( z '1E62' ), int ( z '1E63' ), & ! LATIN SMALL LETTER S WITH DOT BELOW <= LATIN CAPITAL LETTER S WITH DOT BELOW int ( z '1E64' ), int ( z '1E65' ), & ! LATIN SMALL LETTER S WITH ACUTE AND DOT ABOVE <= LATIN CAPITAL LETTER S WITH ACUTE AND DOT ABOVE int ( z '1E66' ), int ( z '1E67' ), & ! LATIN SMALL LETTER S WITH CARON AND DOT ABOVE <= LATIN CAPITAL LETTER S WITH CARON AND DOT ABOVE int ( z '1E68' ), int ( z '1E69' ), & ! LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE <= LATIN CAPITAL LETTER S WITH DOT BELOW AND DOT ABOVE int ( z '1E6A' ), int ( z '1E6B' ), & ! LATIN SMALL LETTER T WITH DOT ABOVE <= LATIN CAPITAL LETTER T WITH DOT ABOVE int ( z '1E6C' ), int ( z '1E6D' ), & ! LATIN SMALL LETTER T WITH DOT BELOW <= LATIN CAPITAL LETTER T WITH DOT BELOW int ( z '1E6E' ), int ( z '1E6F' ), & ! LATIN SMALL LETTER T WITH LINE BELOW <= LATIN CAPITAL LETTER T WITH LINE BELOW int ( z '1E70' ), int ( z '1E71' ), & ! LATIN SMALL LETTER T WITH CIRCUMFLEX BELOW <= LATIN CAPITAL LETTER T WITH CIRCUMFLEX BELOW int ( z '1E72' ), int ( z '1E73' ), & ! LATIN SMALL LETTER U WITH DIAERESIS BELOW <= LATIN CAPITAL LETTER U WITH DIAERESIS BELOW int ( z '1E74' ), int ( z '1E75' ), & ! LATIN SMALL LETTER U WITH TILDE BELOW <= LATIN CAPITAL LETTER U WITH TILDE BELOW int ( z '1E76' ), int ( z '1E77' ), & ! LATIN SMALL LETTER U WITH CIRCUMFLEX BELOW <= LATIN CAPITAL LETTER U WITH CIRCUMFLEX BELOW int ( z '1E78' ), int ( z '1E79' ), & ! LATIN SMALL LETTER U WITH TILDE AND ACUTE <= LATIN CAPITAL LETTER U WITH TILDE AND ACUTE int ( z '1E7A' ), int ( z '1E7B' ), & ! LATIN SMALL LETTER U WITH MACRON AND DIAERESIS <= LATIN CAPITAL LETTER U WITH MACRON AND DIAERESIS int ( z '1E7C' ), int ( z '1E7D' ), & ! LATIN SMALL LETTER V WITH TILDE <= LATIN CAPITAL LETTER V WITH TILDE int ( z '1E7E' ), int ( z '1E7F' ), & ! LATIN SMALL LETTER V WITH DOT BELOW <= LATIN CAPITAL LETTER V WITH DOT BELOW int ( z '1E80' ), int ( z '1E81' ), & ! LATIN SMALL LETTER W WITH GRAVE <= LATIN CAPITAL LETTER W WITH GRAVE int ( z '1E82' ), int ( z '1E83' ), & ! LATIN SMALL LETTER W WITH ACUTE <= LATIN CAPITAL LETTER W WITH ACUTE int ( z '1E84' ), int ( z '1E85' ), & ! LATIN SMALL LETTER W WITH DIAERESIS <= LATIN CAPITAL LETTER W WITH DIAERESIS int ( z '1E86' ), int ( z '1E87' ), & ! LATIN SMALL LETTER W WITH DOT ABOVE <= LATIN CAPITAL LETTER W WITH DOT ABOVE int ( z '1E88' ), int ( z '1E89' ), & ! LATIN SMALL LETTER W WITH DOT BELOW <= LATIN CAPITAL LETTER W WITH DOT BELOW int ( z '1E8A' ), int ( z '1E8B' ), & ! LATIN SMALL LETTER X WITH DOT ABOVE <= LATIN CAPITAL LETTER X WITH DOT ABOVE int ( z '1E8C' ), int ( z '1E8D' ), & ! LATIN SMALL LETTER X WITH DIAERESIS <= LATIN CAPITAL LETTER X5 WITH DIAERESIS int ( z '1E8E' ), int ( z '1E8F' ), & ! LATIN SMALL LETTER Y WITH DOT ABOVE <= LATIN CAPITAL LETTER Y WITH DOT ABOVE int ( z '1E90' ), int ( z '1E91' ), & ! LATIN SMALL LETTER Z WITH CIRCUMFLEX <= LATIN CAPITAL LETTER Z WITH CIRCUMFLEX int ( z '1E92' ), int ( z '1E93' ), & ! LATIN SMALL LETTER Z WITH DOT BELOW <= LATIN CAPITAL LETTER Z WITH DOT BELOW int ( z '1E94' ), int ( z '1E95' ), & ! LATIN SMALL LETTER Z WITH LINE BELOW <= LATIN CAPITAL LETTER Z WITH LINE BELOW int ( z '1EA0' ), int ( z '1EA1' ), & ! LATIN SMALL LETTER A WITH DOT BELOW <= LATIN CAPITAL LETTER A WITH DOT BELOW int ( z '1EA2' ), int ( z '1EA3' ), & ! LATIN SMALL LETTER A WITH HOOK ABOVE <= LATIN CAPITAL LETTER A WITH HOOK ABOVE int ( z '1EA4' ), int ( z '1EA5' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE <= LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE int ( z '1EA6' ), int ( z '1EA7' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND GRAVE <= LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND GRAVE int ( z '1EA8' ), int ( z '1EA9' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE <= LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE int ( z '1EAA' ), int ( z '1EAB' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND TILDE <= LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND TILDE int ( z '1EAC' ), int ( z '1EAD' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND DOT BELOW <= LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND DOT BELOW int ( z '1EAE' ), int ( z '1EAF' ), & ! LATIN SMALL LETTER A WITH BREVE AND ACUTE <= LATIN CAPITAL LETTER A WITH BREVE AND ACUTE int ( z '1EB0' ), int ( z '1EB1' ), & ! LATIN SMALL LETTER A WITH BREVE AND GRAVE <= LATIN CAPITAL LETTER A WITH BREVE AND GRAVE int ( z '1EB2' ), int ( z '1EB3' ), & ! LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE <= LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE int ( z '1EB4' ), int ( z '1EB5' ), & ! LATIN SMALL LETTER A WITH BREVE AND TILDE <= LATIN CAPITAL LETTER A WITH BREVE AND TILDE int ( z '1EB6' ), int ( z '1EB7' ), & ! LATIN SMALL LETTER A WITH BREVE AND DOT BELOW <= LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW int ( z '1EB8' ), int ( z '1EB9' ), & ! LATIN SMALL LETTER E WITH DOT BELOW <= LATIN CAPITAL LETTER E WITH DOT BELOW int ( z '1EBA' ), int ( z '1EBB' ), & ! LATIN SMALL LETTER E WITH HOOK ABOVE <= LATIN CAPITAL LETTER E WITH HOOK ABOVE int ( z '1EBC' ), int ( z '1EBD' ), & ! LATIN SMALL LETTER E WITH TILDE <= LATIN CAPITAL LETTER E WITH TILDE int ( z '1EBE' ), int ( z '1EBF' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE <= LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE int ( z '1EC0' ), int ( z '1EC1' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND GRAVE <= LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE int ( z '1EC2' ), int ( z '1EC3' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE <= LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE int ( z '1EC4' ), int ( z '1EC5' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND TILDE <= LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND TILDE int ( z '1EC6' ), int ( z '1EC7' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW <= LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND DOT BELOW int ( z '1EC8' ), int ( z '1EC9' ), & ! LATIN SMALL LETTER I WITH HOOK ABOVE <= LATIN CAPITAL LETTER I WITH HOOK ABOVE int ( z '1ECA' ), int ( z '1ECB' ), & ! LATIN SMALL LETTER I WITH DOT BELOW <= LATIN CAPITAL LETTER I WITH DOT BELOW int ( z '1ECC' ), int ( z '1ECD' ), & ! LATIN SMALL LETTER O WITH DOT BELOW <= LATIN CAPITAL LETTER O WITH DOT BELOW int ( z '1ECE' ), int ( z '1ECF' ), & ! LATIN SMALL LETTER O WITH HOOK ABOVE <= LATIN CAPITAL LETTER O WITH HOOK ABOVE int ( z '1ED0' ), int ( z '1ED1' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE <= LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE int ( z '1ED2' ), int ( z '1ED3' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND GRAVE <= LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND GRAVE int ( z '1ED4' ), int ( z '1ED5' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE <= LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE int ( z '1ED6' ), int ( z '1ED7' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND TILDE <= LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND TILDE int ( z '1ED8' ), int ( z '1ED9' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW <= LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND DOT BELOW int ( z '1EDA' ), int ( z '1EDB' ), & ! LATIN SMALL LETTER O WITH HORN AND ACUTE <= LATIN CAPITAL LETTER O WITH HORN AND ACUTE int ( z '1EDC' ), int ( z '1EDD' ), & ! LATIN SMALL LETTER O WITH HORN AND GRAVE <= LATIN CAPITAL LETTER O WITH HORN AND GRAVE int ( z '1EDE' ), int ( z '1EDF' ), & ! LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE <= LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE int ( z '1EE0' ), int ( z '1EE1' ), & ! LATIN SMALL LETTER O WITH HORN AND TILDE <= LATIN CAPITAL LETTER O WITH HORN AND TILDE int ( z '1EE2' ), int ( z '1EE3' ), & ! LATIN SMALL LETTER O WITH HORN AND DOT BELOW <= LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW int ( z '1EE4' ), int ( z '1EE5' ), & ! LATIN SMALL LETTER U WITH DOT BELOW <= LATIN CAPITAL LETTER U WITH DOT BELOW int ( z '1EE6' ), int ( z '1EE7' ), & ! LATIN SMALL LETTER U WITH HOOK ABOVE <= LATIN CAPITAL LETTER U WITH HOOK ABOVE int ( z '1EE8' ), int ( z '1EE9' ), & ! LATIN SMALL LETTER U WITH HORN AND ACUTE <= LATIN CAPITAL LETTER U WITH HORN AND ACUTE int ( z '1EEA' ), int ( z '1EEB' ), & ! LATIN SMALL LETTER U WITH HORN AND GRAVE <= LATIN CAPITAL LETTER U WITH HORN AND GRAVE int ( z '1EEC' ), int ( z '1EED' ), & ! LATIN SMALL LETTER U WITH HORN AND HOCK ABOVE <= LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE int ( z '1EEE' ), int ( z '1EEF' ), & ! LATIN SMALL LETTER U WITH HORN AND TILDE <= LATIN CAPITAL LETTER U WITH HORN AND TILDE int ( z '1EF0' ), int ( z '1EF1' ), & ! LATIN SMALL LETTER U WITH HORN AND DOT BELOW <= LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW int ( z '1EF2' ), int ( z '1EF3' ), & ! LATIN SMALL LETTER Y WITH GRAVE <= LATIN CAPITAL LETTER Y WITH GRAVE int ( z '1EF4' ), int ( z '1EF5' ), & ! LATIN SMALL LETTER Y WITH DOT BELOW <= LATIN CAPITAL LETTER Y WITH DOT BELOW int ( z '1EF6' ), int ( z '1EF7' ), & ! LATIN SMALL LETTER Y WITH HOOK ABOVE <= LATIN CAPITAL LETTER Y WITH HOOK ABOVE int ( z '1EF8' ), int ( z '1EF9' ), & ! LATIN SMALL LETTER Y WITH TILDE <= LATIN CAPITAL LETTER Y WITH TILDE int ( z '1F08' ), int ( z '1F00' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI <= GREEK CAPITAL LETTER ALPHA WITH PSILI int ( z '1F09' ), int ( z '1F01' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA <= GREEK CAPITAL LETTER ALPHA WITH DASIA int ( z '1F0A' ), int ( z '1F02' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA <= GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA int ( z '1F0B' ), int ( z '1F03' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA <= GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA int ( z '1F0C' ), int ( z '1F04' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA <= GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA int ( z '1F0D' ), int ( z '1F05' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA <= GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA int ( z '1F0E' ), int ( z '1F06' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI <= GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI int ( z '1F0F' ), int ( z '1F07' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI <= GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI int ( z '1F18' ), int ( z '1F10' ), & ! GREEK SMALL LETTER EPSILON WITH PSILI <= GREEK CAPITAL LETTER EPSILON WITH PSILI int ( z '1F19' ), int ( z '1F11' ), & ! GREEK SMALL LETTER EPSILON WITH DASIA <= GREEK CAPITAL LETTER EPSILON WITH DASIA int ( z '1F1A' ), int ( z '1F12' ), & ! GREEK SMALL LETTER EPSILON WITH PSILI AND VARIA <= GREEK CAPITAL LETTER EPSILON WITH PSILI AND VARIA int ( z '1F1B' ), int ( z '1F13' ), & ! GREEK SMALL LETTER EPSILON WITH DASIA AND VARIA <= GREEK CAPITAL LETTER EPSILON WITH DASIA AND VARIA int ( z '1F1C' ), int ( z '1F14' ), & ! GREEK SMALL LETTER EPSILON WITH PSILI AND OXIA <= GREEK CAPITAL LETTER EPSILON WITH PSILI AND OXIA int ( z '1F1D' ), int ( z '1F15' ), & ! GREEK SMALL LETTER EPSILON WITH DASIA AND OXIA <= GREEK CAPITAL LETTER EPSILON WITH DASIA AND OXIA int ( z '1F28' ), int ( z '1F20' ), & ! GREEK SMALL LETTER ETA WITH PSILI <= GREEK CAPITAL LETTER ETA WITH PSILI int ( z '1F29' ), int ( z '1F21' ), & ! GREEK SMALL LETTER ETA WITH DASIA <= GREEK CAPITAL LETTER ETA WITH DASIA int ( z '1F2A' ), int ( z '1F22' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND VARIA <= GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA int ( z '1F2B' ), int ( z '1F23' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND VARIA <= GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA int ( z '1F2C' ), int ( z '1F24' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND OXIA <= GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA int ( z '1F2D' ), int ( z '1F25' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND OXIA <= GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA int ( z '1F2E' ), int ( z '1F26' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI <= GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI int ( z '1F2F' ), int ( z '1F27' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI <= GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI int ( z '1F38' ), int ( z '1F30' ), & ! GREEK SMALL LETTER IOTA WITH PSILI <= GREEK CAPITAL LETTER IOTA WITH PSILI int ( z '1F39' ), int ( z '1F31' ), & ! GREEK SMALL LETTER IOTA WITH DASIA <= GREEK CAPITAL LETTER IOTA WITH DASIA int ( z '1F3A' ), int ( z '1F32' ), & ! GREEK SMALL LETTER IOTA WITH PSILI AND VARIA <= GREEK CAPITAL LETTER IOTA WITH PSILI AND VARIA int ( z '1F3B' ), int ( z '1F33' ), & ! GREEK SMALL LETTER IOTA WITH DASIA AND VARIA <= GREEK CAPITAL LETTER IOTA WITH DASIA AND VARIA int ( z '1F3C' ), int ( z '1F34' ), & ! GREEK SMALL LETTER IOTA WITH PSILI AND OXIA <= GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA int ( z '1F3D' ), int ( z '1F35' ), & ! GREEK SMALL LETTER IOTA WITH DASIA AND OXIA <= GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA int ( z '1F3E' ), int ( z '1F36' ), & ! GREEK SMALL LETTER IOTA WITH PSILI AND PERISPOMENI <= GREEK CAPITAL LETTER IOTA WITH PSILI AND PERISPOMENI int ( z '1F3F' ), int ( z '1F37' ), & ! GREEK SMALL LETTER IOTA WITH DASIA AND PERISPOMENI <= GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI int ( z '1F48' ), int ( z '1F40' ), & ! GREEK SMALL LETTER OMICRON WITH PSILI <= GREEK CAPITAL LETTER OMICRON WITH PSILI int ( z '1F49' ), int ( z '1F41' ), & ! GREEK SMALL LETTER OMICRON WITH DASIA <= GREEK CAPITAL LETTER OMICRON WITH DASIA int ( z '1F4A' ), int ( z '1F42' ), & ! GREEK SMALL LETTER OMICRON WITH PSILI AND VARIA <= GREEK CAPITAL LETTER OMICRON WITH PSILI AND VARIA int ( z '1F4B' ), int ( z '1F43' ), & ! GREEK SMALL LETTER OMICRON WITH DASIA AND VARIA <= GREEK CAPITAL LETTER OMICRON WITH DASIA AND VARIA int ( z '1F4C' ), int ( z '1F44' ), & ! GREEK SMALL LETTER OMICRON WITH PSILI AND OXIA <= GREEK CAPITAL LETTER OMICRON WITH PSILI AND OXIA int ( z '1F4D' ), int ( z '1F45' ), & ! GREEK SMALL LETTER OMICRON WITH DASIA AND OXIA <= GREEK CAPITAL LETTER OMICRON WITH DASIA AND OXIA int ( z '1F59' ), int ( z '1F51' ), & ! GREEK SMALL LETTER UPSILON WITH DASIA <= GREEK CAPITAL LETTER UPSILON WITH OASIS int ( z '1F5B' ), int ( z '1F53' ), & ! GREEK SMALL LETTER UPSILON WITH DASIA AND VARIA <= GREEK CAPITAL LETTER UPSILON WITH DASIA AND VARIA int ( z '1F5D' ), int ( z '1F55' ), & ! GREEK SMALL LETTER UPSILON WITH DASIA AND OXIA <= GREEK CAPITAL LETTER UPSILON WITH DASIA AND OXIA int ( z '1F5F' ), int ( z '1F57' ), & ! GREEK SMALL LETTER UPSILON WITH DASIA AND PERISPOMENI <= GREEK CAPITAL LETTER UPSILON WITH DASIA AND PERISPOMENI int ( z '1F68' ), int ( z '1F60' ), & ! GREEK SMALL LETTER OMEGA WITh PSILI <= GREEK CAPITAL LETTER OMEGA WITH PSILI int ( z '1F69' ), int ( z '1F61' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA <= GREEK CAPITAL LETTER OMEGA WITH DASIA int ( z '1F6A' ), int ( z '1F62' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA <= GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA int ( z '1F6B' ), int ( z '1F63' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA <= GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA int ( z '1F6C' ), int ( z '1F64' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA <= GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA int ( z '1F6D' ), int ( z '1F65' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA <= GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA int ( z '1F6E' ), int ( z '1F66' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI <= GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI int ( z '1F6F' ), int ( z '1F67' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI <= GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI int ( z '1F88' ), int ( z '1F80' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ALPHA WITh PSILI AND PROSGEGRAMMENI int ( z '1F89' ), int ( z '1F81' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ALPHA WITH DASIA AND PROSGEGRAMMENI int ( z '1F8A' ), int ( z '1F82' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI int ( z '1F8B' ), int ( z '1F83' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI int ( z '1F8C' ), int ( z '1F84' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMEN int ( z '1F8D' ), int ( z '1F85' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMEN int ( z '1F8E' ), int ( z '1F86' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1F8F' ), int ( z '1F87' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1F98' ), int ( z '1F90' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ETA WITH PSILI AND PROSGEGRAMMENI int ( z '1F99' ), int ( z '1F91' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ETA WITH DASIA AND PROSGEGRAMMENI int ( z '1F9A' ), int ( z '1F92' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI int ( z '1F9B' ), int ( z '1F93' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI int ( z '1F9C' ), int ( z '1F94' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI int ( z '1F9D' ), int ( z '1F95' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI int ( z '1F9E' ), int ( z '1F96' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1F9F' ), int ( z '1F97' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1FA8' ), int ( z '1FA0' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER OMEGA WITH PSILI AND PROSGEGRAMMENI int ( z '1FA9' ), int ( z '1FA1' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER OMEGA WITH DASIA AND PROSGEGRAMMENI int ( z '1FAA' ), int ( z '1FA2' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI int ( z '1FAB' ), int ( z '1FA3' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI int ( z '1FAC' ), int ( z '1FA4' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI int ( z '1FAD' ), int ( z '1FA5' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI int ( z '1FAE' ), int ( z '1FA6' ), & ! GREEK SMALL LETTER OMEGA WITh PSILI AND PERISPOMENI AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1FAF' ), int ( z '1FA7' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND PEPISPOMENI AND YPOGEGRAMMENI <= GREEK CAPITAL LETTER OMECA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1FB8' ), int ( z '1FB0' ), & ! GREEK SMALL LETTER ALPHA WITH VRACHY <= GREEK CAPITAL LETTER ALPHA WITH VRACHY int ( z '1FB9' ), int ( z '1FB1' ), & ! GREEK SMALL LETTER ALPHA WITH MACRON <= GREEK CAPITAL LETTER ALPHA WITH MACRON int ( z '1FD8' ), int ( z '1FD0' ), & ! GREEK SMALL LETTER IOTA WITH VRACHY <= GREEK CAPITAL LETTER IOTA WITH VRACHY int ( z '1FD9' ), int ( z '1FD1' ), & ! GREEK SMALL LETTER IOTA WITH MACRON <= GREEK CAPITAL LETTER IOTA WITH MACRON int ( z '1FE8' ), int ( z '1FE0' ), & ! GREEK SMALL LETTER UPSILON WITH VRACHY <= GREEK CAPITAL LETTER UPSILON WITH VRACHY int ( z '1FE9' ), int ( z '1FE1' ), & ! GREEK SMALL LETTER UPSILON WITH MACRON <= GREEK CAPITAL LETTER UPSILON WITH MACRON int ( z '24B6' ), int ( z '24D0' ), & ! CIRCLED LATIN SMALL LETTER A <= CIRCLED LATIN CAPITAL LETTER A int ( z '24B7' ), int ( z '24D1' ), & ! CIRCLED LATIN SMALL LETTER B <= CIRCLED LATIN CAPITAL LETTER B int ( z '24B8' ), int ( z '24D2' ), & ! CIRCLED LATIN SMALL LETTER C <= CIRCLED LATIN CAPITAL LETTER C int ( z '24B9' ), int ( z '24D3' ), & ! CIRCLED LATIN SMALL LETTER D <= CIRCLED LATIN CAPITAL LETTER D int ( z '24BA' ), int ( z '24D4' ), & ! CIRCLED LATIN SMALL LETTER E <= CIRCLED LATIN CAPITAL LETTER E int ( z '24BB' ), int ( z '24D5' ), & ! CIRCLED LATIN SMALL LETTER F <= CIRCLED LATIN CAPITAL LETTER F int ( z '24BC' ), int ( z '24D6' ), & ! CIRCLED LATIN SMALL LETTER G <= CIRCLED LATIN CAPITAL LETTER G int ( z '24BD' ), int ( z '24D7' ), & ! CIRCLED LATIN SMALL LETTER H <= CIRCLED LATIN CAPITAL LETTER H int ( z '24BE' ), int ( z '24D8' ), & ! CIRCLED LATIN SMALL LETTER I <= CIRCLED LATIN CAPITAL LETTER I int ( z '24BF' ), int ( z '24D9' ), & ! CIRCLED LATIN SMALL LETTER J <= CIRCLED LATIN CAPITAL LETTER J int ( z '24C0' ), int ( z '24DA' ), & ! CIRCLED LATIN SMALL LETTER K <= CIRCLED LATIN CAPITAL LETTER K int ( z '24C1' ), int ( z '24DB' ), & ! CIRCLED LATIN SMALL LETTER L <= CIRCLED LATIN CAPITAL LETTER L int ( z '24C2' ), int ( z '24DC' ), & ! CIRCLED LATIN SMALL LETTER M <= CIRCLED LATIN CAPITAL LETTER M int ( z '24C3' ), int ( z '24DD' ), & ! CIRCLED LATIN SMALL LETTER N <= CIRCLED LATIN CAPITAL LETTER N int ( z '24C4' ), int ( z '24DE' ), & ! CIRCLED LATIN SMALL LETTER O <= CIRCLED LATIN CAPITAL LETTER O int ( z '24C5' ), int ( z '24DF' ), & ! CIRCLED LATIN SMALL LETTER P <= CIRCLED LATIN CAPITAL LETTER P int ( z '24C6' ), int ( z '24E0' ), & ! CIRCLED LATIN SMALL LETTER Q <= CIRCLED LATIN CAPITAL LETTER Q int ( z '24C7' ), int ( z '24E1' ), & ! CIRCLED LATIN SMALL LETTER R <= CIRCLED LATIN CAPITAL LETTER R int ( z '24C8' ), int ( z '24E2' ), & ! CIRCLED LATIN SMALL LETTER S <= CIRCLED LATIN CAPITAL LETTER S int ( z '24C9' ), int ( z '24E3' ), & ! CIRCLED LATIN SMALL LETTER T <= CIRCLED LATIN CAPITAL LETTER T int ( z '24CA' ), int ( z '24E4' ), & ! CIRCLED LATIN SMALL LETTER U <= CIRCLED LATIN CAPITAL LETTER U int ( z '24CB' ), int ( z '24E5' ), & ! CIRCLED LATIN SMALL LETTER V <= CIRCLED LATIN CAPITAL LETTER V int ( z '24CC' ), int ( z '24E6' ), & ! CIRCLED LATIN SMALL LETTER W <= CIRCLED LATIN CAPITAL LETTER W int ( z '24CD' ), int ( z '24E7' ), & ! CIRCLED LATIN SMALL LETTER X <= CIRCLED LATIN CAPITAL LETTER X int ( z '24CE' ), int ( z '24E8' ), & ! CIRCLED LATIN SMALL LETTER Y <= CIRCLED LATIN CAPITAL LETTER Y int ( z '24CF' ), int ( z '24E9' ), & ! CIRCLED LATIN SMALL LETTER Z <= CIRCLED LATIN CAPITAL LETTER Z int ( z 'FF21' ), int ( z 'FF41' ), & ! FULLWIDTH LATIN SMALL LETTER A <= FULLWIDTH LATIN CAPITAL LETTER A int ( z 'FF22' ), int ( z 'FF42' ), & ! FULLWIDTH LATIN SMALL LETTER B <= FULLWIDTH LATIN CAPITAL LETTER B int ( z 'FF23' ), int ( z 'FF43' ), & ! FULLWIDTH LATIN SMALL LETTER C <= FULLWIDTH LATIN CAPITAL LETTER C int ( z 'FF24' ), int ( z 'FF44' ), & ! FULLWIDTH LATIN SMALL LETTER D <= FULLWIDTH LATIN CAPITAL LETTER D int ( z 'FF25' ), int ( z 'FF45' ), & ! FULLWIDTH LATIN SMALL LETTER E <= FULLWIDTH LATIN CAPITAL LETTER E int ( z 'FF26' ), int ( z 'FF46' ), & ! FULLWIDTH LATIN SMALL LETTER F <= FULLWIDTH LATIN CAPITAL LETTER F int ( z 'FF27' ), int ( z 'FF47' ), & ! FULLWIDTH LATIN SMALL LETTER G <= FULLWIDTH LATIN CAPITAL LETTER G int ( z 'FF28' ), int ( z 'FF48' ), & ! FULLWIDTH LATIN SMALL LETTER H <= FULLWIDTH LATIN CAPITAL LETTER H int ( z 'FF29' ), int ( z 'FF49' ), & ! FULLWIDTH LATIN SMALL LETTER I <= FULLWIDTH LATIN CAPITAL LETTER I int ( z 'FF2A' ), int ( z 'FF4A' ), & ! FULLWIDTH LATIN SMALL LETTER J <= FULLWIDTH LATIN CAPITAL LETTER J int ( z 'FF2B' ), int ( z 'FF4B' ), & ! FULLWIDTH LATIN SMALL LETTER K <= FULLWIDTH LATIN CAPITAL LETTER K int ( z 'FF2C' ), int ( z 'FF4C' ), & ! FULLWIDTH LATIN SMALL LETTER L <= FULLWIDTH LATIN CAPITAL LETTER L int ( z 'FF2D' ), int ( z 'FF4D' ), & ! FULLWIDTH LATIN SMALL LETTER M <= FULLWIDTH LATIN CAPITAL LETTER M int ( z 'FF2E' ), int ( z 'FF4E' ), & ! FULLWIDTH LATIN SMALL LETTER N <= FULLWIDTH LATIN CAPITAL LETTER N int ( z 'FF2F' ), int ( z 'FF4F' ), & ! FULLWIDTH LATIN SMALL LETTER O <= FULLWIDTH LATIN CAPITAL LETTER O int ( z 'FF30' ), int ( z 'FF50' ), & ! FULLWIDTH LATIN SMALL LETTER P <= FULLWIDTH LATIN CAPITAL LETTER P int ( z 'FF31' ), int ( z 'FF51' ), & ! FULLWIDTH LATIN SMALL LETTER Q <= FULLWIDTH LATIN CAPITAL LETTER Q int ( z 'FF32' ), int ( z 'FF52' ), & ! FULLWIDTH LATIN SMALL LETTER R <= FULLWIDTH LATIN CAPITAL LETTER R int ( z 'FF33' ), int ( z 'FF53' ), & ! FULLWIDTH LATIN SMALL LETTER S <= FULLWIDTH LATIN CAPITAL LETTER S int ( z 'FF34' ), int ( z 'FF54' ), & ! FULLWIDTH LATIN SMALL LETTER T <= FULLWIDTH LATIN CAPITAL LETTER T int ( z 'FF35' ), int ( z 'FF55' ), & ! FULLWIDTH LATIN SMALL LETTER U <= FULLWIDTH LATIN CAPITAL LETTER U int ( z 'FF36' ), int ( z 'FF56' ), & ! FULLWIDTH LATIN SMALL LETTER V <= FULLWIDTH LATIN CAPITAL LETTER V int ( z 'FF37' ), int ( z 'FF57' ), & ! FULLWIDTH LATIN SMALL LETTER W <= FULLWIDTH LATIN CAPITAL LETTER W int ( z 'FF38' ), int ( z 'FF58' ), & ! FULLWIDTH LATIN SMALL LETTER X <= FULLWIDTH LATIN CAPITAL LETTER X int ( z 'FF39' ), int ( z 'FF59' ), & ! FULLWIDTH LATIN SMALL LETTER Y <= FULLWIDTH LATIN CAPITAL LETTER Y int ( z 'FF3A' ), int ( z 'FF5A' )] & ! FULLWIDTH LATIN SMALL LETTER Z <= FULLWIDTH LATIN CAPITAL LETTER Z , shape ( uplow ), order = [ 2 , 1 ]) contains !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure subroutine codepoints_to_utf8_chars ( unicode , utf8 , nerr ) integer , intent ( in ) :: unicode (:) character , allocatable , intent ( out ) :: utf8 (:) integer , intent ( out ) :: nerr integer :: i , n_unicode , n_utf8 , cp character , allocatable :: temp_utf8 (:) n_unicode = size ( unicode ) allocate ( temp_utf8 ( 4 * n_unicode )) n_utf8 = 0 nerr = 0 do i = 1 , n_unicode cp = unicode ( i ) select case ( cp ) case ( 0 : 127 ) ! 1 byte : 0xxxxxxx n_utf8 = n_utf8 + 1 temp_utf8 ( n_utf8 ) = char ( cp ) case ( 128 : 2047 ) ! 2 bytes : 110xxxxx 10xxxxxx n_utf8 = n_utf8 + 2 temp_utf8 ( n_utf8 - 1 ) = char ( ior ( 192 , ishft ( cp , - 6 ))) temp_utf8 ( n_utf8 ) = char ( ior ( 128 , iand ( cp , 63 ))) case ( 2048 : 65535 ) ! 3 bytes : 1110xxxx 10xxxxxx 10xxxxxx if ( cp >= 55296 . and . cp <= 57343 ) then nerr = nerr + 1 n_utf8 = n_utf8 + 1 temp_utf8 ( n_utf8 ) = '?' cycle endif n_utf8 = n_utf8 + 3 temp_utf8 ( n_utf8 - 2 ) = char ( ior ( 224 , ishft ( cp , - 12 ))) temp_utf8 ( n_utf8 - 1 ) = char ( ior ( 128 , iand ( ishft ( cp , - 6 ), 63 ))) temp_utf8 ( n_utf8 ) = char ( ior ( 128 , iand ( cp , 63 ))) case ( 65536 : 1114111 ) ! 4 bytes : 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx n_utf8 = n_utf8 + 4 temp_utf8 ( n_utf8 - 3 ) = char ( ior ( 240 , ishft ( cp , - 18 ))) temp_utf8 ( n_utf8 - 2 ) = char ( ior ( 128 , iand ( ishft ( cp , - 12 ), 63 ))) temp_utf8 ( n_utf8 - 1 ) = char ( ior ( 128 , iand ( ishft ( cp , - 6 ), 63 ))) temp_utf8 ( n_utf8 ) = char ( ior ( 128 , iand ( cp , 63 ))) case default nerr = nerr + 1 n_utf8 = n_utf8 + 1 temp_utf8 ( n_utf8 ) = '?' end select enddo allocate ( utf8 ( n_utf8 )) utf8 = temp_utf8 ( 1 : n_utf8 ) end subroutine codepoints_to_utf8_chars !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure subroutine utf8_to_codepoints_chars ( utf8 , unicode , nerr ) ! in fact, this routine is also able to decode an ISOLATIN string character , intent ( in ) :: utf8 (:) integer , allocatable , intent ( out ) :: unicode (:) integer , intent ( out ) :: nerr integer :: n_out integer :: i , len8 , b1 , b2 , b3 , b4 integer :: cp , nbytes , nerr0 integer , allocatable :: temp (:) nerr = 0 len8 = size ( utf8 ) i = 1 n_out = 0 allocate ( temp ( len8 )) ! big enough to store all unicode values do while ( i <= len8 ) nerr0 = nerr b1 = ichar ( utf8 ( i )) if ( b1 < 0 ) b1 = b1 + 256 nbytes = 1 select case ( b1 ) case ( 0 : 127 ) cp = b1 case ( 192 : 223 ) if ( i + 1 > len8 ) then nbytes = len8 - i + 1 nerr = nerr + 1 cp = ICHAR ( '?' ) else nbytes = 2 b2 = ichar ( utf8 ( i + 1 )); if ( b2 < 0 ) b2 = b2 + 256 if ( iand ( b2 , 192 ) /= 128 ) then nerr = nerr + 1 cp = ICHAR ( '?' ) else cp = iand ( b1 , 31 ) cp = ishft ( cp , 6 ) + iand ( b2 , 63 ) endif endif case ( 224 : 239 ) if ( i + 2 > len8 ) then nbytes = len8 - i + 1 nerr = nerr + 1 cp = ICHAR ( '?' ) else nbytes = 3 b2 = ichar ( utf8 ( i + 1 )); if ( b2 < 0 ) b2 = b2 + 256 b3 = ichar ( utf8 ( i + 2 )); if ( b3 < 0 ) b3 = b3 + 256 if ( iand ( b2 , 192 ) /= 128 . or . iand ( b3 , 192 ) /= 128 ) then nerr = nerr + 1 cp = ICHAR ( '?' ) else cp = iand ( b1 , 15 ) cp = ishft ( cp , 6 ) + iand ( b2 , 63 ) cp = ishft ( cp , 6 ) + iand ( b3 , 63 ) endif endif case ( 240 : 247 ) if ( i + 3 > len8 ) then nbytes = len8 - i + 1 nerr = nerr + 1 cp = ICHAR ( '?' ) else nbytes = 4 b2 = ichar ( utf8 ( i + 1 )); if ( b2 < 0 ) b2 = b2 + 256 b3 = ichar ( utf8 ( i + 2 )); if ( b3 < 0 ) b3 = b3 + 256 b4 = ichar ( utf8 ( i + 3 )); if ( b4 < 0 ) b4 = b4 + 256 if ( iand ( b2 , 192 ) /= 128 . or . iand ( b3 , 192 ) /= 128 . or . iand ( b4 , 192 ) /= 128 ) then nerr = nerr + 1 cp = ICHAR ( '?' ) else cp = iand ( b1 , 7 ) cp = ishft ( cp , 6 ) + iand ( b2 , 63 ) cp = ishft ( cp , 6 ) + iand ( b3 , 63 ) cp = ishft ( cp , 6 ) + iand ( b4 , 63 ) endif endif case default nerr = nerr + 1 cp = ICHAR ( '?' ) end select if ( nerr0 /= nerr ) then ! This is an invalid UTF-8 start byte. We apply the heuristic ! and interpret it as an ISO-8859-15 character. select case ( b1 ) case ( 164 ); cp = 8364 ! Euro case ( 166 ); cp = 352 ! S caron case ( 168 ); cp = 353 ! s caron case ( 180 ); cp = 381 ! Z caron case ( 184 ); cp = 382 ! z caron case ( 188 ); cp = 338 ! OE case ( 189 ); cp = 339 ! oe case ( 190 ); cp = 376 ! Y trema case default cp = b1 ! For all other chars, the codepoint is the byte value end select nbytes = 1 endif n_out = n_out + 1 temp ( n_out ) = cp i = i + nbytes enddo allocate ( unicode ( n_out )) unicode = temp ( 1 : n_out ) end subroutine utf8_to_codepoints_chars !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure function a2s ( array ) result ( string ) ! @(#) M_strs a2s(3fp) function to copy char array to string character ( len = 1 ), intent ( in ) :: array (:) character ( len = SIZE ( array )) :: string integer :: i forall ( i = 1 : size ( array )) string ( i : i ) = array ( i ) !  string=transfer(array,string) end function a2s !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure function s2a ( string ) RESULT ( array ) ! @(#) M_strs s2a(3fp) function to copy string(1 Clen(string)) to char array character ( len =* ), intent ( in ) :: string character ( len = 1 ) :: array ( len ( string )) integer :: i forall ( i = 1 : len ( string )) array ( i ) = string ( i : i ) !  array=transfer(string,array) end function s2a !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure function binary_search ( arr , target ) result ( index ) implicit none integer , intent ( in ) :: arr (:) ! The sorted array to search integer , intent ( in ) :: target ! The value to find integer :: index ! The returned index of the target, or -1 if not found integer :: low , high , mid low = 1 high = size ( arr ) index = - 1 ! Initialize to -1 (not found) do while ( low <= high ) mid = low + ( high - low ) / 2 ! Calculate middle index to prevent overflow if ( arr ( mid ) == target ) then index = mid exit elseif ( arr ( mid ) < target ) then low = mid + 1 else high = mid - 1 endif enddo end function binary_search !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure subroutine codepoints_to_utf8_str ( unicode , utf8 , nerr ) integer , intent ( in ) :: unicode (:) character ( len = :), allocatable , intent ( out ) :: utf8 integer , intent ( out ) :: nerr character , allocatable :: utf8_chars (:) nerr = 0 call codepoints_to_utf8_chars ( unicode , utf8_chars , nerr ) utf8 = a2s ( utf8_chars ) end subroutine codepoints_to_utf8_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure subroutine utf8_to_codepoints_str ( utf8 , unicode , nerr ) ! in fact, this routine is also able to decode an ISOLATIN string character ( len =* ), intent ( in ) :: utf8 integer , allocatable , intent ( out ) :: unicode (:) integer , intent ( out ) :: nerr character , allocatable :: temp (:) temp = s2a ( utf8 ) call utf8_to_codepoints_chars ( temp , unicode , nerr ) end subroutine utf8_to_codepoints_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Constructor for new string instances from a scalar character value. elemental module function new_str ( string ) result ( new ) character ( len =* ), intent ( in ), optional :: string type ( unicode_type ) :: new integer :: nerr if ( present ( string )) then call utf8_to_codepoints_str ( string , new % codes , nerr ) endif end function new_str ! Constructor for new string instance from a vector integer value. module function new_codes ( codes ) result ( new ) integer , intent ( in ) :: codes (:) type ( unicode_type ) :: new new % codes = codes end function new_codes !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Assign a character sequence to a string. elemental subroutine assign_str_char ( lhs , rhs ) type ( unicode_type ), intent ( inout ) :: lhs character ( len =* ), intent ( in ) :: rhs integer :: nerr call utf8_to_codepoints_str ( rhs , lhs % codes , nerr ) end subroutine assign_str_char ! Assign a character sequence to a string. subroutine assign_str_codes ( lhs , rhs ) type ( unicode_type ), intent ( inout ) :: lhs integer , intent ( in ) :: rhs (:) lhs % codes = rhs end subroutine assign_str_codes !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Returns the length of the character sequence represented by the string. elemental function len_str ( string ) result ( length ) type ( unicode_type ), intent ( in ) :: string integer :: length if ( allocated ( string % codes )) then length = size ( string % codes ) else length = 0 endif end function len_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Return the character sequence represented by the string. pure function char_str ( string ) result ( aline ) type ( unicode_type ), intent ( in ) :: string character ( len = :), allocatable :: aline integer :: nerr call codepoints_to_utf8_str ( string % codes , aline , nerr ) end function char_str pure function char_strs ( string ) result ( lines ) type ( unicode_type ), intent ( in ) :: string (:) character ( len = :), allocatable :: lines (:) character ( len = :), allocatable :: aline integer :: i integer :: mx integer :: nerr mx = 0 do i = 1 , size ( string ) call codepoints_to_utf8_str ( string ( i )% codes , aline , nerr ) mx = max ( mx , len ( aline )) enddo allocate ( character ( len = mx ) :: lines ( size ( string )) ) do i = 1 , size ( string ) call codepoints_to_utf8_str ( string ( i )% codes , aline , nerr ) lines ( i )(:) = aline enddo end function char_strs pure function char_str_range ( string , first , last ) result ( aline ) type ( unicode_type ), intent ( in ) :: string integer , intent ( in ) :: first integer , intent ( in ) :: last character ( len = :), allocatable :: aline integer :: nerr call codepoints_to_utf8_str ( string % codes ( first : last ), aline , nerr ) end function char_str_range pure function char_strs_range ( string , first , last ) result ( lines ) type ( unicode_type ), intent ( in ) :: string (:) integer , intent ( in ) :: first integer , intent ( in ) :: last character ( len = :), allocatable :: lines (:) character ( len = :), allocatable :: aline integer :: i integer :: mx integer :: nerr mx = 0 do i = 1 , size ( string ) call codepoints_to_utf8_str ( string ( i )% codes ( first : last ), aline , nerr ) mx = max ( mx , len ( aline )) enddo allocate ( character ( len = mx ) :: lines ( size ( string )) ) do i = 1 , size ( string ) call codepoints_to_utf8_str ( string ( i )% codes ( first : last ), aline , nerr ) lines ( i )(:) = aline enddo end function char_strs_range pure function char_str_range_step ( string , first , last , step ) result ( aline ) type ( unicode_type ), intent ( in ) :: string integer , intent ( in ) :: first integer , intent ( in ) :: last integer , intent ( in ) :: step character ( len = :), allocatable :: aline integer :: nerr call codepoints_to_utf8_str ( string % codes ( first : last : step ), aline , nerr ) end function char_str_range_step pure function char_strs_range_step ( string , first , last , step ) result ( lines ) type ( unicode_type ), intent ( in ) :: string (:) integer , intent ( in ) :: first integer , intent ( in ) :: last integer , intent ( in ) :: step character ( len = :), allocatable :: lines (:) character ( len = :), allocatable :: aline integer :: i integer :: mx integer :: nerr mx = 0 do i = 1 , size ( string ) call codepoints_to_utf8_str ( string ( i )% codes ( first : last : step ), aline , nerr ) mx = max ( mx , len ( aline )) enddo allocate ( character ( len = mx ) :: lines ( size ( string )) ) do i = 1 , size ( string ) call codepoints_to_utf8_str ( string ( i )% codes ( first : last : step ), aline , nerr ) lines ( i )(:) = aline enddo end function char_strs_range_step !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Repeats the character sequence held by the string by the number of specified copies. ! This method is elemental and returns a scalar character value. elemental function repeat_str ( string , ncopies ) result ( repeated_str ) type ( unicode_type ), intent ( in ) :: string integer , intent ( in ) :: ncopies type ( unicode_type ) :: repeated_str integer :: i repeated_str % codes = [( string % codes , i = 1 , ncopies )] end function repeat_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Returns length of character sequence without trailing spaces represented by the string. ! elemental function len_trim_str ( string ) result ( length ) type ( unicode_type ), intent ( in ) :: string integer :: length do length = size ( string % codes ), 1 , - 1 if ( any ( string % codes ( length ). eq . G_SPACES )) cycle exit enddo end function len_trim_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! This method is elemental and returns a scalar character value. elemental function trim_str ( string ) result ( trimmed_str ) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ) :: trimmed_str integer :: last last = len_trim_str ( string ) trimmed_str % codes = string % codes (: last ) end function trim_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! right-justify string by moving trailing spaces to beginning of string so length is retained even if spaces are of varied width impure elemental function adjustr_str ( string ) result ( adjusted ) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ) :: adjusted integer :: last last = len_trim_str ( string ) adjusted % codes = cshift ( string % codes , - ( size ( string % codes ) - last )) end function adjustr_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !left-justify string by  moving leading spaces to end of string so length is retained even if spaces are of varied width elemental function adjustl_str ( string ) result ( adjusted ) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ) :: adjusted integer :: first do first = 1 , size ( string % codes ), 1 if ( any ( string % codes ( first ). eq . G_SPACES )) cycle exit enddo adjusted % codes = cshift ( string % codes , first - 1 ) end function adjustl_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Concatenate two character sequences, LHS, RHS or both can be represented by a byte string or unicode_type. ! elemental function concat_str_str ( lhs , rhs ) result ( lhsrhs ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs type ( unicode_type ) :: lhsrhs lhsrhs % codes = [ lhs % codes , rhs % codes ] end function concat_str_str elemental function concat_str_char ( lhs , rhs ) result ( lhsrhs ) type ( unicode_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs type ( unicode_type ) :: lhsrhs lhsrhs = unicode_type ( rhs ) lhsrhs % codes = [ lhs % codes , lhsrhs % codes ] end function concat_str_char elemental function concat_char_str ( lhs , rhs ) result ( lhsrhs ) character ( len =* ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs type ( unicode_type ) :: lhsrhs lhsrhs = unicode_type ( lhs ) lhsrhs % codes = [ lhsrhs % codes , rhs % codes ] end function concat_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Compare two character sequences for non-equality; LHS, RHS or both sequences can be a unicode string or character variable. ! elemental function lne_str_str ( lhs , rhs ) result ( is_equal ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_equal integer :: icount if ( lhs % len_trim (). eq . rhs % len_trim ()) then icount = lhs % len_trim () is_equal = . not . all ( lhs % codes (: icount ) . eq . rhs % codes (: icount ) ) else is_equal = . true . endif end function lne_str_str elemental function lne_str_char ( lhs , rhs ) result ( is_equal ) type ( unicode_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_equal is_equal = lne_str_str ( lhs , unicode_type ( rhs )) end function lne_str_char elemental function lne_char_str ( lhs , rhs ) result ( is_equal ) character ( len =* ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_equal is_equal = lne_str_str ( unicode_type ( lhs ), rhs ) end function lne_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Compare two character sequences for equality; LHS, RHS or both sequences can be a unicode string or character variable. ! elemental function leq_str_str ( lhs , rhs ) result ( is_equal ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_equal integer :: icount if ( lhs % len_trim (). eq . rhs % len_trim ()) then icount = lhs % len_trim () is_equal = all ( lhs % codes (: icount ) . eq . rhs % codes (: icount ) ) else is_equal = . false . endif end function leq_str_str elemental function leq_str_char ( lhs , rhs ) result ( is_equal ) type ( unicode_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_equal is_equal = leq_str_str ( lhs , unicode_type ( rhs )) end function leq_str_char elemental function leq_char_str ( lhs , rhs ) result ( is_equal ) character ( len =* ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_equal is_equal = leq_str_str ( unicode_type ( lhs ), rhs ) end function leq_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Lexically compare two character sequences for being greater or equal elemental function lge_str_str ( lhs , rhs ) result ( is_lge ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_lge integer :: i integer :: llen integer :: rlen llen = len_trim ( lhs ) rlen = len_trim ( rhs ) FOUND : block do i = 1 , min ( llen , rlen ) select case ( lhs % codes ( i ) - rhs % codes ( i )) case ( 0 ); cycle case ( 1 :); is_lge = . true .; exit FOUND case (: - 1 ); is_lge = . false .; exit FOUND end select enddo ! all equal, decide based on difference in length select case ( llen - rlen ) case ( 0 ); is_lge = . true . case ( 1 :); is_lge = . true . case (: - 1 ); is_lge = . false . end select endblock FOUND end function lge_str_str elemental function lge_str_char ( lhs , rhs ) result ( is_lge ) type ( unicode_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lge is_lge = lge_str_str ( lhs , unicode_type ( rhs )) end function lge_str_char elemental function lge_char_str ( lhs , rhs ) result ( is_lge ) character ( len =* ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_lge is_lge = lge_str_str ( unicode_type ( lhs ), rhs ) end function lge_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Lexically compare two character sequences for being less than or equal elemental function lle_str_str ( lhs , rhs ) result ( is_lle ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_lle integer :: i integer :: llen integer :: rlen llen = len_trim ( lhs ) rlen = len_trim ( rhs ) FOUND : block do i = 1 , min ( llen , rlen ) select case ( lhs % codes ( i ) - rhs % codes ( i ) ) case ( 0 ); cycle case ( 1 :); is_lle = . false .; exit FOUND case (: - 1 ); is_lle = . true .; exit FOUND end select enddo ! all equal, decide based on difference in length select case ( llen - rlen ) case (: - 1 ); is_lle = . true . case ( 0 ); is_lle = . true . case ( 1 :); is_lle = . false . end select endblock FOUND end function lle_str_str elemental function lle_str_char ( lhs , rhs ) result ( is_lle ) type ( unicode_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lle is_lle = lle_str_str ( lhs , unicode_type ( rhs )) end function lle_str_char elemental function lle_char_str ( lhs , rhs ) result ( is_lle ) character ( len =* ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_lle is_lle = lle_str_str ( unicode_type ( lhs ), rhs ) end function lle_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Lexically compare two character sequences for being less than elemental function llt_str_str ( lhs , rhs ) result ( is_llt ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_llt integer :: i integer :: llen integer :: rlen llen = len_trim ( lhs ) rlen = len_trim ( rhs ) FOUND : block do i = 1 , min ( llen , rlen ) select case ( lhs % codes ( i ) - rhs % codes ( i )) case ( 0 ); cycle ; case ( 1 :); is_llt = . false .; exit FOUND case (: - 1 ); is_llt = . true .; exit FOUND end select enddo ! all equal, decide based on difference in length select case ( llen - rlen ) case ( 0 ); is_llt = . false . case ( 1 :); is_llt = . false . case (: - 1 ); is_llt = . true . end select endblock FOUND end function llt_str_str elemental function llt_str_char ( lhs , rhs ) result ( is_llt ) type ( unicode_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_llt is_llt = llt_str_str ( lhs , unicode_type ( rhs )) end function llt_str_char elemental function llt_char_str ( lhs , rhs ) result ( is_llt ) character ( len =* ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_llt is_llt = llt_str_str ( unicode_type ( lhs ), rhs ) end function llt_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Lexically compare two character sequences for being greater than elemental function lgt_str_str ( lhs , rhs ) result ( is_lgt ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_lgt integer :: i integer :: llen integer :: rlen llen = len_trim ( lhs ) rlen = len_trim ( rhs ) FOUND : block do i = 1 , min ( llen , rlen ) select case ( lhs % codes ( i ) - rhs % codes ( i )) case ( 0 ); cycle ; case ( 1 :); is_lgt = . true .; exit FOUND case (: - 1 ); is_lgt = . false .; exit FOUND end select enddo ! all equal, decide based on difference in length select case ( llen - rlen ) case ( 0 ); is_lgt = . false . case ( 1 :); is_lgt = . true . case (: - 1 ); is_lgt = . false . end select endblock FOUND end function lgt_str_str elemental function lgt_str_char ( lhs , rhs ) result ( is_lgt ) type ( unicode_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lgt is_lgt = lgt_str_str ( lhs , unicode_type ( rhs )) end function lgt_str_char elemental function lgt_char_str ( lhs , rhs ) result ( is_lgt ) character ( len =* ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_lgt is_lgt = lgt_str_str ( unicode_type ( lhs ), rhs ) end function lgt_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! find location of substring within string elemental function index_str_str ( string , substring , back ) result ( foundat ) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: substring logical , intent ( in ), optional :: back integer :: foundat integer :: i integer :: strlen integer :: sublen logical :: back_local back_local = . false . if ( present ( back )) back_local = back strlen = string % len () sublen = substring % len () foundat = 0 if ( back_local ) then do i = strlen - sublen + 1 , 1 , - 1 if ( all ( string % codes ( i : i + sublen - 1 ) . eq . substring % codes ) ) then foundat = i exit endif enddo else do i = 1 , strlen - sublen + 1 if ( all ( string % codes ( i : i + sublen - 1 ) . eq . substring % codes ) ) then foundat = i exit endif enddo endif end function index_str_str elemental function index_str_char ( string , substring , back ) result ( foundat ) type ( unicode_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring logical , intent ( in ), optional :: back integer :: foundat foundat = index_str_str ( string , unicode_type ( substring ), back ) end function index_str_char elemental function index_char_str ( string , substring , back ) result ( foundat ) character ( len =* ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: substring logical , intent ( in ), optional :: back integer :: foundat foundat = index_str_str ( unicode_type ( string ), substring , back ) end function index_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !! !! In computing, Unicode characters are typically sorted using one of two methods: !! !! a simple binary code point sort or a more sophisticated, !! language-sensitive collation. The correct approach depends on whether a !! linguistically accurate \"alphabetical\" order is needed or if a simple, !! fixed order is sufficient. !! !! Binary code point sort !! !! This is the simplest and fastest method, often used as a default by !! programming languages and databases. !! !!     How it works: Strings are sorted based on the numeric value of their !!     underlying Unicode code points. For example, a character with a code !!     point of U+0061 (lowercase \"a\") will always be placed before U+0062 !!     (lowercase \"b\") because 97 is less than 98. !! !!     Limitations: While this works for the basic English alphabet, it !!     produces non-intuitive results for other characters because the code !!     point value does not correlate with linguistic sorting rules. For !!     instance, it may place: !! !!         Uppercase letters before all lowercase letters (Z comes before a). !! !!         Accented letters in an order that is not linguistically correct !!         for a given language (e.g., in German, an umlauted character !!         like ö might be sorted differently than a plain o). !! !!         Characters from different scripts (like Latin, Greek, and !!         Cyrillic) in an order determined solely by their assigned code !!         point blocks. !! !! Unicode Collation Algorithm (UCA) !! !! This is the standard, more robust method for sorting that produces !! correct, language-sensitive results. It is described in Unicode Technical !! Standard #10. !! !!     How it works: Instead of sorting by a single numeric value, the !!     UCA uses a multi-level approach to determine a sort key for each !!     string. The algorithm takes into account the specific rules (or !!     \"tailorings\") of a given language or locale, which are defined in !!     the Common Locale Data Repository (CLDR). !! !!     Multi-level sorting: The UCA uses a hierarchy of weights for each !!     character: !! !!         Primary: Compares the base letter, ignoring case and accents. This !!         groups all versions of \"a\" (a, á, A, Á) together. !! !!         Secondary: Compares accents and diacritics. This establishes the !!         order for different versions of the same base letter (e.g., o, !!         ó, ô). !! !!         Tertiary: Compares case differences (uppercase vs. lowercase). !! !!         Quaternary: Deals with other special features, such as handling !!         punctuation. !! !!     Locale-specific rules: The UCA can apply different rules based on !!     a user's location. For example: !! !!         In German phonebooks, umlauted letters (ä) are often sorted as !!         if they were ae. In other contexts, they are sorted with their !!         base letter (a). !! !!         The correct sorting order for Chinese characters can be based !!         on pronunciation (Pinyin) or stroke count, depending on the !!         dictionary or region. !! !! How to choose a sorting method !! !!     Use binary sorting for performance when linguistic order doesn't !!     matter. This is fine for internal data processing where you just !!     need a consistent, quick sort. !! !!     Use the UCA for user-facing applications where culturally appropriate !!     sorting is critical. If your application supports multiple languages, !!     you must use a language-sensitive collator to provide the sorting !!     users will expect. Most modern programming languages and databases !!     have built-in libraries that implement the Unicode Collation !!     Algorithm. !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !> !!##NAME !!    sort_quick_rx(3f) - [M_unicode:sort:quicksort] indexed hybrid quicksort of an array !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!      subroutine sort_quick_rx(data,index) !! !!          type(unicode_type),intent(in) :: data(:) !!          integer,intent(out)           :: indx(size(data)) !! !!##DESCRIPTION !!    A rank hybrid quicksort. The data is not moved. An integer array is !!    generated instead with values that are indices to the sorted order !!    of the data. This requires a second array the size of the input !!    array, which for large arrays would require a significant amount of !!    memory. One major advantage of this method is that !!    the indices can be used to access an entire user-defined type !!    in sorted order. This makes this seemingly simple sort procedure !!    usuable with the vast majority of user-defined types.  or other !!    correlated data. !! !!##BACKGROUND !!    From Leonard J. Moss of SLAC: !! !!    Here's a hybrid QuickSort I wrote a number of years ago. It's !!    based on suggestions in Knuth, Volume 3, and performs much better !!    than a pure QuickSort on short or partially ordered input arrays. !! !!    This routine performs an in-memory sort of the first N elements of !!    array DATA, returning into array INDEX the indices of elements of !!    DATA arranged in ascending order. Thus, !! !!       DATA(INDX(1)) will be the smallest number in array DATA; !!       DATA(INDX(N)) will be the largest number in DATA. !! !!    The original data is not physically rearranged. The original order !!    of equal input values is not necessarily preserved. !! !!    sort_quick_rx(3f) uses a hybrid QuickSort algorithm, based on several !!    suggestions in Knuth, Volume 3, Section 5.2.2. In particular, the !!    \"pivot key\" [my term] for dividing each subsequence is chosen to be !!    the median of the first, last, and middle values of the subsequence; !!    and the QuickSort is cut off when a subsequence has 9 or fewer !!    elements, and a straight insertion sort of the entire array is done !!    at the end. The result is comparable to a pure insertion sort for !!    very short arrays, and very fast for very large arrays (of order 12 !!    micro-sec/element on the 3081K for arrays of 10K elements). It is !!    also not subject to the poor performance of the pure QuickSort on !!    partially ordered data. !! !!    Complex values are sorted by the magnitude of sqrt(r**2+i**2). !! !!    o Created: sortrx(3f): 15 Jul 1986, Len Moss !!    o saved from url=(0044)http://www.fortran.com/fortran/quick_sort2.f !!    o changed to update syntax from F77 style; John S. Urban 20161021 !!    o generalized from only real values to include other intrinsic types; !!      John S. Urban 20210110 !!    o type(unicode_type) version JSU 2025-09-20. See M_sort for other types. !! !!##EXAMPLES !! !!  Sample usage: !! !!    program demo_sort_quick_rx !!    use M_unicode, only : sort_quick_rx, unicode_type, assignment(=) !!    implicit none !!    character(len=*),parameter :: g='(*(g0))' !!    integer,parameter  :: isz=4 !!    type(unicode_type) :: rr(isz) !!    integer            :: ii(isz) !!    integer            :: i !!       write(*,g)'sort array with sort_quick_rx(3f)' !!       rr(1)=\"the\" !!       rr(2)=\"quick\" !!       rr(3)=\"brown\" !!       rr(4)=\"fox\" !!       call sort_quick_rx(rr,ii) !! !!       write(*,g)'original order' !!       do i=1,size(rr) !!          write(*,g)rr(i)%character() !!       enddo !! !!       write(*,g)'sorted order' !!       do i=1,size(rr) !!          write(*,g)rr(ii(i))%character() !!       enddo !! !!    end program demo_sort_quick_rx !! !!   Results: !! !==================================================================================================================================! !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !==================================================================================================================================! subroutine sort_quick_rx ( data , indx ) ! ident_30=\"@(#) M_unicode sort_quick_rx(3f) indexed hybrid quicksort of a type(unicode_type) array\" type ( unicode_type ), intent ( in ) :: data (:) integer ( kind = int32 ), intent ( out ) :: indx (:) type ( unicode_type ) :: datap integer ( kind = int32 ) :: n integer ( kind = int32 ) :: lstk ( 31 ), rstk ( 31 ), istk integer ( kind = int32 ) :: l , r , i , j , p , indexp , indext !  QuickSort Cutoff ! !  Quit QuickSort-ing when a subsequence contains M or fewer elements and finish off at end with straight insertion sort. !  According to Knuth, V.3, the optimum value of M is around 9. integer , parameter :: M = 9 !=================================================================================================================================== n = size ( data ) if ( size ( indx ). lt . n ) then ! if index is not big enough, only sort part of the data write ( * , * ) '*sort_quick_rx* ERROR: insufficient space to store index data' n = size ( indx ) endif !=================================================================================================================================== !  Make initial guess for INDEX do i = 1 , n indx ( i ) = i enddo !  If array is short go directly to the straight insertion sort, else execute a QuickSort if ( N . gt . M ) then !============================================================================================================================= !  QuickSort ! !  The \"Qn:\"s correspond roughly to steps in Algorithm Q, Knuth, V.3, PP.116-117, modified to select the median !  of the first, last, and middle elements as the \"pivot key\" (in Knuth's notation, \"K\"). Also modified to leave !  data in place and produce an INDEX array. To simplify comments, let DATA[I]=DATA(INDX(I)). ! Q1: Initialize istk = 0 l = 1 r = n !============================================================================================================================= TOP : do ! Q2: Sort the subsequence DATA[L]..DATA[R]. ! !  At this point, DATA[l] <= DATA[m] <= DATA[r] for all l < L, r > R, and L <= m <= R. !  (First time through, there is no DATA for l < L or r > R.) i = l j = r ! Q2.5: Select pivot key ! !  Let the pivot, P, be the midpoint of this subsequence, P=(L+R)/2; then rearrange INDX(L), INDX(P), and INDX(R) !  so the corresponding DATA values are in increasing order. The pivot key, DATAP, is then DATA[P]. p = ( l + r ) / 2 indexp = indx ( p ) datap = data ( indexp ) if ( data ( indx ( l )) . gt . datap ) then indx ( p ) = indx ( l ) indx ( l ) = indexp indexp = indx ( p ) datap = data ( indexp ) endif if ( datap . gt . data ( indx ( r ))) then if ( data ( indx ( l )) . gt . data ( indx ( r ))) then indx ( p ) = indx ( l ) indx ( l ) = indx ( r ) else indx ( p ) = indx ( r ) endif indx ( r ) = indexp indexp = indx ( p ) datap = data ( indexp ) endif !  Now we swap values between the right and left sides and/or move DATAP until all smaller values are on the left and all !  larger values are on the right. Neither the left or right side will be internally ordered yet; however, DATAP will be !  in its final position. Q3 : do ! Q3: Search for datum on left >= DATAP !   At this point, DATA[L] <= DATAP. We can therefore start scanning up from L, looking for a value >= DATAP !   (this scan is guaranteed to terminate since we initially placed DATAP near the middle of the subsequence). I = I + 1 if ( data ( indx ( i )). lt . datap ) then cycle Q3 endif !----------------------------------------------------------------------------------------------------------------------- ! Q4: Search for datum on right <= DATAP ! !   At this point, DATA[R] >= DATAP. We can therefore start scanning down from R, looking for a value <= DATAP !   (this scan is guaranteed to terminate since we initially placed DATAP near the middle of the subsequence). Q4 : do j = j - 1 if ( data ( indx ( j )). le . datap ) then exit Q4 endif enddo Q4 !----------------------------------------------------------------------------------------------------------------------- ! Q5: Have the two scans collided? if ( i . lt . j ) then ! Q6: No, interchange DATA[I] <--> DATA[J] and continue indext = indx ( i ) indx ( i ) = indx ( j ) indx ( j ) = indext cycle Q3 else ! Q7: Yes, select next subsequence to sort !   At this point, I >= J and DATA[l] <= DATA[I] == DATAP <= DATA[r], for all L <= l < I and J < r <= R. !   If both subsequences are more than M elements long, push the longer one on the stack !   and go back to QuickSort the shorter; if only one is more than M elements long, go back and QuickSort it; !   otherwise, pop a subsequence off the stack and QuickSort it. if ( r - j . ge . i - l . and . i - l . gt . m ) then istk = istk + 1 lstk ( istk ) = j + 1 rstk ( istk ) = r r = i - 1 elseif ( i - l . gt . r - j . and . r - j . gt . m ) then istk = istk + 1 lstk ( istk ) = l rstk ( istk ) = i - 1 l = j + 1 elseif ( r - j . gt . m ) then l = j + 1 elseif ( i - l . gt . m ) then r = i - 1 else ! Q8: Pop the stack, or terminate QuickSort if empty if ( istk . lt . 1 ) then exit TOP endif l = lstk ( istk ) r = rstk ( istk ) istk = istk - 1 endif cycle TOP endif ! never get here, as cycle Q3 or cycle TOP enddo Q3 exit TOP enddo TOP endif !=================================================================================================================================== ! Q9: Straight Insertion sort do i = 2 , n if ( data ( indx ( i - 1 )) . gt . data ( indx ( i ))) then indexp = indx ( i ) datap = data ( indexp ) p = i - 1 INNER : do indx ( p + 1 ) = indx ( p ) p = p - 1 if ( p . le . 0 ) then exit INNER endif if ( data ( indx ( p )). le . datap ) then exit INNER endif enddo INNER indx ( p + 1 ) = indexp endif enddo !=================================================================================================================================== !     All done end subroutine sort_quick_rx !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== elemental pure function upper ( str ) result ( string ) ! ident_25=\"@(#) M_unicode upper(3f) returns an uppercase string\" type ( unicode_type ), intent ( in ) :: str ! input string to convert to all uppercase type ( unicode_type ) :: string ! output string that contains no miniscule letters integer :: i ! loop counter integer :: pos integer , parameter :: ade_a = iachar ( 'a' ), ade_z = iachar ( 'z' ) integer , parameter :: diff = iachar ( 'A' ) - iachar ( 'a' ) string = str do i = 1 , len ( str ) ! step thru each letter in the string in specified range select case ( str % codes ( i )) case ( ade_a : ade_z ) string % codes ( i ) = str % codes ( i ) + diff case default pos = binary_search ( lowup (:, 1 ), str % codes ( i )) if ( pos > 0 ) then string % codes ( i ) = lowup ( pos , 2 ) endif end select enddo if ( len ( str ). eq . 0 ) string = str end function upper elemental pure function lower ( str ) result ( string ) ! ident_25=\"@(#) M_unicode lower(3f) returns a lowercase string\" type ( unicode_type ), intent ( in ) :: str ! input string to convert to all lowercase type ( unicode_type ) :: string ! output string that contains no miniscule letters integer :: i ! loop counter integer :: pos integer , parameter :: ade_a = iachar ( 'A' ), ade_z = iachar ( 'Z' ) integer , parameter :: diff = iachar ( 'A' ) - iachar ( 'a' ) string = str do i = 1 , len ( str ) ! step thru each letter in the string in specified range select case ( str % codes ( i )) case ( ade_a : ade_z ) string % codes ( i ) = str % codes ( i ) - diff case default pos = binary_search ( uplow (:, 1 ), str % codes ( i )) if ( pos > 0 ) then string % codes ( i ) = uplow ( pos , 2 ) endif end select enddo if ( len ( str ). eq . 0 ) string = str end function lower !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== impure subroutine split_tokens ( string , set , tokens , separator ) ! Splits a string into tokens using characters in set as token delimiters. ! If present, separator contains the array of token delimiters. type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set type ( unicode_type ), allocatable , intent ( out ) :: tokens (:) type ( unicode_type ), allocatable , intent ( out ), optional :: separator (:) integer , allocatable :: first (:), last (:) integer :: n integer :: imax ! AUTHOR  : Milan Curcic, \"milancurcic@hey.com\" ! LICENSE : MIT ! VERSION : version 0.1.0, copyright 2020, Milan Curcic call split_first_last ( string , set , first , last ) ! maxval() of a zero-size array is set to a flag value not zero or length of character string if ( size ( first ). eq . 0 ) then imax = 0 else imax = maxval ( last - first ) + 1 endif allocate ( tokens ( size ( first ))) do n = 1 , size ( tokens ) tokens ( n ) = string % character ( first ( n ), last ( n ), 1 ) enddo if ( present ( separator )) then allocate ( separator ( size ( tokens ) - 1 )) do n = 1 , size ( tokens ) - 1 separator ( n ) = string % character ( first ( n + 1 ) - 1 , first ( n + 1 ) - 1 , 1 ) enddo endif end subroutine split_tokens !=================================================================================================================================== impure subroutine split_first_last ( string , set , first , last ) ! Computes the first and last indices of tokens in input string, delimited ! by the characters in set, and stores them into first and last output ! arrays. type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set integer , allocatable , intent ( out ) :: first (:) integer , allocatable , intent ( out ) :: last (:) type ( unicode_type ) :: set_array ( len ( set )) logical , dimension ( len ( string )) :: is_first , is_last , is_separator integer :: i integer :: n integer :: slen ! AUTHOR   : Milan Curcic, \"milancurcic@hey.com\" ! LICENSE  : MIT ! VERSION  : version 0.1.0, copyright 2020, Milan Curcic ! MODIFIED : 2025-09-21 JSU slen = len ( string ) do n = 1 , len ( set ) set_array ( n ) = set % character ( n , n ) enddo FINDIT : do n = 1 , slen do i = 1 , len ( set ) is_separator ( n ) = . false . if ( string % character ( n , n ) == set_array ( i )% character () ) then is_separator ( n ) = . true . exit endif enddo enddo FINDIT is_first = . false . is_last = . false . if (. not . is_separator ( 1 )) is_first ( 1 ) = . true . do concurrent ( n = 2 : slen - 1 ) if (. not . is_separator ( n )) then if ( is_separator ( n - 1 )) is_first ( n ) = . true . if ( is_separator ( n + 1 )) is_last ( n ) = . true . else if ( is_separator ( n - 1 )) then is_first ( n ) = . true . is_last ( n - 1 ) = . true . endif endif enddo if (. not . is_separator ( slen )) is_last ( slen ) = . true . first = pack ([( n , n = 1 , slen )], is_first ) last = pack ([( n , n = 1 , slen )], is_last ) end subroutine split_first_last !=================================================================================================================================== impure subroutine split_pos ( string , set , pos , back ) ! If back is absent, computes the leftmost token delimiter in string whose ! position is > pos. If back is present and true, computes the rightmost ! token delimiter in string whose position is < pos. The result is stored ! in pos. type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set integer , intent ( in out ) :: pos logical , intent ( in ), optional :: back logical :: backward type ( unicode_type ) :: set_array ( len ( set )) integer :: i integer :: result_pos integer :: n ! AUTHOR   : Milan Curcic, \"milancurcic@hey.com\" ! LICENSE  : MIT ! VERSION  : version 0.1.0, copyright 2020, Milan Curcic ! MODIFIED : 2025-09-21 JSU backward = . false . if ( present ( back )) backward = back do n = 1 , len ( set ) set_array ( n ) = set % character ( n , n ) enddo if ( backward ) then result_pos = 0 FINDIT : do n = pos - 1 , 1 , - 1 do i = 1 , len ( set ) if ( string % character ( n , n ) == set_array ( i )% character () ) then result_pos = n exit FINDIT endif enddo enddo FINDIT else result_pos = len ( string ) + 1 GETPOS : do n = pos + 1 , len ( string ) do i = 1 , len ( set ) if ( string % character ( n , n ) == set_array ( i )% character () ) then result_pos = n exit GETPOS endif enddo enddo GETPOS endif pos = result_pos end subroutine split_pos !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== elemental pure function uscan ( string , set , back ) result ( pos ) !@(#) M_unicode:uscan(3f)  Scan a string for the presence of a set of characters type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set logical , intent ( in ), optional :: back logical :: back_local integer :: pos integer :: value integer :: i back_local = . false . if ( present ( back )) back_local = back pos = 0 do i = 1 , len ( set ) value = set % codes ( i ) pos = findloc ( string % codes , value , dim = 1 , back = back_local ) if ( pos . ne . 0 ) exit enddo end function uscan !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== elemental impure function uverify ( string , set , back ) result ( result ) !@(#)  uverify(3) ‐ [CHARACTER:SEARCH] Position of a character in a string that does not appear in a given set of characters. type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set type ( unicode_type ) :: str logical , intent ( in ), optional :: back integer :: result integer :: pos integer :: i result = 0 do i = 1 , len ( string ) str = string % character ( i , i ) pos = index ( set , str , back ) if ( pos . eq . 0 ) then result = i exit endif enddo end function uverify !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_upper ( self ) result ( string_out ) class ( unicode_type ), intent ( in ) :: self type ( unicode_type ) :: string_out string_out = upper ( self ) end function oop_upper !=================================================================================================================================== function oop_lower ( self ) result ( string_out ) class ( unicode_type ), intent ( in ) :: self type ( unicode_type ) :: string_out string_out = lower ( self ) end function oop_lower !=================================================================================================================================== function oop_adjustl ( self ) result ( string_out ) class ( unicode_type ), intent ( in ) :: self type ( unicode_type ) :: string_out string_out = adjustl_str ( self ) end function oop_adjustl !=================================================================================================================================== function oop_adjustr ( self ) result ( string_out ) ! ident_13=\"@(#) M_strs oop_adjustr(3f) adjust string to right\" class ( unicode_type ), intent ( in ) :: self type ( unicode_type ) :: string_out string_out = adjustr_str ( self ) end function oop_adjustr !=================================================================================================================================== function oop_character ( self , first , last , step ) result ( str_out ) class ( unicode_type ), intent ( in ) :: self character ( len = :), allocatable :: str_out integer , intent ( in ), optional :: first , last , step integer :: start , end , inc type ( unicode_type ) :: temp if ( present ( step )) then ; inc = step ; else ; inc = 1 ; endif if ( present ( first )) then ; start = first ; else ; start = 1 ; endif if ( present ( last )) then ; end = last ; else ; end = len ( self ); endif temp = self % codes ( start : end : inc ) str_out = char_str ( temp ) end function oop_character !=================================================================================================================================== function oop_bytes ( self , first , last , step ) result ( bytes_out ) class ( unicode_type ), intent ( in ) :: self integer , intent ( in ), optional :: first , last , step character ( len = 1 ), allocatable :: bytes_out (:) bytes_out = s2a ( oop_character ( self , first , last , step )) end function oop_bytes !=================================================================================================================================== function oop_codepoint ( self , first , last , step ) result ( codes_out ) class ( unicode_type ), intent ( in ) :: self integer , allocatable :: codes_out (:) integer , intent ( in ), optional :: first , last , step integer :: start , end , inc if ( present ( step )) then ; inc = step ; else ; inc = 1 ; endif if ( present ( first )) then ; start = first ; else ; start = 1 ; endif if ( present ( last )) then ; end = last ; else ; end = len ( self ); endif codes_out = self % codes ( start : end : inc ) end function oop_codepoint !=================================================================================================================================== impure function oop_verify ( self , set , back ) result ( pos ) class ( unicode_type ), intent ( in ) :: self class ( unicode_type ), intent ( in ) :: set logical , intent ( in ), optional :: back integer :: pos pos = uverify ( self , set , back = back ) end function oop_verify !=================================================================================================================================== pure function oop_scan ( self , set , back ) result ( pos ) class ( unicode_type ), intent ( in ) :: self class ( unicode_type ), intent ( in ) :: set logical , optional , intent ( in ) :: back integer :: pos pos = uscan ( self , set , back = back ) end function oop_scan !=================================================================================================================================== function oop_tokenize ( self , set ) result ( tokens ) class ( unicode_type ), intent ( in ) :: self type ( unicode_type ), intent ( in ) :: set type ( unicode_type ), allocatable :: tokens (:) integer , allocatable :: begin (:) integer , allocatable :: end (:) integer :: i call split ( self , set , begin , end ) allocate ( tokens ( size ( begin ))) do i = 1 , size ( begin ) tokens ( i ) = self % character ( begin ( i ), end ( i )) enddo end function oop_tokenize !=================================================================================================================================== function oop_split ( self , set ) result ( tokens ) class ( unicode_type ), intent ( in ) :: self type ( unicode_type ), intent ( in ) :: set type ( unicode_type ), allocatable :: tokens (:) call split ( self , set , tokens ) end function oop_split !=================================================================================================================================== pure function oop_trim ( self ) result ( string_out ) class ( unicode_type ), intent ( in ) :: self type ( unicode_type ) :: string_out string_out = trim ( self ) end function oop_trim !=================================================================================================================================== pure function oop_len_trim ( self ) result ( len_trim_out ) class ( unicode_type ), intent ( in ) :: self integer :: len_trim_out len_trim_out = len_trim ( self ) end function oop_len_trim !=================================================================================================================================== pure function oop_len ( self ) result ( len_out ) class ( unicode_type ), intent ( in ) :: self integer :: len_out len_out = len ( self ) end function oop_len !=================================================================================================================================== impure function oop_index ( self , substring ) result ( index_out ) class ( unicode_type ), intent ( in ) :: self class ( * ), intent ( in ) :: substring integer :: index_out select type ( substring ) type is ( character ( len =* )) index_out = index ( self , unicode_type ( substring )) type is ( unicode_type ) index_out = index ( self , substring ) class default stop '<ERROR>*oop_index* unknown type' end select end function oop_index !=================================================================================================================================== impure function oop_eq ( self , string ) result ( is_eq ) class ( unicode_type ), intent ( in ) :: self class ( * ), intent ( in ) :: string logical :: is_eq select type ( string ) type is ( character ( len =* )) is_eq = leq_str_char ( self , string ) type is ( unicode_type ) is_eq = leq_str_str ( self , string ) class default stop '<ERROR>*oop_eq* unknown type' end select end function oop_eq !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== end module M_unicode","tags":"","url":"sourcefile/m_unicode.f90.html"},{"title":"uplow.f90 – M_unicode","text":"Source Code program testit !use M_unicode, only : assignment(=), unicode_type use M_unicode ! Unicode lowercase to uppercase conversion mapping table integer , parameter :: lowhigh = 666 integer , parameter :: lowup ( lowhigh , 2 ) = reshape ([ & int ( z '0061' ), int ( z '0041' ), & ! LATIN SMALL LETTER A => LATIN CAPITAL LETTER A int ( z '0062' ), int ( z '0042' ), & ! LATIN SMALL LETTER B => LATIN CAPITAL LETTER B int ( z '0063' ), int ( z '0043' ), & ! LATIN SMALL LETTER C => LATIN CAPITAL LETTER C int ( z '0064' ), int ( z '0044' ), & ! LATIN SMALL LETTER D => LATIN CAPITAL LETTER D int ( z '0065' ), int ( z '0045' ), & ! LATIN SMALL LETTER E => LATIN CAPITAL LETTER E int ( z '0066' ), int ( z '0046' ), & ! LATIN SMALL LETTER F => LATIN CAPITAL LETTER F int ( z '0067' ), int ( z '0047' ), & ! LATIN SMALL LETTER G => LATIN CAPITAL LETTER G int ( z '0068' ), int ( z '0048' ), & ! LATIN SMALL LETTER H => LATIN CAPITAL LETTER H int ( z '0069' ), int ( z '0049' ), & ! LATIN SMALL LETTER I => LATIN CAPITAL LETTER I int ( z '006A' ), int ( z '004A' ), & ! LATIN SMALL LETTER J => LATIN CAPITAL LETTER J int ( z '006B' ), int ( z '004B' ), & ! LATIN SMALL LETTER K => LATIN CAPITAL LETTER K int ( z '006C' ), int ( z '004C' ), & ! LATIN SMALL LETTER L => LATIN CAPITAL LETTER L int ( z '006D' ), int ( z '004D' ), & ! LATIN SMALL LETTER M => LATIN CAPITAL LETTER M int ( z '006E' ), int ( z '004E' ), & ! LATIN SMALL LETTER N => LATIN CAPITAL LETTER N int ( z '006F' ), int ( z '004F' ), & ! LATIN SMALL LETTER O => LATIN CAPITAL LETTER O int ( z '0070' ), int ( z '0050' ), & ! LATIN SMALL LETTER P => LATIN CAPITAL LETTER P int ( z '0071' ), int ( z '0051' ), & ! LATIN SMALL LETTER Q => LATIN CAPITAL LETTER Q int ( z '0072' ), int ( z '0052' ), & ! LATIN SMALL LETTER R => LATIN CAPITAL LETTER R int ( z '0073' ), int ( z '0053' ), & ! LATIN SMALL LETTER S => LATIN CAPITAL LETTER S int ( z '0074' ), int ( z '0054' ), & ! LATIN SMALL LETTER T => LATIN CAPITAL LETTER T int ( z '0075' ), int ( z '0055' ), & ! LATIN SMALL LETTER U => LATIN CAPITAL LETTER U int ( z '0076' ), int ( z '0056' ), & ! LATIN SMALL LETTER V => LATIN CAPITAL LETTER V int ( z '0077' ), int ( z '0057' ), & ! LATIN SMALL LETTER W => LATIN CAPITAL LETTER W int ( z '0078' ), int ( z '0058' ), & ! LATIN SMALL LETTER X => LATIN CAPITAL LETTER X int ( z '0079' ), int ( z '0059' ), & ! LATIN SMALL LETTER Y => LATIN CAPITAL LETTER Y int ( z '007A' ), int ( z '005A' ), & ! LATIN SMALL LETTER Z => LATIN CAPITAL LETTER Z int ( z '00E0' ), int ( z '00C0' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A GRAVE int ( z '00E1' ), int ( z '00C1' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A ACUTE int ( z '00E2' ), int ( z '00C2' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A CIRCUMFLEX int ( z '00E3' ), int ( z '00C3' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A TILDE int ( z '00E4' ), int ( z '00C4' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A DIAERESIS int ( z '00E5' ), int ( z '00C5' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A RING int ( z '00E6' ), int ( z '00C6' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER A E int ( z '00E7' ), int ( z '00C7' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER C CEDILLA int ( z '00E8' ), int ( z '00C8' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER E GRAVE int ( z '00E9' ), int ( z '00C9' ), & ! LATIN SMALL LETTER A GRAVE => LATIN CAPITAL LETTER E ACUTE int ( z '00EA' ), int ( z '00CA' ), & ! LATIN SMALL LETTER E CIRCUMFLEX => LATIN CAPITAL LETTER E CIRCUMFLEX int ( z '00EB' ), int ( z '00CB' ), & ! LATIN SMALL LETTER E DIAERESIS => LATIN CAPITAL LETTER E DIAERESIS int ( z '00EC' ), int ( z '00CC' ), & ! LATIN SMALL LETTER I GRAVE => LATIN CAPITAL LETTER I GRAVE int ( z '00ED' ), int ( z '00CD' ), & ! LATIN SMALL LETTER I ACUTE => LATIN CAPITAL LETTER I ACUTE int ( z '00EE' ), int ( z '00CE' ), & ! LATIN SMALL LETTER I CIRCUMFLEX => LATIN CAPITAL LETTER I CIRCUMFLEX int ( z '00EF' ), int ( z '00CF' ), & ! LATIN SMALL LETTER I DIAERESIS => LATIN CAPITAL LETTER I DIAERESIS int ( z '00F0' ), int ( z '00D0' ), & ! LATIN SMALL LETTER ETH => LATIN CAPITAL LETTER ETH int ( z '00F1' ), int ( z '00D1' ), & ! LATIN SMALL LETTER N TILDE => LATIN CAPITAL LETTER N TILDE int ( z '00F2' ), int ( z '00D2' ), & ! LATIN SMALL LETTER O GRAVE => LATIN CAPITAL LETTER O GRAVE int ( z '00F3' ), int ( z '00D3' ), & ! LATIN SMALL LETTER O ACUTE => LATIN CAPITAL LETTER O ACUTE int ( z '00F4' ), int ( z '00D4' ), & ! LATIN SMALL LETTER O CIRCUMFLEX => LATIN CAPITAL LETTER O CIRCUMFLEX int ( z '00F5' ), int ( z '00D5' ), & ! LATIN SMALL LETTER O TILDE => LATIN CAPITAL LETTER O TILDE int ( z '00F6' ), int ( z '00D6' ), & ! LATIN SMALL LETTER O DIAERESIS => LATIN CAPITAL LETTER O DIAERESIS int ( z '00F8' ), int ( z '00D8' ), & ! LATIN SMALL LETTER O SLASH => LATIN CAPITAL LETTER O SLASH int ( z '00F9' ), int ( z '00D9' ), & ! LATIN SMALL LETTER U GRAVE => LATIN CAPITAL LETTER U GRAVE int ( z '00FA' ), int ( z '00DA' ), & ! LATIN SMALL LETTER U ACUTE => LATIN CAPITAL LETTER U ACUTE int ( z '00FB' ), int ( z '00DB' ), & ! LATIN SMALL LETTER U CIRCUMFLEX => LATIN CAPITAL LETTER U CIRCUMFLEX int ( z '00FC' ), int ( z '00DC' ), & ! LATIN SMALL LETTER U DIAERESIS => LATIN CAPITAL LETTER U DIAERESIS int ( z '00FD' ), int ( z '00DD' ), & ! LATIN SMALL LETTER Y ACUTE => LATIN CAPITAL LETTER Y ACUTE int ( z '00FE' ), int ( z '00DE' ), & ! LATIN SMALL LETTER THORN => LATIN CAPITAL LETTER THORN int ( z '00FF' ), int ( z '0178' ), & ! LATIN SMALL LETTER Y DIAERESIS => LATIN CAPITAL LETTER Y WITH DIAERESIS int ( z '0101' ), int ( z '0100' ), & ! LATIN SMALL LETTER A WITH MACRON => LATIN CAPITAL LETTER A WITH MACRON int ( z '0103' ), int ( z '0102' ), & ! LATIN SMALL LETTER A WITH BREVE => LATIN CAPITAL LETTER A WITH BREVE int ( z '0105' ), int ( z '0104' ), & ! LATIN SMALL LETTER A WITH OGONEK => LATIN CAPITAL LETTER A WITH OGONEK int ( z '0107' ), int ( z '0106' ), & ! LATIN SMALL LETTER C WITH ACUTE => LATIN CAPITAL LETTER C WITH ACUTE int ( z '0109' ), int ( z '0108' ), & ! LATIN SMALL LETTER C WITH CIRCUMFLEX => LATIN CAPITAL LETTER C WITH CIRCUMFLEX int ( z '010B' ), int ( z '010A' ), & ! LATIN SMALL LETTER C WITH DOT ABOVE => LATIN CAPITAL LETTER C WITH DOT ABOVE int ( z '010D' ), int ( z '010C' ), & ! LATIN SMALL LETTER C WITH CARON => LATIN CAPITAL LETTER C WITH CARON int ( z '010F' ), int ( z '010E' ), & ! LATIN SMALL LETTER D WITH CARON => LATIN CAPITAL LETTER D WITH CARON int ( z '0111' ), int ( z '0110' ), & ! LATIN SMALL LETTER D WITH STROKE => LATIN CAPITAL LETTER D WITH STROKE int ( z '0113' ), int ( z '0112' ), & ! LATIN SMALL LETTER E WITH MACRON => LATIN CAPITAL LETTER E WITH MACRON int ( z '0115' ), int ( z '0114' ), & ! LATIN SMALL LETTER E WITH BREVE => LATIN CAPITAL LETTER E WITH BREVE int ( z '0117' ), int ( z '0116' ), & ! LATIN SMALL LETTER E WITH DOT ABOVE => LATIN CAPITAL LETTER E WITH DOT ABOVE int ( z '0119' ), int ( z '0118' ), & ! LATIN SMALL LETTER E WITH OGONEK => LATIN CAPITAL LETTER E WITH OGONEK int ( z '011B' ), int ( z '011A' ), & ! LATIN SMALL LETTER E WITH CARON => LATIN CAPITAL LETTER E WITH CARON int ( z '011D' ), int ( z '011C' ), & ! LATIN SMALL LETTER G WITH CIRCUMFLEX => LATIN CAPITAL LETTER G WITH CIRCUMFLEX int ( z '011F' ), int ( z '011E' ), & ! LATIN SMALL LETTER G WITH BREVE => LATIN CAPITAL LETTER G WITH BREVE int ( z '0121' ), int ( z '0120' ), & ! LATIN SMALL LETTER G WITH DOT ABOVE => LATIN CAPITAL LETTER G WITH DOT ABOVE int ( z '0123' ), int ( z '0122' ), & ! LATIN SMALL LETTER G WITH CEDILLA => LATIN CAPITAL LETTER G WITH CEDILLA int ( z '0125' ), int ( z '0124' ), & ! LATIN SMALL LETTER H WITH CIRCUMFLEX => LATIN CAPITAL LETTER H WITH CIRCUMFLEX int ( z '0127' ), int ( z '0126' ), & ! LATIN SMALL LETTER H WITH STROKE => LATIN CAPITAL LETTER H WITH STROKE int ( z '0129' ), int ( z '0128' ), & ! LATIN SMALL LETTER I WITH TILDE => LATIN CAPITAL LETTER I WITH TILDE int ( z '012B' ), int ( z '012A' ), & ! LATIN SMALL LETTER I WITH MACRON => LATIN CAPITAL LETTER I WITH MACRON int ( z '012D' ), int ( z '012C' ), & ! LATIN SMALL LETTER I WITH BREVE => LATIN CAPITAL LETTER I WITH BREVE int ( z '012F' ), int ( z '012E' ), & ! LATIN SMALL LETTER I WITH OGONEK => LATIN CAPITAL LETTER I WITH OGONEK int ( z '0131' ), int ( z '0049' ), & ! LATIN SMALL LETTER DOTLESS I => LATIN CAPITAL LETTER I int ( z '0133' ), int ( z '0132' ), & ! LATIN SMALL LIGATURE IJ => LATIN CAPITAL LIGATURE IJ int ( z '0135' ), int ( z '0134' ), & ! LATIN SMALL LETTER J WITH CIRCUMFLEX => LATIN CAPITAL LETTER J WITH CIRCUMFLEX int ( z '0137' ), int ( z '0136' ), & ! LATIN SMALL LETTER K WITH CEDILLA => LATIN CAPITAL LETTER K WITH CEDILLA int ( z '013A' ), int ( z '0139' ), & ! LATIN SMALL LETTER L WITH ACUTE => LATIN CAPITAL LETTER L WITH ACUTE int ( z '013C' ), int ( z '013B' ), & ! LATIN SMALL LETTER L WITH CEDILLA => LATIN CAPITAL LETTER L WITH CEDILLA int ( z '013E' ), int ( z '013D' ), & ! LATIN SMALL LETTER L WITH CARON => LATIN CAPITAL LETTER L WITH CARON int ( z '0140' ), int ( z '013F' ), & ! LATIN SMALL LETTER L WITH MIDDLE DOT => LATIN CAPITAL LETTER L WITH MIDDLE DOT int ( z '0142' ), int ( z '0141' ), & ! LATIN SMALL LETTER L WITH STROKE => LATIN CAPITAL LETTER L WITH STROKE int ( z '0144' ), int ( z '0143' ), & ! LATIN SMALL LETTER N WITH ACUTE => LATIN CAPITAL LETTER N WITH ACUTE int ( z '0146' ), int ( z '0145' ), & ! LATIN SMALL LETTER N WITH CEDILLA => LATIN CAPITAL LETTER N WITH CEDILLA int ( z '0148' ), int ( z '0147' ), & ! LATIN SMALL LETTER N WITH CARON => LATIN CAPITAL LETTER N WITH CARON int ( z '014B' ), int ( z '014A' ), & ! LATIN SMALL LETTER ENG (SAMI) => LATIN CAPITAL LETTER ENG (SAMI) int ( z '014D' ), int ( z '014C' ), & ! LATIN SMALL LETTER O WITH MACRON => LATIN CAPITAL LETTER O WITH MACRON int ( z '014F' ), int ( z '014E' ), & ! LATIN SMALL LETTER O WITH BREVE => LATIN CAPITAL LETTER O WITH BREVE int ( z '0151' ), int ( z '0150' ), & ! LATIN SMALL LETTER O WITH DOUBLE ACUTE => LATIN CAPITAL LETTER O WITH DOUBLE ACUTE int ( z '0153' ), int ( z '0152' ), & ! LATIN SMALL LIGATURE OE => LATIN CAPITAL LIGATURE OE int ( z '0155' ), int ( z '0154' ), & ! LATIN SMALL LETTER R WITH ACUTE => LATIN CAPITAL LETTER R WITH ACUTE int ( z '0157' ), int ( z '0156' ), & ! LATIN SMALL LETTER R WITH CEDILLA => LATIN CAPITAL LETTER R WITH CEDILLA int ( z '0159' ), int ( z '0158' ), & ! LATIN SMALL LETTER R WITH CARON => LATIN CAPITAL LETTER R WITH CARON int ( z '015B' ), int ( z '015A' ), & ! LATIN SMALL LETTER S WITH ACUTE => LATIN CAPITAL LETTER S WITH ACUTE int ( z '015D' ), int ( z '015C' ), & ! LATIN SMALL LETTER S WITH CIRCUMFLEX => LATIN CAPITAL LETTER S WITH CIRCUMFLEX int ( z '015F' ), int ( z '015E' ), & ! LATIN SMALL LETTER S WITH CEDILLA => LATIN CAPITAL LETTER S WITH CEDILLA int ( z '0161' ), int ( z '0160' ), & ! LATIN SMALL LETTER S WITH CARON => LATIN CAPITAL LETTER S WITH CARON int ( z '0163' ), int ( z '0162' ), & ! LATIN SMALL LETTER T WITH CEDILLA => LATIN CAPITAL LETTER T WITH CEDILLA int ( z '0165' ), int ( z '0164' ), & ! LATIN SMALL LETTER T WITH CARON => LATIN CAPITAL LETTER T WITH CARON int ( z '0167' ), int ( z '0166' ), & ! LATIN SMALL LETTER T WITH STROKE => LATIN CAPITAL LETTER T WITH STROKE int ( z '0169' ), int ( z '0168' ), & ! LATIN SMALL LETTER U WITH TILDE => LATIN CAPITAL LETTER U WITH TILDE int ( z '016B' ), int ( z '016A' ), & ! LATIN SMALL LETTER U WITH MACRON => LATIN CAPITAL LETTER U WITH MACRON int ( z '016D' ), int ( z '016C' ), & ! LATIN SMALL LETTER U WITH BREVE => LATIN CAPITAL LETTER U WITH BREVE int ( z '016F' ), int ( z '016E' ), & ! LATIN SMALL LETTER U WITH RING ABOVE => LATIN CAPITAL LETTER U WITH RING ABOVE int ( z '0171' ), int ( z '0170' ), & ! LATIN SMALL LETTER U WITH DOUBLE ACUTE => LATIN CAPITAL LETTER U WITH DOUBLE ACUTE int ( z '0173' ), int ( z '0172' ), & ! LATIN SMALL LETTER U WITH OGONEK => LATIN CAPITAL LETTER U WITH OGONEK int ( z '0175' ), int ( z '0174' ), & ! LATIN SMALL LETTER W WITH CIRCUMFLEX => LATIN CAPITAL LETTER W WITH CIRCUMFLEX int ( z '0177' ), int ( z '0176' ), & ! LATIN SMALL LETTER Y WITH CIRCUMFLEX => LATIN CAPITAL LETTER Y WITH CIRCUMFLEX int ( z '017A' ), int ( z '0179' ), & ! LATIN SMALL LETTER Z WITH ACUTE => LATIN CAPITAL LETTER Z WITH ACUTE int ( z '017C' ), int ( z '017B' ), & ! LATIN SMALL LETTER Z WITH DOT ABOVE => LATIN CAPITAL LETTER Z WITH DOT ABOVE int ( z '017E' ), int ( z '017D' ), & ! LATIN SMALL LETTER Z WITH CARON => LATIN CAPITAL LETTER Z WITH CARON int ( z '0183' ), int ( z '0182' ), & ! LATIN SMALL LETTER B WITH TOPBAR => LATIN CAPITAL LETTER B WITH TOPBAR int ( z '0185' ), int ( z '0184' ), & ! LATIN SMALL LETTER TONE SIX => LATIN CAPITAL LETTER TONE SIX int ( z '0188' ), int ( z '0187' ), & ! LATIN SMALL LETTER C WITH HOOK => LATIN CAPITAL LETTER C WITH HOOK int ( z '018C' ), int ( z '018B' ), & ! LATIN SMALL LETTER D WITH TOPBAR => LATIN CAPITAL LETTER D WITH TOPBAR int ( z '0192' ), int ( z '0191' ), & ! LATIN SMALL LETTER F WITH HOOK => LATIN CAPITAL LETTER F WITH HOOK int ( z '0199' ), int ( z '0198' ), & ! LATIN SMALL LETTER K WITH HOOK => LATIN CAPITAL LETTER K WITH HOOK int ( z '01A1' ), int ( z '01A0' ), & ! LATIN SMALL LETTER O WITH HORN => LATIN CAPITAL LETTER O WITH HORN int ( z '01A3' ), int ( z '01A2' ), & ! LATIN SMALL LETTER OI => LATIN CAPITAL LETTER OI int ( z '01A5' ), int ( z '01A4' ), & ! LATIN SMALL LETTER P WITH HOOK => LATIN CAPITAL LETTER P WITH HOOK int ( z '01A8' ), int ( z '01A7' ), & ! LATIN SMALL LETTER TONE TWO => LATIN CAPITAL LETTER TONE TWO int ( z '01AD' ), int ( z '01AC' ), & ! LATIN SMALL LETTER T WITH HOOK => LATIN CAPITAL LETTER T WITH HOOK int ( z '01B0' ), int ( z '01AF' ), & ! LATIN SMALL LETTER U WITH HORN => LATIN CAPITAL LETTER U WITH HORN int ( z '01B4' ), int ( z '01B3' ), & ! LATIN SMALL LETTER Y WITH HOOK => LATIN CAPITAL LETTER Y WITH HOOK int ( z '01B6' ), int ( z '01B5' ), & ! LATIN SMALL LETTER Z WITH STROKE => LATIN CAPITAL LETTER Z WITH STROKE int ( z '01B9' ), int ( z '01B8' ), & ! LATIN SMALL LETTER EZH REVERSED => LATIN CAPITAL LETTER EZH REVERSED int ( z '01BD' ), int ( z '01BC' ), & ! LATIN SMALL LETTER TONE FIVE => LATIN CAPITAL LETTER TONE FIVE int ( z '01C6' ), int ( z '01C4' ), & ! LATIN SMALL LETTER DZ WITH CARON => LATIN CAPITAL LETTER DZ WITH CARON int ( z '01C9' ), int ( z '01C7' ), & ! LATIN SMALL LETTER LJ => LATIN CAPITAL LETTER LJ int ( z '01CC' ), int ( z '01CA' ), & ! LATIN SMALL LETTER NJ => LATIN CAPITAL LETTER NJ int ( z '01CE' ), int ( z '01CD' ), & ! LATIN SMALL LETTER A WITH CARON => LATIN CAPITAL LETTER A WITH CARON int ( z '01D0' ), int ( z '01CF' ), & ! LATIN SMALL LETTER I WITH CARON => LATIN CAPITAL LETTER I WITH CARON int ( z '01D2' ), int ( z '01D1' ), & ! LATIN SMALL LETTER O WITH CARON => LATIN CAPITAL LETTER O WITH CARON int ( z '01D4' ), int ( z '01D3' ), & ! LATIN SMALL LETTER U WITH CARON => LATIN CAPITAL LETTER U WITH CARON int ( z '01D6' ), int ( z '01D5' ), & ! LATIN SMALL LETTER U WITH DIAERESIS AND MACRON => LATIN CAPITAL LETTER U WITH DIAERESIS AND MACRON int ( z '01D8' ), int ( z '01D7' ), & ! LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE => LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE int ( z '01DA' ), int ( z '01D9' ), & ! LATIN SMALL LETTER U WITH DIAERESIS AND CARON => LATIN CAPITAL LETTER U WITH DIAERESIS AND CARON int ( z '01DC' ), int ( z '01DB' ), & ! LATIN SMALL LETTER U WITH DIAERESIS AND GRAVE => LATIN CAPITAL LETTER U WITH DIAERESIS AND GRAVE int ( z '01DF' ), int ( z '01DE' ), & ! LATIN SMALL LETTER A WITH DIAERESIS AND MACRON => LATIN CAPITAL LETTER A WITH DIAERESIS AND MACRON int ( z '01E1' ), int ( z '01E0' ), & ! LATIN SMALL LETTER A WITH DOT ABOVE AND MACRON => LATIN CAPITAL LETTER A WITH DOT ABOVE AND MACRON int ( z '01E3' ), int ( z '01E2' ), & ! LATIN SMALL LIGATURE AE WITH MACRON => LATIN CAPITAL LIGATURE AE MTH MACRON int ( z '01E5' ), int ( z '01E4' ), & ! LATIN SMALL LETTER G WITH STROKE => LATIN CAPITAL LETTER G WITH STROKE int ( z '01E7' ), int ( z '01E6' ), & ! LATIN SMALL LETTER G WITH CARON => LATIN CAPITAL LETTER G WITH CARON int ( z '01E9' ), int ( z '01E8' ), & ! LATIN SMALL LETTER K WITH CARON => LATIN CAPITAL LETTER K WITH CARON int ( z '01EB' ), int ( z '01EA' ), & ! LATIN SMALL LETTER O WITH OGONEK => LATIN CAPITAL LETTER O WITH OGONEK int ( z '01ED' ), int ( z '01EC' ), & ! LATIN SMALL LETTER O WITH OGONEK AND MACRON => LATIN CAPITAL LETTER O WITH OGONEK AND MACRON int ( z '01EF' ), int ( z '01EE' ), & ! LATIN SMALL LETTER EZH WITH CARON => LATIN CAPITAL LETTER EZH WITH CARON int ( z '01F3' ), int ( z '01F1' ), & ! LATIN SMALL LETTER DZ => LATIN CAPITAL LETTER DZ int ( z '01F5' ), int ( z '01F4' ), & ! LATIN SMALL LETTER G WITH ACUTE => LATIN CAPITAL LETTER G WITH ACUTE int ( z '01FB' ), int ( z '01FA' ), & ! LATIN SMALL LETTER A WITH RING ABOVE AND ACUTE => LATIN CAPITAL LETTER A WITH RING ABOVE AND ACUTE int ( z '01FD' ), int ( z '01FC' ), & ! LATIN SMALL LIGATURE AE WITH ACUTE => LATIN CAPITAL LIGATURE AE WITH ACUTE int ( z '01FF' ), int ( z '01FE' ), & ! LATIN SMALL LETTER O WITH STROKE AND ACUTE => LATIN CAPITAL LETTER O WITH STROKE AND ACUTE int ( z '0201' ), int ( z '0200' ), & ! LATIN SMALL LETTER A WITH DOUBLE GRAVE => LATIN CAPITAL LETTER A WITH DOUBLE GRAVE int ( z '0203' ), int ( z '0202' ), & ! LATIN SMALL LETTER A WITH INVERTED BREVE => LATIN CAPITAL LETTER A WITH INVERTED BREVE int ( z '0205' ), int ( z '0204' ), & ! LATIN SMALL LETTER E WITH DOUBLE GRAVE => LATIN CAPITAL LETTER E WITH DOUBLE GRAVE int ( z '0207' ), int ( z '0206' ), & ! LATIN SMALL LETTER E WITH INVERTED BREVE => LATIN CAPITAL LETTER E WITH INVERTED BREVE int ( z '0209' ), int ( z '0208' ), & ! LATIN SMALL LETTER I WITH DOUBLE GRAVE => LATIN CAPITAL LETTER I WITH DOUBLE GRAVE int ( z '020B' ), int ( z '020A' ), & ! LATIN SMALL LETTER I WITH INVERTED BREVE => LATIN CAPITAL LETTER I WITH INVERTED BREVE int ( z '020D' ), int ( z '020C' ), & ! LATIN SMALL LETTER O WITH DOUBLE GRAVE => LATIN CAPITAL LETTER O WITH DOUBLE GRAVE int ( z '020F' ), int ( z '020E' ), & ! LATIN SMALL LETTER O WITH INVERTED BREVE => LATIN CAPITAL LETTER O WITH INVERTED BREVE int ( z '0211' ), int ( z '0210' ), & ! LATIN SMALL LETTER R WITH DOUBLE GRAVE => LATIN CAPITAL LETTER R WITH DOUBLE GRAVE int ( z '0213' ), int ( z '0212' ), & ! LATIN SMALL LETTER R WITH INVERTED BREVE => LATIN CAPITAL LETTER R WITH INVERTED BREVE int ( z '0215' ), int ( z '0214' ), & ! LATIN SMALL LETTER U WITH DOUBLE GRAVE => LATIN CAPITAL LETTER U WITH DOUBLE GRAVE int ( z '0217' ), int ( z '0216' ), & ! LATIN SMALL LETTER U WITH INVERTED BREVE => LATIN CAPITAL LETTER U WITH INVERTED BREVE int ( z '0253' ), int ( z '0181' ), & ! LATIN SMALL LETTER B WITH HOOK => LATIN CAPITAL LETTER B WITH HOOK int ( z '0254' ), int ( z '0186' ), & ! LATIN SMALL LETTER OPEN O => LATIN CAPITAL LETTER OPEN O int ( z '0257' ), int ( z '018A' ), & ! LATIN SMALL LETTER D WITH HOOK => LATIN CAPITAL LETTER D WITH HOOK int ( z '0258' ), int ( z '018E' ), & ! LATIN SMALL LETTER REVERSED E => LATIN CAPITAL LETTER REVERSED E int ( z '0259' ), int ( z '018F' ), & ! LATIN SMALL LETTER SCHWA => LATIN CAPITAL LETTER SCHWA int ( z '025B' ), int ( z '0190' ), & ! LATIN SMALL LETTER OPEN E => LATIN CAPITAL LETTER OPEN E int ( z '0260' ), int ( z '0193' ), & ! LATIN SMALL LETTER G WITH HOOK => LATIN CAPITAL LETTER G WITH HOOK int ( z '0263' ), int ( z '0194' ), & ! LATIN SMALL LETTER GAMMA => LATIN CAPITAL LETTER GAMMA int ( z '0268' ), int ( z '0197' ), & ! LATIN SMALL LETTER I WITH STROKE => LATIN CAPITAL LETTER I WITH STROKE int ( z '0269' ), int ( z '0196' ), & ! LATIN SMALL LETTER IOTA => LATIN CAPITAL LETTER IOTA int ( z '026F' ), int ( z '019C' ), & ! LATIN SMALL LETTER TURNED M => LATIN CAPITAL LETTER TURNED M int ( z '0272' ), int ( z '019D' ), & ! LATIN SMALL LETTER N WITH LEFT HOOK => LATIN CAPITAL LETTER N WITH LEFT HOOK int ( z '0275' ), int ( z '019F' ), & ! LATIN SMALL LETTER BARRED O => LATIN CAPITAL LETTER O WITH MIDDLE TILDE int ( z '0283' ), int ( z '01A9' ), & ! LATIN SMALL LETTER ESH => LATIN CAPITAL LETTER ESH int ( z '0288' ), int ( z '01AE' ), & ! LATIN SMALL LETTER T WITH RETROFLEX HOOK => LATIN CAPITAL LETTER T WITH RETROFLEX HOOK int ( z '028A' ), int ( z '01B1' ), & ! LATIN SMALL LETTER UPSILON => LATIN CAPITAL LETTER UPSILON int ( z '028B' ), int ( z '01B2' ), & ! LATIN SMALL LETTER V WITH HOOK => LATIN CAPITAL LETTER V WITH HOOK int ( z '0292' ), int ( z '01B7' ), & ! LATIN SMALL LETTER EZH => LATIN CAPITAL LETTER EZH int ( z '03AC' ), int ( z '0386' ), & ! GREEK SMALL LETTER ALPHA WITH TONOS => GREEK CAPITAL LETTER ALPHA WITH TONOS int ( z '03AD' ), int ( z '0388' ), & ! GREEK SMALL LETTER EPSILON WITH TONOS => GREEK CAPITAL LETTER EPSILON WITH TONOS int ( z '03AE' ), int ( z '0389' ), & ! GREEK SMALL LETTER ETA WITH TONOS => GREEK CAPITAL LETTER ETA WITH TONOS int ( z '03AF' ), int ( z '038A' ), & ! GREEK SMALL LETTER IOTA WITH TONOS => GREEK CAPITAL LETTER IOTA WITH TONOS int ( z '03B1' ), int ( z '0391' ), & ! GREEK SMALL LETTER ALPHA => GREEK CAPITAL LETTER ALPHA int ( z '03B2' ), int ( z '0392' ), & ! GREEK SMALL LETTER BETA => GREEK CAPITAL LETTER BETA int ( z '03B3' ), int ( z '0393' ), & ! GREEK SMALL LETTER GAMMA => GREEK CAPITAL LETTER GAMMA int ( z '03B4' ), int ( z '0394' ), & ! GREEK SMALL LETTER DELTA => GREEK CAPITAL LETTER DELTA int ( z '03B5' ), int ( z '0395' ), & ! GREEK SMALL LETTER EPSILON => GREEK CAPITAL LETTER EPSILON int ( z '03B6' ), int ( z '0396' ), & ! GREEK SMALL LETTER ZETA => GREEK CAPITAL LETTER ZETA int ( z '03B7' ), int ( z '0397' ), & ! GREEK SMALL LETTER ETA => GREEK CAPITAL LETTER ETA int ( z '03B8' ), int ( z '0398' ), & ! GREEK SMALL LETTER THETA => GREEK CAPITAL LETTER THETA int ( z '03B9' ), int ( z '0399' ), & ! GREEK SMALL LETTER IOTA => GREEK CAPITAL LETTER IOTA int ( z '03BA' ), int ( z '039A' ), & ! GREEK SMALL LETTER KAPPA => GREEK CAPITAL LETTER KAPPA int ( z '03BB' ), int ( z '039B' ), & ! GREEK SMALL LETTER LAMDA => GREEK CAPITAL LETTER LAMDA int ( z '03BC' ), int ( z '039C' ), & ! GREEK SMALL LETTER MU => GREEK CAPITAL LETTER MU int ( z '03BD' ), int ( z '039D' ), & ! GREEK SMALL LETTER NU => GREEK CAPITAL LETTER NU int ( z '03BE' ), int ( z '039E' ), & ! GREEK SMALL LETTER XI => GREEK CAPITAL LETTER XI int ( z '03BF' ), int ( z '039F' ), & ! GREEK SMALL LETTER OMICRON => GREEK CAPITAL LETTER OMICRON int ( z '03C0' ), int ( z '03A0' ), & ! GREEK SMALL LETTER PI => GREEK CAPITAL LETTER PI int ( z '03C1' ), int ( z '03A1' ), & ! GREEK SMALL LETTER RHO => GREEK CAPITAL LETTER RHO int ( z '03C3' ), int ( z '03A3' ), & ! GREEK SMALL LETTER SIGMA => GREEK CAPITAL LETTER SIGMA int ( z '03C4' ), int ( z '03A4' ), & ! GREEK SMALL LETTER TAU => GREEK CAPITAL LETTER TAU int ( z '03C5' ), int ( z '03A5' ), & ! GREEK SMALL LETTER UPSILON => GREEK CAPITAL LETTER UPSILON int ( z '03C6' ), int ( z '03A6' ), & ! GREEK SMALL LETTER PHI => GREEK CAPITAL LETTER PHI int ( z '03C7' ), int ( z '03A7' ), & ! GREEK SMALL LETTER CHI => GREEK CAPITAL LETTER CHI int ( z '03C8' ), int ( z '03A8' ), & ! GREEK SMALL LETTER PSI => GREEK CAPITAL LETTER PSI int ( z '03C9' ), int ( z '03A9' ), & ! GREEK SMALL LETTER OMEGA => GREEK CAPITAL LETTER OMEGA int ( z '03CA' ), int ( z '03AA' ), & ! GREEK SMALL LETTER IOTA WITH DIALYTIKA => GREEK CAPITAL LETTER IOTA WITH DIALYTIKA int ( z '03CB' ), int ( z '03AB' ), & ! GREEK SMALL LETTER UPSILON WITH DIALYTIKA => GREEK CAPITAL LETTER UPSILON WITH DIALYTIKA int ( z '03CC' ), int ( z '038C' ), & ! GREEK SMALL LETTER OMICRON WITH TONOS => GREEK CAPITAL LETTER OMICRON WITH TONOS int ( z '03CD' ), int ( z '038E' ), & ! GREEK SMALL LETTER UPSILON WITH TONOS => GREEK CAPITAL LETTER UPSILON WITH TONOS int ( z '03CE' ), int ( z '038F' ), & ! GREEK SMALL LETTER OMEGA WITH TONOS => GREEK CAPITAL LETTER OMEGA WITH TONOS int ( z '03E3' ), int ( z '03E2' ), & ! COPTIC SMALL LETTER SHEI => COPTIC CAPITAL LETTER SHEI int ( z '03E5' ), int ( z '03E4' ), & ! COPTIC SMALL LETTER FEI => COPTIC CAPITAL LETTER FEI int ( z '03E7' ), int ( z '03E6' ), & ! COPTIC SMALL LETTER KHEI => COPTIC CAPITAL LETTER KHEI int ( z '03E9' ), int ( z '03E8' ), & ! COPTIC SMALL LETTER HORI => COPTIC CAPITAL LETTER HORI int ( z '03EB' ), int ( z '03EA' ), & ! COPTIC SMALL LETTER GANGIA => COPTIC CAPITAL LETTER GANGIA int ( z '03ED' ), int ( z '03EC' ), & ! COPTIC SMALL LETTER SHIMA => COPTIC CAPITAL LETTER SHIMA int ( z '03EF' ), int ( z '03EE' ), & ! COPTIC SMALL LETTER DEI => COPTIC CAPITAL LETTER DEI int ( z '0430' ), int ( z '0410' ), & ! CYRILLIC SMALL LETTER A => CYRILLIC CAPITAL LETTER A int ( z '0431' ), int ( z '0411' ), & ! CYRILLIC SMALL LETTER BE => CYRILLIC CAPITAL LETTER BE int ( z '0432' ), int ( z '0412' ), & ! CYRILLIC SMALL LETTER VE => CYRILLIC CAPITAL LETTER VE int ( z '0433' ), int ( z '0413' ), & ! CYRILLIC SMALL LETTER GHE => CYRILLIC CAPITAL LETTER GHE int ( z '0434' ), int ( z '0414' ), & ! CYRILLIC SMALL LETTER DE => CYRILLIC CAPITAL LETTER DE int ( z '0435' ), int ( z '0415' ), & ! CYRILLIC SMALL LETTER IE => CYRILLIC CAPITAL LETTER IE int ( z '0436' ), int ( z '0416' ), & ! CYRILLIC SMALL LETTER ZHE => CYRILLIC CAPITAL LETTER ZHE int ( z '0437' ), int ( z '0417' ), & ! CYRILLIC SMALL LETTER ZE => CYRILLIC CAPITAL LETTER ZE int ( z '0438' ), int ( z '0418' ), & ! CYRILLIC SMALL LETTER I => CYRILLIC CAPITAL LETTER I int ( z '0439' ), int ( z '0419' ), & ! CYRILLIC SMALL LETTER SHORT I => CYRILLIC CAPITAL LETTER SHORT I int ( z '043A' ), int ( z '041A' ), & ! CYRILLIC SMALL LETTER KA => CYRILLIC CAPITAL LETTER KA int ( z '043B' ), int ( z '041B' ), & ! CYRILLIC SMALL LETTER EL => CYRILLIC CAPITAL LETTER EL int ( z '043C' ), int ( z '041C' ), & ! CYRILLIC SMALL LETTER EM => CYRILLIC CAPITAL LETTER EM int ( z '043D' ), int ( z '041D' ), & ! CYRILLIC SMALL LETTER EN => CYRILLIC CAPITAL LETTER EN int ( z '043E' ), int ( z '041E' ), & ! CYRILLIC SMALL LETTER O => CYRILLIC CAPITAL LETTER O int ( z '043F' ), int ( z '041F' ), & ! CYRILLIC SMALL LETTER PE => CYRILLIC CAPITAL LETTER PE int ( z '0440' ), int ( z '0420' ), & ! CYRILLIC SMALL LETTER ER => CYRILLIC CAPITAL LETTER ER int ( z '0441' ), int ( z '0421' ), & ! CYRILLIC SMALL LETTER ES => CYRILLIC CAPITAL LETTER ES int ( z '0442' ), int ( z '0422' ), & ! CYRILLIC SMALL LETTER TE => CYRILLIC CAPITAL LETTER TE int ( z '0443' ), int ( z '0423' ), & ! CYRILLIC SMALL LETTER U => CYRILLIC CAPITAL LETTER U int ( z '0444' ), int ( z '0424' ), & ! CYRILLIC SMALL LETTER EF => CYRILLIC CAPITAL LETTER EF int ( z '0445' ), int ( z '0425' ), & ! CYRILLIC SMALL LETTER HA => CYRILLIC CAPITAL LETTER HA int ( z '0446' ), int ( z '0426' ), & ! CYRILLIC SMALL LETTER TSE => CYRILLIC CAPITAL LETTER TSE int ( z '0447' ), int ( z '0427' ), & ! CYRILLIC SMALL LETTER CHE => CYRILLIC CAPITAL LETTER CHE int ( z '0448' ), int ( z '0428' ), & ! CYRILLIC SMALL LETTER SHA => CYRILLIC CAPITAL LETTER SHA int ( z '0449' ), int ( z '0429' ), & ! CYRILLIC SMALL LETTER SHCHA => CYRILLIC CAPITAL LETTER SHCHA int ( z '044A' ), int ( z '042A' ), & ! CYRILLIC SMALL LETTER HARD SIGN => CYRILLIC CAPITAL LETTER HARD SIGN int ( z '044B' ), int ( z '042B' ), & ! CYRILLIC SMALL LETTER YERU => CYRILLIC CAPITAL LETTER YERU int ( z '044C' ), int ( z '042C' ), & ! CYRILLIC SMALL LETTER SOFT SIGN => CYRILLIC CAPITAL LETTER SOFT SIGN int ( z '044D' ), int ( z '042D' ), & ! CYRILLIC SMALL LETTER E => CYRILLIC CAPITAL LETTER E int ( z '044E' ), int ( z '042E' ), & ! CYRILLIC SMALL LETTER YU => CYRILLIC CAPITAL LETTER YU int ( z '044F' ), int ( z '042F' ), & ! CYRILLIC SMALL LETTER YA => CYRILLIC CAPITAL LETTER YA int ( z '0451' ), int ( z '0401' ), & ! CYRILLIC SMALL LETTER IO => CYRILLIC CAPITAL LETTER IO int ( z '0452' ), int ( z '0402' ), & ! CYRILLIC SMALL LETTER DJE (SERBOCROATIAN) => CYRILLIC CAPITAL LETTER DJE (SERBOCROATIAN) int ( z '0453' ), int ( z '0403' ), & ! CYRILLIC SMALL LETTER GJE => CYRILLIC CAPITAL LETTER GJE int ( z '0454' ), int ( z '0404' ), & ! CYRILLIC SMALL LETTER UKRAINIAN IE => CYRILLIC CAPITAL LETTER UKRAINIAN IE int ( z '0455' ), int ( z '0405' ), & ! CYRILLIC SMALL LETTER DZE => CYRILLIC CAPITAL LETTER DZE int ( z '0456' ), int ( z '0406' ), & ! CYRILLIC SMALL LETTER BYELORUSSIAN-UKRAINIAN I => CYRILLIC CAPITAL LETTER BYELORUSSIAN_UKRAINIAN I int ( z '0457' ), int ( z '0407' ), & ! CYRILLIC SMALL LETTER YI (UKRAINIAN) => CYRILLIC CAPITAL LETTER YI (UKRAINIAN) int ( z '0458' ), int ( z '0408' ), & ! CYRILLIC SMALL LETTER JE => CYRILLIC CAPITAL LETTER JE int ( z '0459' ), int ( z '0409' ), & ! CYRILLIC SMALL LETTER LJE => CYRILLIC CAPITAL LETTER LJE int ( z '045A' ), int ( z '040A' ), & ! CYRILLIC SMALL LETTER NJE => CYRILLIC CAPITAL LETTER NJE int ( z '045B' ), int ( z '040B' ), & ! CYRILLIC SMALL LETTER TSHE (SERBOCROATIAN) => CYRILLIC CAPITAL LETTER TSHE (SERBOCROATIAN) int ( z '045C' ), int ( z '040C' ), & ! CYRILLIC SMALL LETTER KJE => CYRILLIC CAPITAL LETTER KJE int ( z '045E' ), int ( z '040E' ), & ! CYRILLIC SMALL LETTER SHORT U (BYELORUSSIAN) => CYRILLIC CAPITAL LETTER SHORT U (BYELORUSSIAN) int ( z '045F' ), int ( z '040F' ), & ! CYRILLIC SMALL LETTER DZHE => CYRILLIC CAPITAL LETTER DZHE int ( z '0461' ), int ( z '0460' ), & ! CYRILLIC SMALL LETTER OMEGA => CYRILLIC CAPITAL LETTER OMEGA int ( z '0463' ), int ( z '0462' ), & ! CYRILLIC SMALL LETTER YAT => CYRILLIC CAPITAL LETTER YAT int ( z '0465' ), int ( z '0464' ), & ! CYRILLIC SMALL LETTER IOTIFIED E => CYRILLIC CAPITAL LETTER IOTIFIED E int ( z '0467' ), int ( z '0466' ), & ! CYRILLIC SMALL LETTER LITTLE YUS => CYRILLIC CAPITAL LETTER LITTLE YUS int ( z '0469' ), int ( z '0468' ), & ! CYRILLIC SMALL LETTER IOTIFIED LITTLE YUS => CYRILLIC CAPITAL LETTER IOTIFIED LITTLE YUS int ( z '046B' ), int ( z '046A' ), & ! CYRILLIC SMALL LETTER BIG YUS => CYRILLIC CAPITAL LETTER BIG YUS int ( z '046D' ), int ( z '046C' ), & ! CYRILLIC SMALL LETTER IOTIFIED BIG YUS => CYRILLIC CAPITAL LETTER IOTIFIED BIG YUS int ( z '046F' ), int ( z '046E' ), & ! CYRILLIC SMALL LETTER KSI => CYRILLIC CAPITAL LETTER KSI int ( z '0471' ), int ( z '0470' ), & ! CYRILLIC SMALL LETTER PSI => CYRILLIC CAPITAL LETTER PSI int ( z '0473' ), int ( z '0472' ), & ! CYRILLIC SMALL LETTER FITA => CYRILLIC CAPITAL LETTER FITA int ( z '0475' ), int ( z '0474' ), & ! CYRILLIC SMALL LETTER IZHITSA => CYRILLIC CAPITAL LETTER IZHITSA int ( z '0477' ), int ( z '0476' ), & ! CYRILLIC SMALL LETTER IZHITSA WITH DOUBLE GRAVE ACCENT => CYRILLIC CAPITAL LETTER IZHITSA WITH DOUBLE GRAVE ACCENT int ( z '0479' ), int ( z '0478' ), & ! CYRILLIC SMALL LETTER UK => CYRILLIC CAPITAL LETTER UK int ( z '047B' ), int ( z '047A' ), & ! CYRILLIC SMALL LETTER ROUND OMEGA => CYRILLIC CAPITAL LETTER ROUND OMEGA int ( z '047D' ), int ( z '047C' ), & ! CYRILLIC SMALL LETTER OMEGA WITH TITLO => CYRILLIC CAPITAL LETTER OMEGA WITH TITLO int ( z '047F' ), int ( z '047E' ), & ! CYRILLIC SMALL LETTER OT => CYRILLIC CAPITAL LETTER OT int ( z '0481' ), int ( z '0480' ), & ! CYRILLIC SMALL LETTER KOPPA => CYRILLIC CAPITAL LETTER KOPPA int ( z '0491' ), int ( z '0490' ), & ! CYRILLIC SMALL LETTER GHE WITH UPTURN => CYRILLIC CAPITAL LETTER GHE WITH UPTURN int ( z '0493' ), int ( z '0492' ), & ! CYRILLIC SMALL LETTER GHE WITH STROKE => CYRILLIC CAPITAL LETTER GHE WITH STROKE int ( z '0495' ), int ( z '0494' ), & ! CYRILLIC SMALL LETTER GHE WITH MIDDLE HOOK => CYRILLIC CAPITAL LETTER GHE WITH MIDDLE HOOK int ( z '0497' ), int ( z '0496' ), & ! CYRILLIC SMALL LETTER ZHE WITH DESCENDER => CYRILLIC CAPITAL LETTER ZHE WITH DESCENDER int ( z '0499' ), int ( z '0498' ), & ! CYRILLIC SMALL LETTER ZE WITH DESCENDER => CYRILLIC CAPITAL LETTER ZE WITH DESCENDER int ( z '049B' ), int ( z '049A' ), & ! CYRILLIC SMALL LETTER KA WITH DESCENDER => CYRILLIC CAPITAL LETTER KA WITH DESCENDER int ( z '049D' ), int ( z '049C' ), & ! CYRILLIC SMALL LETTER KA WITH VERTICAL STROKE => CYRILLIC CAPITAL LETTER KA WITH VERTICAL STROKE int ( z '049F' ), int ( z '049E' ), & ! CYRILLIC SMALL LETTER KA WITH STROKE => CYRILLIC CAPITAL LETTER KA WITH STROKE int ( z '04A1' ), int ( z '04A0' ), & ! CYRILLIC SMALL LETTER EASHKIR KA => CYRILLIC CAPITAL LETTER BASHKIR KA int ( z '04A3' ), int ( z '04A2' ), & ! CYRILLIC SMALL LETTER EN WITH DESCENOER => CYRILLIC CAPITAL LETTER EN WITH DESCENDER int ( z '04A5' ), int ( z '04A4' ), & ! CYRILLIC SMALL LIGATURE EN GHE => CYRILLIC CAPITAL LIGATURE EN GHF int ( z '04A7' ), int ( z '04A6' ), & ! CYRILLIC SMALL LETTER PE WITH MIDDLE HOOK (ABKHASIAN) => CYRILLIC CAPITAL LETTER PE WITH MIDDLE HOOK (ABKHASIAN) int ( z '04A9' ), int ( z '04A8' ), & ! CYRILLIC SMALL LETTER ABKHASIAN HA => CYRILLIC CAPITAL LETTER ABKHASIAN HA int ( z '04AB' ), int ( z '04AA' ), & ! CYRILLIC SMALL LETTER ES WITH DESCENDER => CYRILLIC CAPITAL LETTER ES WITH DESCENDER int ( z '04AD' ), int ( z '04AC' ), & ! CYRILLIC SMALL LETTER TE WITH DESCENDER => CYRILLIC CAPITAL LETTER TE WITH DESCENDER int ( z '04AF' ), int ( z '04AE' ), & ! CYRILLIC SMALL LETTER STRAIGHT U => CYRILLIC CAPITAL LETTER STRAIGHT U int ( z '04B1' ), int ( z '04B0' ), & ! CYRILLIC SMALL LETTER STRAIGHT U WITH STROKE => CYRILLIC CAPITAL LETTER STRAIGHT U WITH STROKE int ( z '04B3' ), int ( z '04B2' ), & ! CYRILLIC SMALL LETTER HA WITH DESCENDER => CYRILLIC CAPITAL LETTER HA WITH DESCENDER int ( z '04B5' ), int ( z '04B4' ), & ! CYRILLIC SMALL LIGATURE TE TSE (ABKHASIAN) => CYRILLIC CAPITAL LIGATURE TE TSE (ABKHASIAN) int ( z '04B7' ), int ( z '04B6' ), & ! CYRILLIC SMALL LETTER CHE WITH DESCENDER => CYRILLIC CAPITAL LETTER CHE WITH DESCENDER int ( z '04B9' ), int ( z '04B8' ), & ! CYRILLIC SMALL LETTER CHE WITH VERTICAL STROKE => CYRILLIC CAPITAL LETTER CHE WITH VERTICAL STROKE int ( z '04BB' ), int ( z '04BA' ), & ! CYRILLIC SMALL LETTER SHHA => CYRILLIC CAPITAL LETTER SHHA int ( z '04BD' ), int ( z '04BC' ), & ! CYRILLIC SMALL LETTER ABKHASIAN CHE => CYRILLIC CAPITAL LETTER ABKHASIAN CHE int ( z '04BF' ), int ( z '04BE' ), & ! CYRILLIC SMALL LETTER ABKHASIAN CHE WITH DESCENDER => CYRILLIC CAPITAL LETTER ABKHASIAN CHE WITH DESCENDER int ( z '04C2' ), int ( z '04C1' ), & ! CYRILLIC SMALL LETTER ZHE WITH BREVE => CYRILLIC CAPITAL LETTER ZHE WITH BREVE int ( z '04C4' ), int ( z '04C3' ), & ! CYRILLIC SMALL LETTER KA WITH HOOK => CYRILLIC CAPITAL LETTER KA WITH HOOK int ( z '04C8' ), int ( z '04C7' ), & ! CYRILLIC SMALL LETTER EN WITH HOOK => CYRILLIC CAPITAL LETTER EN WITH HOOK int ( z '04CC' ), int ( z '04CB' ), & ! CYRILLIC SMALL LETTER KHAKASSIAN CHE => CYRILLIC CAPITAL LETTER KHAKASSIAN CHE int ( z '04D1' ), int ( z '04D0' ), & ! CYRILLIC SMALL LETTER A WITH BREVE => CYRILLIC CAPITAL LETTER A WITH BREVE int ( z '04D3' ), int ( z '04D2' ), & ! CYRILLIC SMALL LETTER A WITH DIAERESIS => CYRILLIC CAPITAL LETTER A WITH DIAERESIS int ( z '04D5' ), int ( z '04D4' ), & ! CYRILLIC SMALL LIGATURE A IE => CYRILLIC CAPITAL LIGATURE A IE int ( z '04D7' ), int ( z '04D6' ), & ! CYRILLIC SMALL LETTER IE WITH BREVE => CYRILLIC CAPITAL LETTER IE WITH BREVE int ( z '04D9' ), int ( z '04D8' ), & ! CYRILLIC SMALL LETTER SCHWA => CYRILLIC CAPITAL LETTER SCHWA int ( z '04DB' ), int ( z '04DA' ), & ! CYRILLIC SMALL LETTER SCHWA WITH DIAERESIS => CYRILLIC CAPITAL LETTER SCHWA WITH DIAERESIS int ( z '04DD' ), int ( z '04DC' ), & ! CYRILLIC SMALL LETTER ZHE WITH DIAERESIS => CYRILLIC CAPITAL LETTER ZHE WITH DIAERESIS int ( z '04DF' ), int ( z '04DE' ), & ! CYRILLIC SMALL LETTER ZE WITH DIAERESIS => CYRILLIC CAPITAL LETTER ZE WITH DIAERESIS int ( z '04E1' ), int ( z '04E0' ), & ! CYRILLIC SMALL LETTER ABKHASIAN DZE => CYRILLIC CAPITAL LETTER ABKHASIAN DZE int ( z '04E3' ), int ( z '04E2' ), & ! CYRILLIC SMALL LETTER I WITH MACRON => CYRILLIC CAPITAL LETTER I WITH MACRON int ( z '04E5' ), int ( z '04E4' ), & ! CYRILLIC SMALL LETTER I WITH DIAERESIS => CYRILLIC CAPITAL LETTER I WITH DIAERESIS int ( z '04E7' ), int ( z '04E6' ), & ! CYRILLIC SMALL LETTER O WITH DIAERESIS => CYRILLIC CAPITAL LETTER O WITH DIAERESIS int ( z '04E9' ), int ( z '04E8' ), & ! CYRILLIC SMALL LETTER BARRED O => CYRILLIC CAPITAL LETTER BARRED O int ( z '04EB' ), int ( z '04EA' ), & ! CYRILLIC SMALL LETTER BARRED O WITH DIAERESIS => CYRILLIC CAPITAL LETTER BARRED O WITH DIAERESIS int ( z '04EF' ), int ( z '04EE' ), & ! CYRILLIC SMALL LETTER U WITH MACRON => CYRILLIC CAPITAL LETTER U WITH MACRON int ( z '04F1' ), int ( z '04F0' ), & ! CYRILLIC SMALL LETTER U WITH DIAERESIS => CYRILLIC CAPITAL LETTER U WITH DIAERESIS int ( z '04F3' ), int ( z '04F2' ), & ! CYRILLIC SMALL LETTER U WITH DOUBLE ACUTE => CYRILLIC CAPITAL LETTER U WITH DOUBLE ACUTE int ( z '04F5' ), int ( z '04F4' ), & ! CYRILLIC SMALL LETTER CHE AITH DIAERESIS => CYRILLIC CAPITAL LETTER CHE WITH DIAERESIS int ( z '04F9' ), int ( z '04F8' ), & ! CYRILLIC SMALL LETTER YERU WITH DIAERESIS => CYRILLIC CAPITAL LETTER YERU WITH DIAERESIS int ( z '0561' ), int ( z '0531' ), & ! ARMENIAN SMALL LETTER AYB => ARMENIAN CAPITAL LETTER AYB int ( z '0562' ), int ( z '0532' ), & ! ARMENIAN SMALL LETTER BEN => ARMENIAN CAPITAL LETTER BEN int ( z '0563' ), int ( z '0533' ), & ! ARMENIAN SMALL LETTER GIM => ARMENIAN CAPITAL LETTER GIM int ( z '0564' ), int ( z '0534' ), & ! ARMENIAN SMALL LETTER DA => ARMENIAN CAPITAL LETTER DA int ( z '0565' ), int ( z '0535' ), & ! ARMENIAN SMALL LETTER ECH => ARMENIAN CAPITAL LETTER ECH int ( z '0566' ), int ( z '0536' ), & ! ARMENIAN SMALL LETTER ZA => ARMENIAN CAPITAL LETTER ZA int ( z '0567' ), int ( z '0537' ), & ! ARMENIAN SMALL LETTER EH => ARMENIAN CAPITAL LETTER EH int ( z '0568' ), int ( z '0538' ), & ! ARMENIAN SMALL LETTER ET => ARMENIAN CAPITAL LETTER ET int ( z '0569' ), int ( z '0539' ), & ! ARMENIAN SMALL LETTER TO => ARMENIAN CAPITAL LETTER TO int ( z '056A' ), int ( z '053A' ), & ! ARMENIAN SMALL LETTER ZHE => ARMENIAN CAPITAL LETTER ZHE int ( z '056B' ), int ( z '053B' ), & ! ARMENIAN SMALL LETTER INI => ARMENIAN CAPITAL LETTER INI int ( z '056C' ), int ( z '053C' ), & ! ARMENIAN SMALL LETTER LIWN => ARMENIAN CAPITAL LETTER LIWN int ( z '056D' ), int ( z '053D' ), & ! ARMENIAN SMALL LETTER XEH => ARMENIAN CAPITAL LETTER XEH int ( z '056E' ), int ( z '053E' ), & ! ARMENIAN SMALL LETTER CA => ARMENIAN CAPITAL LETTER CA int ( z '056F' ), int ( z '053F' ), & ! ARMENIAN SMALL LETTER KEN => ARMENIAN CAPITAL LETTER KEN int ( z '0570' ), int ( z '0540' ), & ! ARMENIAN SMALL LETTER HO => ARMENIAN CAPITAL LETTER HO int ( z '0571' ), int ( z '0541' ), & ! ARMENIAN SMALL LETTER JA => ARMENIAN CAPITAL LETTER JA int ( z '0572' ), int ( z '0542' ), & ! ARMENIAN SMALL LETTER GHAD => ARMENIAN CAPITAL LETTER GHAD int ( z '0573' ), int ( z '0543' ), & ! ARMENIAN SMALL LETTER CHEH => ARMENIAN CAPITAL LETTER CHEH int ( z '0574' ), int ( z '0544' ), & ! ARMENIAN SMALL LETTER MEN => ARMENIAN CAPITAL LETTER MEN int ( z '0575' ), int ( z '0545' ), & ! ARMENIAN SMALL LETTER YI => ARMENIAN CAPITAL LETTER YI int ( z '0576' ), int ( z '0546' ), & ! ARMENIAN SMALL LETTER NOW => ARMENIAN CAPITAL LETTER NOW int ( z '0577' ), int ( z '0547' ), & ! ARMENIAN SMALL LETTER SNA => ARMENIAN CAPITAL LETTER SHA int ( z '0578' ), int ( z '0548' ), & ! ARMENIAN SMALL LETTER VO => ARMENIAN CAPITAL LETTER VO int ( z '0579' ), int ( z '0549' ), & ! ARMENIAN SMALL LETTER CHA => ARMENIAN CAPITAL LETTER CHA int ( z '057A' ), int ( z '054A' ), & ! ARMENIAN SMALL LETTER PEH => ARMENIAN CAPITAL LETTER PEH int ( z '057B' ), int ( z '054B' ), & ! ARMENIAN SMALL LETTER JHEH => ARMENIAN CAPITAL LETTER JHEH int ( z '057C' ), int ( z '054C' ), & ! ARMENIAN SMALL LETTER RA => ARMENIAN CAPITAL LETTER RA int ( z '057D' ), int ( z '054D' ), & ! ARMENIAN SMALL LETTER SEH => ARMENIAN CAPITAL LETTER SEH int ( z '057E' ), int ( z '054E' ), & ! ARMENIAN SMALL LETTER VEW => ARMENIAN CAPITAL LETTER VEW int ( z '057F' ), int ( z '054F' ), & ! ARMENIAN SMALL LETTER TIWN => ARMENIAN CAPITAL LETTER TIWN int ( z '0580' ), int ( z '0550' ), & ! ARMENIAN SMALL LETTER REH => ARMENIAN CAPITAL LETTER REH int ( z '0581' ), int ( z '0551' ), & ! ARMENIAN SMALL LETTER CO => ARMENIAN CAPITAL LETTER CO int ( z '0582' ), int ( z '0552' ), & ! ARMENIAN SMALL LETTER YIWN => ARMENIAN CAPITAL LETTER YIWN int ( z '0583' ), int ( z '0553' ), & ! ARMENIAN SMALL LETTER PIWP => ARMENIAN CAPITAL LETTER PIWR int ( z '0584' ), int ( z '0554' ), & ! ARMENIAN SMALL LETTER KEH => ARMENIAN CAPITAL LETTER KEH int ( z '0585' ), int ( z '0555' ), & ! ARMENIAN SMALL LETTER OH => ARMENIAN CAPITAL LETTER OH int ( z '0586' ), int ( z '0556' ), & ! ARMENIAN SMALL LETTER FEH => ARMENIAN CAPITAL LETTER FEH int ( z '10D0' ), int ( z '10A0' ), & ! GEORGIAN LETTER AN => GEORGIAN CAPITAL LETTER AN (KHUTSURI) int ( z '10D1' ), int ( z '10A1' ), & ! GEORGIAN LETTER BAN => GEORGIAN CAPITAL LETTER BAN (KHUTSURI) int ( z '10D2' ), int ( z '10A2' ), & ! GEORGIAN LETTER GAN => GEORGIAN CAPITAL LETTER GAN (KHUTSURI) int ( z '10D3' ), int ( z '10A3' ), & ! GEORGIAN LETTER DON => GEORGIAN CAPITAL LETTER DON (KHUTSURI) int ( z '10D4' ), int ( z '10A4' ), & ! GEORGIAN LETTER EN => GEORGIAN CAPITAL LETTER EN (KHUTSURI) int ( z '10D5' ), int ( z '10A5' ), & ! GEORGIAN LETTER VIN => GEORGIAN CAPITAL LETTER VIN (KHUTSURI) int ( z '10D6' ), int ( z '10A6' ), & ! GEORGIAN LETTER ZEN => GEORGIAN CAPITAL LETTER ZEN (KHUTSURI) int ( z '10D7' ), int ( z '10A7' ), & ! GEORGIAN LETTER TAN => GEORGIAN CAPITAL LETTER TAN (KHUTSURI) int ( z '10D8' ), int ( z '10A8' ), & ! GEORGIAN LETTER IN => GEORGIAN CAPITAL LETTER IN (KHUTSURI) int ( z '10D9' ), int ( z '10A9' ), & ! GEORGIAN LETTER KAN => GEORGIAN CAPITAL LETTER KAN (KHUTSURI) int ( z '10DA' ), int ( z '10AA' ), & ! GEORGIAN LETTER LAS => GEORGIAN CAPITAL LETTER LAS (KHUTSURI) int ( z '10DB' ), int ( z '10AB' ), & ! GEORGIAN LETTER MAN => GEORGIAN CAPITAL LETTER MAN (KHUTSURI) int ( z '10DC' ), int ( z '10AC' ), & ! GEORGIAN LETTER NAR => GEORGIAN CAPITAL LETTER NAR (KHUTSURI) int ( z '10DD' ), int ( z '10AD' ), & ! GEORGIAN LETTER ON => GEORGIAN CAPITAL LETTER ON (KHUTSURI) int ( z '10DE' ), int ( z '10AE' ), & ! GEORGIAN LETTER PAR => GEORGIAN CAPITAL LETTER PAR (KHUTSURI) int ( z '10DF' ), int ( z '10AF' ), & ! GEORGIAN LETTER ZHAR => GEORGIAN CAPITAL LETTER ZHAR (KHUTSURI) int ( z '10E0' ), int ( z '10B0' ), & ! GEORGIAN LETTER RAE => GEORGIAN CAPITAL LETTER RAE (KHUTSURI) int ( z '10E1' ), int ( z '10B1' ), & ! GEORGIAN LETTER SAN => GEORGIAN CAPITAL LETTER SAN (KHUTSURI) int ( z '10E2' ), int ( z '10B2' ), & ! GEORGIAN LETTER TAR => GEORGIAN CAPITAL LETTER TAR (KHUTSURI) int ( z '10E3' ), int ( z '10B3' ), & ! GEORGIAN LETTER UN => GEORGIAN CAPITAL LETTER UN (KHUTSURI) int ( z '10E4' ), int ( z '10B4' ), & ! GEORGIAN LETTER PHAR => GEORGIAN CAPITAL LETTER PHAR (KHUTSURI) int ( z '10E5' ), int ( z '10B5' ), & ! GEORGIAN LETTER KHAR => GEORGIAN CAPITAL LETTER KHAR (KHUTSURI) int ( z '10E6' ), int ( z '10B6' ), & ! GEORGIAN LETTER GHAN => GEORGIAN CAPITAL LETTER GHAN (KHUTSURI) int ( z '10E7' ), int ( z '10B7' ), & ! GEORGIAN LETTER QAR => GEORGIAN CAPITAL LETTER QAR (KHUTSURI) int ( z '10E8' ), int ( z '10B8' ), & ! GEORGIAN LETTER SHIN => GEORGIAN CAPITAL LETTER SHIN (KHUTSURI) int ( z '10E9' ), int ( z '10B9' ), & ! GEORGIAN LETTER CHIN => GEORGIAN CAPITAL LETTER CHIN (KHUTSURI) int ( z '10EA' ), int ( z '10BA' ), & ! GEORGIAN LETTER CAN => GEORGIAN CAPITAL LETTER CAN (KHUTSURI) int ( z '10EB' ), int ( z '10BB' ), & ! GEORGIAN LETTER JIL => GEORGIAN CAPITAL LETTER JIL (KHUTSURI) int ( z '10EC' ), int ( z '10BC' ), & ! GEORGIAN LETTER CIL => GEORGIAN CAPITAL LETTER CIL (KHUTSURI) int ( z '10ED' ), int ( z '10BD' ), & ! GEORGIAN LETTER CHAR => GEORGIAN CAPITAL LETTER CHAR (KHUTSURI) int ( z '10EE' ), int ( z '10BE' ), & ! GEORGIAN LETTER XAN => GEORGIAN CAPITAL LETTER XAN (KHUTSURI) int ( z '10EF' ), int ( z '10BF' ), & ! GEORGIAN LETTER JHAN => GEORGIAN CAPITAL LETTER JHAN (KHUTSURI) int ( z '10F0' ), int ( z '10C0' ), & ! GEORGIAN LETTER HAE => GEORGIAN CAPITAL LETTER HAE (KHUTSURI) int ( z '10F1' ), int ( z '10C1' ), & ! GEORGIAN LETTER HE => GEORGIAN CAPITAL LETTER HE (KHUTSURI) int ( z '10F2' ), int ( z '10C2' ), & ! GEORGIAN LETTER HIE => GEORGIAN CAPITAL LETTER HIE (KHUTSURI) int ( z '10F3' ), int ( z '10C3' ), & ! GEORGIAN LETTER WE => GEORGIAN CAPITAL LETTER WE (KHUTSURI) int ( z '10F4' ), int ( z '10C4' ), & ! GEORGIAN LETTER HAR => GEORGIAN CAPITAL LETTER HAR (KHUTSURI) int ( z '10F5' ), int ( z '10C5' ), & ! GEORGIAN LETTER HOE => GEORGIAN CAPITAL LETTER HOE (KHUTSURI) int ( z '1E01' ), int ( z '1E00' ), & ! LATIN SMALL LETTER A WITH RING BELOW => LATIN CAPITAL LETTER A WITH RING BELOW int ( z '1E03' ), int ( z '1E02' ), & ! LATIN SMALL LETTER B WITH DOT ABOVE => LATIN CAPITAL LETTER B WITH DOT ABOVE int ( z '1E05' ), int ( z '1E04' ), & ! LATIN SMALL LETTER B WITH DOT BELOW => LATIN CAPITAL LETTER B WITH DOT BELOW int ( z '1E07' ), int ( z '1E06' ), & ! LATIN SMALL LETTER B WITH LINE BELOW => LATIN CAPITAL LETTER B WITH LINE BELOW int ( z '1E09' ), int ( z '1E08' ), & ! LATIN SMALL LETTER C WITH CEDILLA AND ACUTE => LATIN CAPITAL LETTER C WITH CEDILLA AND ACUTE int ( z '1E0B' ), int ( z '1E0A' ), & ! LATIN SMALL LETTER D WITH DOT ABOVE => LATIN CAPITAL LETTER D WITH DOT ABOVE int ( z '1E0D' ), int ( z '1E0C' ), & ! LATIN SMALL LETTER D WITH DOT BELOW => LATIN CAPITAL LETTER D WITH DOT BELOW int ( z '1E0F' ), int ( z '1E0E' ), & ! LATIN SMALL LETTER D WITH LINE BELOW => LATIN CAPITAL LETTER D WITH LINE BELOW int ( z '1E11' ), int ( z '1E10' ), & ! LATIN SMALL LETTER D WITH CEDILLA => LATIN CAPITAL LETTER D WITH CEDILLA int ( z '1E13' ), int ( z '1E12' ), & ! LATIN SMALL LETTER D WITH CIRCUMFLEX BELOW => LATIN CAPITAL LETTER D WITH CIRCUMFLEX BELOW int ( z '1E15' ), int ( z '1E14' ), & ! LATIN SMALL LETTER E WITH MACRON AND GRAVE => LATIN CAPITAL LETTER E WITH MACRON AND GRAVE int ( z '1E17' ), int ( z '1E16' ), & ! LATIN SMALL LETTER E WITH MACRON AND ACUTE => LATIN CAPITAL LETTER E WITH MACRON AND ACUTE int ( z '1E19' ), int ( z '1E18' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX BELOW => LATIN CAPITAL LETTER E WITH CIRCUMFLEX BELOW int ( z '1E1B' ), int ( z '1E1A' ), & ! LATIN SMALL LETTER E WITH TILDE BELOW => LATIN CAPITAL LETTER E WITH TILDE BELOW int ( z '1E1D' ), int ( z '1E1C' ), & ! LATIN SMALL LETTER E WITH CEDILLA AND BREVE => LATIN CAPITAL LETTER E WITH CEDILLA AND BREVE int ( z '1E1F' ), int ( z '1E1E' ), & ! LATIN SMALL LETTER F WITH DOT ABOVE => LATIN CAPITAL LETTER F WITH DOT ABOVE int ( z '1E21' ), int ( z '1E20' ), & ! LATIN SMALL LETTER G WITH MACRON => LATIN CAPITAL LETTER G WITH MACRON int ( z '1E23' ), int ( z '1E22' ), & ! LATIN SMALL LETTER H WITH DOT ABOVE => LATIN CAPITAL LETTER H WITH DOT ABOVE int ( z '1E25' ), int ( z '1E24' ), & ! LATIN SMALL LETTER H WITH DOT BELOW => LATIN CAPITAL LETTER H WITH DOT BELOW int ( z '1E27' ), int ( z '1E26' ), & ! LATIN SMALL LETTER H WITH DIAERESIS => LATIN CAPITAL LETTER H WITH DIAERESIS int ( z '1E29' ), int ( z '1E28' ), & ! LATIN SMALL LETTER H WITH CEDILLA => LATIN CAPITAL LETTER H WITH CEDILLA int ( z '1E2B' ), int ( z '1E2A' ), & ! LATIN SMALL LETTER H WITH BREVE BELOW => LATIN CAPITAL LETTER H WITH BREVE BELOW int ( z '1E2D' ), int ( z '1E2C' ), & ! LATIN SMALL LETTER I WITH TILDE BELOW => LATIN CAPITAL LETTER I WITH TILDE BELOW int ( z '1E2F' ), int ( z '1E2E' ), & ! LATIN SMALL LETTER I WITH DIAERESIS AND ACUTE => LATIN CAPITAL LETTER I WITH DIAERESIS AND ACUTE int ( z '1E31' ), int ( z '1E30' ), & ! LATIN SMALL LETTER K WITH ACUTE => LATIN CAPITAL LETTER K WITH ACUTE int ( z '1E33' ), int ( z '1E32' ), & ! LATIN SMALL LETTER K WITH DOT BELOW => LATIN CAPITAL LETTER K WITH DOT BELOW int ( z '1E35' ), int ( z '1E34' ), & ! LATIN SMALL LETTER K WITH LINE BELOW => LATIN CAPITAL LETTER K WITH LINE BELOW int ( z '1E37' ), int ( z '1E36' ), & ! LATIN SMALL LETTER L WITH DOT BELOW => LATIN CAPITAL LETTER L WITH DOT BELOW int ( z '1E39' ), int ( z '1E38' ), & ! LATIN SMALL LETTER L WITH DOT BELOW AND MACRON => LATIN CAPITAL LETTER L WITH DOT BELOW AND MACRON int ( z '1E3B' ), int ( z '1E3A' ), & ! LATIN SMALL LETTER L WITH LINE BELOW => LATIN CAPITAL LETTER L WITH LINE BELOW int ( z '1E3D' ), int ( z '1E3C' ), & ! LATIN SMALL LETTER L WITH CIRCUMFLEX BELOW => LATIN CAPITAL LETTER L WITH CIRCUMFLEX BELOW int ( z '1E3F' ), int ( z '1E3E' ), & ! LATIN SMALL LETTER M WITH ACUTE => LATIN CAPITAL LETTER M WITH ACUTE int ( z '1E41' ), int ( z '1E40' ), & ! LATIN SMALL LETTER M WITH DOT ABOVE => LATIN CAPITAL LETTER M WITH DOT ABOVE int ( z '1E43' ), int ( z '1E42' ), & ! LATIN SMALL LETTER M WITH DOT BELOW => LATIN CAPITAL LETTER M WITH DOT BELOW int ( z '1E45' ), int ( z '1E44' ), & ! LATIN SMALL LETTER N WITH DOT ABOVE => LATIN CAPITAL LETTER N WITH DOT ABOVE int ( z '1E47' ), int ( z '1E46' ), & ! LATIN SMALL LETTER N WITH DOT BELOW => LATIN CAPITAL LETTER N WITH DOT BELOW int ( z '1E49' ), int ( z '1E48' ), & ! LATIN SMALL LETTER N WITH LINE BELOW => LATIN CAPITAL LETTER N WITH LINE BELOW int ( z '1E4B' ), int ( z '1E4A' ), & ! LATIN SMALL LETTER N WITH CIRCUMFLEX BELOW => LATIN CAPITAL LETTER N WITH CIRCUMFLEX BELOW int ( z '1E4D' ), int ( z '1E4C' ), & ! LATIN SMALL LETTER O WITH TILDE AND ACUTE => LATIN CAPITAL LETTER O WITH TILDE AND ACUTE int ( z '1E4F' ), int ( z '1E4E' ), & ! LATIN SMALL LETTER O WITH TlLDE AND DIAERESIS => LATIN CAPITAL LETTER O WITH TILDE AND DIAERESIS int ( z '1E51' ), int ( z '1E50' ), & ! LATIN SMALL LETTER O WITH MACRON AND GRAVE => LATIN CAPITAL LETTER O WITH MACRON AND GRAVE int ( z '1E53' ), int ( z '1E52' ), & ! LATIN SMALL LETTER O WITH MACRON AND ACUTE => LATIN CAPITAL LETTER O WITH MACRON AND ACUTE int ( z '1E55' ), int ( z '1E54' ), & ! LATIN SMALL LETTER P WITH ACUTE => LATIN CAPITAL LETTER P WITH ACUTE int ( z '1E57' ), int ( z '1E56' ), & ! LATIN SMALL LETTER P WITH DOT ABOVE => LATIN CAPITAL LETTER P WITH DOT ABOVE int ( z '1E59' ), int ( z '1E58' ), & ! LATIN SMALL LETTER R WITH DOT ABOVE => LATIN CAPITAL LETTER R WITH DOT ABOVE int ( z '1E5B' ), int ( z '1E5A' ), & ! LATIN SMALL LETTER R WITH DOT BELOW => LATIN CAPITAL LETTER R WITH DOT BELOW int ( z '1E5D' ), int ( z '1E5C' ), & ! LATIN SMALL LETTER R WITH DOT BELOW AND MACRON => LATIN CAPITAL LETTER R WITH DOT BELOW AND MACRON int ( z '1E5F' ), int ( z '1E5E' ), & ! LATIN SMALL LETTER R WITH LINE BELOW => LATIN CAPITAL LETTER R WITH LINE BELOW int ( z '1E61' ), int ( z '1E60' ), & ! LATIN SMALL LETTER S WITH DOT ABOVE => LATIN CAPITAL LETTER S WITH DOT ABOVE int ( z '1E63' ), int ( z '1E62' ), & ! LATIN SMALL LETTER S WITH DOT BELOW => LATIN CAPITAL LETTER S WITH DOT BELOW int ( z '1E65' ), int ( z '1E64' ), & ! LATIN SMALL LETTER S WITH ACUTE AND DOT ABOVE => LATIN CAPITAL LETTER S WITH ACUTE AND DOT ABOVE int ( z '1E67' ), int ( z '1E66' ), & ! LATIN SMALL LETTER S WITH CARON AND DOT ABOVE => LATIN CAPITAL LETTER S WITH CARON AND DOT ABOVE int ( z '1E69' ), int ( z '1E68' ), & ! LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE => LATIN CAPITAL LETTER S WITH DOT BELOW AND DOT ABOVE int ( z '1E6B' ), int ( z '1E6A' ), & ! LATIN SMALL LETTER T WITH DOT ABOVE => LATIN CAPITAL LETTER T WITH DOT ABOVE int ( z '1E6D' ), int ( z '1E6C' ), & ! LATIN SMALL LETTER T WITH DOT BELOW => LATIN CAPITAL LETTER T WITH DOT BELOW int ( z '1E6F' ), int ( z '1E6E' ), & ! LATIN SMALL LETTER T WITH LINE BELOW => LATIN CAPITAL LETTER T WITH LINE BELOW int ( z '1E71' ), int ( z '1E70' ), & ! LATIN SMALL LETTER T WITH CIRCUMFLEX BELOW => LATIN CAPITAL LETTER T WITH CIRCUMFLEX BELOW int ( z '1E73' ), int ( z '1E72' ), & ! LATIN SMALL LETTER U WITH DIAERESIS BELOW => LATIN CAPITAL LETTER U WITH DIAERESIS BELOW int ( z '1E75' ), int ( z '1E74' ), & ! LATIN SMALL LETTER U WITH TILDE BELOW => LATIN CAPITAL LETTER U WITH TILDE BELOW int ( z '1E77' ), int ( z '1E76' ), & ! LATIN SMALL LETTER U WITH CIRCUMFLEX BELOW => LATIN CAPITAL LETTER U WITH CIRCUMFLEX BELOW int ( z '1E79' ), int ( z '1E78' ), & ! LATIN SMALL LETTER U WITH TILDE AND ACUTE => LATIN CAPITAL LETTER U WITH TILDE AND ACUTE int ( z '1E7B' ), int ( z '1E7A' ), & ! LATIN SMALL LETTER U WITH MACRON AND DIAERESIS => LATIN CAPITAL LETTER U WITH MACRON AND DIAERESIS int ( z '1E7D' ), int ( z '1E7C' ), & ! LATIN SMALL LETTER V WITH TILDE => LATIN CAPITAL LETTER V WITH TILDE int ( z '1E7F' ), int ( z '1E7E' ), & ! LATIN SMALL LETTER V WITH DOT BELOW => LATIN CAPITAL LETTER V WITH DOT BELOW int ( z '1E81' ), int ( z '1E80' ), & ! LATIN SMALL LETTER W WITH GRAVE => LATIN CAPITAL LETTER W WITH GRAVE int ( z '1E83' ), int ( z '1E82' ), & ! LATIN SMALL LETTER W WITH ACUTE => LATIN CAPITAL LETTER W WITH ACUTE int ( z '1E85' ), int ( z '1E84' ), & ! LATIN SMALL LETTER W WITH DIAERESIS => LATIN CAPITAL LETTER W WITH DIAERESIS int ( z '1E87' ), int ( z '1E86' ), & ! LATIN SMALL LETTER W WITH DOT ABOVE => LATIN CAPITAL LETTER W WITH DOT ABOVE int ( z '1E89' ), int ( z '1E88' ), & ! LATIN SMALL LETTER W WITH DOT BELOW => LATIN CAPITAL LETTER W WITH DOT BELOW int ( z '1E8B' ), int ( z '1E8A' ), & ! LATIN SMALL LETTER X WITH DOT ABOVE => LATIN CAPITAL LETTER X WITH DOT ABOVE int ( z '1E8D' ), int ( z '1E8C' ), & ! LATIN SMALL LETTER X WITH DIAERESIS => LATIN CAPITAL LETTER X5 WITH DIAERESIS int ( z '1E8F' ), int ( z '1E8E' ), & ! LATIN SMALL LETTER Y WITH DOT ABOVE => LATIN CAPITAL LETTER Y WITH DOT ABOVE int ( z '1E91' ), int ( z '1E90' ), & ! LATIN SMALL LETTER Z WITH CIRCUMFLEX => LATIN CAPITAL LETTER Z WITH CIRCUMFLEX int ( z '1E93' ), int ( z '1E92' ), & ! LATIN SMALL LETTER Z WITH DOT BELOW => LATIN CAPITAL LETTER Z WITH DOT BELOW int ( z '1E95' ), int ( z '1E94' ), & ! LATIN SMALL LETTER Z WITH LINE BELOW => LATIN CAPITAL LETTER Z WITH LINE BELOW int ( z '1EA1' ), int ( z '1EA0' ), & ! LATIN SMALL LETTER A WITH DOT BELOW => LATIN CAPITAL LETTER A WITH DOT BELOW int ( z '1EA3' ), int ( z '1EA2' ), & ! LATIN SMALL LETTER A WITH HOOK ABOVE => LATIN CAPITAL LETTER A WITH HOOK ABOVE int ( z '1EA5' ), int ( z '1EA4' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND ACUTE => LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND ACUTE int ( z '1EA7' ), int ( z '1EA6' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND GRAVE => LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND GRAVE int ( z '1EA9' ), int ( z '1EA8' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE => LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND HOOK ABOVE int ( z '1EAB' ), int ( z '1EAA' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND TILDE => LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND TILDE int ( z '1EAD' ), int ( z '1EAC' ), & ! LATIN SMALL LETTER A WITH CIRCUMFLEX AND DOT BELOW => LATIN CAPITAL LETTER A WITH CIRCUMFLEX AND DOT BELOW int ( z '1EAF' ), int ( z '1EAE' ), & ! LATIN SMALL LETTER A WITH BREVE AND ACUTE => LATIN CAPITAL LETTER A WITH BREVE AND ACUTE int ( z '1EB1' ), int ( z '1EB0' ), & ! LATIN SMALL LETTER A WITH BREVE AND GRAVE => LATIN CAPITAL LETTER A WITH BREVE AND GRAVE int ( z '1EB3' ), int ( z '1EB2' ), & ! LATIN SMALL LETTER A WITH BREVE AND HOOK ABOVE => LATIN CAPITAL LETTER A WITH BREVE AND HOOK ABOVE int ( z '1EB5' ), int ( z '1EB4' ), & ! LATIN SMALL LETTER A WITH BREVE AND TILDE => LATIN CAPITAL LETTER A WITH BREVE AND TILDE int ( z '1EB7' ), int ( z '1EB6' ), & ! LATIN SMALL LETTER A WITH BREVE AND DOT BELOW => LATIN CAPITAL LETTER A WITH BREVE AND DOT BELOW int ( z '1EB9' ), int ( z '1EB8' ), & ! LATIN SMALL LETTER E WITH DOT BELOW => LATIN CAPITAL LETTER E WITH DOT BELOW int ( z '1EBB' ), int ( z '1EBA' ), & ! LATIN SMALL LETTER E WITH HOOK ABOVE => LATIN CAPITAL LETTER E WITH HOOK ABOVE int ( z '1EBD' ), int ( z '1EBC' ), & ! LATIN SMALL LETTER E WITH TILDE => LATIN CAPITAL LETTER E WITH TILDE int ( z '1EBF' ), int ( z '1EBE' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND ACUTE => LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND ACUTE int ( z '1EC1' ), int ( z '1EC0' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND GRAVE => LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND GRAVE int ( z '1EC3' ), int ( z '1EC2' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE => LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND HOOK ABOVE int ( z '1EC5' ), int ( z '1EC4' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND TILDE => LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND TILDE int ( z '1EC7' ), int ( z '1EC6' ), & ! LATIN SMALL LETTER E WITH CIRCUMFLEX AND DOT BELOW => LATIN CAPITAL LETTER E WITH CIRCUMFLEX AND DOT BELOW int ( z '1EC9' ), int ( z '1EC8' ), & ! LATIN SMALL LETTER I WITH HOOK ABOVE => LATIN CAPITAL LETTER I WITH HOOK ABOVE int ( z '1ECB' ), int ( z '1ECA' ), & ! LATIN SMALL LETTER I WITH DOT BELOW => LATIN CAPITAL LETTER I WITH DOT BELOW int ( z '1ECD' ), int ( z '1ECC' ), & ! LATIN SMALL LETTER O WITH DOT BELOW => LATIN CAPITAL LETTER O WITH DOT BELOW int ( z '1ECF' ), int ( z '1ECE' ), & ! LATIN SMALL LETTER O WITH HOOK ABOVE => LATIN CAPITAL LETTER O WITH HOOK ABOVE int ( z '1ED1' ), int ( z '1ED0' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND ACUTE => LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND ACUTE int ( z '1ED3' ), int ( z '1ED2' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND GRAVE => LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND GRAVE int ( z '1ED5' ), int ( z '1ED4' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE => LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND HOOK ABOVE int ( z '1ED7' ), int ( z '1ED6' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND TILDE => LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND TILDE int ( z '1ED9' ), int ( z '1ED8' ), & ! LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW => LATIN CAPITAL LETTER O WITH CIRCUMFLEX AND DOT BELOW int ( z '1EDB' ), int ( z '1EDA' ), & ! LATIN SMALL LETTER O WITH HORN AND ACUTE => LATIN CAPITAL LETTER O WITH HORN AND ACUTE int ( z '1EDD' ), int ( z '1EDC' ), & ! LATIN SMALL LETTER O WITH HORN AND GRAVE => LATIN CAPITAL LETTER O WITH HORN AND GRAVE int ( z '1EDF' ), int ( z '1EDE' ), & ! LATIN SMALL LETTER O WITH HORN AND HOOK ABOVE => LATIN CAPITAL LETTER O WITH HORN AND HOOK ABOVE int ( z '1EE1' ), int ( z '1EE0' ), & ! LATIN SMALL LETTER O WITH HORN AND TILDE => LATIN CAPITAL LETTER O WITH HORN AND TILDE int ( z '1EE3' ), int ( z '1EE2' ), & ! LATIN SMALL LETTER O WITH HORN AND DOT BELOW => LATIN CAPITAL LETTER O WITH HORN AND DOT BELOW int ( z '1EE5' ), int ( z '1EE4' ), & ! LATIN SMALL LETTER U WITH DOT BELOW => LATIN CAPITAL LETTER U WITH DOT BELOW int ( z '1EE7' ), int ( z '1EE6' ), & ! LATIN SMALL LETTER U WITH HOOK ABOVE => LATIN CAPITAL LETTER U WITH HOOK ABOVE int ( z '1EE9' ), int ( z '1EE8' ), & ! LATIN SMALL LETTER U WITH HORN AND ACUTE => LATIN CAPITAL LETTER U WITH HORN AND ACUTE int ( z '1EEB' ), int ( z '1EEA' ), & ! LATIN SMALL LETTER U WITH HORN AND GRAVE => LATIN CAPITAL LETTER U WITH HORN AND GRAVE int ( z '1EED' ), int ( z '1EEC' ), & ! LATIN SMALL LETTER U WITH HORN AND HOCK ABOVE => LATIN CAPITAL LETTER U WITH HORN AND HOOK ABOVE int ( z '1EEF' ), int ( z '1EEE' ), & ! LATIN SMALL LETTER U WITH HORN AND TILDE => LATIN CAPITAL LETTER U WITH HORN AND TILDE int ( z '1EF1' ), int ( z '1EF0' ), & ! LATIN SMALL LETTER U WITH HORN AND DOT BELOW => LATIN CAPITAL LETTER U WITH HORN AND DOT BELOW int ( z '1EF3' ), int ( z '1EF2' ), & ! LATIN SMALL LETTER Y WITH GRAVE => LATIN CAPITAL LETTER Y WITH GRAVE int ( z '1EF5' ), int ( z '1EF4' ), & ! LATIN SMALL LETTER Y WITH DOT BELOW => LATIN CAPITAL LETTER Y WITH DOT BELOW int ( z '1EF7' ), int ( z '1EF6' ), & ! LATIN SMALL LETTER Y WITH HOOK ABOVE => LATIN CAPITAL LETTER Y WITH HOOK ABOVE int ( z '1EF9' ), int ( z '1EF8' ), & ! LATIN SMALL LETTER Y WITH TILDE => LATIN CAPITAL LETTER Y WITH TILDE int ( z '1F00' ), int ( z '1F08' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI => GREEK CAPITAL LETTER ALPHA WITH PSILI int ( z '1F01' ), int ( z '1F09' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA => GREEK CAPITAL LETTER ALPHA WITH DASIA int ( z '1F02' ), int ( z '1F0A' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA => GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA int ( z '1F03' ), int ( z '1F0B' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA => GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA int ( z '1F04' ), int ( z '1F0C' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA => GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA int ( z '1F05' ), int ( z '1F0D' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA => GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA int ( z '1F06' ), int ( z '1F0E' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI => GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI int ( z '1F07' ), int ( z '1F0F' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI => GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI int ( z '1F10' ), int ( z '1F18' ), & ! GREEK SMALL LETTER EPSILON WITH PSILI => GREEK CAPITAL LETTER EPSILON WITH PSILI int ( z '1F11' ), int ( z '1F19' ), & ! GREEK SMALL LETTER EPSILON WITH DASIA => GREEK CAPITAL LETTER EPSILON WITH DASIA int ( z '1F12' ), int ( z '1F1A' ), & ! GREEK SMALL LETTER EPSILON WITH PSILI AND VARIA => GREEK CAPITAL LETTER EPSILON WITH PSILI AND VARIA int ( z '1F13' ), int ( z '1F1B' ), & ! GREEK SMALL LETTER EPSILON WITH DASIA AND VARIA => GREEK CAPITAL LETTER EPSILON WITH DASIA AND VARIA int ( z '1F14' ), int ( z '1F1C' ), & ! GREEK SMALL LETTER EPSILON WITH PSILI AND OXIA => GREEK CAPITAL LETTER EPSILON WITH PSILI AND OXIA int ( z '1F15' ), int ( z '1F1D' ), & ! GREEK SMALL LETTER EPSILON WITH DASIA AND OXIA => GREEK CAPITAL LETTER EPSILON WITH DASIA AND OXIA int ( z '1F20' ), int ( z '1F28' ), & ! GREEK SMALL LETTER ETA WITH PSILI => GREEK CAPITAL LETTER ETA WITH PSILI int ( z '1F21' ), int ( z '1F29' ), & ! GREEK SMALL LETTER ETA WITH DASIA => GREEK CAPITAL LETTER ETA WITH DASIA int ( z '1F22' ), int ( z '1F2A' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND VARIA => GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA int ( z '1F23' ), int ( z '1F2B' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND VARIA => GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA int ( z '1F24' ), int ( z '1F2C' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND OXIA => GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA int ( z '1F25' ), int ( z '1F2D' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND OXIA => GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA int ( z '1F26' ), int ( z '1F2E' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI => GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI int ( z '1F27' ), int ( z '1F2F' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI => GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI int ( z '1F30' ), int ( z '1F38' ), & ! GREEK SMALL LETTER IOTA WITH PSILI => GREEK CAPITAL LETTER IOTA WITH PSILI int ( z '1F31' ), int ( z '1F39' ), & ! GREEK SMALL LETTER IOTA WITH DASIA => GREEK CAPITAL LETTER IOTA WITH DASIA int ( z '1F32' ), int ( z '1F3A' ), & ! GREEK SMALL LETTER IOTA WITH PSILI AND VARIA => GREEK CAPITAL LETTER IOTA WITH PSILI AND VARIA int ( z '1F33' ), int ( z '1F3B' ), & ! GREEK SMALL LETTER IOTA WITH DASIA AND VARIA => GREEK CAPITAL LETTER IOTA WITH DASIA AND VARIA int ( z '1F34' ), int ( z '1F3C' ), & ! GREEK SMALL LETTER IOTA WITH PSILI AND OXIA => GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA int ( z '1F35' ), int ( z '1F3D' ), & ! GREEK SMALL LETTER IOTA WITH DASIA AND OXIA => GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA int ( z '1F36' ), int ( z '1F3E' ), & ! GREEK SMALL LETTER IOTA WITH PSILI AND PERISPOMENI => GREEK CAPITAL LETTER IOTA WITH PSILI AND PERISPOMENI int ( z '1F37' ), int ( z '1F3F' ), & ! GREEK SMALL LETTER IOTA WITH DASIA AND PERISPOMENI => GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI int ( z '1F40' ), int ( z '1F48' ), & ! GREEK SMALL LETTER OMICRON WITH PSILI => GREEK CAPITAL LETTER OMICRON WITH PSILI int ( z '1F41' ), int ( z '1F49' ), & ! GREEK SMALL LETTER OMICRON WITH DASIA => GREEK CAPITAL LETTER OMICRON WITH DASIA int ( z '1F42' ), int ( z '1F4A' ), & ! GREEK SMALL LETTER OMICRON WITH PSILI AND VARIA => GREEK CAPITAL LETTER OMICRON WITH PSILI AND VARIA int ( z '1F43' ), int ( z '1F4B' ), & ! GREEK SMALL LETTER OMICRON WITH DASIA AND VARIA => GREEK CAPITAL LETTER OMICRON WITH DASIA AND VARIA int ( z '1F44' ), int ( z '1F4C' ), & ! GREEK SMALL LETTER OMICRON WITH PSILI AND OXIA => GREEK CAPITAL LETTER OMICRON WITH PSILI AND OXIA int ( z '1F45' ), int ( z '1F4D' ), & ! GREEK SMALL LETTER OMICRON WITH DASIA AND OXIA => GREEK CAPITAL LETTER OMICRON WITH DASIA AND OXIA int ( z '1F51' ), int ( z '1F59' ), & ! GREEK SMALL LETTER UPSILON WITH DASIA => GREEK CAPITAL LETTER UPSILON WITH OASIS int ( z '1F53' ), int ( z '1F5B' ), & ! GREEK SMALL LETTER UPSILON WITH DASIA AND VARIA => GREEK CAPITAL LETTER UPSILON WITH DASIA AND VARIA int ( z '1F55' ), int ( z '1F5D' ), & ! GREEK SMALL LETTER UPSILON WITH DASIA AND OXIA => GREEK CAPITAL LETTER UPSILON WITH DASIA AND OXIA int ( z '1F57' ), int ( z '1F5F' ), & ! GREEK SMALL LETTER UPSILON WITH DASIA AND PERISPOMENI => GREEK CAPITAL LETTER UPSILON WITH DASIA AND PERISPOMENI int ( z '1F60' ), int ( z '1F68' ), & ! GREEK SMALL LETTER OMEGA WITh PSILI => GREEK CAPITAL LETTER OMEGA WITH PSILI int ( z '1F61' ), int ( z '1F69' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA => GREEK CAPITAL LETTER OMEGA WITH DASIA int ( z '1F62' ), int ( z '1F6A' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA => GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA int ( z '1F63' ), int ( z '1F6B' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA => GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA int ( z '1F64' ), int ( z '1F6C' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA => GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA int ( z '1F65' ), int ( z '1F6D' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA => GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA int ( z '1F66' ), int ( z '1F6E' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND PERISPOMENI => GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI int ( z '1F67' ), int ( z '1F6F' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND PERISPOMENI => GREEK CAPITAL LETTER OMEGA WITH DASIA AND PERISPOMENI int ( z '1F80' ), int ( z '1F88' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITh PSILI AND PROSGEGRAMMENI int ( z '1F81' ), int ( z '1F89' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH DASIA AND PROSGEGRAMMENI int ( z '1F82' ), int ( z '1F8A' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND VARIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH PSILI AND VARIA AND PROSGEGRAMMENI int ( z '1F83' ), int ( z '1F8B' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND VARIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH DASIA AND VARIA AND PROSGEGRAMMENI int ( z '1F84' ), int ( z '1F8C' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND OXIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH PSILI AND OXIA AND PROSGEGRAMMEN int ( z '1F85' ), int ( z '1F8D' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND OXIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH DASIA AND OXIA AND PROSGEGRAMMEN int ( z '1F86' ), int ( z '1F8E' ), & ! GREEK SMALL LETTER ALPHA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1F87' ), int ( z '1F8F' ), & ! GREEK SMALL LETTER ALPHA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ALPHA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1F90' ), int ( z '1F98' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH PSILI AND PROSGEGRAMMENI int ( z '1F91' ), int ( z '1F99' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH DASIA AND PROSGEGRAMMENI int ( z '1F92' ), int ( z '1F9A' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND VARIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH PSILI AND VARIA AND PROSGEGRAMMENI int ( z '1F93' ), int ( z '1F9B' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND VARIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH DASIA AND VARIA AND PROSGEGRAMMENI int ( z '1F94' ), int ( z '1F9C' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND OXIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH PSILI AND OXIA AND PROSGEGRAMMENI int ( z '1F95' ), int ( z '1F9D' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND OXIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH DASIA AND OXIA AND PROSGEGRAMMENI int ( z '1F96' ), int ( z '1F9E' ), & ! GREEK SMALL LETTER ETA WITH PSILI AND PERISPOMENI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1F97' ), int ( z '1F9F' ), & ! GREEK SMALL LETTER ETA WITH DASIA AND PERISPOMENI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER ETA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1FA0' ), int ( z '1FA8' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH PSILI AND PROSGEGRAMMENI int ( z '1FA1' ), int ( z '1FA9' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH DASIA AND PROSGEGRAMMENI int ( z '1FA2' ), int ( z '1FAA' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND VARIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH PSILI AND VARIA AND PROSGEGRAMMENI int ( z '1FA3' ), int ( z '1FAB' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND VARIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH DASIA AND VARIA AND PROSGEGRAMMENI int ( z '1FA4' ), int ( z '1FAC' ), & ! GREEK SMALL LETTER OMEGA WITH PSILI AND OXIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH PSILI AND OXIA AND PROSGEGRAMMENI int ( z '1FA5' ), int ( z '1FAD' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND OXIA AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH DASIA AND OXIA AND PROSGEGRAMMENI int ( z '1FA6' ), int ( z '1FAE' ), & ! GREEK SMALL LETTER OMEGA WITh PSILI AND PERISPOMENI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMEGA WITH PSILI AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1FA7' ), int ( z '1FAF' ), & ! GREEK SMALL LETTER OMEGA WITH DASIA AND PEPISPOMENI AND YPOGEGRAMMENI => GREEK CAPITAL LETTER OMECA WITH DASIA AND PERISPOMENI AND PROSGEGRAMMENI int ( z '1FB0' ), int ( z '1FB8' ), & ! GREEK SMALL LETTER ALPHA WITH VRACHY => GREEK CAPITAL LETTER ALPHA WITH VRACHY int ( z '1FB1' ), int ( z '1FB9' ), & ! GREEK SMALL LETTER ALPHA WITH MACRON => GREEK CAPITAL LETTER ALPHA WITH MACRON int ( z '1FD0' ), int ( z '1FD8' ), & ! GREEK SMALL LETTER IOTA WITH VRACHY => GREEK CAPITAL LETTER IOTA WITH VRACHY int ( z '1FD1' ), int ( z '1FD9' ), & ! GREEK SMALL LETTER IOTA WITH MACRON => GREEK CAPITAL LETTER IOTA WITH MACRON int ( z '1FE0' ), int ( z '1FE8' ), & ! GREEK SMALL LETTER UPSILON WITH VRACHY => GREEK CAPITAL LETTER UPSILON WITH VRACHY int ( z '1FE1' ), int ( z '1FE9' ), & ! GREEK SMALL LETTER UPSILON WITH MACRON => GREEK CAPITAL LETTER UPSILON WITH MACRON int ( z '24D0' ), int ( z '24B6' ), & ! CIRCLED LATIN SMALL LETTER A => CIRCLED LATIN CAPITAL LETTER A int ( z '24D1' ), int ( z '24B7' ), & ! CIRCLED LATIN SMALL LETTER B => CIRCLED LATIN CAPITAL LETTER B int ( z '24D2' ), int ( z '24B8' ), & ! CIRCLED LATIN SMALL LETTER C => CIRCLED LATIN CAPITAL LETTER C int ( z '24D3' ), int ( z '24B9' ), & ! CIRCLED LATIN SMALL LETTER D => CIRCLED LATIN CAPITAL LETTER D int ( z '24D4' ), int ( z '24BA' ), & ! CIRCLED LATIN SMALL LETTER E => CIRCLED LATIN CAPITAL LETTER E int ( z '24D5' ), int ( z '24BB' ), & ! CIRCLED LATIN SMALL LETTER F => CIRCLED LATIN CAPITAL LETTER F int ( z '24D6' ), int ( z '24BC' ), & ! CIRCLED LATIN SMALL LETTER G => CIRCLED LATIN CAPITAL LETTER G int ( z '24D7' ), int ( z '24BD' ), & ! CIRCLED LATIN SMALL LETTER H => CIRCLED LATIN CAPITAL LETTER H int ( z '24D8' ), int ( z '24BE' ), & ! CIRCLED LATIN SMALL LETTER I => CIRCLED LATIN CAPITAL LETTER I int ( z '24D9' ), int ( z '24BF' ), & ! CIRCLED LATIN SMALL LETTER J => CIRCLED LATIN CAPITAL LETTER J int ( z '24DA' ), int ( z '24C0' ), & ! CIRCLED LATIN SMALL LETTER K => CIRCLED LATIN CAPITAL LETTER K int ( z '24DB' ), int ( z '24C1' ), & ! CIRCLED LATIN SMALL LETTER L => CIRCLED LATIN CAPITAL LETTER L int ( z '24DC' ), int ( z '24C2' ), & ! CIRCLED LATIN SMALL LETTER M => CIRCLED LATIN CAPITAL LETTER M int ( z '24DD' ), int ( z '24C3' ), & ! CIRCLED LATIN SMALL LETTER N => CIRCLED LATIN CAPITAL LETTER N int ( z '24DE' ), int ( z '24C4' ), & ! CIRCLED LATIN SMALL LETTER O => CIRCLED LATIN CAPITAL LETTER O int ( z '24DF' ), int ( z '24C5' ), & ! CIRCLED LATIN SMALL LETTER P => CIRCLED LATIN CAPITAL LETTER P int ( z '24E0' ), int ( z '24C6' ), & ! CIRCLED LATIN SMALL LETTER Q => CIRCLED LATIN CAPITAL LETTER Q int ( z '24E1' ), int ( z '24C7' ), & ! CIRCLED LATIN SMALL LETTER R => CIRCLED LATIN CAPITAL LETTER R int ( z '24E2' ), int ( z '24C8' ), & ! CIRCLED LATIN SMALL LETTER S => CIRCLED LATIN CAPITAL LETTER S int ( z '24E3' ), int ( z '24C9' ), & ! CIRCLED LATIN SMALL LETTER T => CIRCLED LATIN CAPITAL LETTER T int ( z '24E4' ), int ( z '24CA' ), & ! CIRCLED LATIN SMALL LETTER U => CIRCLED LATIN CAPITAL LETTER U int ( z '24E5' ), int ( z '24CB' ), & ! CIRCLED LATIN SMALL LETTER V => CIRCLED LATIN CAPITAL LETTER V int ( z '24E6' ), int ( z '24CC' ), & ! CIRCLED LATIN SMALL LETTER W => CIRCLED LATIN CAPITAL LETTER W int ( z '24E7' ), int ( z '24CD' ), & ! CIRCLED LATIN SMALL LETTER X => CIRCLED LATIN CAPITAL LETTER X int ( z '24E8' ), int ( z '24CE' ), & ! CIRCLED LATIN SMALL LETTER Y => CIRCLED LATIN CAPITAL LETTER Y int ( z '24E9' ), int ( z '24CF' ), & ! CIRCLED LATIN SMALL LETTER Z => CIRCLED LATIN CAPITAL LETTER Z int ( z 'FF41' ), int ( z 'FF21' ), & ! FULLWIDTH LATIN SMALL LETTER A => FULLWIDTH LATIN CAPITAL LETTER A int ( z 'FF42' ), int ( z 'FF22' ), & ! FULLWIDTH LATIN SMALL LETTER B => FULLWIDTH LATIN CAPITAL LETTER B int ( z 'FF43' ), int ( z 'FF23' ), & ! FULLWIDTH LATIN SMALL LETTER C => FULLWIDTH LATIN CAPITAL LETTER C int ( z 'FF44' ), int ( z 'FF24' ), & ! FULLWIDTH LATIN SMALL LETTER D => FULLWIDTH LATIN CAPITAL LETTER D int ( z 'FF45' ), int ( z 'FF25' ), & ! FULLWIDTH LATIN SMALL LETTER E => FULLWIDTH LATIN CAPITAL LETTER E int ( z 'FF46' ), int ( z 'FF26' ), & ! FULLWIDTH LATIN SMALL LETTER F => FULLWIDTH LATIN CAPITAL LETTER F int ( z 'FF47' ), int ( z 'FF27' ), & ! FULLWIDTH LATIN SMALL LETTER G => FULLWIDTH LATIN CAPITAL LETTER G int ( z 'FF48' ), int ( z 'FF28' ), & ! FULLWIDTH LATIN SMALL LETTER H => FULLWIDTH LATIN CAPITAL LETTER H int ( z 'FF49' ), int ( z 'FF29' ), & ! FULLWIDTH LATIN SMALL LETTER I => FULLWIDTH LATIN CAPITAL LETTER I int ( z 'FF4A' ), int ( z 'FF2A' ), & ! FULLWIDTH LATIN SMALL LETTER J => FULLWIDTH LATIN CAPITAL LETTER J int ( z 'FF4B' ), int ( z 'FF2B' ), & ! FULLWIDTH LATIN SMALL LETTER K => FULLWIDTH LATIN CAPITAL LETTER K int ( z 'FF4C' ), int ( z 'FF2C' ), & ! FULLWIDTH LATIN SMALL LETTER L => FULLWIDTH LATIN CAPITAL LETTER L int ( z 'FF4D' ), int ( z 'FF2D' ), & ! FULLWIDTH LATIN SMALL LETTER M => FULLWIDTH LATIN CAPITAL LETTER M int ( z 'FF4E' ), int ( z 'FF2E' ), & ! FULLWIDTH LATIN SMALL LETTER N => FULLWIDTH LATIN CAPITAL LETTER N int ( z 'FF4F' ), int ( z 'FF2F' ), & ! FULLWIDTH LATIN SMALL LETTER O => FULLWIDTH LATIN CAPITAL LETTER O int ( z 'FF50' ), int ( z 'FF30' ), & ! FULLWIDTH LATIN SMALL LETTER P => FULLWIDTH LATIN CAPITAL LETTER P int ( z 'FF51' ), int ( z 'FF31' ), & ! FULLWIDTH LATIN SMALL LETTER Q => FULLWIDTH LATIN CAPITAL LETTER Q int ( z 'FF52' ), int ( z 'FF32' ), & ! FULLWIDTH LATIN SMALL LETTER R => FULLWIDTH LATIN CAPITAL LETTER R int ( z 'FF53' ), int ( z 'FF33' ), & ! FULLWIDTH LATIN SMALL LETTER S => FULLWIDTH LATIN CAPITAL LETTER S int ( z 'FF54' ), int ( z 'FF34' ), & ! FULLWIDTH LATIN SMALL LETTER T => FULLWIDTH LATIN CAPITAL LETTER T int ( z 'FF55' ), int ( z 'FF35' ), & ! FULLWIDTH LATIN SMALL LETTER U => FULLWIDTH LATIN CAPITAL LETTER U int ( z 'FF56' ), int ( z 'FF36' ), & ! FULLWIDTH LATIN SMALL LETTER V => FULLWIDTH LATIN CAPITAL LETTER V int ( z 'FF57' ), int ( z 'FF37' ), & ! FULLWIDTH LATIN SMALL LETTER W => FULLWIDTH LATIN CAPITAL LETTER W int ( z 'FF58' ), int ( z 'FF38' ), & ! FULLWIDTH LATIN SMALL LETTER X => FULLWIDTH LATIN CAPITAL LETTER X int ( z 'FF59' ), int ( z 'FF39' ), & ! FULLWIDTH LATIN SMALL LETTER Y => FULLWIDTH LATIN CAPITAL LETTER Y int ( z 'FF5A' ), int ( z 'FF3A' )] & ! FULLWIDTH LATIN SMALL LETTER Z => FULLWIDTH LATIN CAPITAL LETTER Z , shape ( lowup ), order = [ 2 , 1 ]) type ( unicode_type ) :: low type ( unicode_type ) :: upp low = lowup (:, 1 ) upp = lowup (:, 2 ) write ( * , '(g0)' ) low % character () write ( * , '(g0)' ) character ( low % upper ()) write ( * , '(g0)' ) upp % character () write ( * , '(g0)' ) character ( upp % lower ()) end program testit","tags":"","url":"sourcefile/uplow.f90.html"},{"title":"demo_verify.f90 – M_unicode","text":"Source Code program checkform ! check if string is of form NN‐HHHHH use M_unicode , only : verify , unicode_type , assignment ( = ) use M_unicode , only : ut => unicode_type implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' character ( len =* ), parameter :: int = '1234567890' character ( len =* ), parameter :: hex = 'abcdefABCDEF0123456789' logical :: lout type ( unicode_type ) :: chars type ( unicode_type ) :: str chars = '32‐af43d' lout = . true . ! are the first two characters integer characters? str = chars % character ( 1 , 2 ) lout = ( verify ( str , ut ( int ) ) == 0 ) . and . lout ! is the third character a dash? str = chars % character ( 3 , 3 ) lout = ( verify ( str , ut ( '‐-' ) ) == 0 ) . and . lout ! is remaining string a valid representation of a hex value? str = chars % character ( 4 , 8 ) lout = ( verify ( str , ut ( hex ) ) == 0 ) . and . lout if ( lout ) then write ( * , g ) trim ( chars % character ()), ' passed' else write ( * , g ) trim ( chars % character ()), ' failed' endif end program checkform","tags":"","url":"sourcefile/demo_verify.f90.html"},{"title":"count_glyphs.f90 – M_unicode","text":"Source Code program count_glyphs ! @(#) read a utf-8 file and write it out with lines prefixed with glyph count of the line use , intrinsic :: iso_fortran_env , only : output_unit , input_unit use M_unicode implicit none intrinsic is_iostat_end character ( len =* ), parameter :: g = '(*(g0))' integer :: length integer :: iostat character ( len = 1024 ) :: aline type ( unicode_type ) :: uline character ( len = 255 ) :: iomsg do read ( input_unit , '(a)' , iostat = iostat , iomsg = iomsg ) aline if ( iostat . eq . 0 ) then uline = trim ( aline ) length = len_trim ( uline ) write ( output_unit , '(i9,\": \",a)' ) length , uline % character ( 1 , length ) elseif ( is_iostat_end ( iostat )) then exit else write ( output_unit , g ) '<ERROR>' , trim ( iomsg ) exit endif enddo end program count_glyphs","tags":"","url":"sourcefile/count_glyphs.f90.html"},{"title":"demo_lower.f90 – M_unicode","text":"Source Code program demo_lower use M_unicode , only : lower , unicode_type , assignment ( = ) implicit none character ( len =* ), parameter :: g = '(*(g0))' type ( unicode_type ) :: pangram type ( unicode_type ) :: lower_pangram ! a sentence containing every letter of the English alphabet pangram = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\" write ( * , g ) pangram % character () lower_pangram = lower ( pangram ) write ( * , g ) lower_pangram % character () end program demo_lower","tags":"","url":"sourcefile/demo_lower.f90.html"},{"title":"demo_tokenize.f90 – M_unicode","text":"Source Code program demo_tokenize use M_unicode , only : assignment ( = ), unicode_type , tokenize , len , character character ( len =* ), parameter :: g0 = '(*(g0))' character ( len =* ), parameter :: g1 = '(*(g0,1x))' type ( unicode_type ), allocatable :: tokens (:) type ( unicode_type ), allocatable :: separators (:) type ( unicode_type ) :: delims type ( unicode_type ) :: herbs integer , allocatable , dimension (:) :: begins integer , allocatable , dimension (:) :: ends integer :: i delims = ',&' herbs = 'parsley,sage,rosemary,&thyme' write ( * , * ) herbs % character () write ( * , g0 ) write ( * , g0 ) 'expecting' write ( * , g0 ) ' tokens    =[parsley][sage][rosemary][][thyme]' write ( * , g0 ) ' separators=,,,&' CALL TOKENIZE ( herbs , delims , tokens , separators ) write ( * , g0 ) 'got' write ( * , g0 ) \" tokens    =\" ,( '[' // tokens ( i )% character (), ']' , i = 1 , size ( tokens )) write ( * , g0 ) \" separators=\" ,( separators ( i )% character (), i = 1 , size ( separators )) write ( * , g0 ) write ( * , g0 ) 'expecting' write ( * , * ) 'begins=' ,[ 1 , 9 , 14 , 23 , 24 ] write ( * , * ) 'ends=  ' ,[ 7 , 12 , 21 , 22 , 28 ] CALL TOKENIZE ( herbs , delims , begins , ends ) write ( * , g0 ) 'got' write ( * , * ) 'begins=' , begins write ( * , * ) 'ends=  ' , ends write ( * , g0 ) write ( * , g0 ) 'OOP' tokens = herbs % tokenize ( delims ) write ( * , g0 ) \" tokens    =\" ,( '[' // tokens ( i )% character (), ']' , i = 1 , size ( tokens )) herbs = 'parsley/sage/rosemary//thyme' delims = '/' tokens = herbs % tokenize ( delims ) write ( * , g0 ) \" tokens    =\" ,( '[' // tokens ( i )% character (), ']' , i = 1 , size ( tokens )) herbs = 'parsley😃sage😃rosemary😃😃thyme' delims = '😃' write ( * , g0 ) ' ' , delims % character () write ( * , g1 ) ' ' , delims % codepoint () tokens = herbs % tokenize ( delims ) write ( * , g0 ) \" tokens    =\" ,( '[' // tokens ( i )% character (), ']' , i = 1 , size ( tokens )) end program demo_tokenize","tags":"","url":"sourcefile/demo_tokenize.f90.html"},{"title":"read_commandline.f90 – M_unicode","text":"Source Code program uni_to_ftn ! @(#) take command line argument utf-8 text and generate Fortran statement that represents the string use , intrinsic :: iso_fortran_env , only : output_unit implicit none character ( len =* ), parameter :: form = '(\"char(int(z''\",z0,\"''))\":,\"// &\")' character ( len =* ), parameter :: g = '(*(g0))' integer :: i character ( len = :), allocatable :: command_line command_line = getargs () ! get string containing all command arguments as CHARACTER bytes ! write the command line out as a Fortran variable expression using the CHAR() function open ( output_unit , encoding = 'UTF-8' ) write ( * , g ) '! ENCODING:[' , command_line // ']' write ( * , g ) 'character(len=*),parameter :: variable= &' write ( * , form )( command_line ( i : i ), i = 1 , len ( command_line )) contains function getargs () result ( command_line ) integer :: length character ( len = :), allocatable :: command_line call get_command ( length = length ) ! get command line length allocate ( character ( len = length ) :: command_line ) ! allocate string big enough to hold command line call get_command ( command = command_line ) ! get command line as a string call get_command_argument ( 0 , length = length ) ! remove argument 0 command_line = command_line ( length + 2 :) end function getargs end program uni_to_ftn","tags":"","url":"sourcefile/read_commandline.f90.html"},{"title":"codepoint.f90 – M_unicode","text":"Source Code program test_for_iso_10646 use M_unicode use iso_fortran_env , only : output_unit implicit none type ( unicode_type ) :: smiley smiley = [ int ( z '1F603' )] open ( output_unit , encoding = 'utf-8' ) write ( * , * ) 'Smiling face with open mouth' , smiley % character () ! 😃 end program test_for_iso_10646","tags":"","url":"sourcefile/codepoint.f90.html"},{"title":"multi_lines.f90 – M_unicode","text":"Source Code program multi_line use iso_fortran_env , only : output_unit use M_unicode use M_unicode , only : ut => unicode_type implicit none integer :: i , longest type ( ut ), allocatable :: upagain (:) upagain = [ & ! ROMANIZATION                         ! ENGLISH ut ( \"七転び八起き。\" ), & ! Nanakorobi yaoki.                    ! Fall seven times, stand up eight. ut ( \"転んでもまた立ち上がる。\" ), & ! Koronde mo mata tachiagaru.          ! Even if you fall down, you will get up again. ut ( \"くじけずに前を向いて歩いていこう。\" )] ! Kujikezu ni mae o muite aruite ikou. ! Don't be discouraged, just keep walking forward. ! open ( output_unit , encoding = 'UTF-8' ) longest = 0 ! get longest trimmed line do i = 1 , size ( upagain ) longest = max ( longest , len_trim ( upagain ( i ))) write ( * , * ) 'LEN=' , len_trim ( upagain ( i )) enddo write ( output_unit , * ) 'longest=' , longest write ( output_unit , * ) do i = 1 , size ( upagain ) write ( output_unit , '(g0)' ) character ( upagain ( i )), len_trim ( upagain ( i )) enddo end program multi_line","tags":"","url":"sourcefile/multi_lines.f90.html"},{"title":"test_M_unicode.f90 – M_unicode","text":"Source Code program test_M_unicode use iso_fortran_env , only : output_unit use M_unicode , only : adjustl , adjustr , index use M_unicode , only : trim , len , len_trim use M_unicode , only : character use M_unicode , only : assignment ( = ), unicode_type , operator ( // ) use M_unicode , only : operator ( <= ), lle use M_unicode , only : operator ( < ), llt use M_unicode , only : operator ( /= ), lne use M_unicode , only : operator ( == ), leq use M_unicode , only : operator ( > ), lgt use M_unicode , only : operator ( >= ), lge use M_unicode , only : utf8_to_codepoints , codepoints_to_utf8 use M_unicode , only : scan , verify use M_unicode , only : split , tokenize use M_unicode , only : repeat use M_unicode , only : upper , lower use M_unicode , only : sort implicit none character ( len =* ), parameter :: g0 = '(*(g0))' logical , parameter :: T = . true . logical , parameter :: F = . false . ! character ( len =* ), parameter :: upagain = \"七転び八起き。転んでもまた立ち上がる。くじけずに前を向いて歩いていこう。\" ! Romanization: ! Nanakorobi yaoki. Koronde mo mata tachiagaru. Kujikezu ni mae o muite aruite ikou. ! or English translation ! \"Fall seven times, stand up eight. Even if you fall down, you will get up again. Don't be discouraged, just keep walking forward.\" ! character ( len = :), allocatable :: astr type ( unicode_type ) :: ut_str type ( unicode_type ) :: smiley integer :: total integer :: i type ( unicode_type ) :: lhs , rhs type ( unicode_type ) :: string , substring smiley = '😃' total = 0 write ( * , g0 ) 'encoding can be altered on an open file' open ( output_unit , encoding = 'UTF-8' ) write ( * , g0 ) astr = 'Hello World and Ni Hao -- 你好' ut_str = astr call checkits ( 'convert to ASCII bytes' , astr , ut_str % bytes (), transfer ( 'Hello World and Ni Hao -- 你好' ,[ 'A' ])) astr = \"  this is a string    \" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), 'this is a string      ' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '      this is a string' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '  this is a string' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 18 ) call check ( 'len_trim' , len_trim ( ut_str ). eq . 18 ) call check ( 'len' , ut_str % len (). eq . 22 ) call check ( 'len' , len ( ut_str ). eq . 22 ) astr = \"  \" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), '  ' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '  ' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 0 ) call check ( 'len' , ut_str % len (). eq . 2 ) astr = \"\" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), '' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 0 ) call check ( 'len' , ut_str % len (). eq . 0 ) astr = \"ALLFULL\" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), 'ALLFULL' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), 'ALLFULL' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), 'ALLFULL' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 7 ) call check ( 'len' , ut_str % len (). eq . 7 ) ut_str = [ 32 , 32 , int ( z '1F603' ), 32 , 32 , 32 ] astr = character ( ut_str ) call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), '😃     ' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '     😃' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '  😃' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 3 ) call check ( 'len' , ut_str % len (). eq . 6 ) if ( total . ne . 0 ) then write ( * , g0 ) total , 'failures' stop 1 endif ut_str = smiley // ' and ' // smiley // 'and' // smiley // smiley // 'is it' astr = '😃 and 😃and😃😃is it' call checkit ( 'concatenation' , astr , character ( ut_str ), '😃 and 😃and😃😃is it' ) lhs = 'this is the left' rhs = 'this is the right' call checkits_l ( 'LLE' , ' ' , [ lle ( lhs , rhs ), lhs <= rhs , lle ( rhs , lhs ), rhs <= lhs ] , [ T , T , F , F ] ) call checkits_l ( 'LLT' , ' ' , [ llt ( lhs , rhs ), lhs < rhs , llt ( rhs , lhs ), rhs < lhs ] , [ T , T , F , F ] ) call checkits_l ( 'LNE' , ' ' , [ lne ( lhs , rhs ), lhs /= rhs , lne ( rhs , lhs ), rhs /= lhs ] , [ T , T , T , T ] ) call checkits_l ( 'LEQ' , ' ' , [ leq ( lhs , rhs ), lhs == rhs , leq ( rhs , lhs ), rhs == lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LGT' , ' ' , [ lgt ( lhs , rhs ), lhs > rhs , lgt ( rhs , lhs ), rhs > lhs ] , [ F , F , T , T ] ) call checkits_l ( 'LGE' , ' ' , [ lge ( lhs , rhs ), lhs >= rhs , lge ( rhs , lhs ), rhs >= lhs ] , [ F , F , T , T ] ) lhs = 'abc' rhs = 'abc ' call checkits_l ( 'LLE' , ' ' , [ lle ( lhs , rhs ), lhs <= rhs , lle ( rhs , lhs ), rhs <= lhs ] , [ T , T , T , T ] ) call checkits_l ( 'LLT' , ' ' , [ llt ( lhs , rhs ), lhs < rhs , llt ( rhs , lhs ), rhs < lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LNE' , ' ' , [ lne ( lhs , rhs ), lhs /= rhs , lne ( rhs , lhs ), rhs /= lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LEQ' , ' ' , [ leq ( lhs , rhs ), lhs == rhs , leq ( rhs , lhs ), rhs == lhs ] , [ T , T , T , T ] ) call checkits_l ( 'LGT' , ' ' , [ lgt ( lhs , rhs ), lhs > rhs , lgt ( rhs , lhs ), rhs > lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LGE' , ' ' , [ lge ( lhs , rhs ), lhs >= rhs , lge ( rhs , lhs ), rhs >= lhs ] , [ T , T , T , T ] ) string = \" can you find me here? \" substring = \"find me\" astr = character ( substring ) call check ( 'index ' // string % character () // ':' // substring % character (), index ( string , substring ). eq . 10 ) call check ( 'index ' // string % character () // ':' // astr , index ( string , astr ). eq . 10 ) string = \" can you find me here? \" substring = \"not there\" astr = character ( substring ) call check ( 'index ' // string % character () // ':' // substring % character (), index ( string , substring ). eq . 0 ) call check ( 'index ' // string % character () // ':' // astr , index ( string , astr ). eq . 0 ) string = \"short\" substring = \"shortnot\" astr = character ( substring ) call check ( 'index ' // string % character () // ':' // substring % character (), index ( string , substring ). eq . 0 ) call check ( 'index ' // string % character () // ':' // astr , index ( string , astr ). eq . 0 ) string = upagain write ( * , g0 ) 'original bytes  :' , upagain write ( * , g0 ) 'bytes reversed  :' , ( upagain ( i : i ), i = len ( upagain ), 1 , - 1 ) write ( * , g0 ) 'original string :' , string % character () write ( * , g0 ) 'string reversed :' , string % character ( string % len (), 1 , - 1 ) contains subroutine checkit ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline character ( len =* ), intent ( in ) :: answer character ( len =* ), intent ( in ) :: expected write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , answer . eq . expected ), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( answer . ne . expected ) total = total + 1 end subroutine checkit subroutine checkits ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline character ( len =* ), intent ( in ) :: answer (:) character ( len =* ), intent ( in ) :: expected (:) write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , all ( answer . eq . expected )), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( all ( answer . ne . expected )) total = total + 1 end subroutine checkits subroutine checkits_l ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline logical , intent ( in ) :: answer (:) logical , intent ( in ) :: expected (:) write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , all ( answer . eqv . expected )), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( all ( answer . neqv . expected )) total = total + 1 end subroutine checkits_l subroutine check ( label , test ) character ( len =* ), intent ( in ) :: label logical , intent ( in ) :: test write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , test ), ' ' , label if (. not . test ) total = total + 1 end subroutine check end program test_M_unicode","tags":"","url":"sourcefile/test_m_unicode.f90.html"},{"title":"bom_start.f90 – M_unicode","text":"Source Code program bom_exe ! ! create a Fortran source file starting with a utf-8 BOM to see if your ! compiler will compile it or fail because a character is not in the ! Fortran character set outside of a comment or literal string ! use iso_fortran_env , only : stdout => output_unit use M_unicode implicit none type ( unicode_type ) :: U_BOM U_bom = [ int ( z 'FEFF' )] write ( stdout , '(a)' , advance = 'no' ) U_bom % character () write ( stdout , '(a)' ) & 'program testit ! Unicode BOM encoded to utf-8 bytes by Fortran' ,& '   write(*,*)\"File starts with BOM from UCS-4 write!\"' ,& 'end program testit' end program bom_exe","tags":"","url":"sourcefile/bom_start.f90.html"},{"title":"demo_scan.f90 – M_unicode","text":"Source Code program demo_scan use M_unicode , only : scan , unicode_type , assignment ( = ) use M_unicode , only : ut => unicode_type implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' type ( ut ) :: line type ( ut ) :: set line = 'parsley😃sage😃rosemary😃😃thyme' set = '😃' write ( * , g ) '123456789012345678901234567890123456789012345678901234567890' write ( * , g ) line % character () write ( * , g ) scan ( line , set ) write ( * , g ) scan ( line , set , back = . true .) write ( * , g ) scan ( line , set , back = . false .) write ( * , g ) scan ( line , unicode_type ( \"NOT\" )) write ( * , g ) 'OOP' write ( * , g ) line % scan ( set ) write ( * , g ) line % scan ( ut ( \"o\" )) end program demo_scan","tags":"","url":"sourcefile/demo_scan.f90.html"},{"title":"demo_sort.f90 – M_unicode","text":"Source Code program demo_sort use M_unicode , only : sort , unicode_type , assignment ( = ) use M_unicode , only : ut => unicode_type implicit none character ( len =* ), parameter :: g = '(*(g0))' integer , parameter :: isz = 4 type ( unicode_type ) :: rr ( isz ) integer :: ii ( isz ) integer :: i write ( * , g ) 'sort array with sort(3f)' rr = [ & ut ( \"the\" ), & ut ( \"quick\" ), & ut ( \"brown\" ), & ut ( \"fox\" ) ] call sort ( rr , ii ) write ( * , g ) 'original order' do i = 1 , size ( rr ) write ( * , g ) rr ( i )% character () enddo write ( * , g ) 'sorted order' do i = 1 , size ( rr ) write ( * , g ) rr ( ii ( i ))% character () enddo end program demo_sort","tags":"","url":"sourcefile/demo_sort.f90.html"},{"title":"demo_use.f90 – M_unicode","text":"Source Code program testit use iso_fortran_env , only : stdout => output_unit ! user-defined type to hold Unicode text use M_unicode , only : unicode_type ! convert unicode_type to CHARACTER variables use M_unicode , only : character ! intrinsic overloads use M_unicode , only : adjustl , adjustr use M_unicode , only : trim , len , len_trim use M_unicode , only : index , scan , verify use M_unicode , only : split , tokenize use M_unicode , only : repeat use M_unicode , only : upper , lower use M_unicode , only : sort ! operators (and overloads) and assignment use M_unicode , only : assignment ( = ) use M_unicode , only : operator ( <= ), lle use M_unicode , only : operator ( < ), llt use M_unicode , only : operator ( /= ), lne use M_unicode , only : operator ( == ), leq use M_unicode , only : operator ( > ), lgt use M_unicode , only : operator ( >= ), lge use M_unicode , only : operator ( // ) ! low-level text conversion to integer codepoint arrays: use M_unicode , only : utf8_to_codepoints , codepoints_to_utf8 implicit none type ( unicode_type ) :: ustr character ( len =* ), parameter :: g = '(*(g0))' !open (stdout, encoding='UTF-8') ! preferred, but not required if not supported ! Constructors ! UNICODE_VARIABLE= UNICODE_VARIABLE|CHARACTER(LEN=*)|INTEGER_ARRAY ! VARiABLE%CHARACTER(start,end,step) returns a CHARACTER string ! VARiABLE%BYTES() returns an array of CHARACTER(len=1) values ustr = 'Hello World and Ni Hao -- 你好  ' write ( stdout , g ) character ( ustr ) ! convert to intrinsic CHARACTER variable write ( stdout , g ) len ( ustr ) write ( stdout , g ) len_trim ( ustr ) write ( stdout , g ) ustr % character ( 27 , 28 ) ! similiar to LINE(27:28) write ( stdout , g ) index ( ustr , '你' ) ! OOPS write ( stdout , g ) ustr % character ( len ( ustr ), 1 , - 1 ) ! reverse string write ( stdout , g ) ustr % codepoint () ! Unicode codepoint values end program testit","tags":"","url":"sourcefile/demo_use.f90.html"},{"title":"fox_and_crow.f90 – M_unicode","text":"Source Code program crow_and_fox use M_unicode , only : unicode_type , ut => unicode_type , character , len ! “The Crow and the Fox” by Jean de la Fontaine type ( unicode_type ), allocatable :: poem (:) integer :: i poem = [& ut ( 'Maître Corbeau, sur un arbre perché,' ), & ut ( 'Tenait en son bec un fromage.' ), & ut ( 'Maître Renard, par l’odeur alléché,' ), & ut ( 'Lui tint à peu près ce langage :' ), & ut ( '«Hé ! bonjour, Monsieur du Corbeau.' ), & ut ( 'Que vous êtes joli ! que vous me semblez beau !' ), & ut ( 'Sans mentir, si votre ramage' ), & ut ( 'Se rapporte à votre plumage,' ), & ut ( 'Vous êtes le Phénix des hôtes de ces bois.»' ), & ut ( 'A ces mots le Corbeau ne se sent pas de joie ;' ), & ut ( 'Et pour montrer sa belle voix,' ), & ut ( 'Il ouvre un large bec, laisse tomber sa proie.' ), & ut ( 'Le Renard s’en saisit, et dit : «Mon bon Monsieur,' ), & ut ( 'Apprenez que tout flatteur' ), & ut ( 'Vit aux dépens de celui qui l’écoute :' ), & ut ( 'Cette leçon vaut bien un fromage, sans doute.»' ), & ut ( 'Le Corbeau, honteux et confus,' ), & ut ( 'Jura, mais un peu tard, qu’on ne l’y prendrait plus.' ), & ut ( ' -- Jean de la Fontaine' )] write ( * , '(g0)' )( character ( poem ( i )), i = 1 , size ( poem )) write ( * , '(a)' ) write ( * , '(*(a))' )( poem ( i )% codepoint (), new_line ( 'a' ), i = 1 , size ( poem )) write ( * , '(a)' ) write ( * , '(*(g0))' )( character ( poem ( i )), len ( poem ( i )), ' ' , len ( poem ( i )% character ()), new_line ( 'a' ), i = 1 , size ( poem )) end program crow_and_fox","tags":"","url":"sourcefile/fox_and_crow.f90.html"}]}