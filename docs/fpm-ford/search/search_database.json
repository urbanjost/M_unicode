var tipuesearch = {"pages":[{"title":" M_unicode ","text":"M_unicode M_unicode A WIP (Work In Progress) Unicode usage from Fortran when UTF-8 source files are supported Fortran 2003 and later standards describe internal representation of\nUnicode using 4-byte-per-character UCS-4 encoding for characters/glyphs,\nincluding an ability to automatically encode and decode data read and\nwritten to UTF-8 files. But Unicode support is optional. Where Unicode is supported (ie. where CHARACTER(KIND=”ISO_10646”)\nis provided)\nThe M_utf8 repository\nsupplements Unicode usage – emphasizing adherence to the standard to\npromote portability. When the compiler does not support CHARACTER(KIND=”ISO_10646”) it\nstill may support UTF-8 source files and permit entering multi-byte\nUnicode characters in comments and (more importantly) in constant\nstrings. This is now very common, as nearly all current operating systems\nand many applications support UTF-8 text files. But whether in input and output files, or as what-you-see-is-what-you-get\ncharacter constants the compiler will see this text as byte streams, and\nwill be unaware of how many Unicode glyphs/characters are represented. So it may often be easy to place Unicode characters in fixed messages, but\nif the text needs manipulated or processed in any way dealing with Unicode\nas a raw series of 8-bit-bytes becomes complex and non-intuitive. To keep processing of Unicode as simple as processing ASCII-7 characters\nthe M_unicode module provides a user-defined type named UNICODE_TYPE and a number of procedures for converting byte streams that represent\nUTF8-encoded text into Unicode code points (ie, 32-bit integer values\nthat generally identify one specific Unicode character). Additionally the most common character-related intrinsics and operators\nare overloaded to work with the UNICODE_TYPE variables; and the type is\nextended to include the procedures and operators as type-bound procedures\nfor programmers that prefer OOP (Object-Oriented Programming) capabilities. M_unicode module ! user-defined type to hold Unicode text public :: unicode_type ! Constructors ! UNICODE_VARIABLE= UNICODE_VARIABLE|CHARACTER(LEN=*)|INTEGER_ARRAY ! VARiABLE%CHARACTER(start,end,step) returns a CHARACTER string ! VARiABLE%BYTES() returns an array of CHARACTER(len=1) values ! convert unicode_type to CHARACTER variables public :: character ! intrinsic overloads public :: adjustl , adjustr , index , len , len_trim , repeat , trim public :: lle , llt , lne , leq , lgt , lge ! operators and assignment public :: assignment ( = ) public :: operator ( <= ), operator ( < ), operator ( /= ), operator ( == ) public :: operator ( > ), operator ( >= ), operator ( // ) ! low-level text conversion to integer codepoint arrays: public :: utf8_to_codepoints , codepoints_to_utf8 UTF-8 source files – just in comments and constants The Fortran character set is the set of characters used in constructing\nFortran code. It is now the same as the ASCII 7-bit character set sans\nthe unprintable control characters. The letters a-z,A-Z and digits 0-9\nand underscore are the only characters allowed in operator symbols. These\nsame characters and the “special” characters (the remaining printable\nASCII 7-bit characters) are used for operators and bracketing, and\nvarious forms of separating and delimiting other lexical tokens. But what about other non-ASCII-7 characters representable by the\nprocessor?  Possibilities include the extended ASCII characters or\nmulti-byte characters as defined for UTF-8 text files. The standard\nstates that, whatever those “additional characters” are, they may appear\nin character constants: 6.1.6 Other characters Additional characters may be representable in the processor , but shall appear on ly in comments ( 6.3.2.3 , 6.3.3.2 ), character constants ( 7.4.4 ), input / output records ( 12.2.2 ), and character string edit descriptors ( 13.3.2 ) . Since ASCII-7-bit is a subset of UTF-8 it is very likely that if your\nsystem supports UTF-8 files that it therefore will allow multi-byte\ncharacters to be represented in comments and character constants. But it is up to the processor whether it supports or even allows\nUTF-8 files.  In the past when UTF-8 file support was rare this meant\nusing UTF-8 multi-byte characters in source files was likely to be very\nnon-portable.  Now that UTF-8 files are supported on most systems this\nextension can be useful, particularly with compilers that do not support\nUCS-4 yet. Without using any Fortran Unicode support features, if the output\nis redirected to a file does it appear correctly? program multibyte character ( len =* ), parameter :: all = '(*(g0))' print all , 'Confucius never claimed to be a prophet, ' print all , 'but I think he foresaw AI! He said ' print all print all , ' \"学而不思则罔，思而不学则殆\"' print all , 'or ' print all , ' (xué ér bù sī zé wǎng, sī ér bù xué zé dài),' print all , 'or ' print all , ' \"To learn without thinking is to be lost, ' print all , ' to think without learning is to be in danger\".' end program multibyte Does it display properly when written to the screen? You might have\na terminal that does not support UTF-8 characters, or might have to\nset your locale properly. If it is not the terminal and your compiler\ndoes support ISO-10646 specifying the encoding of the output file\nas UTF-8 will likely correct any output issues even though the strings\nare a series of bytes and not UCS-4 encoded: program multibyte_encoded use , intrinsic :: iso_fortran_env , only : stdout => output_unit implicit none open ( stdout , encoding = 'utf-8' ) write ( stdout , '(a)' ) & 'Confucius never claimed to be a prophet, ' ,& 'but I think he foresaw AI! He said ' ,& '' ,& ' \"学而不思则罔，思而不学则殆\"' ,& 'or' ,& ' (xué ér bù sī zé wǎng, sī ér bù xué zé dài),' ,& 'or' ,& ' \"To learn without thinking is to be lost, ' ,& ' to think without learning is to be in danger\".' end program multibyte_encoded Remember that unless the compiler directly supports UTF-8 representation\n( so far I have identified no compilers that do so) these strings are seen\nby the compiler as a string of bytes, and is otherwise unaware they\nrepresent Unicode characters. If they are just to be read and written as-is\nas in the previous example program that is not a major concern; but if you\nare manipulating or processing the strings in significant ways you probably\nwant to convert the strings to TYPE(UNICODE_TYPE). Summary Yes, a Fortran source file can contain multibyte Unicode characters, but\nthe level of support and how they are handled depends on the specific\nFortran compiler and operating system and is not otherwise defined by\nthe Fortran standard. The appearance of multi-byte characters in comments and character\nconstants is typically all that is allowed and compiler errors occur\nwhen unsupported characters outside the Fortran character set are used\nin the body of the code – unless the vendor extends Fortran beyond the\nrequirements of the Fortran standard. It is assumed here that is not\nthe case; so be careful that outside of quoted strings and comments that\nonly ASCII-7-bit characters are used to write the actual coding instructions. Some editors might try to be “helpful” and change ASCII quote and dash\ncharacters to other characters when editing UTF-8 files, so be aware\nyou might need to normalize your source files into the allowed Fortran\ncharacter set. When using Unicode as byte streams avoid list-directed output. It\ndoes not know which bytes are composing a glyph and may split lines at\ninappropriate points. Compiler Support: Even with standard features, compiler support for Unicode in source\n   files can vary. Some compilers might require specific flags (e.g.,\n   -qmbcs for XL Fortran) or might offer better integration with\n   system-level Unicode functionalities. Source File Encoding: The encoding of the Fortran source file itself is crucial. If the\n    file is saved in a Unicode encoding like UTF-8, the compiler needs\n   to be able to correctly interpret these characters during compilation. Limitations: While modern Fortran can handle Unicode characters, there might still be\nlimitations compared to languages like C++ regarding the ease of use with\ncomplex Unicode features (e.g., surrogate pairs, text directionality, normalization). In summary: While it is possible to include multibyte Unicode characters in Fortran\nsource files, especially with modern Fortran standards and supportive\ncompilers, it requires careful consideration of the compiler’s\ncapabilities and the source file’s encoding. ## References Initially based on a discussion begun in\nhttps://fortran-lang.discourse.group/t/how-to-use-utf-8-in-gfortran/9949, 2025-08;\nincluding features and enhancements from Francois Jacq. The improvements include procedures for handling ASCII encoding extensions\noften used for internationalization that pre-date Unicode, such as the\nLatin encodings now in module\nThe M_isolatin . The intent is for the M_unicode module to be useful on many platforms, but currently\nit is primarily tested with GCC/gfortran and Intel/ifx on Linux and Cygwin. program testit use iso_fortran_env , only : stdout => output_unit use M_unicode implicit none type ( unicode_type ) :: uline !open (stdout, encoding='UTF-8') ! preferred, but not required if not supported uline = 'Hello World and Ni Hao -- 你好  ' ) write ( stdout , * ) character ( str ) ! convert to intrinsic CHARACTER variable write ( stdout , * ) len ( str ) write ( stdout , * ) len_trim ( str ) write ( stdout , * ) str ( 27 : 28 ) write ( stdout , * ) index ( uline , '你' ) ! OOPS write ( stdout , * ) str % character ( len ( str ), 1 , - 1 ) ! reverse string write ( stdout , * ) str % codes ! Unicode code point values end program testit See Also https://fortran-lang.discourse.group/t/how-to-use-utf-8-in-gfortran/9949 https://fortran-lang.discourse.group/t/how-do-i-file-read-french-special-characters-like-e-etc/6618 https://fortran-lang.discourse.group/t/using-unicode-characters-in-fortran/2764 Developer Info John S. Urban","tags":"home","url":"index.html"},{"title":"unicode_type – M_unicode ","text":"type, public :: unicode_type Constructor public        interface unicode_type private module function new_codes(codes) result(new) Arguments Type Intent Optional Attributes Name integer, intent(in) :: codes (:) Return Value type( unicode_type ) private elemental module function new_str(string) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Return Value type( unicode_type ) Type-Bound Procedures procedure, public :: adjustl => oop_adjustl private  function oop_adjustl(self) result(string_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self Return Value type( unicode_type ) procedure, public :: adjustr => oop_adjustr private  function oop_adjustr(self) result(string_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self Return Value type( unicode_type ) procedure, public :: character => oop_character private  function oop_character(self, first, last, step) result(bytes_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self integer, intent(in), optional :: first integer, intent(in), optional :: last integer, intent(in), optional :: step Return Value character(len=:), allocatable procedure, public :: codepoint => oop_codepoint private  function oop_codepoint(self, first, last, step) result(codes_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self integer, intent(in), optional :: first integer, intent(in), optional :: last integer, intent(in), optional :: step Return Value integer, allocatable, (:) procedure, public :: index => oop_index private impure function oop_index(self, substring) result(index_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self class(*), intent(in) :: substring Return Value integer procedure, public :: len => oop_len private pure function oop_len(self) result(len_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self Return Value integer procedure, public :: len_trim => oop_len_trim private pure function oop_len_trim(self) result(len_trim_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self Return Value integer procedure, public :: lower => oop_lower private  function oop_lower(self) result(string_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self Return Value type( unicode_type ) procedure, public :: split => oop_split private  function oop_split(self, set) result(tokens) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self type( unicode_type ), intent(in) :: set Return Value type( unicode_type ), allocatable, (:) procedure, public :: tokenize => oop_tokenize procedure  ::  sort           =>  oop_sort private  function oop_tokenize(self, set) result(tokens) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self type( unicode_type ), intent(in) :: set Return Value type( unicode_type ), allocatable, (:) procedure, public :: trim => oop_trim private pure function oop_trim(self) result(string_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self Return Value type( unicode_type ) procedure, public :: upper => oop_upper private  function oop_upper(self) result(string_out) Arguments Type Intent Optional Attributes Name class( unicode_type ), intent(in) :: self Return Value type( unicode_type ) Source Code type :: unicode_type ! Unicode string type holding an arbitrary sequence of integer codes. !sequence ! not used for storage association; a kludge to prevent extending this type. private integer , allocatable :: codes (:) contains ! METHODS: procedure :: character => oop_character procedure :: codepoint => oop_codepoint procedure :: adjustl => oop_adjustl procedure :: adjustr => oop_adjustr procedure :: index => oop_index procedure :: len => oop_len procedure :: len_trim => oop_len_trim procedure :: trim => oop_trim procedure :: split => oop_split procedure :: tokenize => oop_tokenize !  procedure  ::  scan           =>  oop_scan !  procedure  ::  verify         =>  oop_verify !! procedure  ::  sort           =>  oop_sort procedure :: upper => oop_upper procedure :: lower => oop_lower !DECLARATION OF OVERLOADED OPERATORS FOR TYPE(UNICODE_TYPE) procedure , private :: eq => oop_eq !   generic           :: operator(==) => eq !   procedure,private :: ge => oop_ge !   generic           :: operator(>=) => oop_ge !   procedure,private :: lt => oop_lt !   generic           :: operator(<)  => oop_lt !   procedure,private :: gt => oop_gt !   generic           :: operator(>)  => oop_gt !   procedure,private :: le => oop_le !   generic           :: operator(<=) => oop_le !   procedure,private :: ne => oop_ne !   generic           :: operator(/=) => oop_ne !   procedure,private :: string_append_value !   generic           :: operator(//) => string_append_value end type unicode_type","tags":"","url":"type/unicode_type.html"},{"title":"printwords – M_unicode","text":"impure elemental subroutine printwords(line) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: line Source Code impure elemental subroutine printwords ( line ) type ( ut ), intent ( in ) :: line pos = 0 write ( * , g ) line % character (), len ( line ) do while ( pos < len ( line )) first = pos + 1 call split ( line , delims , pos ) last = pos - 1 print g , line % character ( first , last ), first , last , pos end do end subroutine printwords","tags":"","url":"proc/printwords.html"},{"title":"getargs – M_unicode","text":"function getargs() result(command_line) Arguments None Return Value character(len=:), allocatable Variables Type Visibility Attributes Name Initial integer, public :: length Source Code function getargs () result ( command_line ) integer :: length character ( len = :), allocatable :: command_line call get_command ( length = length ) ! get command line length allocate ( character ( len = length ) :: command_line ) ! allocate string big enough to hold command line call get_command ( command = command_line ) ! get command line as a string call get_command_argument ( 0 , length = length ) ! remove argument 0 command_line = adjustl ( command_line ( length + 1 :)) end function getargs","tags":"","url":"proc/getargs.html"},{"title":"ucs4_to_utf8 – M_unicode","text":"function ucs4_to_utf8(ucs4_string) result(corrected) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*), intent(in) :: ucs4_string Return Value character(len=:), allocatable Variables Type Visibility Attributes Name Initial character(len=len=(len(ucs4_string)*4)), public :: line integer, public :: lun Source Code function ucs4_to_utf8 ( ucs4_string ) result ( corrected ) character ( len =* , kind = ucs4 ), intent ( in ) :: ucs4_string character ( len = :), allocatable :: corrected character ( len = ( len ( ucs4_string ) * 4 )) :: line integer :: lun open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) write ( lun , '(A)' ) ucs4_string rewind ( lun ) open ( unit = lun , encoding = 'default' ) read ( lun , '(A)' ) line close ( lun ) corrected = trim ( line ) end function ucs4_to_utf8","tags":"","url":"proc/ucs4_to_utf8.html"},{"title":"utf8_to_ucs4 – M_unicode","text":"function utf8_to_ucs4(string) result(corrected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(kind=ucs4, len=:), allocatable Variables Type Visibility Attributes Name Initial character(kind=ucs4, len=len=(len(string))), public :: line integer, public :: lun Source Code function utf8_to_ucs4 ( string ) result ( corrected ) character ( len =* ), intent ( in ) :: string character ( len = :, kind = ucs4 ), allocatable :: corrected character ( len = ( len ( string )), kind = ucs4 ) :: line integer :: lun open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) write ( lun , '(A)' ) string rewind ( lun ) read ( lun , '(A)' ) line close ( lun ) corrected = trim ( line ) end function utf8_to_ucs4","tags":"","url":"proc/utf8_to_ucs4.html"},{"title":"lower – M_unicode","text":"public pure elemental function lower(str) result(string) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: str Return Value type( unicode_type ) Source Code elemental pure function lower ( str ) result ( string ) ! ident_25=\"@(#) M_strings lower(3f) returns an lowercase string\" type ( unicode_type ), intent ( in ) :: str ! input string to convert to all lowercase type ( unicode_type ) :: string ! output string that contains no miniscule letters integer :: i ! loop counter integer , parameter :: ade_a = iachar ( 'A' ), ade_z = iachar ( 'Z' ) integer , parameter :: diff = iachar ( 'A' ) - iachar ( 'a' ) string = str do i = 1 , len ( str ) ! step thru each letter in the string in specified range select case ( str % codes ( i )) case ( ade_a : ade_z ) string % codes ( i ) = str % codes ( i ) - diff end select enddo if ( len ( str ). eq . 0 ) string = str end function lower","tags":"","url":"proc/lower.html"},{"title":"upper – M_unicode","text":"public pure elemental function upper(str) result(string) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: str Return Value type( unicode_type ) Source Code elemental pure function upper ( str ) result ( string ) ! ident_25=\"@(#) M_strings upper(3f) returns an uppercase string\" type ( unicode_type ), intent ( in ) :: str ! input string to convert to all uppercase type ( unicode_type ) :: string ! output string that contains no miniscule letters integer :: i ! loop counter integer , parameter :: ade_a = iachar ( 'a' ), ade_z = iachar ( 'z' ) integer , parameter :: diff = iachar ( 'A' ) - iachar ( 'a' ) string = str do i = 1 , len ( str ) ! step thru each letter in the string in specified range select case ( str % codes ( i )) case ( ade_a : ade_z ) string % codes ( i ) = str % codes ( i ) + diff end select enddo if ( len ( str ). eq . 0 ) string = str end function upper","tags":"","url":"proc/upper.html"},{"title":"sort_quick_rx – M_unicode","text":"public  subroutine sort_quick_rx(data, indx) NAME sort_quick_rx(3f) - [M_unicode:sort:quicksort] indexed hybrid quicksort of an array\n(LICENSE:PD) SYNOPSIS subroutine sort_quick_rx(data,index)\n\n      type(unicode_type),intent(in) :: data(:)\n      integer,intent(out)           :: indx(size(data)) DESCRIPTION A rank hybrid quicksort . The data is not moved . An integer array is generated instead with values that are indices to the sorted order of the data . This requires a second array the size of the input array , which for large arrays would require a significant amount of memory . One major advantage of this method is that the indices can be used to access an entire user - defined type in sorted order . This makes this seemingly simple sort procedure usuable with the vast majority of user - defined types . or other correlated data . BACKGROUND From Leonard J . Moss of SLAC : Here ' s a hybrid QuickSort I wrote a number of years ago . It ' s based on suggestions in Knuth , Volume 3 , and performs much better than a pure QuickSort on short or partially ordered input arrays . This routine performs an in - memory sort of the first N elements of array DATA , returning into array INDEX the indices of elements of DATA arranged in ascending order . Thus , DATA ( INDX ( 1 )) will be the smallest number in array DATA ; DATA ( INDX ( N )) will be the largest number in DATA . The original data is not physically rearranged . The original order of equal input values is not necessarily preserved . sort_quick_rx ( 3f ) uses a hybrid QuickSort algorithm , based on several suggestions in Knuth , Volume 3 , Section 5.2.2 . In particular , the \"pivot key\" [ my term ] for dividing each subsequence is chosen to be the median of the first , last , and middle values of the subsequence ; and the QuickSort is cut off when a subsequence has 9 or fewer elements , and a straight insertion sort of the entire array is done at the end . The result is comparable to a pure insertion sort for very short arrays , and very fast for very large arrays ( of order 12 micro - sec / element on the 3081 K for arrays of 10 K elements ). It is also not subject to the poor performance of the pure QuickSort on partially ordered data . Complex values are sorted by the magnitude of sqrt ( r ** 2 + i ** 2 ). o Created : sortrx ( 3f ) : 15 Jul 1986 , Len Moss o saved from url = ( 0044 ) http : //www.fortran.com/fortran/quick_sort2.f o changed to update syntax from F77 style ; John S . Urban 20161021 o generalized from only real values to include other intrinsic types ; John S . Urban 20210110 o type ( unicode_type ) version JSU 2025-09 -20. See M_sort for other types . EXAMPLES Sample usage: program demo_sort_quick_rx use M_unicode , only : sort_quick_rx , unicode_type , assignment ( = ) implicit none character ( len =* ), parameter :: g = '( * ( g0 ))' integer , parameter :: isz = 4 type ( unicode_type ) :: rr ( isz ) integer :: ii ( isz ) integer :: i write ( * , g )' sort array with sort_quick_rx ( 3f )' rr ( 1 ) = \"the\" rr ( 2 ) = \"quick\" rr ( 3 ) = \"brown\" rr ( 4 ) = \"fox\" call sort_quick_rx ( rr , ii ) write ( * , g )' original order ' do i = 1 , size ( rr ) write ( * , g ) rr ( i ) % character () enddo write ( * , g )' sorted order ' do i = 1 , size ( rr ) write ( * , g ) rr ( ii ( i )) % character () enddo end program demo_sort_quick_rx Results: Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: data (:) integer(kind=int32), intent(out) :: indx (:) Source Code subroutine sort_quick_rx ( data , indx ) ! ident_30=\"@(#) M_unicode sort_quick_rx(3f) indexed hybrid quicksort of a type(unicode_type) array\" type ( unicode_type ), intent ( in ) :: data (:) integer ( kind = int32 ), intent ( out ) :: indx (:) type ( unicode_type ) :: datap integer ( kind = int32 ) :: n integer ( kind = int32 ) :: lstk ( 31 ), rstk ( 31 ), istk integer ( kind = int32 ) :: l , r , i , j , p , indexp , indext !  QuickSort Cutoff ! !  Quit QuickSort-ing when a subsequence contains M or fewer elements and finish off at end with straight insertion sort. !  According to Knuth, V.3, the optimum value of M is around 9. integer , parameter :: M = 9 !=================================================================================================================================== n = size ( data ) if ( size ( indx ). lt . n ) then ! if index is not big enough, only sort part of the data write ( * , * ) '*sort_quick_rx* ERROR: insufficient space to store index data' n = size ( indx ) endif !=================================================================================================================================== !  Make initial guess for INDEX do i = 1 , n indx ( i ) = i enddo !  If array is short go directly to the straight insertion sort, else execute a QuickSort if ( N . gt . M ) then !============================================================================================================================= !  QuickSort ! !  The \"Qn:\"s correspond roughly to steps in Algorithm Q, Knuth, V.3, PP.116-117, modified to select the median !  of the first, last, and middle elements as the \"pivot key\" (in Knuth's notation, \"K\"). Also modified to leave !  data in place and produce an INDEX array. To simplify comments, let DATA[I]=DATA(INDX(I)). ! Q1: Initialize istk = 0 l = 1 r = n !============================================================================================================================= TOP : do ! Q2: Sort the subsequence DATA[L]..DATA[R]. ! !  At this point, DATA[l] <= DATA[m] <= DATA[r] for all l < L, r > R, and L <= m <= R. !  (First time through, there is no DATA for l < L or r > R.) i = l j = r ! Q2.5: Select pivot key ! !  Let the pivot, P, be the midpoint of this subsequence, P=(L+R)/2; then rearrange INDX(L), INDX(P), and INDX(R) !  so the corresponding DATA values are in increasing order. The pivot key, DATAP, is then DATA[P]. p = ( l + r ) / 2 indexp = indx ( p ) datap = data ( indexp ) if ( data ( indx ( l )) . gt . datap ) then indx ( p ) = indx ( l ) indx ( l ) = indexp indexp = indx ( p ) datap = data ( indexp ) endif if ( datap . gt . data ( indx ( r ))) then if ( data ( indx ( l )) . gt . data ( indx ( r ))) then indx ( p ) = indx ( l ) indx ( l ) = indx ( r ) else indx ( p ) = indx ( r ) endif indx ( r ) = indexp indexp = indx ( p ) datap = data ( indexp ) endif !  Now we swap values between the right and left sides and/or move DATAP until all smaller values are on the left and all !  larger values are on the right. Neither the left or right side will be internally ordered yet; however, DATAP will be !  in its final position. Q3 : do ! Q3: Search for datum on left >= DATAP !   At this point, DATA[L] <= DATAP. We can therefore start scanning up from L, looking for a value >= DATAP !   (this scan is guaranteed to terminate since we initially placed DATAP near the middle of the subsequence). I = I + 1 if ( data ( indx ( i )). lt . datap ) then cycle Q3 endif !----------------------------------------------------------------------------------------------------------------------- ! Q4: Search for datum on right <= DATAP ! !   At this point, DATA[R] >= DATAP. We can therefore start scanning down from R, looking for a value <= DATAP !   (this scan is guaranteed to terminate since we initially placed DATAP near the middle of the subsequence). Q4 : do j = j - 1 if ( data ( indx ( j )). le . datap ) then exit Q4 endif enddo Q4 !----------------------------------------------------------------------------------------------------------------------- ! Q5: Have the two scans collided? if ( i . lt . j ) then ! Q6: No, interchange DATA[I] <--> DATA[J] and continue indext = indx ( i ) indx ( i ) = indx ( j ) indx ( j ) = indext cycle Q3 else ! Q7: Yes, select next subsequence to sort !   At this point, I >= J and DATA[l] <= DATA[I] == DATAP <= DATA[r], for all L <= l < I and J < r <= R. !   If both subsequences are more than M elements long, push the longer one on the stack !   and go back to QuickSort the shorter; if only one is more than M elements long, go back and QuickSort it; !   otherwise, pop a subsequence off the stack and QuickSort it. if ( r - j . ge . i - l . and . i - l . gt . m ) then istk = istk + 1 lstk ( istk ) = j + 1 rstk ( istk ) = r r = i - 1 else if ( i - l . gt . r - j . and . r - j . gt . m ) then istk = istk + 1 lstk ( istk ) = l rstk ( istk ) = i - 1 l = j + 1 else if ( r - j . gt . m ) then l = j + 1 else if ( i - l . gt . m ) then r = i - 1 else ! Q8: Pop the stack, or terminate QuickSort if empty if ( istk . lt . 1 ) then exit TOP endif l = lstk ( istk ) r = rstk ( istk ) istk = istk - 1 endif cycle TOP endif ! never get here, as cycle Q3 or cycle TOP enddo Q3 exit TOP enddo TOP endif !=================================================================================================================================== ! Q9: Straight Insertion sort do i = 2 , n if ( data ( indx ( i - 1 )) . gt . data ( indx ( i ))) then indexp = indx ( i ) datap = data ( indexp ) p = i - 1 INNER : do indx ( p + 1 ) = indx ( p ) p = p - 1 if ( p . le . 0 ) then exit INNER endif if ( data ( indx ( p )). le . datap ) then exit INNER endif enddo INNER indx ( p + 1 ) = indexp endif enddo !=================================================================================================================================== !     All done end subroutine sort_quick_rx","tags":"","url":"proc/sort_quick_rx.html"},{"title":"adjustl – M_unicode","text":"public interface adjustl Module Procedures private elemental function adjustl_str(string) result(adjusted) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value type( unicode_type )","tags":"","url":"interface/adjustl.html"},{"title":"adjustr – M_unicode","text":"public interface adjustr Module Procedures private elemental function adjustr_str(string) result(adjusted) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value type( unicode_type )","tags":"","url":"interface/adjustr.html"},{"title":"assignment(=) – M_unicode","text":"public interface assignment(=) Module Procedures private elemental subroutine assign_str_char(lhs, rhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(inout) :: lhs character(len=*), intent(in) :: rhs private  subroutine assign_str_codes(lhs, rhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(inout) :: lhs integer, intent(in) :: rhs (:)","tags":"","url":"interface/assignment(=).html"},{"title":"character – M_unicode","text":"public interface character Module Procedures private pure function char_str(string) result(aline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value character(len=:), allocatable private pure function char_str_range(string, first, last) result(aline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in) :: first integer, intent(in) :: last Return Value character(len=:), allocatable private pure function char_str_range_step(string, first, last, step) result(aline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in) :: first integer, intent(in) :: last integer, intent(in) :: step Return Value character(len=:), allocatable","tags":"","url":"interface/character.html"},{"title":"codepoints_to_utf8 – M_unicode","text":"public interface codepoints_to_utf8 Module Procedures private pure subroutine codepoints_to_utf8_str(unicode, utf8, nerr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unicode (:) character(len=:), intent(out), allocatable :: utf8 integer, intent(out) :: nerr private pure subroutine codepoints_to_utf8_chars(unicode, utf8, nerr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unicode (:) character(len=1), intent(out), allocatable :: utf8 (:) integer, intent(out) :: nerr","tags":"","url":"interface/codepoints_to_utf8.html"},{"title":"index – M_unicode","text":"public interface index Module Procedures private elemental function index_str_str(string, substring) result(foundat) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: substring Return Value integer private elemental function index_str_char(string, substring) result(foundat) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string character(len=*), intent(in) :: substring Return Value integer private elemental function index_char_str(string, substring) result(foundat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( unicode_type ), intent(in) :: substring Return Value integer","tags":"","url":"interface/index.html"},{"title":"len – M_unicode","text":"public interface len Module Procedures private elemental function len_str(string) result(length) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value integer","tags":"","url":"interface/len.html"},{"title":"len_trim – M_unicode","text":"public interface len_trim Module Procedures private elemental function len_trim_str(string) result(length) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value integer","tags":"","url":"interface/len_trim.html"},{"title":"leq – M_unicode","text":"public interface leq Module Procedures private elemental function leq_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function leq_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function leq_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/leq.html"},{"title":"lge – M_unicode","text":"public interface lge Module Procedures private elemental function lge_str_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lge_str_char(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lge_char_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/lge.html"},{"title":"lgt – M_unicode","text":"public interface lgt Module Procedures private elemental function lgt_str_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lgt_str_char(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lgt_char_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/lgt.html"},{"title":"lle – M_unicode","text":"public interface lle Module Procedures private elemental function lle_str_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lle_str_char(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lle_char_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/lle.html"},{"title":"llt – M_unicode","text":"public interface llt Module Procedures private elemental function llt_str_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function llt_str_char(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function llt_char_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/llt.html"},{"title":"lne – M_unicode","text":"public interface lne Module Procedures private elemental function lne_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lne_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lne_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/lne.html"},{"title":"operator(//) – M_unicode","text":"public interface operator(//) Module Procedures private elemental function concat_str_str(lhs, rhs) result(lhsrhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value type( unicode_type ) private elemental function concat_str_char(lhs, rhs) result(lhsrhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value type( unicode_type ) private elemental function concat_char_str(lhs, rhs) result(lhsrhs) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value type( unicode_type )","tags":"","url":"interface/operator(SLASHSLASH).html"},{"title":"operator(/=) – M_unicode","text":"public interface operator(/=) Module Procedures private elemental function lne_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lne_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lne_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(SLASH=).html"},{"title":"operator(<) – M_unicode","text":"public interface operator(<) Module Procedures private elemental function llt_str_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function llt_str_char(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function llt_char_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(lt).html"},{"title":"operator(<=) – M_unicode","text":"public interface operator(<=) Module Procedures private elemental function lle_str_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lle_str_char(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lle_char_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(lt=).html"},{"title":"operator(==) – M_unicode","text":"public interface operator(==) Module Procedures private elemental function leq_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function leq_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function leq_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(==).html"},{"title":"operator(>) – M_unicode","text":"public interface operator(>) Module Procedures private elemental function lgt_str_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lgt_str_char(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lgt_char_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(gt).html"},{"title":"operator(>=) – M_unicode","text":"public interface operator(>=) Module Procedures private elemental function lge_str_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lge_str_char(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lge_char_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(gt=).html"},{"title":"repeat – M_unicode","text":"public interface repeat Module Procedures private elemental function repeat_str(string, ncopies) result(repeated_str) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in) :: ncopies Return Value type( unicode_type )","tags":"","url":"interface/repeat.html"},{"title":"split – M_unicode","text":"public interface split Module Procedures private impure subroutine split_first_last(string, set, first, last) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set integer, intent(out), allocatable :: first (:) integer, intent(out), allocatable :: last (:) private impure subroutine split_pos(string, set, pos, back) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set integer, intent(inout) :: pos logical, intent(in), optional :: back private impure subroutine split_tokens(string, set, tokens, separator) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set type( unicode_type ), intent(out), allocatable :: tokens (:) type( unicode_type ), intent(out), optional, allocatable :: separator (:)","tags":"","url":"interface/split.html"},{"title":"tokenize – M_unicode","text":"public interface tokenize Module Procedures private impure subroutine split_first_last(string, set, first, last) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set integer, intent(out), allocatable :: first (:) integer, intent(out), allocatable :: last (:) private impure subroutine split_pos(string, set, pos, back) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set integer, intent(inout) :: pos logical, intent(in), optional :: back private impure subroutine split_tokens(string, set, tokens, separator) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set type( unicode_type ), intent(out), allocatable :: tokens (:) type( unicode_type ), intent(out), optional, allocatable :: separator (:)","tags":"","url":"interface/tokenize.html"},{"title":"trim – M_unicode","text":"public interface trim Module Procedures private elemental function trim_str(string) result(trimmed_str) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value type( unicode_type )","tags":"","url":"interface/trim.html"},{"title":"unicode_type – M_unicode","text":"public interface unicode_type Functions private module function new_codes(codes) result(new) Arguments Type Intent Optional Attributes Name integer, intent(in) :: codes (:) Return Value type( unicode_type ) private elemental module function new_str(string) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Return Value type( unicode_type )","tags":"","url":"interface/unicode_type.html"},{"title":"utf8_to_codepoints – M_unicode","text":"public interface utf8_to_codepoints Module Procedures private pure subroutine utf8_to_codepoints_str(utf8, unicode, nerr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: utf8 integer, intent(out), allocatable :: unicode (:) integer, intent(out) :: nerr private pure subroutine utf8_to_codepoints_chars(utf8, unicode, nerr) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: utf8 (:) integer, intent(out), allocatable :: unicode (:) integer, intent(out) :: nerr","tags":"","url":"interface/utf8_to_codepoints.html"},{"title":"check – M_unicode","text":"subroutine check(label, test) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label logical, intent(in) :: test Source Code subroutine check ( label , test ) character ( len =* ), intent ( in ) :: label logical , intent ( in ) :: test write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , test ), ' ' , label if (. not . test ) total = total + 1 end subroutine check","tags":"","url":"proc/check.html"},{"title":"checkit – M_unicode","text":"subroutine checkit(label, aline, answer, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label character(len=*), intent(in) :: aline character(len=*), intent(in) :: answer character(len=*), intent(in) :: expected Source Code subroutine checkit ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline character ( len =* ), intent ( in ) :: answer character ( len =* ), intent ( in ) :: expected write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , answer . eq . expected ), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( answer . ne . expected ) total = total + 1 end subroutine checkit","tags":"","url":"proc/checkit.html"},{"title":"checkits – M_unicode","text":"subroutine checkits(label, aline, answer, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label character(len=*), intent(in) :: aline character(len=*), intent(in) :: answer (:) character(len=*), intent(in) :: expected (:) Source Code subroutine checkits ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline character ( len =* ), intent ( in ) :: answer (:) character ( len =* ), intent ( in ) :: expected (:) write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , all ( answer . eq . expected )), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( all ( answer . ne . expected )) total = total + 1 end subroutine checkits","tags":"","url":"proc/checkits.html"},{"title":"checkits_l – M_unicode","text":"subroutine checkits_l(label, aline, answer, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label character(len=*), intent(in) :: aline logical, intent(in) :: answer (:) logical, intent(in) :: expected (:) Source Code subroutine checkits_l ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline logical , intent ( in ) :: answer (:) logical , intent ( in ) :: expected (:) write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , all ( answer . eqv . expected )), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( all ( answer . neqv . expected )) total = total + 1 end subroutine checkits_l","tags":"","url":"proc/checkits_l.html"},{"title":"M_unicode – M_unicode","text":"In computing, Unicode characters are typically sorted using one of two methods: a simple binary code point sort or a more sophisticated,\nlanguage-sensitive collation. The correct approach depends on whether a\nlinguistically accurate “alphabetical” order is needed or if a simple,\nfixed order is sufficient. Binary code point sort This is the simplest and fastest method, often used as a default by\nprogramming languages and databases. How it works: Strings are sorted based on the numeric value of their underlying Unicode code points . For example , a character with a code point of U + 0061 ( lowercase \"a\" ) will always be placed before U + 0062 ( lowercase \"b\" ) because 97 is less than 98. Limitations: While this works for the basic English alphabet , it produces non - intuitive results for other characters because the code point value does not correlate with linguistic sorting rules . For instance , it may place: Uppercase letters before all lowercase letters ( Z comes before a ). Accented letters in an order that is not linguistically correct for a given language ( e . g ., in German , an umlauted character like ö might be sorted differently than a plain o ). Characters from different scripts ( like Latin , Greek , and Cyrillic ) in an order determined solely by their assigned code point blocks . Unicode Collation Algorithm (UCA) This is the standard, more robust method for sorting that produces\ncorrect, language-sensitive results. It is described in Unicode Technical\nStandard #10. How it works: Instead of sorting by a single numeric value , the UCA uses a multi - level approach to determine a sort key for each string . The algorithm takes into account the specific rules ( or \"tailorings\" ) of a given language or locale , which are defined in the Common Locale Data Repository ( CLDR ). Multi - level sorting: The UCA uses a hierarchy of weights for each character: Primary: Compares the base letter , ignoring case and accents . This groups all versions of \"a\" ( a , á , A , Á ) together . Secondary: Compares accents and diacritics . This establishes the order for different versions of the same base letter ( e . g ., o , ó , ô ). Tertiary: Compares case differences ( uppercase vs . lowercase ). Quaternary: Deals with other special features , such as handling punctuation . Locale - specific rules: The UCA can apply different rules based on a user ' s location . For example: In German phonebooks , umlauted letters ( ä ) are often sorted as if they were ae . In other contexts , they are sorted with their base letter ( a ). The correct sorting order for Chinese characters can be based on pronunciation ( Pinyin ) or stroke count , depending on the dictionary or region . How to choose a sorting method Use binary sorting for performance when linguistic order doesn ' t matter . This is fine for internal data processing where you just need a consistent , quick sort . Use the UCA for user - facing applications where culturally appropriate sorting is critical . If your application supports multiple languages , you must use a language - sensitive collator to provide the sorting users will expect . Most modern programming languages and databases have built - in libraries that implement the Unicode Collation Algorithm . Uses iso_fortran_env Interfaces public        interface adjustl private elemental function adjustl_str(string) result(adjusted) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value type( unicode_type ) public        interface adjustr private elemental function adjustr_str(string) result(adjusted) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value type( unicode_type ) public        interface assignment(=) private elemental subroutine assign_str_char(lhs, rhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(inout) :: lhs character(len=*), intent(in) :: rhs private  subroutine assign_str_codes(lhs, rhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(inout) :: lhs integer, intent(in) :: rhs (:) public        interface character private pure function char_str(string) result(aline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value character(len=:), allocatable private pure function char_str_range(string, first, last) result(aline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in) :: first integer, intent(in) :: last Return Value character(len=:), allocatable private pure function char_str_range_step(string, first, last, step) result(aline) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in) :: first integer, intent(in) :: last integer, intent(in) :: step Return Value character(len=:), allocatable public        interface codepoints_to_utf8 private pure subroutine codepoints_to_utf8_str(unicode, utf8, nerr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unicode (:) character(len=:), intent(out), allocatable :: utf8 integer, intent(out) :: nerr private pure subroutine codepoints_to_utf8_chars(unicode, utf8, nerr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: unicode (:) character(len=1), intent(out), allocatable :: utf8 (:) integer, intent(out) :: nerr public        interface index private elemental function index_str_str(string, substring) result(foundat) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: substring Return Value integer private elemental function index_str_char(string, substring) result(foundat) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string character(len=*), intent(in) :: substring Return Value integer private elemental function index_char_str(string, substring) result(foundat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( unicode_type ), intent(in) :: substring Return Value integer public        interface len private elemental function len_str(string) result(length) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value integer public        interface len_trim private elemental function len_trim_str(string) result(length) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value integer public        interface leq private elemental function leq_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function leq_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function leq_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface lge private elemental function lge_str_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lge_str_char(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lge_char_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface lgt private elemental function lgt_str_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lgt_str_char(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lgt_char_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface lle private elemental function lle_str_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lle_str_char(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lle_char_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface llt private elemental function llt_str_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function llt_str_char(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function llt_char_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface lne private elemental function lne_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lne_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lne_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface operator(//) private elemental function concat_str_str(lhs, rhs) result(lhsrhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value type( unicode_type ) private elemental function concat_str_char(lhs, rhs) result(lhsrhs) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value type( unicode_type ) private elemental function concat_char_str(lhs, rhs) result(lhsrhs) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value type( unicode_type ) public        interface operator(/=) private elemental function lne_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lne_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lne_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface operator(<) private elemental function llt_str_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function llt_str_char(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function llt_char_str(lhs, rhs) result(is_llt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface operator(<=) private elemental function lle_str_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lle_str_char(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lle_char_str(lhs, rhs) result(is_lle) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface operator(==) private elemental function leq_char_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function leq_str_char(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function leq_str_str(lhs, rhs) result(is_equal) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface operator(>) private elemental function lgt_str_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lgt_str_char(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lgt_char_str(lhs, rhs) result(is_lgt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface operator(>=) private elemental function lge_str_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical private elemental function lge_str_char(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lge_char_str(lhs, rhs) result(is_lge) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( unicode_type ), intent(in) :: rhs Return Value logical public        interface repeat private elemental function repeat_str(string, ncopies) result(repeated_str) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string integer, intent(in) :: ncopies Return Value type( unicode_type ) public        interface split private impure subroutine split_first_last(string, set, first, last) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set integer, intent(out), allocatable :: first (:) integer, intent(out), allocatable :: last (:) private impure subroutine split_pos(string, set, pos, back) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set integer, intent(inout) :: pos logical, intent(in), optional :: back private impure subroutine split_tokens(string, set, tokens, separator) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set type( unicode_type ), intent(out), allocatable :: tokens (:) type( unicode_type ), intent(out), optional, allocatable :: separator (:) public        interface tokenize private impure subroutine split_first_last(string, set, first, last) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set integer, intent(out), allocatable :: first (:) integer, intent(out), allocatable :: last (:) private impure subroutine split_pos(string, set, pos, back) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set integer, intent(inout) :: pos logical, intent(in), optional :: back private impure subroutine split_tokens(string, set, tokens, separator) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string type( unicode_type ), intent(in) :: set type( unicode_type ), intent(out), allocatable :: tokens (:) type( unicode_type ), intent(out), optional, allocatable :: separator (:) public        interface trim private elemental function trim_str(string) result(trimmed_str) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: string Return Value type( unicode_type ) public        interface unicode_type private module function new_codes(codes) result(new) Arguments Type Intent Optional Attributes Name integer, intent(in) :: codes (:) Return Value type( unicode_type ) private elemental module function new_str(string) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Return Value type( unicode_type ) public        interface utf8_to_codepoints private pure subroutine utf8_to_codepoints_str(utf8, unicode, nerr) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: utf8 integer, intent(out), allocatable :: unicode (:) integer, intent(out) :: nerr private pure subroutine utf8_to_codepoints_chars(utf8, unicode, nerr) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: utf8 (:) integer, intent(out), allocatable :: unicode (:) integer, intent(out) :: nerr Derived Types type, public :: unicode_type Constructor private\n\n                    module\n                    function new_codes (codes) private\n\n                    elemental, module\n                    function new_str (string) Type-Bound Procedures procedure, public :: adjustl => oop_adjustl procedure, public :: adjustr => oop_adjustr procedure, public :: character => oop_character procedure, public :: codepoint => oop_codepoint procedure, public :: index => oop_index procedure, public :: len => oop_len procedure, public :: len_trim => oop_len_trim procedure, public :: lower => oop_lower procedure, public :: split => oop_split procedure, public :: tokenize => oop_tokenize procedure  ::  sort           =>  oop_sort procedure, public :: trim => oop_trim procedure, public :: upper => oop_upper Functions public pure elemental function lower (str) result(string) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: str Return Value type( unicode_type ) public pure elemental function upper (str) result(string) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: str Return Value type( unicode_type ) Subroutines public  subroutine sort_quick_rx (data, indx) Sample usage: Read more… Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: data (:) integer(kind=int32), intent(out) :: indx (:)","tags":"","url":"module/m_unicode.html"},{"title":"demo_split – M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial type( unicode_type ), allocatable :: array (:) type( unicode_type ) :: delims integer :: first character(len=*), parameter :: g = '(*(g0,1x))' integer :: i integer :: last integer :: pos type( unicode_type ) :: proverb type( unicode_type ) :: word Subroutines impure elemental subroutine printwords (line) Arguments Type Intent Optional Attributes Name type( unicode_type ), intent(in) :: line Source Code program demo_split use M_unicode , only : split , unicode_type , assignment ( = ), len , character use M_unicode , only : ut => unicode_type implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' type ( ut ) :: proverb type ( ut ) :: delims type ( ut ), allocatable :: array (:) type ( ut ) :: word integer :: first integer :: last integer :: pos integer :: i delims = '=|; ' proverb = \"Más vale pájaro en mano, que ciento volando.\" call printwords ( proverb ) ! there really are not spaces between these glyphs array = [ & ut ( \"七転び八起き。\" ), & ut ( \"転んでもまた立ち上がる。\" ), & ut ( \"くじけずに前を向いて歩いていこう。& \" )] call printwords ( array ) write ( * , g ) 'OOP' array = proverb % split ( ut ( ' ' )) write ( * , '(*(:\"[\",a,\"]\"))' )( character ( array ( i )), i = 1 , size ( array )) contains impure elemental subroutine printwords ( line ) type ( ut ), intent ( in ) :: line pos = 0 write ( * , g ) line % character (), len ( line ) do while ( pos < len ( line )) first = pos + 1 call split ( line , delims , pos ) last = pos - 1 print g , line % character ( first , last ), first , last , pos end do end subroutine printwords end program demo_split","tags":"","url":"program/demo_split.html"},{"title":"demo_upper – M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0))' type( unicode_type ) :: pangram type( unicode_type ) :: upper_pangram Source Code program demo_upper use M_unicode , only : upper , unicode_type , assignment ( = ) implicit none character ( len =* ), parameter :: g = '(*(g0))' type ( unicode_type ) :: pangram type ( unicode_type ) :: upper_pangram ! a sentence containing every letter of the English alphabet pangram = \"The quick brown fox jumps over the lazy dog.\" write ( * , g ) pangram % character () upper_pangram = upper ( pangram ) write ( * , g ) upper_pangram % character () end program demo_upper","tags":"","url":"program/demo_upper.html"},{"title":"assign_exe – M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=:), allocatable :: aline character(len=*), parameter :: g = '(*(g0))' character(len=*), parameter :: smiley = '😃' type( unicode_type ) :: substring type( unicode_type ) :: uline Source Code program assign_exe use M_unicode , only : len , len_trim , repeat , trim , adjustr , adjustl use M_unicode , only : character use M_unicode , only : assignment ( = ), unicode_type character ( len =* ), parameter :: g = '(*(g0))' character ( len = :), allocatable :: aline type ( unicode_type ) :: uline , substring character ( len =* ), parameter :: smiley = '😃' aline = \"Доки не впріти, доти не вміти.\" write ( * , g ) '123456789012345678901234567890' write ( * , g ) aline write ( * , g ) 'length in bytes is: ' , len ( aline ) uline = aline write ( * , g ) 'length in glyphs is: ' , len ( uline ) write ( * , g ) 'string is: ' , character ( uline ) write ( * , g ) 'third word is: ' , character ( uline , 9 , 14 ) ! substring substring = character ( uline , 17 , 29 ) write ( * , g ) 'string is: ' , character ( substring ) uline = repeat ( smiley , 30 ) write ( * , g ) character ( uline ) write ( * , g ) len_trim ( uline ) uline = aline // '      ' write ( * , g ) len_trim ( uline ) uline = [ 32 , 160 , 8192 , 8193 , 8194 , 8195 , 8196 , 8197 , 8198 , 8199 , 8200 , 8201 , 8202 , 8239 , 8287 , 12288 ] write ( * , g ) 'spaces:' , character ( uline ), len ( uline ), len_trim ( uline ) uline = [ 32 , 160 , 8192 , 8193 , 8194 , 8195 , 8196 , 8197 , 8198 , 8199 , 8200 , 8201 , 8202 , 8239 , 8287 , 12288 ] uline = trim ( uline ) write ( * , g ) 'trim:' , '[' , character ( uline ), ']' uline = '    this  is just a    string        ' write ( * , g ) 'adjustr:' , '[' , character ( uline ), '] ==> [' , character ( adjustr ( uline )), ']' uline = '    this  is just a    string        ' write ( * , g ) 'adjustl:' , '[' , character ( uline ), '] ==> [' , character ( adjustl ( uline )), ']' !write(*,g)uline%codes !write(*,g)uline end program assign_exe","tags":"","url":"program/assign_exe.html"},{"title":"test_for_iso_10646 – M_unicode","text":"Uses M_unicode iso_fortran_env Variables Type Attributes Name Initial type( unicode_type ) :: smiley Source Code program test_for_iso_10646 use M_unicode use iso_fortran_env , only : output_unit implicit none type ( unicode_type ) :: smiley smiley = [ int ( z '1F603' )] open ( output_unit , encoding = 'utf-8' ) write ( * , * ) 'Smiling face with open mouth' , smiley % character () ! 😃 end program test_for_iso_10646","tags":"","url":"program/test_for_iso_10646.html"},{"title":"demo_sort_quick_rx – M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0))' integer :: i integer :: ii (isz) integer, parameter :: isz = 4 type( unicode_type ) :: rr (isz) Source Code program demo_sort_quick_rx use M_unicode , only : sort_quick_rx , unicode_type , assignment ( = ) use M_unicode , only : ut => unicode_type implicit none character ( len =* ), parameter :: g = '(*(g0))' integer , parameter :: isz = 4 type ( unicode_type ) :: rr ( isz ) integer :: ii ( isz ) integer :: i write ( * , g ) 'sort array with sort_quick_rx(3f)' rr = [ & ut ( \"the\" ), & ut ( \"quick\" ), & ut ( \"brown\" ), & ut ( \"fox\" ) ] call sort_quick_rx ( rr , ii ) write ( * , g ) 'original order' do i = 1 , size ( rr ) write ( * , g ) rr ( i )% character () enddo write ( * , g ) 'sorted order' do i = 1 , size ( rr ) write ( * , g ) rr ( ii ( i ))% character () enddo end program demo_sort_quick_rx","tags":"","url":"program/demo_sort_quick_rx.html"},{"title":"uni_to_ftn – M_unicode","text":"Uses iso_fortran_env Variables Type Attributes Name Initial character(len=:), allocatable :: command_line character(len=*), parameter :: form = '(\"char(int(z''\",z0,\"''),kind=ucs4)\":,\"// &\")' character(len=*), parameter :: g = '(*(g0))' integer :: i integer, parameter :: ucs4 = selected_char_kind('ISO_10646') character(kind=ucs4, len=:), allocatable :: ustr Functions function getargs () result(command_line) Arguments None Return Value character(len=:), allocatable function ucs4_to_utf8 (ucs4_string) result(corrected) Arguments Type Intent Optional Attributes Name character(kind=ucs4, len=*), intent(in) :: ucs4_string Return Value character(len=:), allocatable function utf8_to_ucs4 (string) result(corrected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(kind=ucs4, len=:), allocatable Source Code program uni_to_ftn ! @(#) take command line argument utf-8 text and generate Fortran statement that represents the string use , intrinsic :: iso_fortran_env , only : output_unit implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* ), parameter :: form = '(\"char(int(z''\",z0,\"''),kind=ucs4)\":,\"// &\")' character ( len =* ), parameter :: g = '(*(g0))' integer :: i character ( len = :), allocatable :: command_line character ( len = :, kind = ucs4 ), allocatable :: ustr command_line = getargs () ! get string containing all command arguments as CHARACTER bytes ustr = utf8_to_ucs4 ( command_line ) ! convert bytes to internal Fortran Unicode representation ! write the command line out as a Fortran variable expression using the CHAR() function open ( output_unit , encoding = 'UTF-8' ) write ( * , g ) '! ENCODING:' , command_line write ( * , g ) 'character(len=*,kind=ucs4),parameter :: variable= &' write ( * , form )( ustr ( i : i ), i = 1 , len ( ustr )) contains function getargs () result ( command_line ) integer :: length character ( len = :), allocatable :: command_line call get_command ( length = length ) ! get command line length allocate ( character ( len = length ) :: command_line ) ! allocate string big enough to hold command line call get_command ( command = command_line ) ! get command line as a string call get_command_argument ( 0 , length = length ) ! remove argument 0 command_line = adjustl ( command_line ( length + 1 :)) end function getargs function utf8_to_ucs4 ( string ) result ( corrected ) character ( len =* ), intent ( in ) :: string character ( len = :, kind = ucs4 ), allocatable :: corrected character ( len = ( len ( string )), kind = ucs4 ) :: line integer :: lun open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) write ( lun , '(A)' ) string rewind ( lun ) read ( lun , '(A)' ) line close ( lun ) corrected = trim ( line ) end function utf8_to_ucs4 function ucs4_to_utf8 ( ucs4_string ) result ( corrected ) character ( len =* , kind = ucs4 ), intent ( in ) :: ucs4_string character ( len = :), allocatable :: corrected character ( len = ( len ( ucs4_string ) * 4 )) :: line integer :: lun open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) write ( lun , '(A)' ) ucs4_string rewind ( lun ) open ( unit = lun , encoding = 'default' ) read ( lun , '(A)' ) line close ( lun ) corrected = trim ( line ) end function ucs4_to_utf8 end program uni_to_ftn","tags":"","url":"program/uni_to_ftn.html"},{"title":"crow_and_fox – M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial integer :: i type(unicode_type), allocatable :: poem (:) Source Code program crow_and_fox use M_unicode , only : unicode_type , ut => unicode_type , character , len ! “The Crow and the Fox” by Jean de la Fontaine type ( unicode_type ), allocatable :: poem (:) integer :: i poem = [& ut ( 'Maître Corbeau, sur un arbre perché,' ), & ut ( 'Tenait en son bec un fromage.' ), & ut ( 'Maître Renard, par l’odeur alléché,' ), & ut ( 'Lui tint à peu près ce langage :' ), & ut ( '«Hé ! bonjour, Monsieur du Corbeau.' ), & ut ( 'Que vous êtes joli ! que vous me semblez beau !' ), & ut ( 'Sans mentir, si votre ramage' ), & ut ( 'Se rapporte à votre plumage,' ), & ut ( 'Vous êtes le Phénix des hôtes de ces bois.»' ), & ut ( 'A ces mots le Corbeau ne se sent pas de joie ;' ), & ut ( 'Et pour montrer sa belle voix,' ), & ut ( 'Il ouvre un large bec, laisse tomber sa proie.' ), & ut ( 'Le Renard s’en saisit, et dit : «Mon bon Monsieur,' ), & ut ( 'Apprenez que tout flatteur' ), & ut ( 'Vit aux dépens de celui qui l’écoute :' ), & ut ( 'Cette leçon vaut bien un fromage, sans doute.»' ), & ut ( 'Le Corbeau, honteux et confus,' ), & ut ( 'Jura, mais un peu tard, qu’on ne l’y prendrait plus.' ), & ut ( ' -- Jean de la Fontaine' )] write ( * , '(g0)' )( character ( poem ( i )), i = 1 , size ( poem )) write ( * , '(a)' ) write ( * , '(*(a))' )( poem ( i )% codepoint (), new_line ( 'a' ), i = 1 , size ( poem )) write ( * , '(a)' ) write ( * , '(*(g0))' )( character ( poem ( i )), len ( poem ( i )), ' ' , len ( poem ( i )% character ()), new_line ( 'a' ), i = 1 , size ( poem )) end program crow_and_fox","tags":"","url":"program/crow_and_fox.html"},{"title":"count_glyphs – M_unicode","text":"Uses M_unicode iso_fortran_env Variables Type Attributes Name Initial character(len=1024) :: aline character(len=*), parameter :: g = '(*(g0))' character(len=255) :: iomsg integer :: iostat integer :: length type( unicode_type ) :: uline Source Code program count_glyphs ! @(#) read a utf-8 file and write it out with lines prefixed with glyph count of the line use , intrinsic :: iso_fortran_env , only : output_unit , input_unit use M_unicode implicit none intrinsic is_iostat_end character ( len =* ), parameter :: g = '(*(g0))' integer :: length integer :: iostat character ( len = 1024 ) :: aline type ( unicode_type ) :: uline character ( len = 255 ) :: iomsg do read ( input_unit , '(a)' , iostat = iostat , iomsg = iomsg ) aline if ( iostat . eq . 0 ) then uline = trim ( aline ) length = len_trim ( uline ) write ( output_unit , '(i9,\": \",a)' ) length , uline % character ( 1 , length ) elseif ( is_iostat_end ( iostat )) then exit else write ( output_unit , g ) '<ERROR>' , trim ( iomsg ) exit endif enddo end program count_glyphs","tags":"","url":"program/count_glyphs.html"},{"title":"demo_lower – M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial character(len=*), parameter :: g = '(*(g0))' type( unicode_type ) :: lower_pangram type( unicode_type ) :: pangram Source Code program demo_lower use M_unicode , only : lower , unicode_type , assignment ( = ) implicit none character ( len =* ), parameter :: g = '(*(g0))' type ( unicode_type ) :: pangram type ( unicode_type ) :: lower_pangram ! a sentence containing every letter of the English alphabet pangram = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\" write ( * , g ) pangram % character () lower_pangram = lower ( pangram ) write ( * , g ) lower_pangram % character () end program demo_lower","tags":"","url":"program/demo_lower.html"},{"title":"note – M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial integer, parameter :: pointer (*) = [int(z'1FBC1'), int(z'1FBC2'), int(z'1FBC3')] type( unicode_type ) :: uline Source Code program note use M_unicode implicit none integer , parameter :: pointer ( * ) = [ int ( z '1FBC1' ), int ( z '1FBC2' ), int ( z '1FBC3' )] type ( unicode_type ) :: uline uline = pointer write ( * , '(*(g0))' ) uline % character () end program note","tags":"","url":"program/note.html"},{"title":"demo_tokenize – M_unicode","text":"Uses M_unicode Variables Type Attributes Name Initial integer, allocatable, dimension(:) :: begins type( unicode_type ) :: delims integer, allocatable, dimension(:) :: ends character(len=*), parameter :: g0 = '(*(g0))' character(len=*), parameter :: g1 = '(*(g0,1x))' type( unicode_type ) :: herbs integer :: i type( unicode_type ), allocatable :: separators (:) type( unicode_type ), allocatable :: tokens (:) Source Code program demo_tokenize use M_unicode , only : assignment ( = ), unicode_type , tokenize , len , character character ( len =* ), parameter :: g0 = '(*(g0))' character ( len =* ), parameter :: g1 = '(*(g0,1x))' type ( unicode_type ), allocatable :: tokens (:) type ( unicode_type ), allocatable :: separators (:) type ( unicode_type ) :: delims type ( unicode_type ) :: herbs integer , allocatable , dimension (:) :: begins integer , allocatable , dimension (:) :: ends integer :: i delims = ',&' herbs = 'parsley,sage,rosemary,&thyme' write ( * , * ) herbs % character () write ( * , g0 ) write ( * , g0 ) 'expecting' write ( * , g0 ) ' tokens    =[parsley][sage][rosemary][][thyme]' write ( * , g0 ) ' separators=,,,&' CALL TOKENIZE ( herbs , delims , tokens , separators ) write ( * , g0 ) 'got' write ( * , g0 ) \" tokens    =\" ,( '[' // tokens ( i )% character (), ']' , i = 1 , size ( tokens )) write ( * , g0 ) \" separators=\" ,( separators ( i )% character (), i = 1 , size ( separators )) write ( * , g0 ) write ( * , g0 ) 'expecting' write ( * , * ) 'begins=' ,[ 1 , 9 , 14 , 23 , 24 ] write ( * , * ) 'ends=  ' ,[ 7 , 12 , 21 , 22 , 28 ] CALL TOKENIZE ( herbs , delims , begins , ends ) write ( * , g0 ) 'got' write ( * , * ) 'begins=' , begins write ( * , * ) 'ends=  ' , ends write ( * , g0 ) write ( * , g0 ) 'OOP' tokens = herbs % tokenize ( delims ) write ( * , g0 ) \" tokens    =\" ,( '[' // tokens ( i )% character (), ']' , i = 1 , size ( tokens )) herbs = 'parsley/sage/rosemary//thyme' delims = '/' tokens = herbs % tokenize ( delims ) write ( * , g0 ) \" tokens    =\" ,( '[' // tokens ( i )% character (), ']' , i = 1 , size ( tokens )) herbs = 'parsley😃sage😃rosemary😃😃thyme' delims = '😃' write ( * , g0 ) ' ' , delims % character () write ( * , g1 ) ' ' , delims % codepoint () tokens = herbs % tokenize ( delims ) write ( * , g0 ) \" tokens    =\" ,( '[' // tokens ( i )% character (), ']' , i = 1 , size ( tokens )) end program demo_tokenize","tags":"","url":"program/demo_tokenize.html"},{"title":"bom_exe – M_unicode","text":"Uses M_unicode iso_fortran_env Variables Type Attributes Name Initial type( unicode_type ) :: U_BOM Source Code program bom_exe ! ! create a Fortran source file starting with a utf-8 BOM to see if your ! compiler will compile it or fail because a character is not in the ! Fortran character set outside of a comment or literal string ! use iso_fortran_env , only : stdout => output_unit use M_unicode implicit none type ( unicode_type ) :: U_BOM U_bom = [ int ( z 'FEFF' )] write ( stdout , '(a)' , advance = 'no' ) U_bom % character () write ( stdout , '(a)' ) & 'program testit ! Unicode BOM encoded to utf-8 bytes by Fortran' ,& '   write(*,*)\"File starts with BOM from UCS-4 write!\"' ,& 'end program testit' end program bom_exe","tags":"","url":"program/bom_exe.html"},{"title":"test_id – M_unicode","text":"Uses iso_fortran_env Variables Type Attributes Name Initial integer :: break character(len=*), parameter :: nl = new_line('a') character(len=:), allocatable :: options integer :: start character(len=:), allocatable :: version integer :: where Source Code program test_id use , intrinsic :: iso_fortran_env , only : compiler_version use , intrinsic :: iso_fortran_env , only : compiler_options implicit none character ( len = :), allocatable :: version , options character ( len =* ), parameter :: nl = new_line ( 'a' ) integer :: where , start , break version = compiler_version () options = ' ' // compiler_options () start = 1 do where = index ( options ( start :), ' -' ) if ( where . eq . 0 ) exit break = where + start - 1 options ( break : break ) = nl start = where enddo if ( start . eq . 1 ) then do where = index ( options ( start :), ' /' ) if ( where . eq . 0 ) exit break = where + start - 1 options ( break : break ) = nl start = where enddo endif print '(*(1x,a))' , & 'This file was compiled by ' , & version , nl , & 'using the options ' , & options end program test_id","tags":"","url":"program/test_id.html"},{"title":"test_M_unicode – M_unicode","text":"Uses M_unicode iso_fortran_env Variables Type Attributes Name Initial logical, parameter :: F = .false. logical, parameter :: T = .true. character(len=:), allocatable :: astr character(len=*), parameter :: g0 = '(*(g0))' integer :: i type( unicode_type ) :: lhs type( unicode_type ) :: rhs type( unicode_type ) :: smiley type( unicode_type ) :: string type( unicode_type ) :: substring integer :: total character(len=*), parameter :: upagain = \"七転び八起き。転んでもまた立ち上がる。くじけずに前を向いて歩いていこう。\" type( unicode_type ) :: ut_str Subroutines subroutine check (label, test) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label logical, intent(in) :: test subroutine checkit (label, aline, answer, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label character(len=*), intent(in) :: aline character(len=*), intent(in) :: answer character(len=*), intent(in) :: expected subroutine checkits (label, aline, answer, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label character(len=*), intent(in) :: aline character(len=*), intent(in) :: answer (:) character(len=*), intent(in) :: expected (:) subroutine checkits_l (label, aline, answer, expected) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: label character(len=*), intent(in) :: aline logical, intent(in) :: answer (:) logical, intent(in) :: expected (:) Source Code program test_M_unicode use iso_fortran_env , only : output_unit use M_unicode , only : adjustl , adjustr , trim , index use M_unicode , only : character use M_unicode , only : assignment ( = ), unicode_type , operator ( // ) use M_unicode , only : operator ( <= ), lle use M_unicode , only : operator ( < ), llt use M_unicode , only : operator ( /= ), lne use M_unicode , only : operator ( == ), leq use M_unicode , only : operator ( > ), lgt use M_unicode , only : operator ( >= ), lge implicit none character ( len =* ), parameter :: g0 = '(*(g0))' logical , parameter :: T = . true . logical , parameter :: F = . false . ! character ( len =* ), parameter :: upagain = \"七転び八起き。転んでもまた立ち上がる。くじけずに前を向いて歩いていこう。\" ! Romanization: ! Nanakorobi yaoki. Koronde mo mata tachiagaru. Kujikezu ni mae o muite aruite ikou. ! or English translation ! \"Fall seven times, stand up eight. Even if you fall down, you will get up again. Don't be discouraged, just keep walking forward.\" ! character ( len = :), allocatable :: astr type ( unicode_type ) :: ut_str type ( unicode_type ) :: smiley integer :: total integer :: i type ( unicode_type ) :: lhs , rhs type ( unicode_type ) :: string , substring smiley = '😃' total = 0 write ( * , g0 ) 'encoding can be altered on an open file' open ( output_unit , encoding = 'UTF-8' ) write ( * , g0 ) astr = 'Hello World and Ni Hao -- 你好' ut_str = astr call checkits ( 'convert to ASCII bytes' , astr , ut_str % bytes (), transfer ( 'Hello World and Ni Hao -- 你好' ,[ 'A' ])) astr = \"  this is a string    \" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), 'this is a string      ' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '      this is a string' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '  this is a string' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 18 ) call check ( 'len' , ut_str % len (). eq . 22 ) astr = \"  \" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), '  ' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '  ' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 0 ) call check ( 'len' , ut_str % len (). eq . 2 ) astr = \"\" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), '' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 0 ) call check ( 'len' , ut_str % len (). eq . 0 ) astr = \"ALLFULL\" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), 'ALLFULL' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), 'ALLFULL' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), 'ALLFULL' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 7 ) call check ( 'len' , ut_str % len (). eq . 7 ) ut_str = [ 32 , 32 , int ( z '1F603' ), 32 , 32 , 32 ] astr = character ( ut_str ) call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), '😃     ' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '     😃' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '  😃' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 3 ) call check ( 'len' , ut_str % len (). eq . 6 ) if ( total . ne . 0 ) then write ( * , g0 ) total , 'failures' stop 1 endif ut_str = smiley // ' and ' // smiley // 'and' // smiley // smiley // 'is it' astr = '😃 and 😃and😃😃is it' call checkit ( 'concatenation' , astr , character ( ut_str ), '😃 and 😃and😃😃is it' ) lhs = 'this is the left' rhs = 'this is the right' call checkits_l ( 'LLE' , ' ' , [ lle ( lhs , rhs ), lhs <= rhs , lle ( rhs , lhs ), rhs <= lhs ] , [ T , T , F , F ] ) call checkits_l ( 'LLT' , ' ' , [ llt ( lhs , rhs ), lhs < rhs , llt ( rhs , lhs ), rhs < lhs ] , [ T , T , F , F ] ) call checkits_l ( 'LNE' , ' ' , [ lne ( lhs , rhs ), lhs /= rhs , lne ( rhs , lhs ), rhs /= lhs ] , [ T , T , T , T ] ) call checkits_l ( 'LEQ' , ' ' , [ leq ( lhs , rhs ), lhs == rhs , leq ( rhs , lhs ), rhs == lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LGT' , ' ' , [ lgt ( lhs , rhs ), lhs > rhs , lgt ( rhs , lhs ), rhs > lhs ] , [ F , F , T , T ] ) call checkits_l ( 'LGE' , ' ' , [ lge ( lhs , rhs ), lhs >= rhs , lge ( rhs , lhs ), rhs >= lhs ] , [ F , F , T , T ] ) lhs = 'abc' rhs = 'abc ' call checkits_l ( 'LLE' , ' ' , [ lle ( lhs , rhs ), lhs <= rhs , lle ( rhs , lhs ), rhs <= lhs ] , [ T , T , T , T ] ) call checkits_l ( 'LLT' , ' ' , [ llt ( lhs , rhs ), lhs < rhs , llt ( rhs , lhs ), rhs < lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LNE' , ' ' , [ lne ( lhs , rhs ), lhs /= rhs , lne ( rhs , lhs ), rhs /= lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LEQ' , ' ' , [ leq ( lhs , rhs ), lhs == rhs , leq ( rhs , lhs ), rhs == lhs ] , [ T , T , T , T ] ) call checkits_l ( 'LGT' , ' ' , [ lgt ( lhs , rhs ), lhs > rhs , lgt ( rhs , lhs ), rhs > lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LGE' , ' ' , [ lge ( lhs , rhs ), lhs >= rhs , lge ( rhs , lhs ), rhs >= lhs ] , [ T , T , T , T ] ) string = \" can you find me here? \" substring = \"find me\" astr = character ( substring ) call check ( 'index ' // string % character () // ':' // substring % character (), index ( string , substring ). eq . 10 ) call check ( 'index ' // string % character () // ':' // astr , index ( string , astr ). eq . 10 ) string = \" can you find me here? \" substring = \"not there\" astr = character ( substring ) call check ( 'index ' // string % character () // ':' // substring % character (), index ( string , substring ). eq . 0 ) call check ( 'index ' // string % character () // ':' // astr , index ( string , astr ). eq . 0 ) string = \"short\" substring = \"shortnot\" astr = character ( substring ) call check ( 'index ' // string % character () // ':' // substring % character (), index ( string , substring ). eq . 0 ) call check ( 'index ' // string % character () // ':' // astr , index ( string , astr ). eq . 0 ) string = upagain write ( * , g0 ) 'original bytes  :' , upagain write ( * , g0 ) 'bytes reversed  :' , ( upagain ( i : i ), i = len ( upagain ), 1 , - 1 ) write ( * , g0 ) 'original string :' , string % character () write ( * , g0 ) 'string reversed :' , string % character ( string % len (), 1 , - 1 ) contains subroutine checkit ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline character ( len =* ), intent ( in ) :: answer character ( len =* ), intent ( in ) :: expected write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , answer . eq . expected ), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( answer . ne . expected ) total = total + 1 end subroutine checkit subroutine checkits ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline character ( len =* ), intent ( in ) :: answer (:) character ( len =* ), intent ( in ) :: expected (:) write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , all ( answer . eq . expected )), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( all ( answer . ne . expected )) total = total + 1 end subroutine checkits subroutine checkits_l ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline logical , intent ( in ) :: answer (:) logical , intent ( in ) :: expected (:) write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , all ( answer . eqv . expected )), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( all ( answer . neqv . expected )) total = total + 1 end subroutine checkits_l subroutine check ( label , test ) character ( len =* ), intent ( in ) :: label logical , intent ( in ) :: test write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , test ), ' ' , label if (. not . test ) total = total + 1 end subroutine check end program test_M_unicode","tags":"","url":"program/test_m_unicode.html"},{"title":"multi_line – M_unicode","text":"Uses M_unicode iso_fortran_env Variables Type Attributes Name Initial integer :: i integer :: longest type( unicode_type ), allocatable :: upagain (:) Source Code program multi_line use iso_fortran_env , only : output_unit use M_unicode use M_unicode , only : ut => unicode_type implicit none integer :: i , longest type ( ut ), allocatable :: upagain (:) upagain = [ & ! ROMANIZATION                         ! ENGLISH ut ( \"七転び八起き。\" ), & ! Nanakorobi yaoki.                    ! Fall seven times, stand up eight. ut ( \"転んでもまた立ち上がる。\" ), & ! Koronde mo mata tachiagaru.          ! Even if you fall down, you will get up again. ut ( \"くじけずに前を向いて歩いていこう。\" )] ! Kujikezu ni mae o muite aruite ikou. ! Don't be discouraged, just keep walking forward. ! open ( output_unit , encoding = 'UTF-8' ) longest = 0 ! get longest trimmed line do i = 1 , size ( upagain ) longest = max ( longest , len_trim ( upagain ( i ))) write ( * , * ) 'LEN=' , len_trim ( upagain ( i )) enddo write ( output_unit , * ) 'longest=' , longest write ( output_unit , * ) do i = 1 , size ( upagain ) write ( output_unit , '(g0)' ) character ( upagain ( i )), len_trim ( upagain ( i )) enddo end program multi_line","tags":"","url":"program/multi_line.html"},{"title":"demo_split.f90 – M_unicode","text":"Source Code program demo_split use M_unicode , only : split , unicode_type , assignment ( = ), len , character use M_unicode , only : ut => unicode_type implicit none character ( len =* ), parameter :: g = '(*(g0,1x))' type ( ut ) :: proverb type ( ut ) :: delims type ( ut ), allocatable :: array (:) type ( ut ) :: word integer :: first integer :: last integer :: pos integer :: i delims = '=|; ' proverb = \"Más vale pájaro en mano, que ciento volando.\" call printwords ( proverb ) ! there really are not spaces between these glyphs array = [ & ut ( \"七転び八起き。\" ), & ut ( \"転んでもまた立ち上がる。\" ), & ut ( \"くじけずに前を向いて歩いていこう。& \" )] call printwords ( array ) write ( * , g ) 'OOP' array = proverb % split ( ut ( ' ' )) write ( * , '(*(:\"[\",a,\"]\"))' )( character ( array ( i )), i = 1 , size ( array )) contains impure elemental subroutine printwords ( line ) type ( ut ), intent ( in ) :: line pos = 0 write ( * , g ) line % character (), len ( line ) do while ( pos < len ( line )) first = pos + 1 call split ( line , delims , pos ) last = pos - 1 print g , line % character ( first , last ), first , last , pos end do end subroutine printwords end program demo_split","tags":"","url":"sourcefile/demo_split.f90.html"},{"title":"demo_upper.f90 – M_unicode","text":"Source Code program demo_upper use M_unicode , only : upper , unicode_type , assignment ( = ) implicit none character ( len =* ), parameter :: g = '(*(g0))' type ( unicode_type ) :: pangram type ( unicode_type ) :: upper_pangram ! a sentence containing every letter of the English alphabet pangram = \"The quick brown fox jumps over the lazy dog.\" write ( * , g ) pangram % character () upper_pangram = upper ( pangram ) write ( * , g ) upper_pangram % character () end program demo_upper","tags":"","url":"sourcefile/demo_upper.f90.html"},{"title":"sample.f90 – M_unicode","text":"Source Code program assign_exe use M_unicode , only : len , len_trim , repeat , trim , adjustr , adjustl use M_unicode , only : character use M_unicode , only : assignment ( = ), unicode_type character ( len =* ), parameter :: g = '(*(g0))' character ( len = :), allocatable :: aline type ( unicode_type ) :: uline , substring character ( len =* ), parameter :: smiley = '😃' aline = \"Доки не впріти, доти не вміти.\" write ( * , g ) '123456789012345678901234567890' write ( * , g ) aline write ( * , g ) 'length in bytes is: ' , len ( aline ) uline = aline write ( * , g ) 'length in glyphs is: ' , len ( uline ) write ( * , g ) 'string is: ' , character ( uline ) write ( * , g ) 'third word is: ' , character ( uline , 9 , 14 ) ! substring substring = character ( uline , 17 , 29 ) write ( * , g ) 'string is: ' , character ( substring ) uline = repeat ( smiley , 30 ) write ( * , g ) character ( uline ) write ( * , g ) len_trim ( uline ) uline = aline // '      ' write ( * , g ) len_trim ( uline ) uline = [ 32 , 160 , 8192 , 8193 , 8194 , 8195 , 8196 , 8197 , 8198 , 8199 , 8200 , 8201 , 8202 , 8239 , 8287 , 12288 ] write ( * , g ) 'spaces:' , character ( uline ), len ( uline ), len_trim ( uline ) uline = [ 32 , 160 , 8192 , 8193 , 8194 , 8195 , 8196 , 8197 , 8198 , 8199 , 8200 , 8201 , 8202 , 8239 , 8287 , 12288 ] uline = trim ( uline ) write ( * , g ) 'trim:' , '[' , character ( uline ), ']' uline = '    this  is just a    string        ' write ( * , g ) 'adjustr:' , '[' , character ( uline ), '] ==> [' , character ( adjustr ( uline )), ']' uline = '    this  is just a    string        ' write ( * , g ) 'adjustl:' , '[' , character ( uline ), '] ==> [' , character ( adjustl ( uline )), ']' !write(*,g)uline%codes !write(*,g)uline end program assign_exe","tags":"","url":"sourcefile/sample.f90.html"},{"title":"codepoint.f90 – M_unicode","text":"Source Code program test_for_iso_10646 use M_unicode use iso_fortran_env , only : output_unit implicit none type ( unicode_type ) :: smiley smiley = [ int ( z '1F603' )] open ( output_unit , encoding = 'utf-8' ) write ( * , * ) 'Smiling face with open mouth' , smiley % character () ! 😃 end program test_for_iso_10646","tags":"","url":"sourcefile/codepoint.f90.html"},{"title":"demo_sort_quick_rx.f90 – M_unicode","text":"Source Code program demo_sort_quick_rx use M_unicode , only : sort_quick_rx , unicode_type , assignment ( = ) use M_unicode , only : ut => unicode_type implicit none character ( len =* ), parameter :: g = '(*(g0))' integer , parameter :: isz = 4 type ( unicode_type ) :: rr ( isz ) integer :: ii ( isz ) integer :: i write ( * , g ) 'sort array with sort_quick_rx(3f)' rr = [ & ut ( \"the\" ), & ut ( \"quick\" ), & ut ( \"brown\" ), & ut ( \"fox\" ) ] call sort_quick_rx ( rr , ii ) write ( * , g ) 'original order' do i = 1 , size ( rr ) write ( * , g ) rr ( i )% character () enddo write ( * , g ) 'sorted order' do i = 1 , size ( rr ) write ( * , g ) rr ( ii ( i ))% character () enddo end program demo_sort_quick_rx","tags":"","url":"sourcefile/demo_sort_quick_rx.f90.html"},{"title":"read_commandline.f90 – M_unicode","text":"Source Code program uni_to_ftn ! @(#) take command line argument utf-8 text and generate Fortran statement that represents the string use , intrinsic :: iso_fortran_env , only : output_unit implicit none integer , parameter :: ucs4 = selected_char_kind ( 'ISO_10646' ) character ( len =* ), parameter :: form = '(\"char(int(z''\",z0,\"''),kind=ucs4)\":,\"// &\")' character ( len =* ), parameter :: g = '(*(g0))' integer :: i character ( len = :), allocatable :: command_line character ( len = :, kind = ucs4 ), allocatable :: ustr command_line = getargs () ! get string containing all command arguments as CHARACTER bytes ustr = utf8_to_ucs4 ( command_line ) ! convert bytes to internal Fortran Unicode representation ! write the command line out as a Fortran variable expression using the CHAR() function open ( output_unit , encoding = 'UTF-8' ) write ( * , g ) '! ENCODING:' , command_line write ( * , g ) 'character(len=*,kind=ucs4),parameter :: variable= &' write ( * , form )( ustr ( i : i ), i = 1 , len ( ustr )) contains function getargs () result ( command_line ) integer :: length character ( len = :), allocatable :: command_line call get_command ( length = length ) ! get command line length allocate ( character ( len = length ) :: command_line ) ! allocate string big enough to hold command line call get_command ( command = command_line ) ! get command line as a string call get_command_argument ( 0 , length = length ) ! remove argument 0 command_line = adjustl ( command_line ( length + 1 :)) end function getargs function utf8_to_ucs4 ( string ) result ( corrected ) character ( len =* ), intent ( in ) :: string character ( len = :, kind = ucs4 ), allocatable :: corrected character ( len = ( len ( string )), kind = ucs4 ) :: line integer :: lun open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) write ( lun , '(A)' ) string rewind ( lun ) read ( lun , '(A)' ) line close ( lun ) corrected = trim ( line ) end function utf8_to_ucs4 function ucs4_to_utf8 ( ucs4_string ) result ( corrected ) character ( len =* , kind = ucs4 ), intent ( in ) :: ucs4_string character ( len = :), allocatable :: corrected character ( len = ( len ( ucs4_string ) * 4 )) :: line integer :: lun open ( newunit = lun , encoding = 'UTF-8' , status = 'scratch' ) write ( lun , '(A)' ) ucs4_string rewind ( lun ) open ( unit = lun , encoding = 'default' ) read ( lun , '(A)' ) line close ( lun ) corrected = trim ( line ) end function ucs4_to_utf8 end program uni_to_ftn","tags":"","url":"sourcefile/read_commandline.f90.html"},{"title":"fox_and_crow.f90 – M_unicode","text":"Source Code program crow_and_fox use M_unicode , only : unicode_type , ut => unicode_type , character , len ! “The Crow and the Fox” by Jean de la Fontaine type ( unicode_type ), allocatable :: poem (:) integer :: i poem = [& ut ( 'Maître Corbeau, sur un arbre perché,' ), & ut ( 'Tenait en son bec un fromage.' ), & ut ( 'Maître Renard, par l’odeur alléché,' ), & ut ( 'Lui tint à peu près ce langage :' ), & ut ( '«Hé ! bonjour, Monsieur du Corbeau.' ), & ut ( 'Que vous êtes joli ! que vous me semblez beau !' ), & ut ( 'Sans mentir, si votre ramage' ), & ut ( 'Se rapporte à votre plumage,' ), & ut ( 'Vous êtes le Phénix des hôtes de ces bois.»' ), & ut ( 'A ces mots le Corbeau ne se sent pas de joie ;' ), & ut ( 'Et pour montrer sa belle voix,' ), & ut ( 'Il ouvre un large bec, laisse tomber sa proie.' ), & ut ( 'Le Renard s’en saisit, et dit : «Mon bon Monsieur,' ), & ut ( 'Apprenez que tout flatteur' ), & ut ( 'Vit aux dépens de celui qui l’écoute :' ), & ut ( 'Cette leçon vaut bien un fromage, sans doute.»' ), & ut ( 'Le Corbeau, honteux et confus,' ), & ut ( 'Jura, mais un peu tard, qu’on ne l’y prendrait plus.' ), & ut ( ' -- Jean de la Fontaine' )] write ( * , '(g0)' )( character ( poem ( i )), i = 1 , size ( poem )) write ( * , '(a)' ) write ( * , '(*(a))' )( poem ( i )% codepoint (), new_line ( 'a' ), i = 1 , size ( poem )) write ( * , '(a)' ) write ( * , '(*(g0))' )( character ( poem ( i )), len ( poem ( i )), ' ' , len ( poem ( i )% character ()), new_line ( 'a' ), i = 1 , size ( poem )) end program crow_and_fox","tags":"","url":"sourcefile/fox_and_crow.f90.html"},{"title":"count_glyphs.f90 – M_unicode","text":"Source Code program count_glyphs ! @(#) read a utf-8 file and write it out with lines prefixed with glyph count of the line use , intrinsic :: iso_fortran_env , only : output_unit , input_unit use M_unicode implicit none intrinsic is_iostat_end character ( len =* ), parameter :: g = '(*(g0))' integer :: length integer :: iostat character ( len = 1024 ) :: aline type ( unicode_type ) :: uline character ( len = 255 ) :: iomsg do read ( input_unit , '(a)' , iostat = iostat , iomsg = iomsg ) aline if ( iostat . eq . 0 ) then uline = trim ( aline ) length = len_trim ( uline ) write ( output_unit , '(i9,\": \",a)' ) length , uline % character ( 1 , length ) elseif ( is_iostat_end ( iostat )) then exit else write ( output_unit , g ) '<ERROR>' , trim ( iomsg ) exit endif enddo end program count_glyphs","tags":"","url":"sourcefile/count_glyphs.f90.html"},{"title":"demo_lower.f90 – M_unicode","text":"Source Code program demo_lower use M_unicode , only : lower , unicode_type , assignment ( = ) implicit none character ( len =* ), parameter :: g = '(*(g0))' type ( unicode_type ) :: pangram type ( unicode_type ) :: lower_pangram ! a sentence containing every letter of the English alphabet pangram = \"THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG\" write ( * , g ) pangram % character () lower_pangram = lower ( pangram ) write ( * , g ) lower_pangram % character () end program demo_lower","tags":"","url":"sourcefile/demo_lower.f90.html"},{"title":"note.f90 – M_unicode","text":"Source Code program note use M_unicode implicit none integer , parameter :: pointer ( * ) = [ int ( z '1FBC1' ), int ( z '1FBC2' ), int ( z '1FBC3' )] type ( unicode_type ) :: uline uline = pointer write ( * , '(*(g0))' ) uline % character () end program note","tags":"","url":"sourcefile/note.f90.html"},{"title":"demo_tokenize.f90 – M_unicode","text":"Source Code program demo_tokenize use M_unicode , only : assignment ( = ), unicode_type , tokenize , len , character character ( len =* ), parameter :: g0 = '(*(g0))' character ( len =* ), parameter :: g1 = '(*(g0,1x))' type ( unicode_type ), allocatable :: tokens (:) type ( unicode_type ), allocatable :: separators (:) type ( unicode_type ) :: delims type ( unicode_type ) :: herbs integer , allocatable , dimension (:) :: begins integer , allocatable , dimension (:) :: ends integer :: i delims = ',&' herbs = 'parsley,sage,rosemary,&thyme' write ( * , * ) herbs % character () write ( * , g0 ) write ( * , g0 ) 'expecting' write ( * , g0 ) ' tokens    =[parsley][sage][rosemary][][thyme]' write ( * , g0 ) ' separators=,,,&' CALL TOKENIZE ( herbs , delims , tokens , separators ) write ( * , g0 ) 'got' write ( * , g0 ) \" tokens    =\" ,( '[' // tokens ( i )% character (), ']' , i = 1 , size ( tokens )) write ( * , g0 ) \" separators=\" ,( separators ( i )% character (), i = 1 , size ( separators )) write ( * , g0 ) write ( * , g0 ) 'expecting' write ( * , * ) 'begins=' ,[ 1 , 9 , 14 , 23 , 24 ] write ( * , * ) 'ends=  ' ,[ 7 , 12 , 21 , 22 , 28 ] CALL TOKENIZE ( herbs , delims , begins , ends ) write ( * , g0 ) 'got' write ( * , * ) 'begins=' , begins write ( * , * ) 'ends=  ' , ends write ( * , g0 ) write ( * , g0 ) 'OOP' tokens = herbs % tokenize ( delims ) write ( * , g0 ) \" tokens    =\" ,( '[' // tokens ( i )% character (), ']' , i = 1 , size ( tokens )) herbs = 'parsley/sage/rosemary//thyme' delims = '/' tokens = herbs % tokenize ( delims ) write ( * , g0 ) \" tokens    =\" ,( '[' // tokens ( i )% character (), ']' , i = 1 , size ( tokens )) herbs = 'parsley😃sage😃rosemary😃😃thyme' delims = '😃' write ( * , g0 ) ' ' , delims % character () write ( * , g1 ) ' ' , delims % codepoint () tokens = herbs % tokenize ( delims ) write ( * , g0 ) \" tokens    =\" ,( '[' // tokens ( i )% character (), ']' , i = 1 , size ( tokens )) end program demo_tokenize","tags":"","url":"sourcefile/demo_tokenize.f90.html"},{"title":"M_unicode.f90 – M_unicode","text":"Source Code module M_unicode ! Unicode-related procedures not requiring compiler support of ISO-10646 ! first presented in https://fortran-lang.discourse.group/t/how-to-use-utf-8-in-gfortran/9949 ! including enhancements and latin support from Francois Jacq, 2025-08 ! use , intrinsic :: iso_fortran_env , only : error_unit , stderr => error_unit use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none private public :: utf8_to_codepoints , codepoints_to_utf8 public :: sort_quick_rx public :: split , tokenize public :: upper , lower private :: a2s , s2a public :: unicode_type public :: assignment ( = ) interface utf8_to_codepoints module procedure utf8_to_codepoints_str , utf8_to_codepoints_chars end interface utf8_to_codepoints interface codepoints_to_utf8 module procedure codepoints_to_utf8_str , codepoints_to_utf8_chars end interface codepoints_to_utf8 interface tokenize module procedure :: split_first_last , split_pos , split_tokens end interface tokenize interface split module procedure :: split_first_last , split_pos , split_tokens end interface split ! Assign a character sequence to a string. interface assignment ( = ) module procedure :: assign_str_char module procedure :: assign_str_codes end interface assignment ( = ) interface character module procedure :: char_str module procedure :: char_str_range module procedure :: char_str_range_step end interface character public :: character ! INTRINSIC COMPATIBILITY interface adjustl ; module procedure :: adjustl_str ; end interface adjustl interface adjustr ; module procedure :: adjustr_str ; end interface adjustr interface len ; module procedure :: len_str ; end interface len interface len_trim ; module procedure :: len_trim_str ; end interface len_trim interface repeat ; module procedure :: repeat_str ; end interface repeat interface trim ; module procedure :: trim_str ; end interface trim interface index ; module procedure :: index_str_str , index_str_char , index_char_str ; end interface index public :: adjustl , adjustr , index , len , len_trim , repeat , trim interface lle ; module procedure :: lle_str_str , lle_str_char , lle_char_str ; end interface lle interface llt ; module procedure :: llt_str_str , llt_str_char , llt_char_str ; end interface llt interface lne ; module procedure :: lne_char_str , lne_str_char , lne_str_str ; end interface lne interface leq ; module procedure :: leq_char_str , leq_str_char , leq_str_str ; end interface leq interface lgt ; module procedure :: lgt_str_str , lgt_str_char , lgt_char_str ; end interface lgt interface lge ; module procedure :: lge_str_str , lge_str_char , lge_char_str ; end interface lge interface operator ( <= ); module procedure :: lle_str_str , lle_str_char , lle_char_str ; end interface operator ( <= ) interface operator ( < ); module procedure :: llt_str_str , llt_str_char , llt_char_str ; end interface operator ( < ) interface operator ( /= ); module procedure :: lne_char_str , lne_str_char , lne_str_str ; end interface operator ( /= ) interface operator ( == ); module procedure :: leq_char_str , leq_str_char , leq_str_str ; end interface operator ( == ) interface operator ( > ); module procedure :: lgt_str_str , lgt_str_char , lgt_char_str ; end interface operator ( > ) interface operator ( >= ); module procedure :: lge_str_str , lge_str_char , lge_char_str ; end interface operator ( >= ) interface operator ( // ); module procedure :: concat_str_str , concat_str_char , concat_char_str ; end interface operator ( // ) public :: lle , llt , lne , leq , lgt , lge public :: operator ( <= ), operator ( < ), operator ( /= ), operator ( == ), operator ( > ), operator ( >= ), operator ( // ) type :: unicode_type ! Unicode string type holding an arbitrary sequence of integer codes. !sequence ! not used for storage association; a kludge to prevent extending this type. private integer , allocatable :: codes (:) contains ! METHODS: procedure :: character => oop_character procedure :: codepoint => oop_codepoint procedure :: adjustl => oop_adjustl procedure :: adjustr => oop_adjustr procedure :: index => oop_index procedure :: len => oop_len procedure :: len_trim => oop_len_trim procedure :: trim => oop_trim procedure :: split => oop_split procedure :: tokenize => oop_tokenize !  procedure  ::  scan           =>  oop_scan !  procedure  ::  verify         =>  oop_verify !! procedure  ::  sort           =>  oop_sort procedure :: upper => oop_upper procedure :: lower => oop_lower !DECLARATION OF OVERLOADED OPERATORS FOR TYPE(UNICODE_TYPE) procedure , private :: eq => oop_eq !   generic           :: operator(==) => eq !   procedure,private :: ge => oop_ge !   generic           :: operator(>=) => oop_ge !   procedure,private :: lt => oop_lt !   generic           :: operator(<)  => oop_lt !   procedure,private :: gt => oop_gt !   generic           :: operator(>)  => oop_gt !   procedure,private :: le => oop_le !   generic           :: operator(<=) => oop_le !   procedure,private :: ne => oop_ne !   generic           :: operator(/=) => oop_ne !   procedure,private :: string_append_value !   generic           :: operator(//) => string_append_value end type unicode_type ! Constructor for new string instances interface unicode_type elemental module function new_str ( string ) result ( new ) character ( len =* ), intent ( in ), optional :: string type ( unicode_type ) :: new end function new_str module function new_codes ( codes ) result ( new ) integer , intent ( in ) :: codes (:) type ( unicode_type ) :: new end function new_codes end interface unicode_type ! space U+0020 32 Common Basic Latin Separator, Most common (normal ! ASCII space) ! ! no-break space U+00A0 160 Common Latin-1 Supplement Separator, ! Non-breaking space: identical to U+0020, but not a point at which a line ! may be broken. ! ! en quad U+2000 8192 General Punctuation Separator, Width of one en. U+2002 ! is canonically equivalent to this character; U+2002 is preferred. ! ! em quad U+2001 8193   Common General Punctuation Separator, ! Also known as \"mutton quad\". Width of one em. U+2003 is ! canonically equivalent to this character; U+2003 is preferred. ! ! en space U+2002 8194   Common General Punctuation Separator, ! space Also known as \"nut\". Width of one en. U+2000 En Quad is ! canonically equivalent to this character; U+2002 is preferred. ! ! em space U+2003 8195  Common General Punctuation Separator, ! space Also known as \"mutton\". Width of one em. U+2001 Em Quad is ! canonically equivalent to this character; U+2003 is preferred. ! ! three-per-em space U+2004 8196 Common General Punctuation Separator, ! Also known as \"thick space\". One third of an em wide. ! ! four-per-em space U+2005 8197 Common General Punctuation Separator, ! space Also known as \"mid space\". One fourth of an em wide. ! ! six-per-em space U+2006 8198 Common General Punctuation Separator, ! space One sixth of an em wide. In computer typography, sometimes equated ! to U+2009. ! ! figure space U+2007 8199 Common General Punctuation Separator, In fonts ! with monospaced digits, equal to the width of one digit. ! ! punctuation space U+2008 8200 Common General Punctuation Separator, ! As wide as the narrow punctuation in a font, i.e. the advance width of ! the period or comma. ! ! thin space U+2009 8201 Common General Punctuation Separator, one-fifth ! (sometimes one-sixth) of an em wide.  Recommended for use as a thousands ! separator for measures made with SI units. Unlike U+2002 to U+2008, ! its width may get adjusted in typesetting. ! ! hair space U+200A 8202 Common General Punctuation Separator, space ! Thinner than a thin space. ! ! narrow no-break space U+202F 8239 Common General Punctuation Separator, ! Similar in function to U+00A0 ! ! No-Break Space. When used with Mongolian, its width is usually one third ! of the normal space; in other context, its width sometimes resembles ! that of the Thin Space (U+2009). ! ! medium mathematical space U+205F 8287   Common General Punctuation ! Separator, space MMSP. Used in mathematical formulae. Four-eighteenths ! of an em. In mathematical typography, the widths of spaces are usually ! given in integral multiples of an eighteenth of an em, and 4/18 em ! may be used in several situations, for example between the a and the + ! and between the + and the b in the expression a + b. ! ! ideographic space U+3000 12288 　 Yes No Common CJK Symbols and ! Punctuation Separator, As wide as a CJK character cell (fullwidth). Used, ! for example, in tai tou. integer , parameter :: G_SPACE = 32 integer , parameter :: G_SPACES ( * ) = [ 32 , 160 , 8192 , 8193 , 8194 , 8195 , 8196 , 8197 , 8198 , 8199 , 8200 , 8201 , 8202 , 8239 , 8287 , 12288 ] contains !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure subroutine codepoints_to_utf8_chars ( unicode , utf8 , nerr ) integer , intent ( in ) :: unicode (:) character , allocatable , intent ( out ) :: utf8 (:) integer , intent ( out ) :: nerr integer :: i , n_unicode , n_utf8 , cp character , allocatable :: temp_utf8 (:) n_unicode = size ( unicode ) allocate ( temp_utf8 ( 4 * n_unicode )) n_utf8 = 0 nerr = 0 do i = 1 , n_unicode cp = unicode ( i ) select case ( cp ) case ( 0 : 127 ) ! 1 byte : 0xxxxxxx n_utf8 = n_utf8 + 1 temp_utf8 ( n_utf8 ) = char ( cp ) case ( 128 : 2047 ) ! 2 bytes : 110xxxxx 10xxxxxx n_utf8 = n_utf8 + 2 temp_utf8 ( n_utf8 - 1 ) = char ( ior ( 192 , ishft ( cp , - 6 ))) temp_utf8 ( n_utf8 ) = char ( ior ( 128 , iand ( cp , 63 ))) case ( 2048 : 65535 ) ! 3 bytes : 1110xxxx 10xxxxxx 10xxxxxx if ( cp >= 55296 . and . cp <= 57343 ) then nerr = nerr + 1 n_utf8 = n_utf8 + 1 temp_utf8 ( n_utf8 ) = '?' cycle endif n_utf8 = n_utf8 + 3 temp_utf8 ( n_utf8 - 2 ) = char ( ior ( 224 , ishft ( cp , - 12 ))) temp_utf8 ( n_utf8 - 1 ) = char ( ior ( 128 , iand ( ishft ( cp , - 6 ), 63 ))) temp_utf8 ( n_utf8 ) = char ( ior ( 128 , iand ( cp , 63 ))) case ( 65536 : 1114111 ) ! 4 bytes : 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx n_utf8 = n_utf8 + 4 temp_utf8 ( n_utf8 - 3 ) = char ( ior ( 240 , ishft ( cp , - 18 ))) temp_utf8 ( n_utf8 - 2 ) = char ( ior ( 128 , iand ( ishft ( cp , - 12 ), 63 ))) temp_utf8 ( n_utf8 - 1 ) = char ( ior ( 128 , iand ( ishft ( cp , - 6 ), 63 ))) temp_utf8 ( n_utf8 ) = char ( ior ( 128 , iand ( cp , 63 ))) case default nerr = nerr + 1 n_utf8 = n_utf8 + 1 temp_utf8 ( n_utf8 ) = '?' end select enddo allocate ( utf8 ( n_utf8 )) utf8 = temp_utf8 ( 1 : n_utf8 ) end subroutine codepoints_to_utf8_chars !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure subroutine utf8_to_codepoints_chars ( utf8 , unicode , nerr ) ! in fact, this routine is also able to decode an ISOLATIN string character , intent ( in ) :: utf8 (:) integer , allocatable , intent ( out ) :: unicode (:) integer , intent ( out ) :: nerr integer :: n_out integer :: i , len8 , b1 , b2 , b3 , b4 integer :: cp , nbytes , nerr0 integer , allocatable :: temp (:) nerr = 0 len8 = size ( utf8 ) i = 1 n_out = 0 allocate ( temp ( len8 )) ! big enough to store all unicode values do while ( i <= len8 ) nerr0 = nerr b1 = ichar ( utf8 ( i )) if ( b1 < 0 ) b1 = b1 + 256 nbytes = 1 select case ( b1 ) case ( 0 : 127 ) cp = b1 case ( 192 : 223 ) if ( i + 1 > len8 ) then nbytes = len8 - i + 1 nerr = nerr + 1 cp = ICHAR ( '?' ) else nbytes = 2 b2 = ichar ( utf8 ( i + 1 )); if ( b2 < 0 ) b2 = b2 + 256 if ( iand ( b2 , 192 ) /= 128 ) then nerr = nerr + 1 cp = ICHAR ( '?' ) else cp = iand ( b1 , 31 ) cp = ishft ( cp , 6 ) + iand ( b2 , 63 ) endif endif case ( 224 : 239 ) if ( i + 2 > len8 ) then nbytes = len8 - i + 1 nerr = nerr + 1 cp = ICHAR ( '?' ) else nbytes = 3 b2 = ichar ( utf8 ( i + 1 )); if ( b2 < 0 ) b2 = b2 + 256 b3 = ichar ( utf8 ( i + 2 )); if ( b3 < 0 ) b3 = b3 + 256 if ( iand ( b2 , 192 ) /= 128 . or . iand ( b3 , 192 ) /= 128 ) then nerr = nerr + 1 cp = ICHAR ( '?' ) else cp = iand ( b1 , 15 ) cp = ishft ( cp , 6 ) + iand ( b2 , 63 ) cp = ishft ( cp , 6 ) + iand ( b3 , 63 ) endif endif case ( 240 : 247 ) if ( i + 3 > len8 ) then nbytes = len8 - i + 1 nerr = nerr + 1 cp = ICHAR ( '?' ) else nbytes = 4 b2 = ichar ( utf8 ( i + 1 )); if ( b2 < 0 ) b2 = b2 + 256 b3 = ichar ( utf8 ( i + 2 )); if ( b3 < 0 ) b3 = b3 + 256 b4 = ichar ( utf8 ( i + 3 )); if ( b4 < 0 ) b4 = b4 + 256 if ( iand ( b2 , 192 ) /= 128 . or . iand ( b3 , 192 ) /= 128 . or . iand ( b4 , 192 ) /= 128 ) then nerr = nerr + 1 cp = ICHAR ( '?' ) else cp = iand ( b1 , 7 ) cp = ishft ( cp , 6 ) + iand ( b2 , 63 ) cp = ishft ( cp , 6 ) + iand ( b3 , 63 ) cp = ishft ( cp , 6 ) + iand ( b4 , 63 ) endif endif case default nerr = nerr + 1 cp = ICHAR ( '?' ) end select if ( nerr0 /= nerr ) then ! This is an invalid UTF-8 start byte. We apply the heuristic ! and interpret it as an ISO-8859-15 character. select case ( b1 ) case ( 164 ); cp = 8364 ! Euro case ( 166 ); cp = 352 ! S caron case ( 168 ); cp = 353 ! s caron case ( 180 ); cp = 381 ! Z caron case ( 184 ); cp = 382 ! z caron case ( 188 ); cp = 338 ! OE case ( 189 ); cp = 339 ! oe case ( 190 ); cp = 376 ! Y trema case default cp = b1 ! For all other chars, the codepoint is the byte value end select nbytes = 1 endif n_out = n_out + 1 temp ( n_out ) = cp i = i + nbytes enddo allocate ( unicode ( n_out )) unicode = temp ( 1 : n_out ) end subroutine utf8_to_codepoints_chars !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure function a2s ( array ) result ( string ) ! @(#) M_strs a2s(3fp) function to copy char array to string character ( len = 1 ), intent ( in ) :: array (:) character ( len = SIZE ( array )) :: string integer :: i forall ( i = 1 : size ( array )) string ( i : i ) = array ( i ) !  string=transfer(array,string) end function a2s !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure function s2a ( string ) RESULT ( array ) ! @(#) M_strs s2a(3fp) function to copy string(1 Clen(string)) to char array character ( len =* ), intent ( in ) :: string character ( len = 1 ) :: array ( len ( string )) integer :: i forall ( i = 1 : len ( string )) array ( i ) = string ( i : i ) !  array=transfer(string,array) end function s2a !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure subroutine codepoints_to_utf8_str ( unicode , utf8 , nerr ) integer , intent ( in ) :: unicode (:) character ( len = :), allocatable , intent ( out ) :: utf8 integer , intent ( out ) :: nerr character , allocatable :: utf8_chars (:) nerr = 0 call codepoints_to_utf8_chars ( unicode , utf8_chars , nerr ) utf8 = a2s ( utf8_chars ) end subroutine codepoints_to_utf8_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== pure subroutine utf8_to_codepoints_str ( utf8 , unicode , nerr ) ! in fact, this routine is also able to decode an ISOLATIN string character ( len =* ), intent ( in ) :: utf8 integer , allocatable , intent ( out ) :: unicode (:) integer , intent ( out ) :: nerr character , allocatable :: temp (:) temp = s2a ( utf8 ) call utf8_to_codepoints_chars ( temp , unicode , nerr ) end subroutine utf8_to_codepoints_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Constructor for new string instances from a scalar character value. elemental module function new_str ( string ) result ( new ) character ( len =* ), intent ( in ), optional :: string type ( unicode_type ) :: new integer :: nerr if ( present ( string )) then call utf8_to_codepoints_str ( string , new % codes , nerr ) endif end function new_str ! Constructor for new string instance from a vector integer value. module function new_codes ( codes ) result ( new ) integer , intent ( in ) :: codes (:) type ( unicode_type ) :: new new % codes = codes end function new_codes !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Assign a character sequence to a string. elemental subroutine assign_str_char ( lhs , rhs ) type ( unicode_type ), intent ( inout ) :: lhs character ( len =* ), intent ( in ) :: rhs integer :: nerr call utf8_to_codepoints_str ( rhs , lhs % codes , nerr ) end subroutine assign_str_char ! Assign a character sequence to a string. subroutine assign_str_codes ( lhs , rhs ) type ( unicode_type ), intent ( inout ) :: lhs integer , intent ( in ) :: rhs (:) lhs % codes = rhs end subroutine assign_str_codes !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Returns the length of the character sequence represented by the string. elemental function len_str ( string ) result ( length ) type ( unicode_type ), intent ( in ) :: string integer :: length if ( allocated ( string % codes )) then length = size ( string % codes ) else length = 0 endif end function len_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Return the character sequence represented by the string. pure function char_str ( string ) result ( aline ) type ( unicode_type ), intent ( in ) :: string character ( len = :), allocatable :: aline integer :: nerr call codepoints_to_utf8_str ( string % codes , aline , nerr ) end function char_str pure function char_str_range ( string , first , last ) result ( aline ) type ( unicode_type ), intent ( in ) :: string integer , intent ( in ) :: first integer , intent ( in ) :: last character ( len = :), allocatable :: aline integer :: nerr call codepoints_to_utf8_str ( string % codes ( first : last ), aline , nerr ) end function char_str_range pure function char_str_range_step ( string , first , last , step ) result ( aline ) type ( unicode_type ), intent ( in ) :: string integer , intent ( in ) :: first integer , intent ( in ) :: last integer , intent ( in ) :: step character ( len = :), allocatable :: aline integer :: nerr call codepoints_to_utf8_str ( string % codes ( first : last : step ), aline , nerr ) end function char_str_range_step !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Repeats the character sequence held by the string by the number of specified copies. ! This method is elemental and returns a scalar character value. elemental function repeat_str ( string , ncopies ) result ( repeated_str ) type ( unicode_type ), intent ( in ) :: string integer , intent ( in ) :: ncopies type ( unicode_type ) :: repeated_str integer :: i repeated_str % codes = [( string % codes , i = 1 , ncopies )] end function repeat_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Returns length of character sequence without trailing spaces represented by the string. ! elemental function len_trim_str ( string ) result ( length ) type ( unicode_type ), intent ( in ) :: string integer :: length do length = size ( string % codes ), 1 , - 1 if ( any ( string % codes ( length ). eq . G_SPACES )) cycle exit enddo end function len_trim_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! This method is elemental and returns a scalar character value. elemental function trim_str ( string ) result ( trimmed_str ) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ) :: trimmed_str integer :: last last = len_trim_str ( string ) trimmed_str % codes = string % codes (: last ) end function trim_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! right-justify string by moving trailing spaces to beginning of string so length is retained even if spaces are of varied width elemental function adjustr_str ( string ) result ( adjusted ) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ) :: adjusted integer :: last last = len_trim_str ( string ) adjusted % codes = cshift ( string % codes , - ( size ( adjusted % codes ) - last - 1 )) end function adjustr_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== !left-justify string by  moving leading spaces to end of string so length is retained even if spaces are of varied width elemental function adjustl_str ( string ) result ( adjusted ) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ) :: adjusted integer :: first do first = 1 , size ( string % codes ), 1 if ( any ( string % codes ( first ). eq . G_SPACES )) cycle exit enddo adjusted % codes = cshift ( string % codes , first - 1 ) end function adjustl_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Concatenate two character sequences, LHS, RHS or both can be represented by a byte string or unicode_type. ! elemental function concat_str_str ( lhs , rhs ) result ( lhsrhs ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs type ( unicode_type ) :: lhsrhs lhsrhs % codes = [ lhs % codes , rhs % codes ] end function concat_str_str elemental function concat_str_char ( lhs , rhs ) result ( lhsrhs ) type ( unicode_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs type ( unicode_type ) :: lhsrhs lhsrhs = unicode_type ( rhs ) lhsrhs % codes = [ lhs % codes , lhsrhs % codes ] end function concat_str_char elemental function concat_char_str ( lhs , rhs ) result ( lhsrhs ) character ( len =* ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs type ( unicode_type ) :: lhsrhs lhsrhs = unicode_type ( lhs ) lhsrhs % codes = [ lhsrhs % codes , rhs % codes ] end function concat_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Compare two character sequences for non-equality; LHS, RHS or both sequences can be a unicode string or character variable. ! elemental function lne_str_str ( lhs , rhs ) result ( is_equal ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_equal integer :: icount if ( lhs % len_trim (). eq . rhs % len_trim ()) then icount = lhs % len_trim () is_equal = . not . all ( lhs % codes (: icount ) . eq . rhs % codes (: icount ) ) else is_equal = . true . endif end function lne_str_str elemental function lne_str_char ( lhs , rhs ) result ( is_equal ) type ( unicode_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_equal is_equal = lne_str_str ( lhs , unicode_type ( rhs )) end function lne_str_char elemental function lne_char_str ( lhs , rhs ) result ( is_equal ) character ( len =* ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_equal is_equal = lne_str_str ( unicode_type ( lhs ), rhs ) end function lne_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Compare two character sequences for equality; LHS, RHS or both sequences can be a unicode string or character variable. ! elemental function leq_str_str ( lhs , rhs ) result ( is_equal ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_equal integer :: icount if ( lhs % len_trim (). eq . rhs % len_trim ()) then icount = lhs % len_trim () is_equal = all ( lhs % codes (: icount ) . eq . rhs % codes (: icount ) ) else is_equal = . false . endif end function leq_str_str elemental function leq_str_char ( lhs , rhs ) result ( is_equal ) type ( unicode_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_equal is_equal = leq_str_str ( lhs , unicode_type ( rhs )) end function leq_str_char elemental function leq_char_str ( lhs , rhs ) result ( is_equal ) character ( len =* ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_equal is_equal = leq_str_str ( unicode_type ( lhs ), rhs ) end function leq_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Lexically compare two character sequences for being greater or equal elemental function lge_str_str ( lhs , rhs ) result ( is_lge ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_lge integer :: i integer :: llen integer :: rlen llen = len_trim ( lhs ) rlen = len_trim ( rhs ) FOUND : block do i = 1 , min ( llen , rlen ) select case ( lhs % codes ( i ) - rhs % codes ( i )) case ( 0 ); cycle case ( 1 :); is_lge = . true .; exit FOUND case (: - 1 ); is_lge = . false .; exit FOUND end select enddo ! all equal, decide based on difference in length select case ( llen - rlen ) case ( 0 ); is_lge = . true . case ( 1 :); is_lge = . true . case (: - 1 ); is_lge = . false . end select endblock FOUND end function lge_str_str elemental function lge_str_char ( lhs , rhs ) result ( is_lge ) type ( unicode_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lge is_lge = lge_str_str ( lhs , unicode_type ( rhs )) end function lge_str_char elemental function lge_char_str ( lhs , rhs ) result ( is_lge ) character ( len =* ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_lge is_lge = lge_str_str ( unicode_type ( lhs ), rhs ) end function lge_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Lexically compare two character sequences for being less than or equal elemental function lle_str_str ( lhs , rhs ) result ( is_lle ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_lle integer :: i integer :: llen integer :: rlen llen = len_trim ( lhs ) rlen = len_trim ( rhs ) FOUND : block do i = 1 , min ( llen , rlen ) select case ( lhs % codes ( i ) - rhs % codes ( i ) ) case ( 0 ); cycle case ( 1 :); is_lle = . false .; exit FOUND case (: - 1 ); is_lle = . true .; exit FOUND end select enddo ! all equal, decide based on difference in length select case ( llen - rlen ) case (: - 1 ); is_lle = . true . case ( 0 ); is_lle = . true . case ( 1 :); is_lle = . false . end select endblock FOUND end function lle_str_str elemental function lle_str_char ( lhs , rhs ) result ( is_lle ) type ( unicode_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lle is_lle = lle_str_str ( lhs , unicode_type ( rhs )) end function lle_str_char elemental function lle_char_str ( lhs , rhs ) result ( is_lle ) character ( len =* ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_lle is_lle = lle_str_str ( unicode_type ( lhs ), rhs ) end function lle_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Lexically compare two character sequences for being less than elemental function llt_str_str ( lhs , rhs ) result ( is_llt ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_llt integer :: i integer :: llen integer :: rlen llen = len_trim ( lhs ) rlen = len_trim ( rhs ) FOUND : block do i = 1 , min ( llen , rlen ) select case ( lhs % codes ( i ) - rhs % codes ( i )) case ( 0 ); cycle ; case ( 1 :); is_llt = . false .; exit FOUND case (: - 1 ); is_llt = . true .; exit FOUND end select enddo ! all equal, decide based on difference in length select case ( llen - rlen ) case ( 0 ); is_llt = . false . case ( 1 :); is_llt = . false . case (: - 1 ); is_llt = . true . end select endblock FOUND end function llt_str_str elemental function llt_str_char ( lhs , rhs ) result ( is_llt ) type ( unicode_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_llt is_llt = llt_str_str ( lhs , unicode_type ( rhs )) end function llt_str_char elemental function llt_char_str ( lhs , rhs ) result ( is_llt ) character ( len =* ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_llt is_llt = llt_str_str ( unicode_type ( lhs ), rhs ) end function llt_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! Lexically compare two character sequences for being greater than elemental function lgt_str_str ( lhs , rhs ) result ( is_lgt ) type ( unicode_type ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_lgt integer :: i integer :: llen integer :: rlen llen = len_trim ( lhs ) rlen = len_trim ( rhs ) FOUND : block do i = 1 , min ( llen , rlen ) select case ( lhs % codes ( i ) - rhs % codes ( i )) case ( 0 ); cycle ; case ( 1 :); is_lgt = . true .; exit FOUND case (: - 1 ); is_lgt = . false .; exit FOUND end select enddo ! all equal, decide based on difference in length select case ( llen - rlen ) case ( 0 ); is_lgt = . false . case ( 1 :); is_lgt = . true . case (: - 1 ); is_lgt = . false . end select endblock FOUND end function lgt_str_str elemental function lgt_str_char ( lhs , rhs ) result ( is_lgt ) type ( unicode_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lgt is_lgt = lgt_str_str ( lhs , unicode_type ( rhs )) end function lgt_str_char elemental function lgt_char_str ( lhs , rhs ) result ( is_lgt ) character ( len =* ), intent ( in ) :: lhs type ( unicode_type ), intent ( in ) :: rhs logical :: is_lgt is_lgt = lgt_str_str ( unicode_type ( lhs ), rhs ) end function lgt_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== ! find location of substring within string elemental function index_str_str ( string , substring ) result ( foundat ) type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: substring integer :: foundat integer :: i integer :: strlen integer :: sublen strlen = string % len () sublen = substring % len () foundat = 0 do i = 1 , strlen - sublen + 1 if ( all ( string % codes ( i : i + sublen - 1 ) . eq . substring % codes ) ) then foundat = i exit endif enddo end function index_str_str elemental function index_str_char ( string , substring ) result ( foundat ) type ( unicode_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring integer :: foundat foundat = index_str_str ( string , unicode_type ( substring )) end function index_str_char elemental function index_char_str ( string , substring ) result ( foundat ) character ( len =* ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: substring integer :: foundat foundat = index_str_str ( unicode_type ( string ), substring ) end function index_char_str !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !! !! In computing, Unicode characters are typically sorted using one of two methods: !! !! a simple binary code point sort or a more sophisticated, !! language-sensitive collation. The correct approach depends on whether a !! linguistically accurate \"alphabetical\" order is needed or if a simple, !! fixed order is sufficient. !! !! Binary code point sort !! !! This is the simplest and fastest method, often used as a default by !! programming languages and databases. !! !!     How it works: Strings are sorted based on the numeric value of their !!     underlying Unicode code points. For example, a character with a code !!     point of U+0061 (lowercase \"a\") will always be placed before U+0062 !!     (lowercase \"b\") because 97 is less than 98. !! !!     Limitations: While this works for the basic English alphabet, it !!     produces non-intuitive results for other characters because the code !!     point value does not correlate with linguistic sorting rules. For !!     instance, it may place: !! !!         Uppercase letters before all lowercase letters (Z comes before a). !! !!         Accented letters in an order that is not linguistically correct !!         for a given language (e.g., in German, an umlauted character !!         like ö might be sorted differently than a plain o). !! !!         Characters from different scripts (like Latin, Greek, and !!         Cyrillic) in an order determined solely by their assigned code !!         point blocks. !! !! Unicode Collation Algorithm (UCA) !! !! This is the standard, more robust method for sorting that produces !! correct, language-sensitive results. It is described in Unicode Technical !! Standard #10. !! !!     How it works: Instead of sorting by a single numeric value, the !!     UCA uses a multi-level approach to determine a sort key for each !!     string. The algorithm takes into account the specific rules (or !!     \"tailorings\") of a given language or locale, which are defined in !!     the Common Locale Data Repository (CLDR). !! !!     Multi-level sorting: The UCA uses a hierarchy of weights for each !!     character: !! !!         Primary: Compares the base letter, ignoring case and accents. This !!         groups all versions of \"a\" (a, á, A, Á) together. !! !!         Secondary: Compares accents and diacritics. This establishes the !!         order for different versions of the same base letter (e.g., o, !!         ó, ô). !! !!         Tertiary: Compares case differences (uppercase vs. lowercase). !! !!         Quaternary: Deals with other special features, such as handling !!         punctuation. !! !!     Locale-specific rules: The UCA can apply different rules based on !!     a user's location. For example: !! !!         In German phonebooks, umlauted letters (ä) are often sorted as !!         if they were ae. In other contexts, they are sorted with their !!         base letter (a). !! !!         The correct sorting order for Chinese characters can be based !!         on pronunciation (Pinyin) or stroke count, depending on the !!         dictionary or region. !! !! How to choose a sorting method !! !!     Use binary sorting for performance when linguistic order doesn't !!     matter. This is fine for internal data processing where you just !!     need a consistent, quick sort. !! !!     Use the UCA for user-facing applications where culturally appropriate !!     sorting is critical. If your application supports multiple languages, !!     you must use a language-sensitive collator to provide the sorting !!     users will expect. Most modern programming languages and databases !!     have built-in libraries that implement the Unicode Collation !!     Algorithm. !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()= !=================================================================================================================================== !> !!##NAME !!    sort_quick_rx(3f) - [M_unicode:sort:quicksort] indexed hybrid quicksort of an array !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!      subroutine sort_quick_rx(data,index) !! !!          type(unicode_type),intent(in) :: data(:) !!          integer,intent(out)           :: indx(size(data)) !! !!##DESCRIPTION !!    A rank hybrid quicksort. The data is not moved. An integer array is !!    generated instead with values that are indices to the sorted order !!    of the data. This requires a second array the size of the input !!    array, which for large arrays would require a significant amount of !!    memory. One major advantage of this method is that !!    the indices can be used to access an entire user-defined type !!    in sorted order. This makes this seemingly simple sort procedure !!    usuable with the vast majority of user-defined types.  or other !!    correlated data. !! !!##BACKGROUND !!    From Leonard J. Moss of SLAC: !! !!    Here's a hybrid QuickSort I wrote a number of years ago. It's !!    based on suggestions in Knuth, Volume 3, and performs much better !!    than a pure QuickSort on short or partially ordered input arrays. !! !!    This routine performs an in-memory sort of the first N elements of !!    array DATA, returning into array INDEX the indices of elements of !!    DATA arranged in ascending order. Thus, !! !!       DATA(INDX(1)) will be the smallest number in array DATA; !!       DATA(INDX(N)) will be the largest number in DATA. !! !!    The original data is not physically rearranged. The original order !!    of equal input values is not necessarily preserved. !! !!    sort_quick_rx(3f) uses a hybrid QuickSort algorithm, based on several !!    suggestions in Knuth, Volume 3, Section 5.2.2. In particular, the !!    \"pivot key\" [my term] for dividing each subsequence is chosen to be !!    the median of the first, last, and middle values of the subsequence; !!    and the QuickSort is cut off when a subsequence has 9 or fewer !!    elements, and a straight insertion sort of the entire array is done !!    at the end. The result is comparable to a pure insertion sort for !!    very short arrays, and very fast for very large arrays (of order 12 !!    micro-sec/element on the 3081K for arrays of 10K elements). It is !!    also not subject to the poor performance of the pure QuickSort on !!    partially ordered data. !! !!    Complex values are sorted by the magnitude of sqrt(r**2+i**2). !! !!    o Created: sortrx(3f): 15 Jul 1986, Len Moss !!    o saved from url=(0044)http://www.fortran.com/fortran/quick_sort2.f !!    o changed to update syntax from F77 style; John S. Urban 20161021 !!    o generalized from only real values to include other intrinsic types; !!      John S. Urban 20210110 !!    o type(unicode_type) version JSU 2025-09-20. See M_sort for other types. !! !!##EXAMPLES !! !!  Sample usage: !! !!    program demo_sort_quick_rx !!    use M_unicode, only : sort_quick_rx, unicode_type, assignment(=) !!    implicit none !!    character(len=*),parameter :: g='(*(g0))' !!    integer,parameter  :: isz=4 !!    type(unicode_type) :: rr(isz) !!    integer            :: ii(isz) !!    integer            :: i !!       write(*,g)'sort array with sort_quick_rx(3f)' !!       rr(1)=\"the\" !!       rr(2)=\"quick\" !!       rr(3)=\"brown\" !!       rr(4)=\"fox\" !!       call sort_quick_rx(rr,ii) !! !!       write(*,g)'original order' !!       do i=1,size(rr) !!          write(*,g)rr(i)%character() !!       enddo !! !!       write(*,g)'sorted order' !!       do i=1,size(rr) !!          write(*,g)rr(ii(i))%character() !!       enddo !! !!    end program demo_sort_quick_rx !! !!   Results: !! !==================================================================================================================================! !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !==================================================================================================================================! subroutine sort_quick_rx ( data , indx ) ! ident_30=\"@(#) M_unicode sort_quick_rx(3f) indexed hybrid quicksort of a type(unicode_type) array\" type ( unicode_type ), intent ( in ) :: data (:) integer ( kind = int32 ), intent ( out ) :: indx (:) type ( unicode_type ) :: datap integer ( kind = int32 ) :: n integer ( kind = int32 ) :: lstk ( 31 ), rstk ( 31 ), istk integer ( kind = int32 ) :: l , r , i , j , p , indexp , indext !  QuickSort Cutoff ! !  Quit QuickSort-ing when a subsequence contains M or fewer elements and finish off at end with straight insertion sort. !  According to Knuth, V.3, the optimum value of M is around 9. integer , parameter :: M = 9 !=================================================================================================================================== n = size ( data ) if ( size ( indx ). lt . n ) then ! if index is not big enough, only sort part of the data write ( * , * ) '*sort_quick_rx* ERROR: insufficient space to store index data' n = size ( indx ) endif !=================================================================================================================================== !  Make initial guess for INDEX do i = 1 , n indx ( i ) = i enddo !  If array is short go directly to the straight insertion sort, else execute a QuickSort if ( N . gt . M ) then !============================================================================================================================= !  QuickSort ! !  The \"Qn:\"s correspond roughly to steps in Algorithm Q, Knuth, V.3, PP.116-117, modified to select the median !  of the first, last, and middle elements as the \"pivot key\" (in Knuth's notation, \"K\"). Also modified to leave !  data in place and produce an INDEX array. To simplify comments, let DATA[I]=DATA(INDX(I)). ! Q1: Initialize istk = 0 l = 1 r = n !============================================================================================================================= TOP : do ! Q2: Sort the subsequence DATA[L]..DATA[R]. ! !  At this point, DATA[l] <= DATA[m] <= DATA[r] for all l < L, r > R, and L <= m <= R. !  (First time through, there is no DATA for l < L or r > R.) i = l j = r ! Q2.5: Select pivot key ! !  Let the pivot, P, be the midpoint of this subsequence, P=(L+R)/2; then rearrange INDX(L), INDX(P), and INDX(R) !  so the corresponding DATA values are in increasing order. The pivot key, DATAP, is then DATA[P]. p = ( l + r ) / 2 indexp = indx ( p ) datap = data ( indexp ) if ( data ( indx ( l )) . gt . datap ) then indx ( p ) = indx ( l ) indx ( l ) = indexp indexp = indx ( p ) datap = data ( indexp ) endif if ( datap . gt . data ( indx ( r ))) then if ( data ( indx ( l )) . gt . data ( indx ( r ))) then indx ( p ) = indx ( l ) indx ( l ) = indx ( r ) else indx ( p ) = indx ( r ) endif indx ( r ) = indexp indexp = indx ( p ) datap = data ( indexp ) endif !  Now we swap values between the right and left sides and/or move DATAP until all smaller values are on the left and all !  larger values are on the right. Neither the left or right side will be internally ordered yet; however, DATAP will be !  in its final position. Q3 : do ! Q3: Search for datum on left >= DATAP !   At this point, DATA[L] <= DATAP. We can therefore start scanning up from L, looking for a value >= DATAP !   (this scan is guaranteed to terminate since we initially placed DATAP near the middle of the subsequence). I = I + 1 if ( data ( indx ( i )). lt . datap ) then cycle Q3 endif !----------------------------------------------------------------------------------------------------------------------- ! Q4: Search for datum on right <= DATAP ! !   At this point, DATA[R] >= DATAP. We can therefore start scanning down from R, looking for a value <= DATAP !   (this scan is guaranteed to terminate since we initially placed DATAP near the middle of the subsequence). Q4 : do j = j - 1 if ( data ( indx ( j )). le . datap ) then exit Q4 endif enddo Q4 !----------------------------------------------------------------------------------------------------------------------- ! Q5: Have the two scans collided? if ( i . lt . j ) then ! Q6: No, interchange DATA[I] <--> DATA[J] and continue indext = indx ( i ) indx ( i ) = indx ( j ) indx ( j ) = indext cycle Q3 else ! Q7: Yes, select next subsequence to sort !   At this point, I >= J and DATA[l] <= DATA[I] == DATAP <= DATA[r], for all L <= l < I and J < r <= R. !   If both subsequences are more than M elements long, push the longer one on the stack !   and go back to QuickSort the shorter; if only one is more than M elements long, go back and QuickSort it; !   otherwise, pop a subsequence off the stack and QuickSort it. if ( r - j . ge . i - l . and . i - l . gt . m ) then istk = istk + 1 lstk ( istk ) = j + 1 rstk ( istk ) = r r = i - 1 else if ( i - l . gt . r - j . and . r - j . gt . m ) then istk = istk + 1 lstk ( istk ) = l rstk ( istk ) = i - 1 l = j + 1 else if ( r - j . gt . m ) then l = j + 1 else if ( i - l . gt . m ) then r = i - 1 else ! Q8: Pop the stack, or terminate QuickSort if empty if ( istk . lt . 1 ) then exit TOP endif l = lstk ( istk ) r = rstk ( istk ) istk = istk - 1 endif cycle TOP endif ! never get here, as cycle Q3 or cycle TOP enddo Q3 exit TOP enddo TOP endif !=================================================================================================================================== ! Q9: Straight Insertion sort do i = 2 , n if ( data ( indx ( i - 1 )) . gt . data ( indx ( i ))) then indexp = indx ( i ) datap = data ( indexp ) p = i - 1 INNER : do indx ( p + 1 ) = indx ( p ) p = p - 1 if ( p . le . 0 ) then exit INNER endif if ( data ( indx ( p )). le . datap ) then exit INNER endif enddo INNER indx ( p + 1 ) = indexp endif enddo !=================================================================================================================================== !     All done end subroutine sort_quick_rx !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== elemental pure function upper ( str ) result ( string ) ! ident_25=\"@(#) M_strings upper(3f) returns an uppercase string\" type ( unicode_type ), intent ( in ) :: str ! input string to convert to all uppercase type ( unicode_type ) :: string ! output string that contains no miniscule letters integer :: i ! loop counter integer , parameter :: ade_a = iachar ( 'a' ), ade_z = iachar ( 'z' ) integer , parameter :: diff = iachar ( 'A' ) - iachar ( 'a' ) string = str do i = 1 , len ( str ) ! step thru each letter in the string in specified range select case ( str % codes ( i )) case ( ade_a : ade_z ) string % codes ( i ) = str % codes ( i ) + diff end select enddo if ( len ( str ). eq . 0 ) string = str end function upper elemental pure function lower ( str ) result ( string ) ! ident_25=\"@(#) M_strings lower(3f) returns an lowercase string\" type ( unicode_type ), intent ( in ) :: str ! input string to convert to all lowercase type ( unicode_type ) :: string ! output string that contains no miniscule letters integer :: i ! loop counter integer , parameter :: ade_a = iachar ( 'A' ), ade_z = iachar ( 'Z' ) integer , parameter :: diff = iachar ( 'A' ) - iachar ( 'a' ) string = str do i = 1 , len ( str ) ! step thru each letter in the string in specified range select case ( str % codes ( i )) case ( ade_a : ade_z ) string % codes ( i ) = str % codes ( i ) - diff end select enddo if ( len ( str ). eq . 0 ) string = str end function lower !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== impure subroutine split_tokens ( string , set , tokens , separator ) ! Splits a string into tokens using characters in set as token delimiters. ! If present, separator contains the array of token delimiters. type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set type ( unicode_type ), allocatable , intent ( out ) :: tokens (:) type ( unicode_type ), allocatable , intent ( out ), optional :: separator (:) integer , allocatable :: first (:), last (:) integer :: n integer :: imax ! AUTHOR  : Milan Curcic, \"milancurcic@hey.com\" ! LICENSE : MIT ! VERSION : version 0.1.0, copyright 2020, Milan Curcic call split_first_last ( string , set , first , last ) ! maxval() of a zero-size array is set to a flag value not zero or length of character string if ( size ( first ). eq . 0 ) then imax = 0 else imax = maxval ( last - first ) + 1 endif allocate ( tokens ( size ( first ))) do n = 1 , size ( tokens ) tokens ( n ) = string % character ( first ( n ), last ( n ), 1 ) enddo if ( present ( separator )) then allocate ( separator ( size ( tokens ) - 1 )) do n = 1 , size ( tokens ) - 1 separator ( n ) = string % character ( first ( n + 1 ) - 1 , first ( n + 1 ) - 1 , 1 ) enddo endif end subroutine split_tokens !=================================================================================================================================== impure subroutine split_first_last ( string , set , first , last ) ! Computes the first and last indices of tokens in input string, delimited ! by the characters in set, and stores them into first and last output ! arrays. type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set integer , allocatable , intent ( out ) :: first (:) integer , allocatable , intent ( out ) :: last (:) type ( unicode_type ) :: set_array ( len ( set )) logical , dimension ( len ( string )) :: is_first , is_last , is_separator integer :: i integer :: n integer :: slen ! AUTHOR   : Milan Curcic, \"milancurcic@hey.com\" ! LICENSE  : MIT ! VERSION  : version 0.1.0, copyright 2020, Milan Curcic ! MODIFIED : 2025-09-21 JSU slen = len ( string ) do n = 1 , len ( set ) set_array ( n ) = set % character ( n , n ) enddo FINDIT : do n = 1 , slen do i = 1 , len ( set ) is_separator ( n ) = . false . if ( string % character ( n , n ) == set_array ( i )% character () ) then is_separator ( n ) = . true . exit endif enddo enddo FINDIT is_first = . false . is_last = . false . if (. not . is_separator ( 1 )) is_first ( 1 ) = . true . do concurrent ( n = 2 : slen - 1 ) if (. not . is_separator ( n )) then if ( is_separator ( n - 1 )) is_first ( n ) = . true . if ( is_separator ( n + 1 )) is_last ( n ) = . true . else if ( is_separator ( n - 1 )) then is_first ( n ) = . true . is_last ( n - 1 ) = . true . endif endif enddo if (. not . is_separator ( slen )) is_last ( slen ) = . true . first = pack ([( n , n = 1 , slen )], is_first ) last = pack ([( n , n = 1 , slen )], is_last ) end subroutine split_first_last !=================================================================================================================================== impure subroutine split_pos ( string , set , pos , back ) ! If back is absent, computes the leftmost token delimiter in string whose ! position is > pos. If back is present and true, computes the rightmost ! token delimiter in string whose position is < pos. The result is stored ! in pos. type ( unicode_type ), intent ( in ) :: string type ( unicode_type ), intent ( in ) :: set integer , intent ( in out ) :: pos logical , intent ( in ), optional :: back logical :: backward type ( unicode_type ) :: set_array ( len ( set )) integer :: i integer :: result_pos integer :: n ! AUTHOR   : Milan Curcic, \"milancurcic@hey.com\" ! LICENSE  : MIT ! VERSION  : version 0.1.0, copyright 2020, Milan Curcic ! MODIFIED : 2025-09-21 JSU backward = . false . if ( present ( back )) backward = back do n = 1 , len ( set ) set_array ( n ) = set % character ( n , n ) enddo if ( backward ) then result_pos = 0 FINDIT : do n = pos - 1 , 1 , - 1 do i = 1 , len ( set ) if ( string % character ( n , n ) == set_array ( i )% character () ) then result_pos = n exit FINDIT endif enddo enddo FINDIT else result_pos = len ( string ) + 1 GETPOS : do n = pos + 1 , len ( string ) do i = 1 , len ( set ) if ( string % character ( n , n ) == set_array ( i )% character () ) then result_pos = n exit GETPOS endif enddo enddo GETPOS endif pos = result_pos end subroutine split_pos !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== function oop_upper ( self ) result ( string_out ) class ( unicode_type ), intent ( in ) :: self type ( unicode_type ) :: string_out string_out = upper ( self ) end function oop_upper !=================================================================================================================================== function oop_lower ( self ) result ( string_out ) class ( unicode_type ), intent ( in ) :: self type ( unicode_type ) :: string_out string_out = lower ( self ) end function oop_lower !=================================================================================================================================== function oop_adjustl ( self ) result ( string_out ) class ( unicode_type ), intent ( in ) :: self type ( unicode_type ) :: string_out string_out = adjustl_str ( self ) end function oop_adjustl !=================================================================================================================================== function oop_adjustr ( self ) result ( string_out ) ! ident_13=\"@(#) M_strs oop_adjustr(3f) adjust string to right\" class ( unicode_type ), intent ( in ) :: self type ( unicode_type ) :: string_out string_out = adjustr_str ( self ) end function oop_adjustr !=================================================================================================================================== function oop_character ( self , first , last , step ) result ( bytes_out ) class ( unicode_type ), intent ( in ) :: self character ( len = :), allocatable :: bytes_out integer , intent ( in ), optional :: first , last , step integer :: start , end , inc type ( unicode_type ) :: temp if ( present ( step )) then ; inc = step ; else ; inc = 1 ; endif if ( present ( first )) then ; start = first ; else ; start = 1 ; endif if ( present ( last )) then ; end = last ; else ; end = len ( self ); endif temp = self % codes ( start : end : inc ) bytes_out = char_str ( temp ) end function oop_character !=================================================================================================================================== function oop_codepoint ( self , first , last , step ) result ( codes_out ) class ( unicode_type ), intent ( in ) :: self integer , allocatable :: codes_out (:) integer , intent ( in ), optional :: first , last , step integer :: start , end , inc type ( unicode_type ) :: temp if ( present ( step )) then ; inc = step ; else ; inc = 1 ; endif if ( present ( first )) then ; start = first ; else ; start = 1 ; endif if ( present ( last )) then ; end = last ; else ; end = len ( self ); endif codes_out = self % codes ( start : end : inc ) end function oop_codepoint !=================================================================================================================================== function oop_tokenize ( self , set ) result ( tokens ) class ( unicode_type ), intent ( in ) :: self type ( unicode_type ), intent ( in ) :: set type ( unicode_type ), allocatable :: tokens (:) integer , allocatable :: begin (:) integer , allocatable :: end (:) integer :: i call split ( self , set , begin , end ) allocate ( tokens ( size ( begin ))) do i = 1 , size ( begin ) tokens ( i ) = self % character ( begin ( i ), end ( i )) enddo end function oop_tokenize !=================================================================================================================================== function oop_split ( self , set ) result ( tokens ) class ( unicode_type ), intent ( in ) :: self type ( unicode_type ), intent ( in ) :: set type ( unicode_type ), allocatable :: tokens (:) call split ( self , set , tokens ) end function oop_split !=================================================================================================================================== function oop_sort ( self ) result ( indx ) class ( unicode_type ), intent ( in ) :: self (:) integer :: indx ( size ( self )) call sort_quick_rx ( self , indx ) end function oop_sort !=================================================================================================================================== pure function oop_trim ( self ) result ( string_out ) class ( unicode_type ), intent ( in ) :: self type ( unicode_type ) :: string_out string_out = trim ( self ) end function oop_trim !=================================================================================================================================== pure function oop_len_trim ( self ) result ( len_trim_out ) class ( unicode_type ), intent ( in ) :: self integer :: len_trim_out len_trim_out = len_trim ( self ) end function oop_len_trim !=================================================================================================================================== pure function oop_len ( self ) result ( len_out ) class ( unicode_type ), intent ( in ) :: self integer :: len_out len_out = len ( self ) end function oop_len !=================================================================================================================================== impure function oop_index ( self , substring ) result ( index_out ) class ( unicode_type ), intent ( in ) :: self class ( * ), intent ( in ) :: substring integer :: index_out select type ( substring ) type is ( character ( len =* )) index_out = index ( self , unicode_type ( substring )) type is ( unicode_type ) index_out = index ( self , substring ) class default stop '<ERROR>*oop_index* unknown type' end select end function oop_index !=================================================================================================================================== impure function oop_eq ( self , string ) result ( is_eq ) class ( unicode_type ), intent ( in ) :: self class ( * ), intent ( in ) :: string logical :: is_eq select type ( string ) type is ( character ( len =* )) is_eq = leq_str_char ( self , string ) type is ( unicode_type ) is_eq = leq_str_str ( self , string ) class default stop '<ERROR>*oop_eq* unknown type' end select end function oop_eq !=================================================================================================================================== !()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()! !=================================================================================================================================== end module M_unicode","tags":"","url":"sourcefile/m_unicode.f90.html"},{"title":"bom_start.f90 – M_unicode","text":"Source Code program bom_exe ! ! create a Fortran source file starting with a utf-8 BOM to see if your ! compiler will compile it or fail because a character is not in the ! Fortran character set outside of a comment or literal string ! use iso_fortran_env , only : stdout => output_unit use M_unicode implicit none type ( unicode_type ) :: U_BOM U_bom = [ int ( z 'FEFF' )] write ( stdout , '(a)' , advance = 'no' ) U_bom % character () write ( stdout , '(a)' ) & 'program testit ! Unicode BOM encoded to utf-8 bytes by Fortran' ,& '   write(*,*)\"File starts with BOM from UCS-4 write!\"' ,& 'end program testit' end program bom_exe","tags":"","url":"sourcefile/bom_start.f90.html"},{"title":"fid.f90 – M_unicode","text":"Source Code program test_id use , intrinsic :: iso_fortran_env , only : compiler_version use , intrinsic :: iso_fortran_env , only : compiler_options implicit none character ( len = :), allocatable :: version , options character ( len =* ), parameter :: nl = new_line ( 'a' ) integer :: where , start , break version = compiler_version () options = ' ' // compiler_options () start = 1 do where = index ( options ( start :), ' -' ) if ( where . eq . 0 ) exit break = where + start - 1 options ( break : break ) = nl start = where enddo if ( start . eq . 1 ) then do where = index ( options ( start :), ' /' ) if ( where . eq . 0 ) exit break = where + start - 1 options ( break : break ) = nl start = where enddo endif print '(*(1x,a))' , & 'This file was compiled by ' , & version , nl , & 'using the options ' , & options end program test_id","tags":"","url":"sourcefile/fid.f90.html"},{"title":"test_M_unicode.f90 – M_unicode","text":"Source Code program test_M_unicode use iso_fortran_env , only : output_unit use M_unicode , only : adjustl , adjustr , trim , index use M_unicode , only : character use M_unicode , only : assignment ( = ), unicode_type , operator ( // ) use M_unicode , only : operator ( <= ), lle use M_unicode , only : operator ( < ), llt use M_unicode , only : operator ( /= ), lne use M_unicode , only : operator ( == ), leq use M_unicode , only : operator ( > ), lgt use M_unicode , only : operator ( >= ), lge implicit none character ( len =* ), parameter :: g0 = '(*(g0))' logical , parameter :: T = . true . logical , parameter :: F = . false . ! character ( len =* ), parameter :: upagain = \"七転び八起き。転んでもまた立ち上がる。くじけずに前を向いて歩いていこう。\" ! Romanization: ! Nanakorobi yaoki. Koronde mo mata tachiagaru. Kujikezu ni mae o muite aruite ikou. ! or English translation ! \"Fall seven times, stand up eight. Even if you fall down, you will get up again. Don't be discouraged, just keep walking forward.\" ! character ( len = :), allocatable :: astr type ( unicode_type ) :: ut_str type ( unicode_type ) :: smiley integer :: total integer :: i type ( unicode_type ) :: lhs , rhs type ( unicode_type ) :: string , substring smiley = '😃' total = 0 write ( * , g0 ) 'encoding can be altered on an open file' open ( output_unit , encoding = 'UTF-8' ) write ( * , g0 ) astr = 'Hello World and Ni Hao -- 你好' ut_str = astr call checkits ( 'convert to ASCII bytes' , astr , ut_str % bytes (), transfer ( 'Hello World and Ni Hao -- 你好' ,[ 'A' ])) astr = \"  this is a string    \" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), 'this is a string      ' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '      this is a string' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '  this is a string' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 18 ) call check ( 'len' , ut_str % len (). eq . 22 ) astr = \"  \" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), '  ' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '  ' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 0 ) call check ( 'len' , ut_str % len (). eq . 2 ) astr = \"\" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), '' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 0 ) call check ( 'len' , ut_str % len (). eq . 0 ) astr = \"ALLFULL\" ut_str = astr call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), 'ALLFULL' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), 'ALLFULL' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), 'ALLFULL' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 7 ) call check ( 'len' , ut_str % len (). eq . 7 ) ut_str = [ 32 , 32 , int ( z '1F603' ), 32 , 32 , 32 ] astr = character ( ut_str ) call checkit ( 'adjustl' , astr , character ( ut_str % adjustl ()), '😃     ' ) call checkit ( 'adjustr' , astr , character ( ut_str % adjustr ()), '     😃' ) call checkit ( 'trim' , astr , character ( trim ( ut_str % trim ())), '  😃' ) call check ( 'len_trim' , ut_str % len_trim (). eq . 3 ) call check ( 'len' , ut_str % len (). eq . 6 ) if ( total . ne . 0 ) then write ( * , g0 ) total , 'failures' stop 1 endif ut_str = smiley // ' and ' // smiley // 'and' // smiley // smiley // 'is it' astr = '😃 and 😃and😃😃is it' call checkit ( 'concatenation' , astr , character ( ut_str ), '😃 and 😃and😃😃is it' ) lhs = 'this is the left' rhs = 'this is the right' call checkits_l ( 'LLE' , ' ' , [ lle ( lhs , rhs ), lhs <= rhs , lle ( rhs , lhs ), rhs <= lhs ] , [ T , T , F , F ] ) call checkits_l ( 'LLT' , ' ' , [ llt ( lhs , rhs ), lhs < rhs , llt ( rhs , lhs ), rhs < lhs ] , [ T , T , F , F ] ) call checkits_l ( 'LNE' , ' ' , [ lne ( lhs , rhs ), lhs /= rhs , lne ( rhs , lhs ), rhs /= lhs ] , [ T , T , T , T ] ) call checkits_l ( 'LEQ' , ' ' , [ leq ( lhs , rhs ), lhs == rhs , leq ( rhs , lhs ), rhs == lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LGT' , ' ' , [ lgt ( lhs , rhs ), lhs > rhs , lgt ( rhs , lhs ), rhs > lhs ] , [ F , F , T , T ] ) call checkits_l ( 'LGE' , ' ' , [ lge ( lhs , rhs ), lhs >= rhs , lge ( rhs , lhs ), rhs >= lhs ] , [ F , F , T , T ] ) lhs = 'abc' rhs = 'abc ' call checkits_l ( 'LLE' , ' ' , [ lle ( lhs , rhs ), lhs <= rhs , lle ( rhs , lhs ), rhs <= lhs ] , [ T , T , T , T ] ) call checkits_l ( 'LLT' , ' ' , [ llt ( lhs , rhs ), lhs < rhs , llt ( rhs , lhs ), rhs < lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LNE' , ' ' , [ lne ( lhs , rhs ), lhs /= rhs , lne ( rhs , lhs ), rhs /= lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LEQ' , ' ' , [ leq ( lhs , rhs ), lhs == rhs , leq ( rhs , lhs ), rhs == lhs ] , [ T , T , T , T ] ) call checkits_l ( 'LGT' , ' ' , [ lgt ( lhs , rhs ), lhs > rhs , lgt ( rhs , lhs ), rhs > lhs ] , [ F , F , F , F ] ) call checkits_l ( 'LGE' , ' ' , [ lge ( lhs , rhs ), lhs >= rhs , lge ( rhs , lhs ), rhs >= lhs ] , [ T , T , T , T ] ) string = \" can you find me here? \" substring = \"find me\" astr = character ( substring ) call check ( 'index ' // string % character () // ':' // substring % character (), index ( string , substring ). eq . 10 ) call check ( 'index ' // string % character () // ':' // astr , index ( string , astr ). eq . 10 ) string = \" can you find me here? \" substring = \"not there\" astr = character ( substring ) call check ( 'index ' // string % character () // ':' // substring % character (), index ( string , substring ). eq . 0 ) call check ( 'index ' // string % character () // ':' // astr , index ( string , astr ). eq . 0 ) string = \"short\" substring = \"shortnot\" astr = character ( substring ) call check ( 'index ' // string % character () // ':' // substring % character (), index ( string , substring ). eq . 0 ) call check ( 'index ' // string % character () // ':' // astr , index ( string , astr ). eq . 0 ) string = upagain write ( * , g0 ) 'original bytes  :' , upagain write ( * , g0 ) 'bytes reversed  :' , ( upagain ( i : i ), i = len ( upagain ), 1 , - 1 ) write ( * , g0 ) 'original string :' , string % character () write ( * , g0 ) 'string reversed :' , string % character ( string % len (), 1 , - 1 ) contains subroutine checkit ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline character ( len =* ), intent ( in ) :: answer character ( len =* ), intent ( in ) :: expected write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , answer . eq . expected ), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( answer . ne . expected ) total = total + 1 end subroutine checkit subroutine checkits ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline character ( len =* ), intent ( in ) :: answer (:) character ( len =* ), intent ( in ) :: expected (:) write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , all ( answer . eq . expected )), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( all ( answer . ne . expected )) total = total + 1 end subroutine checkits subroutine checkits_l ( label , aline , answer , expected ) character ( len =* ), intent ( in ) :: label character ( len =* ), intent ( in ) :: aline logical , intent ( in ) :: answer (:) logical , intent ( in ) :: expected (:) write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , all ( answer . eqv . expected )), ' ' , label , ':[' , aline , '][' , answer , '][' , expected , ']' if ( all ( answer . neqv . expected )) total = total + 1 end subroutine checkits_l subroutine check ( label , test ) character ( len =* ), intent ( in ) :: label logical , intent ( in ) :: test write ( * , g0 ) merge ( 'PASSED' , 'FAILED' , test ), ' ' , label if (. not . test ) total = total + 1 end subroutine check end program test_M_unicode","tags":"","url":"sourcefile/test_m_unicode.f90.html"},{"title":"multi_lines.f90 – M_unicode","text":"Source Code program multi_line use iso_fortran_env , only : output_unit use M_unicode use M_unicode , only : ut => unicode_type implicit none integer :: i , longest type ( ut ), allocatable :: upagain (:) upagain = [ & ! ROMANIZATION                         ! ENGLISH ut ( \"七転び八起き。\" ), & ! Nanakorobi yaoki.                    ! Fall seven times, stand up eight. ut ( \"転んでもまた立ち上がる。\" ), & ! Koronde mo mata tachiagaru.          ! Even if you fall down, you will get up again. ut ( \"くじけずに前を向いて歩いていこう。\" )] ! Kujikezu ni mae o muite aruite ikou. ! Don't be discouraged, just keep walking forward. ! open ( output_unit , encoding = 'UTF-8' ) longest = 0 ! get longest trimmed line do i = 1 , size ( upagain ) longest = max ( longest , len_trim ( upagain ( i ))) write ( * , * ) 'LEN=' , len_trim ( upagain ( i )) enddo write ( output_unit , * ) 'longest=' , longest write ( output_unit , * ) do i = 1 , size ( upagain ) write ( output_unit , '(g0)' ) character ( upagain ( i )), len_trim ( upagain ( i )) enddo end program multi_line","tags":"","url":"sourcefile/multi_lines.f90.html"}]}