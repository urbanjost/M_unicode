<html> 
<head> 
<title> </title>
<style> 
px {font-family: "Lucida Console", Monaco, monospace }
p { font-size:100%; line-height:1.1em; }
body {xfont-style: sans-serif}
body {
color:#333; font-family:Verdana, Arial, Helvetica, sans-serif; font-size:1em; line-height:1.3em; }
a:visited { color:#666; }
h1,h2,h3,h4,h5,h6 { color:#333; font-family:georgia, verdana, sans-serif; }
h1 { font-size:150%; page-break-before:auto;background-color: #aaaaff}
h2 { font-size:143%;color:teal; }
h3 { font-size:134%;color:blue; }
h4 { font-size:120%;color:gray; }
img { max-width: 55em}
p{ padding: 0;margin:0; }
p{ padding-right:1.4em; }
p{ padding-bottom:0.1em; }
p{ padding-top:1em; }
p{ whitespace: pre-wrap; }
h5,h6 { font-size:100% }
a.nav,a:link.nav, a:visited.nav { background-color:#FFF; color:#000; }
XXtable { border:double #000; border-collapse:collapse; }
XXtable { border-collapse:collapse; }
XXtd { border:thin solid #888; }
XXtd { border:none; }
li { margin-bottom:0.5em; }
blockquote { display:block; font-size:100%; line-height:1.1em; margin:0 0 0.5em; padding:0 2.5em; }
pre { background-color:#DDD; font-size:100%; overflow:auto; padding:1em; }
a,li span { color:#000; }
a:hover, a.nav:hover, a:hover math { background-color:#000; color:#FFF; }
#Container { margin:0 10px; text-align:center; background-color: #BBB}
#Content { border-top:none; margin:auto; padding:0.3em; text-align:left; width:100%; max-width:55em; background:#FFF}
span.webName { font-size:.5em; }
textarea#content { font-size: 1em; line-height: 1.125; }
h1#pageName { line-height:1em; margin:0.2em 0 0.2em 0; padding:0; }
.property { color:#666; font-size:100%; }
a.existingWikiWord[title]{ //border: 1px dashed #BBB; }
.byline { color:#666; font-size:1.0em; font-style:italic; margin-bottom:1em; padding-top:1px; } 
</style> 
</head>
<BODY bgcolor=#F0F0F0 text=#000000 link=#0000ff vlink=#C000C0 alink=#ff0000><A NAME=top></A>
<!--
<h5><a href="https://github.com/urbanjost/M_unicode">[UP]</a></h5>
<button type="button" onclick="javascript:history.back()">Back</button>
-->
<div id="Container">
<div id="Content">
<CENTER>
<H1><HR><I>Manual Reference Pages &nbsp;-&nbsp;</I><NOBR>tokenize (3m_unicode)</NOBR><HR></H1>
</CENTER>
<A name=0>

     <H3>NAME</H3>

</A>
<BLOCKQUOTE>
TOKENIZE(3f) - [M_unicode:PARSE] Parse a string into tokens.
(LICENSE:MIT)
<P>
</BLOCKQUOTE>
<A name=contents></A><H3>CONTENTS</H3></A>
<BLOCKQUOTE>
<A HREF=#1>Synopsis</A><BR>
<A HREF=#2>Characteristics</A><BR>
<A HREF=#3>Description</A><BR>
<A HREF=#4>Options</A><BR>
<A HREF=#5>Examples</A><BR>
<A HREF=#6>See Also</A><BR>
<A HREF=#7>Author</A><BR>
<A HREF=#8>License</A><BR>
</BLOCKQUOTE>
<A name=9>

     <H3>SYNOPSIS</H3>

</A>
<BLOCKQUOTE>
TOKEN form (returns array of strings)
<P>
<PRE>
   subroutine tokenize(string, set, tokens [, separator])
<P>
    type(unicode_type),intent(in) :: string
    type(unicode_type),intent(in) :: set
    type(unicode_type),allocatable,intent(out) :: tokens(:)
    type(unicode_type),allocatable,intent(out),optional :: separator(:)
<P>
</PRE>
ARRAY BOUNDS form (returns arrays defining token positions)
<P>
<PRE>
   subroutine tokenize (string, set, first, last)
<P>
    type(unicode_type),intent(in) :: string
    type(unicode_type),intent(in) :: set
    integer,allocatable,intent(out) :: first(:)
    integer,allocatable,intent(out) :: last(:)
<P>
</PRE>
</BLOCKQUOTE>
<A name=2>

     <H3>CHARACTERISTICS</H3>

</A>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=3%>
o
</TD><TD>
STRING ‐ a scalar of type string. It is an INTENT(IN)
argument.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
SET ‐ a scalar of type string with the same kind type
parameter as STRING. It is an INTENT(IN) argument.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
SEPARATOR ‐ (optional) shall be of type string. It is an
INTENT(OUT)argument. It shall not be a coarray or a coindexed object.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
TOKENS ‐ of type string. It is an INTENT(OUT) argument. It shall
not be a coarray or a coindexed object.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
FIRST,LAST ‐ an allocatable array of type integer and rank
one. It is an INTENT(OUT) argument. It shall not be a coarray or a
coindexed object.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=3>

     <H3>DESCRIPTION</H3>

</A>
<BLOCKQUOTE>
TOKENIZE(3) parses a string into tokens. There are two forms of the
subroutine TOKENIZE(3).
<TABLE cellpadding=3><!-- tsb: TOKENIZE(3) parses a string into tokens. There are two forms of the
 -->
<TR></TR><TR></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
The token form returns an array with one token per element,
all of the same length as the longest token.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
The array bounds form returns two integer arrays. One
contains the beginning position of the tokens and the other the end
positions.
</TD></TR>
<TR></TR></TABLE>Since the token form pads all the tokens to the same length the
original number of trailing spaces of each token accept for the
longest is lost.
<P>
The array bounds form retains information regarding the exact token
length even when padded by spaces.
</BLOCKQUOTE>
<A name=4>

     <H3>OPTIONS</H3>

</A>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=6% nowrap>
<B>•</B> </TD><TD valign=bottom>
STRING : The string to parse into tokens.
</TD></TR>
<TR></TR></TABLE><TABLE cellpadding=3>
<TR valign=top><TD width=3%>
o
</TD><TD>
SET : Each character in SET is a token delimiter. A
sequence of zero or more characters in STRING delimited by any token
delimiter, or the beginning or end of STRING, comprise a token. Thus,
two consecutive token delimiters in STRING, or a token delimiter
in the first or last character of STRING, indicate a token with
zero length.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
TOKENS : It shall be an allocatable array of rank one with
deferred length. It is allocated with the lower bound equal to one
and the upper bound equal to the number of tokens in STRING, and
with character length equal to the length of the longest token.
<P>
The tokens in STRING are assigned in the order found, as if by
intrinsic assignment, to the elements of TOKENS, in array element
order.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
FIRST : shall be an allocatable array of type integer and rank one.
It is an INTENT(OUT) argument. It shall not be a coarray or
a coindexed object.
<P>
It is allocated with the lower bound equal to one and the upper
bound equal to the number of tokens in STRING. Each element is
assigned, in array element order, the starting position of each
token in STRING, in the order found.
<P>
If a token has zero length, the starting position is equal to
one if the token is at the beginning of STRING, and one greater
than the position of the preceding delimiter otherwise.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
LAST : It is allocated with the lower bound equal to one and the
upper bound equal to the number of tokens in STRING. Each
element is assigned, in array element order, the ending position
of each token in STRING, in the order found.
<P>
If a token has zero length, the ending position is one less than
the starting position.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=5>

     <H3>EXAMPLES</H3>

</A>
<BLOCKQUOTE>
<P>
Sample of uses
<P>
<PRE>
   program demo_tokenize
   use M_unicode, only : tokenize, ut=&gt;unicode_type,ch=&gt;character
   use M_unicode, only : assignment(=),operator(/=)
   implicit none
   !
   ! some useful formats
   character(len=*),parameter ::       &
    & brackets=&#146;(*("[",g0,"]":,","))&#146; ,&
    & a_commas=&#146;(a,*(g0:,","))&#146;       ,&
    & gen=&#146;(*(g0))&#146;
   !
   ! Execution of TOKEN form (return array of tokens)
   !
      block
      type(ut)             :: string
      type(ut),allocatable :: tokens(:)
      integer              :: i
         string = &#146;  first,second ,third       &#146;
         call tokenize(string, set=&#146;;,&#146;, tokens=tokens )
         write(*,brackets)ch(tokens)
<P>
         string = &#146;  first , second ,third       &#146;
         call tokenize(string, set=&#146; ,&#146;, tokens=tokens )
         write(*,brackets)(tokens(i)%character(),i=1,size(tokens))
         ! remove blank tokens
         tokens=pack(tokens, tokens /= &#146;&#146; )
         write(*,brackets)ch(tokens)
   !
      endblock
   !
   ! Execution of BOUNDS form (return position of tokens)
   !
      block
      type(ut)                   :: string
      character(len=*),parameter :: set = " ,"
      integer,allocatable        :: first(:), last(:)
         write(*,gen)repeat(&#146;1234567890&#146;,6)
         string = &#146;first,second,,fourth&#146;
         write(*,gen)ch(string)
         call tokenize (string, set, first, last)
         write(*,a_commas)&#146;FIRST=&#146;,first
         write(*,a_commas)&#146;LAST=&#146;,last
         write(*,a_commas)&#146;HAS LENGTH=&#146;,last-first.gt.0
      endblock
   !
   end program demo_tokenize
<P>
</PRE>
Results:
<P>
<PRE>
   &gt; [  first     ],[second      ],[third       ]
   &gt; [],[first],[],[],[second],[],[third],[],[],[],[],[]
   &gt; [first ],[second],[third ]
   &gt; 123456789012345678901234567890123456789012345678901234567890
   &gt; first,second,,fourth
   &gt; FIRST=1,7,14,15
   &gt; LAST=5,12,13,20
   &gt; HAS LENGTH=T,T,F,T
<P>
</PRE>
</BLOCKQUOTE>
<A name=6>

     <H3>SEE ALSO</H3>

</A>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=3%>
o
</TD><TD>
SPLIT(3) ‐ return tokens from a string, one at a time
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
INDEX(3) ‐ Position of a substring within a string
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
SCAN(3) ‐ Scan a string for the presence of a set of characters
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
VERIFY(3) ‐ Position of a character in a string of characters
that does not appear in a given set of characters.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=7>

     <H3>AUTHOR</H3>

</A>
<BLOCKQUOTE>
Milan Curcic, "<A HREF="mailto:milancurcic@hey.com">milancurcic@hey.com</A>"
John S. Urban -- UTF-8 version
</BLOCKQUOTE>
<A name=8>

     <H3>LICENSE</H3>

</A>
<BLOCKQUOTE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; MIT</H4>
</A>
<BLOCKQUOTE>
</BLOCKQUOTE>
<P><HR>
<br><br><center><img src="images/tokenize.gif"></center>
</div>
</div>
</body>
</HTML>
