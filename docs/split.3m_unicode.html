<html> 
<head> 
<title> </title>
<style> 
px {font-family: "Lucida Console", Monaco, monospace }
p { font-size:100%; line-height:1.1em; }
body {xfont-style: sans-serif}
body {
color:#333; font-family:Verdana, Arial, Helvetica, sans-serif; font-size:1em; line-height:1.3em; }
a:visited { color:#666; }
h1,h2,h3,h4,h5,h6 { color:#333; font-family:georgia, verdana, sans-serif; }
h1 { font-size:150%; page-break-before:auto;background-color: #aaaaff}
h2 { font-size:143%;color:teal; }
h3 { font-size:134%;color:blue; }
h4 { font-size:120%;color:gray; }
img { max-width: 55em}
p{ padding: 0;margin:0; }
p{ padding-right:1.4em; }
p{ padding-bottom:0.1em; }
p{ padding-top:1em; }
p{ whitespace: pre-wrap; }
h5,h6 { font-size:100% }
a.nav,a:link.nav, a:visited.nav { background-color:#FFF; color:#000; }
XXtable { border:double #000; border-collapse:collapse; }
XXtable { border-collapse:collapse; }
XXtd { border:thin solid #888; }
XXtd { border:none; }
li { margin-bottom:0.5em; }
blockquote { display:block; font-size:100%; line-height:1.1em; margin:0 0 0.5em; padding:0 2.5em; }
pre { background-color:#DDD; font-size:100%; overflow:auto; padding:1em; }
a,li span { color:#000; }
a:hover, a.nav:hover, a:hover math { background-color:#000; color:#FFF; }
#Container { margin:0 10px; text-align:center; background-color: #BBB}
#Content { border-top:none; margin:auto; padding:0.3em; text-align:left; width:100%; max-width:55em; background:#FFF}
span.webName { font-size:.5em; }
textarea#content { font-size: 1em; line-height: 1.125; }
h1#pageName { line-height:1em; margin:0.2em 0 0.2em 0; padding:0; }
.property { color:#666; font-size:100%; }
a.existingWikiWord[title]{ //border: 1px dashed #BBB; }
.byline { color:#666; font-size:1.0em; font-style:italic; margin-bottom:1em; padding-top:1px; } 
</style> 
</head>
<BODY bgcolor=#F0F0F0 text=#000000 link=#0000ff vlink=#C000C0 alink=#ff0000><A NAME=top></A>
<!--
<h5><a href="https://github.com/urbanjost/M_unicode">[UP]</a></h5>
<button type="button" onclick="javascript:history.back()">Back</button>
-->
<div id="Container">
<div id="Content">
<CENTER>
<H1><HR><I>Manual Reference Pages &nbsp;-&nbsp;</I><NOBR>split (3m_unicode)</NOBR><HR></H1>
</CENTER>
<A name=0>

     <H3>NAME</H3>

</A>
<BLOCKQUOTE>
split(3) - [M_unicode:SPLIT] parse a string into tokens, one at a time.
<P>
</BLOCKQUOTE>
<A name=contents></A><H3>CONTENTS</H3></A>
<BLOCKQUOTE>
<A HREF=#1>Synopsis</A><BR>
<A HREF=#2>Characteristics</A><BR>
<A HREF=#3>Description</A><BR>
<A HREF=#4>Options</A><BR>
<A HREF=#5>Example</A><BR>
<A HREF=#6>See Also</A><BR>
<A HREF=#7>Author</A><BR>
<A HREF=#8>License</A><BR>
</BLOCKQUOTE>
<A name=9>

     <H3>SYNOPSIS</H3>

</A>
<BLOCKQUOTE>
call split (string, set, pos [, back])
<P>
<PRE>
   type(unicode_type),intent(in) :: string
   type(unicode_type),intent(in) :: set
   integer,intent(inout)         :: pos
   logical,intent(in),optional   :: back
<P>
</PRE>
</BLOCKQUOTE>
<A name=2>

     <H3>CHARACTERISTICS</H3>

</A>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=3%>
o
</TD><TD>
STRING is a scalar character variable
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
SET is a scalar string variable
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=3>

     <H3>DESCRIPTION</H3>

</A>
<BLOCKQUOTE>
Find the extent of consecutive tokens in a string. given a string and
a position to start looking for a token return the position of the
end of the token. a set of separator characters may be specified as
well as the direction of parsing.
<P>
typically consecutive calls are used to parse a string into a set of
tokens by stepping through the start and end positions of each token.
</BLOCKQUOTE>
<A name=4>

     <H3>OPTIONS</H3>

</A>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=3%>
o
</TD><TD>
STRING : the string to search for tokens in.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
SET : Each character in set is a token delimiter. a sequence of
zero or more characters in string delimited by any token delimiter,
or the beginning or end of string, comprise a token. thus, two
consecutive token delimiters in STRING, or a token delimiter in the
first or last character of STRING, indicate a token with zero length.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
POS : on input, the position from which to start looking for the next
separator from. This is typically the first character or the last
returned value of POS if searching from left to right (ie. back is
absent or .true.) or the last character or the last returned value
of POS when searching from right to left (ie. when back is .FALSE.).
<P>
If BACK is present with the value .TRUE., the value of pos shall be
in the range 0 &lt; POS &lt;= len(STRING)+1; otherwise it shall be in the
range 0 &lt;= POS &lt;= len(STRING).
<P>
So POS on input is typically an end of the string or the position
of a separator, probably from a previous call to split but POS on
input can be any position in the range 1 &lt;= POS &lt;= len(STRING). if
POS points to a non-separator character in the string the call is
still valid but it will start searching from the specified position
and that will result (somewhat obviously) in the string from POS on
input to the returned POS being a partial token.
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
BACK : If BACK is absent or is present with the value .FALSE., POS is
assigned the position of the leftmost token delimiter in string
whose position is greater than POS, or if there is no such character,
it is assigned a value one greater than the length of string. this
identifies a token with starting position one greater than the value
of POS on invocation, and ending position one less than the value
of POS on return.
<P>
If BACK is present with the value .TRUE., POS is assigned the
position of the rightmost token delimiter in string whose position
is less than POS, or if there is no such character, it is assigned
the value zero. This identifies a token with ending position one
less than the value of POS on invocation, and starting position one
<TABLE width=100% cellpadding=3><!-- tsb: If BACK is present with the value .TRUE., POS is assigned the
 -->
<TR></TR><TR></TR>
<TR valign=top><TD colspan=2>
<B>greater than the value of POS</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
on return.
</TD></TR>
<TR></TR></TABLE></TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=5>

     <H3>EXAMPLE</H3>

</A>
<BLOCKQUOTE>
sample program:
<P>
<PRE>
   program demo_split
   use iso_fortran_env, only : stdout =&gt; output_unit
   use M_unicode,       only : unicode_type, assignment(=)
   use M_unicode,       only : split, len, character
   use M_unicode,       only : ut=&gt;unicode_type
   implicit none
   character(len=*),parameter :: g=&#146;(*(g0,1x))&#146;
   type(ut)                   :: proverb
   type(ut)                   :: delims
   type(ut),allocatable       :: array(:)
   integer                    :: first
   integer                    :: last
   integer                    :: pos
   integer                    :: i
<P>
      delims= &#146;=|; &#146;
<P>
      proverb="Más vale pájaro en mano, que ciento volando."
      call printwords(proverb)
<P>
      ! there really are not spaces between these glyphs
      array=[ &
       ut("七転び八起き。"), &
       ut("転んでもまた立ち上がる。"), &
       ut("くじけずに前を向いて歩いていこう。")]
      call printwords(array)
<P>
      write(stdout,g)&#146;OOP&#146;
      array=proverb%split(ut(&#146; &#146;))
      write(stdout,&#146;(*(:"[",a,"]"))&#146;)(character(array(i)),i=1,size(array))
<P>
   contains
   impure elemental subroutine printwords(line)
   type(ut),intent(in) :: line
      pos = 0
      write(stdout,g)line%character(),len(line)
      do while (pos &lt; len(line))
          first = pos + 1
          call split (line, delims, pos)
          last = pos - 1
          print g, line%character(first,last),first,last,pos
      end do
   end subroutine printwords
<P>
   end program demo_split
<P>
</PRE>
Results:
<P>
<PRE>
   &gt; Project is up to date
   &gt; Más vale pájaro en mano, que ciento volando. 44
   &gt; Más 1 3 4
   &gt; vale 5 8 9
   &gt; pájaro 10 15 16
   &gt; en 17 18 19
   &gt; mano, 20 24 25
   &gt; que 26 28 29
   &gt; ciento 30 35 36
   &gt; volando. 37 44 45
   &gt; 七転び八起き。 7
   &gt; 七転び八起き。 1 7 8
   &gt; 転んでもまた立ち上がる。 12
   &gt; 転んでもまた立ち上がる。 1 12 13
   &gt; くじけずに前を向いて歩いていこう。 17
   &gt; くじけずに前を向いて歩いていこう。 1 17 18
   &gt; OOP
   &gt; [Más][vale][pájaro][en][mano,][que][ciento][volando.]
<P>
</PRE>
</BLOCKQUOTE>
<A name=6>

     <H3>SEE ALSO</H3>

</A>
<BLOCKQUOTE>
<TABLE cellpadding=3>
<TR valign=top><TD width=3%>
o
</TD><TD>
tokenize(3) - parse a string into tokens
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
index(3) - position of a substring within a string
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
scan(3) - scan a string for the presence of a set of characters
</TD></TR>
<TR valign=top><TD width=3%>
o
</TD><TD>
verify(3) - position of a character in a string of characters that does
not appear in a given set of characters.
</TD></TR>
<TR></TR></TABLE></BLOCKQUOTE>
<A name=7>

     <H3>AUTHOR</H3>

</A>
<BLOCKQUOTE>
John S. Urban
</BLOCKQUOTE>
<A name=8>

     <H3>LICENSE</H3>

</A>
<BLOCKQUOTE>
</BLOCKQUOTE>
<A name=>

    <H4>&nbsp; &nbsp; MIT</H4>
</A>
<BLOCKQUOTE>
</BLOCKQUOTE>
<P><HR>
<br><br><center><img src="images/split.gif"></center>
</div>
</div>
</body>
</HTML>
